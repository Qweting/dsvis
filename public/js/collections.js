(()=>{"use strict";var __webpack_modules__={166:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval("\n// NAMESPACE OBJECT: ./node_modules/@svgdotjs/svg.js/src/modules/core/circled.js\nvar circled_namespaceObject = {};\n__webpack_require__.r(circled_namespaceObject);\n__webpack_require__.d(circled_namespaceObject, {\n  cx: () => (cx),\n  cy: () => (cy),\n  height: () => (height),\n  rx: () => (rx),\n  ry: () => (ry),\n  width: () => (width),\n  x: () => (x),\n  y: () => (y)\n});\n\n// NAMESPACE OBJECT: ./node_modules/@svgdotjs/svg.js/src/modules/core/gradiented.js\nvar gradiented_namespaceObject = {};\n__webpack_require__.r(gradiented_namespaceObject);\n__webpack_require__.d(gradiented_namespaceObject, {\n  from: () => (from),\n  to: () => (to)\n});\n\n// NAMESPACE OBJECT: ./node_modules/@svgdotjs/svg.js/src/modules/core/pointed.js\nvar pointed_namespaceObject = {};\n__webpack_require__.r(pointed_namespaceObject);\n__webpack_require__.d(pointed_namespaceObject, {\n  MorphArray: () => (MorphArray),\n  height: () => (pointed_height),\n  width: () => (pointed_width),\n  x: () => (pointed_x),\n  y: () => (pointed_y)\n});\n\n// NAMESPACE OBJECT: ./node_modules/@svgdotjs/svg.js/src/modules/core/poly.js\nvar poly_namespaceObject = {};\n__webpack_require__.r(poly_namespaceObject);\n__webpack_require__.d(poly_namespaceObject, {\n  array: () => (array),\n  clear: () => (clear),\n  move: () => (move),\n  plot: () => (plot),\n  size: () => (size)\n});\n\n// NAMESPACE OBJECT: ./node_modules/@svgdotjs/svg.js/src/modules/core/textable.js\nvar textable_namespaceObject = {};\n__webpack_require__.r(textable_namespaceObject);\n__webpack_require__.d(textable_namespaceObject, {\n  amove: () => (amove),\n  ax: () => (ax),\n  ay: () => (ay),\n  build: () => (build),\n  center: () => (center),\n  cx: () => (textable_cx),\n  cy: () => (textable_cy),\n  length: () => (textable_length),\n  move: () => (textable_move),\n  plain: () => (plain),\n  x: () => (textable_x),\n  y: () => (textable_y)\n});\n\n// NAMESPACE OBJECT: ./node_modules/@svgdotjs/svg.js/src/modules/core/containerGeometry.js\nvar containerGeometry_namespaceObject = {};\n__webpack_require__.r(containerGeometry_namespaceObject);\n__webpack_require__.d(containerGeometry_namespaceObject, {\n  dmove: () => (dmove),\n  dx: () => (dx),\n  dy: () => (dy),\n  height: () => (containerGeometry_height),\n  move: () => (containerGeometry_move),\n  size: () => (containerGeometry_size),\n  width: () => (containerGeometry_width),\n  x: () => (containerGeometry_x),\n  y: () => (containerGeometry_y)\n});\n\n;// ./node_modules/@svgdotjs/svg.js/src/utils/methods.js\nconst methods = {}\nconst names = []\n\nfunction registerMethods(name, m) {\n  if (Array.isArray(name)) {\n    for (const _name of name) {\n      registerMethods(_name, m)\n    }\n    return\n  }\n\n  if (typeof name === 'object') {\n    for (const _name in name) {\n      registerMethods(_name, name[_name])\n    }\n    return\n  }\n\n  addMethodNames(Object.getOwnPropertyNames(m))\n  methods[name] = Object.assign(methods[name] || {}, m)\n}\n\nfunction getMethodsFor(name) {\n  return methods[name] || {}\n}\n\nfunction getMethodNames() {\n  return [...new Set(names)]\n}\n\nfunction addMethodNames(_names) {\n  names.push(..._names)\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/utils/utils.js\n// Map function\nfunction map(array, block) {\n  let i\n  const il = array.length\n  const result = []\n\n  for (i = 0; i < il; i++) {\n    result.push(block(array[i]))\n  }\n\n  return result\n}\n\n// Filter function\nfunction filter(array, block) {\n  let i\n  const il = array.length\n  const result = []\n\n  for (i = 0; i < il; i++) {\n    if (block(array[i])) {\n      result.push(array[i])\n    }\n  }\n\n  return result\n}\n\n// Degrees to radians\nfunction radians(d) {\n  return ((d % 360) * Math.PI) / 180\n}\n\n// Radians to degrees\nfunction degrees(r) {\n  return ((r * 180) / Math.PI) % 360\n}\n\n// Convert camel cased string to dash separated\nfunction unCamelCase(s) {\n  return s.replace(/([A-Z])/g, function (m, g) {\n    return '-' + g.toLowerCase()\n  })\n}\n\n// Capitalize first letter of a string\nfunction capitalize(s) {\n  return s.charAt(0).toUpperCase() + s.slice(1)\n}\n\n// Calculate proportional width and height values when necessary\nfunction proportionalSize(element, width, height, box) {\n  if (width == null || height == null) {\n    box = box || element.bbox()\n\n    if (width == null) {\n      width = (box.width / box.height) * height\n    } else if (height == null) {\n      height = (box.height / box.width) * width\n    }\n  }\n\n  return {\n    width: width,\n    height: height\n  }\n}\n\n/**\n * This function adds support for string origins.\n * It searches for an origin in o.origin o.ox and o.originX.\n * This way, origin: {x: 'center', y: 50} can be passed as well as ox: 'center', oy: 50\n **/\nfunction getOrigin(o, element) {\n  const origin = o.origin\n  // First check if origin is in ox or originX\n  let ox = o.ox != null ? o.ox : o.originX != null ? o.originX : 'center'\n  let oy = o.oy != null ? o.oy : o.originY != null ? o.originY : 'center'\n\n  // Then check if origin was used and overwrite in that case\n  if (origin != null) {\n    ;[ox, oy] = Array.isArray(origin)\n      ? origin\n      : typeof origin === 'object'\n        ? [origin.x, origin.y]\n        : [origin, origin]\n  }\n\n  // Make sure to only call bbox when actually needed\n  const condX = typeof ox === 'string'\n  const condY = typeof oy === 'string'\n  if (condX || condY) {\n    const { height, width, x, y } = element.bbox()\n\n    // And only overwrite if string was passed for this specific axis\n    if (condX) {\n      ox = ox.includes('left')\n        ? x\n        : ox.includes('right')\n          ? x + width\n          : x + width / 2\n    }\n\n    if (condY) {\n      oy = oy.includes('top')\n        ? y\n        : oy.includes('bottom')\n          ? y + height\n          : y + height / 2\n    }\n  }\n\n  // Return the origin as it is if it wasn't a string\n  return [ox, oy]\n}\n\nconst descriptiveElements = new Set(['desc', 'metadata', 'title'])\nconst isDescriptive = (element) =>\n  descriptiveElements.has(element.nodeName)\n\nconst writeDataToDom = (element, data, defaults = {}) => {\n  const cloned = { ...data }\n\n  for (const key in cloned) {\n    if (cloned[key].valueOf() === defaults[key]) {\n      delete cloned[key]\n    }\n  }\n\n  if (Object.keys(cloned).length) {\n    element.node.setAttribute('data-svgjs', JSON.stringify(cloned)) // see #428\n  } else {\n    element.node.removeAttribute('data-svgjs')\n    element.node.removeAttribute('svgjs:data')\n  }\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/namespaces.js\n// Default namespaces\nconst svg = 'http://www.w3.org/2000/svg'\nconst html = 'http://www.w3.org/1999/xhtml'\nconst xmlns = 'http://www.w3.org/2000/xmlns/'\nconst xlink = 'http://www.w3.org/1999/xlink'\n\n;// ./node_modules/@svgdotjs/svg.js/src/utils/window.js\nconst globals = {\n  window: typeof window === 'undefined' ? null : window,\n  document: typeof document === 'undefined' ? null : document\n}\n\nfunction registerWindow(win = null, doc = null) {\n  globals.window = win\n  globals.document = doc\n}\n\nconst save = {}\n\nfunction saveWindow() {\n  save.window = globals.window\n  save.document = globals.document\n}\n\nfunction restoreWindow() {\n  globals.window = save.window\n  globals.document = save.document\n}\n\nfunction withWindow(win, fn) {\n  saveWindow()\n  registerWindow(win, win.document)\n  fn(win, win.document)\n  restoreWindow()\n}\n\nfunction getWindow() {\n  return globals.window\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/Base.js\nclass Base {\n  // constructor (node/*, {extensions = []} */) {\n  //   // this.tags = []\n  //   //\n  //   // for (let extension of extensions) {\n  //   //   extension.setup.call(this, node)\n  //   //   this.tags.push(extension.name)\n  //   // }\n  // }\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/utils/adopter.js\n\n\n\n\n\n\nconst adopter_elements = {}\nconst root = '___SYMBOL___ROOT___'\n\n// Method for element creation\nfunction create(name, ns = svg) {\n  // create element\n  return globals.document.createElementNS(ns, name)\n}\n\nfunction adopter_makeInstance(element, isHTML = false) {\n  if (element instanceof Base) return element\n\n  if (typeof element === 'object') {\n    return adopter(element)\n  }\n\n  if (element == null) {\n    return new adopter_elements[root]()\n  }\n\n  if (typeof element === 'string' && element.charAt(0) !== '<') {\n    return adopter(globals.document.querySelector(element))\n  }\n\n  // Make sure, that HTML elements are created with the correct namespace\n  const wrapper = isHTML ? globals.document.createElement('div') : create('svg')\n  wrapper.innerHTML = element\n\n  // We can use firstChild here because we know,\n  // that the first char is < and thus an element\n  element = adopter(wrapper.firstChild)\n\n  // make sure, that element doesn't have its wrapper attached\n  wrapper.removeChild(wrapper.firstChild)\n  return element\n}\n\nfunction nodeOrNew(name, node) {\n  return node &&\n    (node instanceof globals.window.Node ||\n      (node.ownerDocument &&\n        node instanceof node.ownerDocument.defaultView.Node))\n    ? node\n    : create(name)\n}\n\n// Adopt existing svg elements\nfunction adopt(node) {\n  // check for presence of node\n  if (!node) return null\n\n  // make sure a node isn't already adopted\n  if (node.instance instanceof Base) return node.instance\n\n  if (node.nodeName === '#document-fragment') {\n    return new adopter_elements.Fragment(node)\n  }\n\n  // initialize variables\n  let className = capitalize(node.nodeName || 'Dom')\n\n  // Make sure that gradients are adopted correctly\n  if (className === 'LinearGradient' || className === 'RadialGradient') {\n    className = 'Gradient'\n\n    // Fallback to Dom if element is not known\n  } else if (!adopter_elements[className]) {\n    className = 'Dom'\n  }\n\n  return new adopter_elements[className](node)\n}\n\nlet adopter = adopt\n\nfunction mockAdopt(mock = adopt) {\n  adopter = mock\n}\n\nfunction register(element, name = element.name, asRoot = false) {\n  adopter_elements[name] = element\n  if (asRoot) adopter_elements[root] = element\n\n  addMethodNames(Object.getOwnPropertyNames(element.prototype))\n\n  return element\n}\n\nfunction getClass(name) {\n  return adopter_elements[name]\n}\n\n// Element id sequence\nlet did = 1000\n\n// Get next named element id\nfunction eid(name) {\n  return 'Svgjs' + capitalize(name) + did++\n}\n\n// Deep new id assignment\nfunction assignNewId(node) {\n  // do the same for SVG child nodes as well\n  for (let i = node.children.length - 1; i >= 0; i--) {\n    assignNewId(node.children[i])\n  }\n\n  if (node.id) {\n    node.id = eid(node.nodeName)\n    return node\n  }\n\n  return node\n}\n\n// Method for extending objects\nfunction extend(modules, methods) {\n  let key, i\n\n  modules = Array.isArray(modules) ? modules : [modules]\n\n  for (i = modules.length - 1; i >= 0; i--) {\n    for (key in methods) {\n      modules[i].prototype[key] = methods[key]\n    }\n  }\n}\n\nfunction wrapWithAttrCheck(fn) {\n  return function (...args) {\n    const o = args[args.length - 1]\n\n    if (o && o.constructor === Object && !(o instanceof Array)) {\n      return fn.apply(this, args.slice(0, -1)).attr(o)\n    } else {\n      return fn.apply(this, args)\n    }\n  }\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/optional/arrange.js\n\n\n\n// Get all siblings, including myself\nfunction siblings() {\n  return this.parent().children()\n}\n\n// Get the current position siblings\nfunction position() {\n  return this.parent().index(this)\n}\n\n// Get the next element (will return null if there is none)\nfunction next() {\n  return this.siblings()[this.position() + 1]\n}\n\n// Get the next element (will return null if there is none)\nfunction prev() {\n  return this.siblings()[this.position() - 1]\n}\n\n// Send given element one step forward\nfunction forward() {\n  const i = this.position()\n  const p = this.parent()\n\n  // move node one step forward\n  p.add(this.remove(), i + 1)\n\n  return this\n}\n\n// Send given element one step backward\nfunction backward() {\n  const i = this.position()\n  const p = this.parent()\n\n  p.add(this.remove(), i ? i - 1 : 0)\n\n  return this\n}\n\n// Send given element all the way to the front\nfunction front() {\n  const p = this.parent()\n\n  // Move node forward\n  p.add(this.remove())\n\n  return this\n}\n\n// Send given element all the way to the back\nfunction back() {\n  const p = this.parent()\n\n  // Move node back\n  p.add(this.remove(), 0)\n\n  return this\n}\n\n// Inserts a given element before the targeted element\nfunction before(element) {\n  element = adopter_makeInstance(element)\n  element.remove()\n\n  const i = this.position()\n\n  this.parent().add(element, i)\n\n  return this\n}\n\n// Inserts a given element after the targeted element\nfunction after(element) {\n  element = adopter_makeInstance(element)\n  element.remove()\n\n  const i = this.position()\n\n  this.parent().add(element, i + 1)\n\n  return this\n}\n\nfunction insertBefore(element) {\n  element = adopter_makeInstance(element)\n  element.before(this)\n  return this\n}\n\nfunction insertAfter(element) {\n  element = adopter_makeInstance(element)\n  element.after(this)\n  return this\n}\n\nregisterMethods('Dom', {\n  siblings,\n  position,\n  next,\n  prev,\n  forward,\n  backward,\n  front,\n  back,\n  before,\n  after,\n  insertBefore,\n  insertAfter\n})\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/regex.js\n// Parse unit value\nconst numberAndUnit =\n  /^([+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?)([a-z%]*)$/i\n\n// Parse hex value\nconst hex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i\n\n// Parse rgb value\nconst rgb = /rgb\\((\\d+),(\\d+),(\\d+)\\)/\n\n// Parse reference id\nconst reference = /(#[a-z_][a-z0-9\\-_]*)/i\n\n// splits a transformation chain\nconst transforms = /\\)\\s*,?\\s*/\n\n// Whitespace\nconst whitespace = /\\s/g\n\n// Test hex value\nconst isHex = /^#[a-f0-9]{3}$|^#[a-f0-9]{6}$/i\n\n// Test rgb value\nconst isRgb = /^rgb\\(/\n\n// Test for blank string\nconst isBlank = /^(\\s+)?$/\n\n// Test for numeric string\nconst isNumber = /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i\n\n// Test for image url\nconst isImage = /\\.(jpg|jpeg|png|gif|svg)(\\?[^=]+.*)?/i\n\n// split at whitespace and comma\nconst delimiter = /[\\s,]+/\n\n// Test for path letter\nconst isPathLetter = /[MLHVCSQTAZ]/i\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/optional/class.js\n\n\n\n// Return array of classes on the node\nfunction classes() {\n  const attr = this.attr('class')\n  return attr == null ? [] : attr.trim().split(delimiter)\n}\n\n// Return true if class exists on the node, false otherwise\nfunction hasClass(name) {\n  return this.classes().indexOf(name) !== -1\n}\n\n// Add class to the node\nfunction addClass(name) {\n  if (!this.hasClass(name)) {\n    const array = this.classes()\n    array.push(name)\n    this.attr('class', array.join(' '))\n  }\n\n  return this\n}\n\n// Remove class from the node\nfunction removeClass(name) {\n  if (this.hasClass(name)) {\n    this.attr(\n      'class',\n      this.classes()\n        .filter(function (c) {\n          return c !== name\n        })\n        .join(' ')\n    )\n  }\n\n  return this\n}\n\n// Toggle the presence of a class on the node\nfunction toggleClass(name) {\n  return this.hasClass(name) ? this.removeClass(name) : this.addClass(name)\n}\n\nregisterMethods('Dom', {\n  classes,\n  hasClass,\n  addClass,\n  removeClass,\n  toggleClass\n})\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/optional/css.js\n\n\n\n// Dynamic style generator\nfunction css(style, val) {\n  const ret = {}\n  if (arguments.length === 0) {\n    // get full style as object\n    this.node.style.cssText\n      .split(/\\s*;\\s*/)\n      .filter(function (el) {\n        return !!el.length\n      })\n      .forEach(function (el) {\n        const t = el.split(/\\s*:\\s*/)\n        ret[t[0]] = t[1]\n      })\n    return ret\n  }\n\n  if (arguments.length < 2) {\n    // get style properties as array\n    if (Array.isArray(style)) {\n      for (const name of style) {\n        const cased = name\n        ret[name] = this.node.style.getPropertyValue(cased)\n      }\n      return ret\n    }\n\n    // get style for property\n    if (typeof style === 'string') {\n      return this.node.style.getPropertyValue(style)\n    }\n\n    // set styles in object\n    if (typeof style === 'object') {\n      for (const name in style) {\n        // set empty string if null/undefined/'' was given\n        this.node.style.setProperty(\n          name,\n          style[name] == null || isBlank.test(style[name]) ? '' : style[name]\n        )\n      }\n    }\n  }\n\n  // set style for property\n  if (arguments.length === 2) {\n    this.node.style.setProperty(\n      style,\n      val == null || isBlank.test(val) ? '' : val\n    )\n  }\n\n  return this\n}\n\n// Show element\nfunction show() {\n  return this.css('display', '')\n}\n\n// Hide element\nfunction hide() {\n  return this.css('display', 'none')\n}\n\n// Is element visible?\nfunction visible() {\n  return this.css('display') !== 'none'\n}\n\nregisterMethods('Dom', {\n  css,\n  show,\n  hide,\n  visible\n})\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/optional/data.js\n\n\n\n// Store data values on svg nodes\nfunction data(a, v, r) {\n  if (a == null) {\n    // get an object of attributes\n    return this.data(\n      map(\n        filter(\n          this.node.attributes,\n          (el) => el.nodeName.indexOf('data-') === 0\n        ),\n        (el) => el.nodeName.slice(5)\n      )\n    )\n  } else if (a instanceof Array) {\n    const data = {}\n    for (const key of a) {\n      data[key] = this.data(key)\n    }\n    return data\n  } else if (typeof a === 'object') {\n    for (v in a) {\n      this.data(v, a[v])\n    }\n  } else if (arguments.length < 2) {\n    try {\n      return JSON.parse(this.attr('data-' + a))\n    } catch (e) {\n      return this.attr('data-' + a)\n    }\n  } else {\n    this.attr(\n      'data-' + a,\n      v === null\n        ? null\n        : r === true || typeof v === 'string' || typeof v === 'number'\n          ? v\n          : JSON.stringify(v)\n    )\n  }\n\n  return this\n}\n\nregisterMethods('Dom', { data })\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/optional/memory.js\n\n\n// Remember arbitrary data\nfunction remember(k, v) {\n  // remember every item in an object individually\n  if (typeof arguments[0] === 'object') {\n    for (const key in k) {\n      this.remember(key, k[key])\n    }\n  } else if (arguments.length === 1) {\n    // retrieve memory\n    return this.memory()[k]\n  } else {\n    // store memory\n    this.memory()[k] = v\n  }\n\n  return this\n}\n\n// Erase a given memory\nfunction forget() {\n  if (arguments.length === 0) {\n    this._memory = {}\n  } else {\n    for (let i = arguments.length - 1; i >= 0; i--) {\n      delete this.memory()[arguments[i]]\n    }\n  }\n  return this\n}\n\n// This triggers creation of a new hidden class which is not performant\n// However, this function is not rarely used so it will not happen frequently\n// Return local memory object\nfunction memory() {\n  return (this._memory = this._memory || {})\n}\n\nregisterMethods('Dom', { remember, forget, memory })\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/Color.js\n\n\nfunction sixDigitHex(hex) {\n  return hex.length === 4\n    ? [\n        '#',\n        hex.substring(1, 2),\n        hex.substring(1, 2),\n        hex.substring(2, 3),\n        hex.substring(2, 3),\n        hex.substring(3, 4),\n        hex.substring(3, 4)\n      ].join('')\n    : hex\n}\n\nfunction componentHex(component) {\n  const integer = Math.round(component)\n  const bounded = Math.max(0, Math.min(255, integer))\n  const hex = bounded.toString(16)\n  return hex.length === 1 ? '0' + hex : hex\n}\n\nfunction is(object, space) {\n  for (let i = space.length; i--; ) {\n    if (object[space[i]] == null) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getParameters(a, b) {\n  const params = is(a, 'rgb')\n    ? { _a: a.r, _b: a.g, _c: a.b, _d: 0, space: 'rgb' }\n    : is(a, 'xyz')\n      ? { _a: a.x, _b: a.y, _c: a.z, _d: 0, space: 'xyz' }\n      : is(a, 'hsl')\n        ? { _a: a.h, _b: a.s, _c: a.l, _d: 0, space: 'hsl' }\n        : is(a, 'lab')\n          ? { _a: a.l, _b: a.a, _c: a.b, _d: 0, space: 'lab' }\n          : is(a, 'lch')\n            ? { _a: a.l, _b: a.c, _c: a.h, _d: 0, space: 'lch' }\n            : is(a, 'cmyk')\n              ? { _a: a.c, _b: a.m, _c: a.y, _d: a.k, space: 'cmyk' }\n              : { _a: 0, _b: 0, _c: 0, space: 'rgb' }\n\n  params.space = b || params.space\n  return params\n}\n\nfunction cieSpace(space) {\n  if (space === 'lab' || space === 'xyz' || space === 'lch') {\n    return true\n  } else {\n    return false\n  }\n}\n\nfunction hueToRgb(p, q, t) {\n  if (t < 0) t += 1\n  if (t > 1) t -= 1\n  if (t < 1 / 6) return p + (q - p) * 6 * t\n  if (t < 1 / 2) return q\n  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6\n  return p\n}\n\nclass Color {\n  constructor(...inputs) {\n    this.init(...inputs)\n  }\n\n  // Test if given value is a color\n  static isColor(color) {\n    return (\n      color && (color instanceof Color || this.isRgb(color) || this.test(color))\n    )\n  }\n\n  // Test if given value is an rgb object\n  static isRgb(color) {\n    return (\n      color &&\n      typeof color.r === 'number' &&\n      typeof color.g === 'number' &&\n      typeof color.b === 'number'\n    )\n  }\n\n  /*\n  Generating random colors\n  */\n  static random(mode = 'vibrant', t) {\n    // Get the math modules\n    const { random, round, sin, PI: pi } = Math\n\n    // Run the correct generator\n    if (mode === 'vibrant') {\n      const l = (81 - 57) * random() + 57\n      const c = (83 - 45) * random() + 45\n      const h = 360 * random()\n      const color = new Color(l, c, h, 'lch')\n      return color\n    } else if (mode === 'sine') {\n      t = t == null ? random() : t\n      const r = round(80 * sin((2 * pi * t) / 0.5 + 0.01) + 150)\n      const g = round(50 * sin((2 * pi * t) / 0.5 + 4.6) + 200)\n      const b = round(100 * sin((2 * pi * t) / 0.5 + 2.3) + 150)\n      const color = new Color(r, g, b)\n      return color\n    } else if (mode === 'pastel') {\n      const l = (94 - 86) * random() + 86\n      const c = (26 - 9) * random() + 9\n      const h = 360 * random()\n      const color = new Color(l, c, h, 'lch')\n      return color\n    } else if (mode === 'dark') {\n      const l = 10 + 10 * random()\n      const c = (125 - 75) * random() + 86\n      const h = 360 * random()\n      const color = new Color(l, c, h, 'lch')\n      return color\n    } else if (mode === 'rgb') {\n      const r = 255 * random()\n      const g = 255 * random()\n      const b = 255 * random()\n      const color = new Color(r, g, b)\n      return color\n    } else if (mode === 'lab') {\n      const l = 100 * random()\n      const a = 256 * random() - 128\n      const b = 256 * random() - 128\n      const color = new Color(l, a, b, 'lab')\n      return color\n    } else if (mode === 'grey') {\n      const grey = 255 * random()\n      const color = new Color(grey, grey, grey)\n      return color\n    } else {\n      throw new Error('Unsupported random color mode')\n    }\n  }\n\n  // Test if given value is a color string\n  static test(color) {\n    return typeof color === 'string' && (isHex.test(color) || isRgb.test(color))\n  }\n\n  cmyk() {\n    // Get the rgb values for the current color\n    const { _a, _b, _c } = this.rgb()\n    const [r, g, b] = [_a, _b, _c].map((v) => v / 255)\n\n    // Get the cmyk values in an unbounded format\n    const k = Math.min(1 - r, 1 - g, 1 - b)\n\n    if (k === 1) {\n      // Catch the black case\n      return new Color(0, 0, 0, 1, 'cmyk')\n    }\n\n    const c = (1 - r - k) / (1 - k)\n    const m = (1 - g - k) / (1 - k)\n    const y = (1 - b - k) / (1 - k)\n\n    // Construct the new color\n    const color = new Color(c, m, y, k, 'cmyk')\n    return color\n  }\n\n  hsl() {\n    // Get the rgb values\n    const { _a, _b, _c } = this.rgb()\n    const [r, g, b] = [_a, _b, _c].map((v) => v / 255)\n\n    // Find the maximum and minimum values to get the lightness\n    const max = Math.max(r, g, b)\n    const min = Math.min(r, g, b)\n    const l = (max + min) / 2\n\n    // If the r, g, v values are identical then we are grey\n    const isGrey = max === min\n\n    // Calculate the hue and saturation\n    const delta = max - min\n    const s = isGrey\n      ? 0\n      : l > 0.5\n        ? delta / (2 - max - min)\n        : delta / (max + min)\n    const h = isGrey\n      ? 0\n      : max === r\n        ? ((g - b) / delta + (g < b ? 6 : 0)) / 6\n        : max === g\n          ? ((b - r) / delta + 2) / 6\n          : max === b\n            ? ((r - g) / delta + 4) / 6\n            : 0\n\n    // Construct and return the new color\n    const color = new Color(360 * h, 100 * s, 100 * l, 'hsl')\n    return color\n  }\n\n  init(a = 0, b = 0, c = 0, d = 0, space = 'rgb') {\n    // This catches the case when a falsy value is passed like ''\n    a = !a ? 0 : a\n\n    // Reset all values in case the init function is rerun with new color space\n    if (this.space) {\n      for (const component in this.space) {\n        delete this[this.space[component]]\n      }\n    }\n\n    if (typeof a === 'number') {\n      // Allow for the case that we don't need d...\n      space = typeof d === 'string' ? d : space\n      d = typeof d === 'string' ? 0 : d\n\n      // Assign the values straight to the color\n      Object.assign(this, { _a: a, _b: b, _c: c, _d: d, space })\n      // If the user gave us an array, make the color from it\n    } else if (a instanceof Array) {\n      this.space = b || (typeof a[3] === 'string' ? a[3] : a[4]) || 'rgb'\n      Object.assign(this, { _a: a[0], _b: a[1], _c: a[2], _d: a[3] || 0 })\n    } else if (a instanceof Object) {\n      // Set the object up and assign its values directly\n      const values = getParameters(a, b)\n      Object.assign(this, values)\n    } else if (typeof a === 'string') {\n      if (isRgb.test(a)) {\n        const noWhitespace = a.replace(whitespace, '')\n        const [_a, _b, _c] = rgb\n          .exec(noWhitespace)\n          .slice(1, 4)\n          .map((v) => parseInt(v))\n        Object.assign(this, { _a, _b, _c, _d: 0, space: 'rgb' })\n      } else if (isHex.test(a)) {\n        const hexParse = (v) => parseInt(v, 16)\n        const [, _a, _b, _c] = hex.exec(sixDigitHex(a)).map(hexParse)\n        Object.assign(this, { _a, _b, _c, _d: 0, space: 'rgb' })\n      } else throw Error(\"Unsupported string format, can't construct Color\")\n    }\n\n    // Now add the components as a convenience\n    const { _a, _b, _c, _d } = this\n    const components =\n      this.space === 'rgb'\n        ? { r: _a, g: _b, b: _c }\n        : this.space === 'xyz'\n          ? { x: _a, y: _b, z: _c }\n          : this.space === 'hsl'\n            ? { h: _a, s: _b, l: _c }\n            : this.space === 'lab'\n              ? { l: _a, a: _b, b: _c }\n              : this.space === 'lch'\n                ? { l: _a, c: _b, h: _c }\n                : this.space === 'cmyk'\n                  ? { c: _a, m: _b, y: _c, k: _d }\n                  : {}\n    Object.assign(this, components)\n  }\n\n  lab() {\n    // Get the xyz color\n    const { x, y, z } = this.xyz()\n\n    // Get the lab components\n    const l = 116 * y - 16\n    const a = 500 * (x - y)\n    const b = 200 * (y - z)\n\n    // Construct and return a new color\n    const color = new Color(l, a, b, 'lab')\n    return color\n  }\n\n  lch() {\n    // Get the lab color directly\n    const { l, a, b } = this.lab()\n\n    // Get the chromaticity and the hue using polar coordinates\n    const c = Math.sqrt(a ** 2 + b ** 2)\n    let h = (180 * Math.atan2(b, a)) / Math.PI\n    if (h < 0) {\n      h *= -1\n      h = 360 - h\n    }\n\n    // Make a new color and return it\n    const color = new Color(l, c, h, 'lch')\n    return color\n  }\n  /*\n  Conversion Methods\n  */\n\n  rgb() {\n    if (this.space === 'rgb') {\n      return this\n    } else if (cieSpace(this.space)) {\n      // Convert to the xyz color space\n      let { x, y, z } = this\n      if (this.space === 'lab' || this.space === 'lch') {\n        // Get the values in the lab space\n        let { l, a, b } = this\n        if (this.space === 'lch') {\n          const { c, h } = this\n          const dToR = Math.PI / 180\n          a = c * Math.cos(dToR * h)\n          b = c * Math.sin(dToR * h)\n        }\n\n        // Undo the nonlinear function\n        const yL = (l + 16) / 116\n        const xL = a / 500 + yL\n        const zL = yL - b / 200\n\n        // Get the xyz values\n        const ct = 16 / 116\n        const mx = 0.008856\n        const nm = 7.787\n        x = 0.95047 * (xL ** 3 > mx ? xL ** 3 : (xL - ct) / nm)\n        y = 1.0 * (yL ** 3 > mx ? yL ** 3 : (yL - ct) / nm)\n        z = 1.08883 * (zL ** 3 > mx ? zL ** 3 : (zL - ct) / nm)\n      }\n\n      // Convert xyz to unbounded rgb values\n      const rU = x * 3.2406 + y * -1.5372 + z * -0.4986\n      const gU = x * -0.9689 + y * 1.8758 + z * 0.0415\n      const bU = x * 0.0557 + y * -0.204 + z * 1.057\n\n      // Convert the values to true rgb values\n      const pow = Math.pow\n      const bd = 0.0031308\n      const r = rU > bd ? 1.055 * pow(rU, 1 / 2.4) - 0.055 : 12.92 * rU\n      const g = gU > bd ? 1.055 * pow(gU, 1 / 2.4) - 0.055 : 12.92 * gU\n      const b = bU > bd ? 1.055 * pow(bU, 1 / 2.4) - 0.055 : 12.92 * bU\n\n      // Make and return the color\n      const color = new Color(255 * r, 255 * g, 255 * b)\n      return color\n    } else if (this.space === 'hsl') {\n      // https://bgrins.github.io/TinyColor/docs/tinycolor.html\n      // Get the current hsl values\n      let { h, s, l } = this\n      h /= 360\n      s /= 100\n      l /= 100\n\n      // If we are grey, then just make the color directly\n      if (s === 0) {\n        l *= 255\n        const color = new Color(l, l, l)\n        return color\n      }\n\n      // TODO I have no idea what this does :D If you figure it out, tell me!\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s\n      const p = 2 * l - q\n\n      // Get the rgb values\n      const r = 255 * hueToRgb(p, q, h + 1 / 3)\n      const g = 255 * hueToRgb(p, q, h)\n      const b = 255 * hueToRgb(p, q, h - 1 / 3)\n\n      // Make a new color\n      const color = new Color(r, g, b)\n      return color\n    } else if (this.space === 'cmyk') {\n      // https://gist.github.com/felipesabino/5066336\n      // Get the normalised cmyk values\n      const { c, m, y, k } = this\n\n      // Get the rgb values\n      const r = 255 * (1 - Math.min(1, c * (1 - k) + k))\n      const g = 255 * (1 - Math.min(1, m * (1 - k) + k))\n      const b = 255 * (1 - Math.min(1, y * (1 - k) + k))\n\n      // Form the color and return it\n      const color = new Color(r, g, b)\n      return color\n    } else {\n      return this\n    }\n  }\n\n  toArray() {\n    const { _a, _b, _c, _d, space } = this\n    return [_a, _b, _c, _d, space]\n  }\n\n  toHex() {\n    const [r, g, b] = this._clamped().map(componentHex)\n    return `#${r}${g}${b}`\n  }\n\n  toRgb() {\n    const [rV, gV, bV] = this._clamped()\n    const string = `rgb(${rV},${gV},${bV})`\n    return string\n  }\n\n  toString() {\n    return this.toHex()\n  }\n\n  xyz() {\n    // Normalise the red, green and blue values\n    const { _a: r255, _b: g255, _c: b255 } = this.rgb()\n    const [r, g, b] = [r255, g255, b255].map((v) => v / 255)\n\n    // Convert to the lab rgb space\n    const rL = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92\n    const gL = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92\n    const bL = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92\n\n    // Convert to the xyz color space without bounding the values\n    const xU = (rL * 0.4124 + gL * 0.3576 + bL * 0.1805) / 0.95047\n    const yU = (rL * 0.2126 + gL * 0.7152 + bL * 0.0722) / 1.0\n    const zU = (rL * 0.0193 + gL * 0.1192 + bL * 0.9505) / 1.08883\n\n    // Get the proper xyz values by applying the bounding\n    const x = xU > 0.008856 ? Math.pow(xU, 1 / 3) : 7.787 * xU + 16 / 116\n    const y = yU > 0.008856 ? Math.pow(yU, 1 / 3) : 7.787 * yU + 16 / 116\n    const z = zU > 0.008856 ? Math.pow(zU, 1 / 3) : 7.787 * zU + 16 / 116\n\n    // Make and return the color\n    const color = new Color(x, y, z, 'xyz')\n    return color\n  }\n\n  /*\n  Input and Output methods\n  */\n\n  _clamped() {\n    const { _a, _b, _c } = this.rgb()\n    const { max, min, round } = Math\n    const format = (v) => max(0, min(round(v), 255))\n    return [_a, _b, _c].map(format)\n  }\n\n  /*\n  Constructing colors\n  */\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/Point.js\n\n\nclass Point {\n  // Initialize\n  constructor(...args) {\n    this.init(...args)\n  }\n\n  // Clone point\n  clone() {\n    return new Point(this)\n  }\n\n  init(x, y) {\n    const base = { x: 0, y: 0 }\n\n    // ensure source as object\n    const source = Array.isArray(x)\n      ? { x: x[0], y: x[1] }\n      : typeof x === 'object'\n        ? { x: x.x, y: x.y }\n        : { x: x, y: y }\n\n    // merge source\n    this.x = source.x == null ? base.x : source.x\n    this.y = source.y == null ? base.y : source.y\n\n    return this\n  }\n\n  toArray() {\n    return [this.x, this.y]\n  }\n\n  transform(m) {\n    return this.clone().transformO(m)\n  }\n\n  // Transform point with matrix\n  transformO(m) {\n    if (!Matrix.isMatrixLike(m)) {\n      m = new Matrix(m)\n    }\n\n    const { x, y } = this\n\n    // Perform the matrix multiplication\n    this.x = m.a * x + m.c * y + m.e\n    this.y = m.b * x + m.d * y + m.f\n\n    return this\n  }\n}\n\nfunction point(x, y) {\n  return new Point(x, y).transformO(this.screenCTM().inverseO())\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/Matrix.js\n\n\n\n\n\n\nfunction closeEnough(a, b, threshold) {\n  return Math.abs(b - a) < (threshold || 1e-6)\n}\n\nclass Matrix {\n  constructor(...args) {\n    this.init(...args)\n  }\n\n  static formatTransforms(o) {\n    // Get all of the parameters required to form the matrix\n    const flipBoth = o.flip === 'both' || o.flip === true\n    const flipX = o.flip && (flipBoth || o.flip === 'x') ? -1 : 1\n    const flipY = o.flip && (flipBoth || o.flip === 'y') ? -1 : 1\n    const skewX =\n      o.skew && o.skew.length\n        ? o.skew[0]\n        : isFinite(o.skew)\n          ? o.skew\n          : isFinite(o.skewX)\n            ? o.skewX\n            : 0\n    const skewY =\n      o.skew && o.skew.length\n        ? o.skew[1]\n        : isFinite(o.skew)\n          ? o.skew\n          : isFinite(o.skewY)\n            ? o.skewY\n            : 0\n    const scaleX =\n      o.scale && o.scale.length\n        ? o.scale[0] * flipX\n        : isFinite(o.scale)\n          ? o.scale * flipX\n          : isFinite(o.scaleX)\n            ? o.scaleX * flipX\n            : flipX\n    const scaleY =\n      o.scale && o.scale.length\n        ? o.scale[1] * flipY\n        : isFinite(o.scale)\n          ? o.scale * flipY\n          : isFinite(o.scaleY)\n            ? o.scaleY * flipY\n            : flipY\n    const shear = o.shear || 0\n    const theta = o.rotate || o.theta || 0\n    const origin = new Point(\n      o.origin || o.around || o.ox || o.originX,\n      o.oy || o.originY\n    )\n    const ox = origin.x\n    const oy = origin.y\n    // We need Point to be invalid if nothing was passed because we cannot default to 0 here. That is why NaN\n    const position = new Point(\n      o.position || o.px || o.positionX || NaN,\n      o.py || o.positionY || NaN\n    )\n    const px = position.x\n    const py = position.y\n    const translate = new Point(\n      o.translate || o.tx || o.translateX,\n      o.ty || o.translateY\n    )\n    const tx = translate.x\n    const ty = translate.y\n    const relative = new Point(\n      o.relative || o.rx || o.relativeX,\n      o.ry || o.relativeY\n    )\n    const rx = relative.x\n    const ry = relative.y\n\n    // Populate all of the values\n    return {\n      scaleX,\n      scaleY,\n      skewX,\n      skewY,\n      shear,\n      theta,\n      rx,\n      ry,\n      tx,\n      ty,\n      ox,\n      oy,\n      px,\n      py\n    }\n  }\n\n  static fromArray(a) {\n    return { a: a[0], b: a[1], c: a[2], d: a[3], e: a[4], f: a[5] }\n  }\n\n  static isMatrixLike(o) {\n    return (\n      o.a != null ||\n      o.b != null ||\n      o.c != null ||\n      o.d != null ||\n      o.e != null ||\n      o.f != null\n    )\n  }\n\n  // left matrix, right matrix, target matrix which is overwritten\n  static matrixMultiply(l, r, o) {\n    // Work out the product directly\n    const a = l.a * r.a + l.c * r.b\n    const b = l.b * r.a + l.d * r.b\n    const c = l.a * r.c + l.c * r.d\n    const d = l.b * r.c + l.d * r.d\n    const e = l.e + l.a * r.e + l.c * r.f\n    const f = l.f + l.b * r.e + l.d * r.f\n\n    // make sure to use local variables because l/r and o could be the same\n    o.a = a\n    o.b = b\n    o.c = c\n    o.d = d\n    o.e = e\n    o.f = f\n\n    return o\n  }\n\n  around(cx, cy, matrix) {\n    return this.clone().aroundO(cx, cy, matrix)\n  }\n\n  // Transform around a center point\n  aroundO(cx, cy, matrix) {\n    const dx = cx || 0\n    const dy = cy || 0\n    return this.translateO(-dx, -dy).lmultiplyO(matrix).translateO(dx, dy)\n  }\n\n  // Clones this matrix\n  clone() {\n    return new Matrix(this)\n  }\n\n  // Decomposes this matrix into its affine parameters\n  decompose(cx = 0, cy = 0) {\n    // Get the parameters from the matrix\n    const a = this.a\n    const b = this.b\n    const c = this.c\n    const d = this.d\n    const e = this.e\n    const f = this.f\n\n    // Figure out if the winding direction is clockwise or counterclockwise\n    const determinant = a * d - b * c\n    const ccw = determinant > 0 ? 1 : -1\n\n    // Since we only shear in x, we can use the x basis to get the x scale\n    // and the rotation of the resulting matrix\n    const sx = ccw * Math.sqrt(a * a + b * b)\n    const thetaRad = Math.atan2(ccw * b, ccw * a)\n    const theta = (180 / Math.PI) * thetaRad\n    const ct = Math.cos(thetaRad)\n    const st = Math.sin(thetaRad)\n\n    // We can then solve the y basis vector simultaneously to get the other\n    // two affine parameters directly from these parameters\n    const lam = (a * c + b * d) / determinant\n    const sy = (c * sx) / (lam * a - b) || (d * sx) / (lam * b + a)\n\n    // Use the translations\n    const tx = e - cx + cx * ct * sx + cy * (lam * ct * sx - st * sy)\n    const ty = f - cy + cx * st * sx + cy * (lam * st * sx + ct * sy)\n\n    // Construct the decomposition and return it\n    return {\n      // Return the affine parameters\n      scaleX: sx,\n      scaleY: sy,\n      shear: lam,\n      rotate: theta,\n      translateX: tx,\n      translateY: ty,\n      originX: cx,\n      originY: cy,\n\n      // Return the matrix parameters\n      a: this.a,\n      b: this.b,\n      c: this.c,\n      d: this.d,\n      e: this.e,\n      f: this.f\n    }\n  }\n\n  // Check if two matrices are equal\n  equals(other) {\n    if (other === this) return true\n    const comp = new Matrix(other)\n    return (\n      closeEnough(this.a, comp.a) &&\n      closeEnough(this.b, comp.b) &&\n      closeEnough(this.c, comp.c) &&\n      closeEnough(this.d, comp.d) &&\n      closeEnough(this.e, comp.e) &&\n      closeEnough(this.f, comp.f)\n    )\n  }\n\n  // Flip matrix on x or y, at a given offset\n  flip(axis, around) {\n    return this.clone().flipO(axis, around)\n  }\n\n  flipO(axis, around) {\n    return axis === 'x'\n      ? this.scaleO(-1, 1, around, 0)\n      : axis === 'y'\n        ? this.scaleO(1, -1, 0, around)\n        : this.scaleO(-1, -1, axis, around || axis) // Define an x, y flip point\n  }\n\n  // Initialize\n  init(source) {\n    const base = Matrix.fromArray([1, 0, 0, 1, 0, 0])\n\n    // ensure source as object\n    source =\n      source instanceof Element\n        ? source.matrixify()\n        : typeof source === 'string'\n          ? Matrix.fromArray(source.split(delimiter).map(parseFloat))\n          : Array.isArray(source)\n            ? Matrix.fromArray(source)\n            : typeof source === 'object' && Matrix.isMatrixLike(source)\n              ? source\n              : typeof source === 'object'\n                ? new Matrix().transform(source)\n                : arguments.length === 6\n                  ? Matrix.fromArray([].slice.call(arguments))\n                  : base\n\n    // Merge the source matrix with the base matrix\n    this.a = source.a != null ? source.a : base.a\n    this.b = source.b != null ? source.b : base.b\n    this.c = source.c != null ? source.c : base.c\n    this.d = source.d != null ? source.d : base.d\n    this.e = source.e != null ? source.e : base.e\n    this.f = source.f != null ? source.f : base.f\n\n    return this\n  }\n\n  inverse() {\n    return this.clone().inverseO()\n  }\n\n  // Inverses matrix\n  inverseO() {\n    // Get the current parameters out of the matrix\n    const a = this.a\n    const b = this.b\n    const c = this.c\n    const d = this.d\n    const e = this.e\n    const f = this.f\n\n    // Invert the 2x2 matrix in the top left\n    const det = a * d - b * c\n    if (!det) throw new Error('Cannot invert ' + this)\n\n    // Calculate the top 2x2 matrix\n    const na = d / det\n    const nb = -b / det\n    const nc = -c / det\n    const nd = a / det\n\n    // Apply the inverted matrix to the top right\n    const ne = -(na * e + nc * f)\n    const nf = -(nb * e + nd * f)\n\n    // Construct the inverted matrix\n    this.a = na\n    this.b = nb\n    this.c = nc\n    this.d = nd\n    this.e = ne\n    this.f = nf\n\n    return this\n  }\n\n  lmultiply(matrix) {\n    return this.clone().lmultiplyO(matrix)\n  }\n\n  lmultiplyO(matrix) {\n    const r = this\n    const l = matrix instanceof Matrix ? matrix : new Matrix(matrix)\n\n    return Matrix.matrixMultiply(l, r, this)\n  }\n\n  // Left multiplies by the given matrix\n  multiply(matrix) {\n    return this.clone().multiplyO(matrix)\n  }\n\n  multiplyO(matrix) {\n    // Get the matrices\n    const l = this\n    const r = matrix instanceof Matrix ? matrix : new Matrix(matrix)\n\n    return Matrix.matrixMultiply(l, r, this)\n  }\n\n  // Rotate matrix\n  rotate(r, cx, cy) {\n    return this.clone().rotateO(r, cx, cy)\n  }\n\n  rotateO(r, cx = 0, cy = 0) {\n    // Convert degrees to radians\n    r = radians(r)\n\n    const cos = Math.cos(r)\n    const sin = Math.sin(r)\n\n    const { a, b, c, d, e, f } = this\n\n    this.a = a * cos - b * sin\n    this.b = b * cos + a * sin\n    this.c = c * cos - d * sin\n    this.d = d * cos + c * sin\n    this.e = e * cos - f * sin + cy * sin - cx * cos + cx\n    this.f = f * cos + e * sin - cx * sin - cy * cos + cy\n\n    return this\n  }\n\n  // Scale matrix\n  scale() {\n    return this.clone().scaleO(...arguments)\n  }\n\n  scaleO(x, y = x, cx = 0, cy = 0) {\n    // Support uniform scaling\n    if (arguments.length === 3) {\n      cy = cx\n      cx = y\n      y = x\n    }\n\n    const { a, b, c, d, e, f } = this\n\n    this.a = a * x\n    this.b = b * y\n    this.c = c * x\n    this.d = d * y\n    this.e = e * x - cx * x + cx\n    this.f = f * y - cy * y + cy\n\n    return this\n  }\n\n  // Shear matrix\n  shear(a, cx, cy) {\n    return this.clone().shearO(a, cx, cy)\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  shearO(lx, cx = 0, cy = 0) {\n    const { a, b, c, d, e, f } = this\n\n    this.a = a + b * lx\n    this.c = c + d * lx\n    this.e = e + f * lx - cy * lx\n\n    return this\n  }\n\n  // Skew Matrix\n  skew() {\n    return this.clone().skewO(...arguments)\n  }\n\n  skewO(x, y = x, cx = 0, cy = 0) {\n    // support uniformal skew\n    if (arguments.length === 3) {\n      cy = cx\n      cx = y\n      y = x\n    }\n\n    // Convert degrees to radians\n    x = radians(x)\n    y = radians(y)\n\n    const lx = Math.tan(x)\n    const ly = Math.tan(y)\n\n    const { a, b, c, d, e, f } = this\n\n    this.a = a + b * lx\n    this.b = b + a * ly\n    this.c = c + d * lx\n    this.d = d + c * ly\n    this.e = e + f * lx - cy * lx\n    this.f = f + e * ly - cx * ly\n\n    return this\n  }\n\n  // SkewX\n  skewX(x, cx, cy) {\n    return this.skew(x, 0, cx, cy)\n  }\n\n  // SkewY\n  skewY(y, cx, cy) {\n    return this.skew(0, y, cx, cy)\n  }\n\n  toArray() {\n    return [this.a, this.b, this.c, this.d, this.e, this.f]\n  }\n\n  // Convert matrix to string\n  toString() {\n    return (\n      'matrix(' +\n      this.a +\n      ',' +\n      this.b +\n      ',' +\n      this.c +\n      ',' +\n      this.d +\n      ',' +\n      this.e +\n      ',' +\n      this.f +\n      ')'\n    )\n  }\n\n  // Transform a matrix into another matrix by manipulating the space\n  transform(o) {\n    // Check if o is a matrix and then left multiply it directly\n    if (Matrix.isMatrixLike(o)) {\n      const matrix = new Matrix(o)\n      return matrix.multiplyO(this)\n    }\n\n    // Get the proposed transformations and the current transformations\n    const t = Matrix.formatTransforms(o)\n    const current = this\n    const { x: ox, y: oy } = new Point(t.ox, t.oy).transform(current)\n\n    // Construct the resulting matrix\n    const transformer = new Matrix()\n      .translateO(t.rx, t.ry)\n      .lmultiplyO(current)\n      .translateO(-ox, -oy)\n      .scaleO(t.scaleX, t.scaleY)\n      .skewO(t.skewX, t.skewY)\n      .shearO(t.shear)\n      .rotateO(t.theta)\n      .translateO(ox, oy)\n\n    // If we want the origin at a particular place, we force it there\n    if (isFinite(t.px) || isFinite(t.py)) {\n      const origin = new Point(ox, oy).transform(transformer)\n      // TODO: Replace t.px with isFinite(t.px)\n      // Doesn't work because t.px is also 0 if it wasn't passed\n      const dx = isFinite(t.px) ? t.px - origin.x : 0\n      const dy = isFinite(t.py) ? t.py - origin.y : 0\n      transformer.translateO(dx, dy)\n    }\n\n    // Translate now after positioning\n    transformer.translateO(t.tx, t.ty)\n    return transformer\n  }\n\n  // Translate matrix\n  translate(x, y) {\n    return this.clone().translateO(x, y)\n  }\n\n  translateO(x, y) {\n    this.e += x || 0\n    this.f += y || 0\n    return this\n  }\n\n  valueOf() {\n    return {\n      a: this.a,\n      b: this.b,\n      c: this.c,\n      d: this.d,\n      e: this.e,\n      f: this.f\n    }\n  }\n}\n\nfunction ctm() {\n  return new Matrix(this.node.getCTM())\n}\n\nfunction screenCTM() {\n  try {\n    /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537\n       This is needed because FF does not return the transformation matrix\n       for the inner coordinate system when getScreenCTM() is called on nested svgs.\n       However all other Browsers do that */\n    if (typeof this.isRoot === 'function' && !this.isRoot()) {\n      const rect = this.rect(1, 1)\n      const m = rect.node.getScreenCTM()\n      rect.remove()\n      return new Matrix(m)\n    }\n    return new Matrix(this.node.getScreenCTM())\n  } catch (e) {\n    console.warn(\n      `Cannot get CTM from SVG node ${this.node.nodeName}. Is the element rendered?`\n    )\n    return new Matrix()\n  }\n}\n\nregister(Matrix, 'Matrix')\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/parser.js\n\n\n\nfunction parser() {\n  // Reuse cached element if possible\n  if (!parser.nodes) {\n    const svg = adopter_makeInstance().size(2, 0)\n    svg.node.style.cssText = [\n      'opacity: 0',\n      'position: absolute',\n      'left: -100%',\n      'top: -100%',\n      'overflow: hidden'\n    ].join(';')\n\n    svg.attr('focusable', 'false')\n    svg.attr('aria-hidden', 'true')\n\n    const path = svg.path().node\n\n    parser.nodes = { svg, path }\n  }\n\n  if (!parser.nodes.svg.node.parentNode) {\n    const b = globals.document.body || globals.document.documentElement\n    parser.nodes.svg.addTo(b)\n  }\n\n  return parser.nodes\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/Box.js\n\n\n\n\n\n\n\n\nfunction isNulledBox(box) {\n  return !box.width && !box.height && !box.x && !box.y\n}\n\nfunction domContains(node) {\n  return (\n    node === globals.document ||\n    (\n      globals.document.documentElement.contains ||\n      function (node) {\n        // This is IE - it does not support contains() for top-level SVGs\n        while (node.parentNode) {\n          node = node.parentNode\n        }\n        return node === globals.document\n      }\n    ).call(globals.document.documentElement, node)\n  )\n}\n\nclass Box {\n  constructor(...args) {\n    this.init(...args)\n  }\n\n  addOffset() {\n    // offset by window scroll position, because getBoundingClientRect changes when window is scrolled\n    this.x += globals.window.pageXOffset\n    this.y += globals.window.pageYOffset\n    return new Box(this)\n  }\n\n  init(source) {\n    const base = [0, 0, 0, 0]\n    source =\n      typeof source === 'string'\n        ? source.split(delimiter).map(parseFloat)\n        : Array.isArray(source)\n          ? source\n          : typeof source === 'object'\n            ? [\n                source.left != null ? source.left : source.x,\n                source.top != null ? source.top : source.y,\n                source.width,\n                source.height\n              ]\n            : arguments.length === 4\n              ? [].slice.call(arguments)\n              : base\n\n    this.x = source[0] || 0\n    this.y = source[1] || 0\n    this.width = this.w = source[2] || 0\n    this.height = this.h = source[3] || 0\n\n    // Add more bounding box properties\n    this.x2 = this.x + this.w\n    this.y2 = this.y + this.h\n    this.cx = this.x + this.w / 2\n    this.cy = this.y + this.h / 2\n\n    return this\n  }\n\n  isNulled() {\n    return isNulledBox(this)\n  }\n\n  // Merge rect box with another, return a new instance\n  merge(box) {\n    const x = Math.min(this.x, box.x)\n    const y = Math.min(this.y, box.y)\n    const width = Math.max(this.x + this.width, box.x + box.width) - x\n    const height = Math.max(this.y + this.height, box.y + box.height) - y\n\n    return new Box(x, y, width, height)\n  }\n\n  toArray() {\n    return [this.x, this.y, this.width, this.height]\n  }\n\n  toString() {\n    return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height\n  }\n\n  transform(m) {\n    if (!(m instanceof Matrix)) {\n      m = new Matrix(m)\n    }\n\n    let xMin = Infinity\n    let xMax = -Infinity\n    let yMin = Infinity\n    let yMax = -Infinity\n\n    const pts = [\n      new Point(this.x, this.y),\n      new Point(this.x2, this.y),\n      new Point(this.x, this.y2),\n      new Point(this.x2, this.y2)\n    ]\n\n    pts.forEach(function (p) {\n      p = p.transform(m)\n      xMin = Math.min(xMin, p.x)\n      xMax = Math.max(xMax, p.x)\n      yMin = Math.min(yMin, p.y)\n      yMax = Math.max(yMax, p.y)\n    })\n\n    return new Box(xMin, yMin, xMax - xMin, yMax - yMin)\n  }\n}\n\nfunction getBox(el, getBBoxFn, retry) {\n  let box\n\n  try {\n    // Try to get the box with the provided function\n    box = getBBoxFn(el.node)\n\n    // If the box is worthless and not even in the dom, retry\n    // by throwing an error here...\n    if (isNulledBox(box) && !domContains(el.node)) {\n      throw new Error('Element not in the dom')\n    }\n  } catch (e) {\n    // ... and calling the retry handler here\n    box = retry(el)\n  }\n\n  return box\n}\n\nfunction bbox() {\n  // Function to get bbox is getBBox()\n  const getBBox = (node) => node.getBBox()\n\n  // Take all measures so that a stupid browser renders the element\n  // so we can get the bbox from it when we try again\n  const retry = (el) => {\n    try {\n      const clone = el.clone().addTo(parser().svg).show()\n      const box = clone.node.getBBox()\n      clone.remove()\n      return box\n    } catch (e) {\n      // We give up...\n      throw new Error(\n        `Getting bbox of element \"${\n          el.node.nodeName\n        }\" is not possible: ${e.toString()}`\n      )\n    }\n  }\n\n  const box = getBox(this, getBBox, retry)\n  const bbox = new Box(box)\n\n  return bbox\n}\n\nfunction rbox(el) {\n  const getRBox = (node) => node.getBoundingClientRect()\n  const retry = (el) => {\n    // There is no point in trying tricks here because if we insert the element into the dom ourselves\n    // it obviously will be at the wrong position\n    throw new Error(\n      `Getting rbox of element \"${el.node.nodeName}\" is not possible`\n    )\n  }\n\n  const box = getBox(this, getRBox, retry)\n  const rbox = new Box(box)\n\n  // If an element was passed, we want the bbox in the coordinate system of that element\n  if (el) {\n    return rbox.transform(el.screenCTM().inverseO())\n  }\n\n  // Else we want it in absolute screen coordinates\n  // Therefore we need to add the scrollOffset\n  return rbox.addOffset()\n}\n\n// Checks whether the given point is inside the bounding box\nfunction inside(x, y) {\n  const box = this.bbox()\n\n  return (\n    x > box.x && y > box.y && x < box.x + box.width && y < box.y + box.height\n  )\n}\n\nregisterMethods({\n  viewbox: {\n    viewbox(x, y, width, height) {\n      // act as getter\n      if (x == null) return new Box(this.attr('viewBox'))\n\n      // act as setter\n      return this.attr('viewBox', new Box(x, y, width, height))\n    },\n\n    zoom(level, point) {\n      // Its best to rely on the attributes here and here is why:\n      // clientXYZ: Doesn't work on non-root svgs because they dont have a CSSBox (silly!)\n      // getBoundingClientRect: Doesn't work because Chrome just ignores width and height of nested svgs completely\n      //                        that means, their clientRect is always as big as the content.\n      //                        Furthermore this size is incorrect if the element is further transformed by its parents\n      // computedStyle: Only returns meaningful values if css was used with px. We dont go this route here!\n      // getBBox: returns the bounding box of its content - that doesn't help!\n      let { width, height } = this.attr(['width', 'height'])\n\n      // Width and height is a string when a number with a unit is present which we can't use\n      // So we try clientXYZ\n      if (\n        (!width && !height) ||\n        typeof width === 'string' ||\n        typeof height === 'string'\n      ) {\n        width = this.node.clientWidth\n        height = this.node.clientHeight\n      }\n\n      // Giving up...\n      if (!width || !height) {\n        throw new Error(\n          'Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element'\n        )\n      }\n\n      const v = this.viewbox()\n\n      const zoomX = width / v.width\n      const zoomY = height / v.height\n      const zoom = Math.min(zoomX, zoomY)\n\n      if (level == null) {\n        return zoom\n      }\n\n      let zoomAmount = zoom / level\n\n      // Set the zoomAmount to the highest value which is safe to process and recover from\n      // The * 100 is a bit of wiggle room for the matrix transformation\n      if (zoomAmount === Infinity) zoomAmount = Number.MAX_SAFE_INTEGER / 100\n\n      point =\n        point || new Point(width / 2 / zoomX + v.x, height / 2 / zoomY + v.y)\n\n      const box = new Box(v).transform(\n        new Matrix({ scale: zoomAmount, origin: point })\n      )\n\n      return this.viewbox(box)\n    }\n  }\n})\n\nregister(Box, 'Box')\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/List.js\n\n// import { subClassArray } from './ArrayPolyfill.js'\n\nclass List extends Array {\n  constructor(arr = [], ...args) {\n    super(arr, ...args)\n    if (typeof arr === 'number') return this\n    this.length = 0\n    this.push(...arr)\n  }\n}\n\n/* = subClassArray('List', Array, function (arr = []) {\n  // This catches the case, that native map tries to create an array with new Array(1)\n  if (typeof arr === 'number') return this\n  this.length = 0\n  this.push(...arr)\n}) */\n\n/* harmony default export */ const types_List = (List);\n\nextend([List], {\n  each(fnOrMethodName, ...args) {\n    if (typeof fnOrMethodName === 'function') {\n      return this.map((el, i, arr) => {\n        return fnOrMethodName.call(el, el, i, arr)\n      })\n    } else {\n      return this.map((el) => {\n        return el[fnOrMethodName](...args)\n      })\n    }\n  },\n\n  toArray() {\n    return Array.prototype.concat.apply([], this)\n  }\n})\n\nconst reserved = ['toArray', 'constructor', 'each']\n\nList.extend = function (methods) {\n  methods = methods.reduce((obj, name) => {\n    // Don't overwrite own methods\n    if (reserved.includes(name)) return obj\n\n    // Don't add private methods\n    if (name[0] === '_') return obj\n\n    // Allow access to original Array methods through a prefix\n    if (name in Array.prototype) {\n      obj['$' + name] = Array.prototype[name]\n    }\n\n    // Relay every call to each()\n    obj[name] = function (...attrs) {\n      return this.each(name, ...attrs)\n    }\n    return obj\n  }, {})\n\n  extend([List], methods)\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/selector.js\n\n\n\n\n\nfunction baseFind(query, parent) {\n  return new types_List(\n    map((parent || globals.document).querySelectorAll(query), function (node) {\n      return adopt(node)\n    })\n  )\n}\n\n// Scoped find method\nfunction find(query) {\n  return baseFind(query, this.node)\n}\n\nfunction findOne(query) {\n  return adopt(this.node.querySelector(query))\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/event.js\n\n\n\n\nlet listenerId = 0\nconst windowEvents = {}\n\nfunction getEvents(instance) {\n  let n = instance.getEventHolder()\n\n  // We dont want to save events in global space\n  if (n === globals.window) n = windowEvents\n  if (!n.events) n.events = {}\n  return n.events\n}\n\nfunction getEventTarget(instance) {\n  return instance.getEventTarget()\n}\n\nfunction clearEvents(instance) {\n  let n = instance.getEventHolder()\n  if (n === globals.window) n = windowEvents\n  if (n.events) n.events = {}\n}\n\n// Add event binder in the SVG namespace\nfunction on(node, events, listener, binding, options) {\n  const l = listener.bind(binding || node)\n  const instance = adopter_makeInstance(node)\n  const bag = getEvents(instance)\n  const n = getEventTarget(instance)\n\n  // events can be an array of events or a string of events\n  events = Array.isArray(events) ? events : events.split(delimiter)\n\n  // add id to listener\n  if (!listener._svgjsListenerId) {\n    listener._svgjsListenerId = ++listenerId\n  }\n\n  events.forEach(function (event) {\n    const ev = event.split('.')[0]\n    const ns = event.split('.')[1] || '*'\n\n    // ensure valid object\n    bag[ev] = bag[ev] || {}\n    bag[ev][ns] = bag[ev][ns] || {}\n\n    // reference listener\n    bag[ev][ns][listener._svgjsListenerId] = l\n\n    // add listener\n    n.addEventListener(ev, l, options || false)\n  })\n}\n\n// Add event unbinder in the SVG namespace\nfunction off(node, events, listener, options) {\n  const instance = adopter_makeInstance(node)\n  const bag = getEvents(instance)\n  const n = getEventTarget(instance)\n\n  // listener can be a function or a number\n  if (typeof listener === 'function') {\n    listener = listener._svgjsListenerId\n    if (!listener) return\n  }\n\n  // events can be an array of events or a string or undefined\n  events = Array.isArray(events) ? events : (events || '').split(delimiter)\n\n  events.forEach(function (event) {\n    const ev = event && event.split('.')[0]\n    const ns = event && event.split('.')[1]\n    let namespace, l\n\n    if (listener) {\n      // remove listener reference\n      if (bag[ev] && bag[ev][ns || '*']) {\n        // removeListener\n        n.removeEventListener(\n          ev,\n          bag[ev][ns || '*'][listener],\n          options || false\n        )\n\n        delete bag[ev][ns || '*'][listener]\n      }\n    } else if (ev && ns) {\n      // remove all listeners for a namespaced event\n      if (bag[ev] && bag[ev][ns]) {\n        for (l in bag[ev][ns]) {\n          off(n, [ev, ns].join('.'), l)\n        }\n\n        delete bag[ev][ns]\n      }\n    } else if (ns) {\n      // remove all listeners for a specific namespace\n      for (event in bag) {\n        for (namespace in bag[event]) {\n          if (ns === namespace) {\n            off(n, [event, ns].join('.'))\n          }\n        }\n      }\n    } else if (ev) {\n      // remove all listeners for the event\n      if (bag[ev]) {\n        for (namespace in bag[ev]) {\n          off(n, [ev, namespace].join('.'))\n        }\n\n        delete bag[ev]\n      }\n    } else {\n      // remove all listeners on a given node\n      for (event in bag) {\n        off(n, event)\n      }\n\n      clearEvents(instance)\n    }\n  })\n}\n\nfunction dispatch(node, event, data, options) {\n  const n = getEventTarget(node)\n\n  // Dispatch event\n  if (event instanceof globals.window.Event) {\n    n.dispatchEvent(event)\n  } else {\n    event = new globals.window.CustomEvent(event, {\n      detail: data,\n      cancelable: true,\n      ...options\n    })\n    n.dispatchEvent(event)\n  }\n  return event\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/EventTarget.js\n\n\n\n\nclass EventTarget extends Base {\n  addEventListener() {}\n\n  dispatch(event, data, options) {\n    return dispatch(this, event, data, options)\n  }\n\n  dispatchEvent(event) {\n    const bag = this.getEventHolder().events\n    if (!bag) return true\n\n    const events = bag[event.type]\n\n    for (const i in events) {\n      for (const j in events[i]) {\n        events[i][j](event)\n      }\n    }\n\n    return !event.defaultPrevented\n  }\n\n  // Fire given event\n  fire(event, data, options) {\n    this.dispatch(event, data, options)\n    return this\n  }\n\n  getEventHolder() {\n    return this\n  }\n\n  getEventTarget() {\n    return this\n  }\n\n  // Unbind event from listener\n  off(event, listener, options) {\n    off(this, event, listener, options)\n    return this\n  }\n\n  // Bind given event to listener\n  on(event, listener, binding, options) {\n    on(this, event, listener, binding, options)\n    return this\n  }\n\n  removeEventListener() {}\n}\n\nregister(EventTarget, 'EventTarget')\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/defaults.js\nfunction noop() {}\n\n// Default animation values\nconst timeline = {\n  duration: 400,\n  ease: '>',\n  delay: 0\n}\n\n// Default attribute values\nconst attrs = {\n  // fill and stroke\n  'fill-opacity': 1,\n  'stroke-opacity': 1,\n  'stroke-width': 0,\n  'stroke-linejoin': 'miter',\n  'stroke-linecap': 'butt',\n  fill: '#000000',\n  stroke: '#000000',\n  opacity: 1,\n\n  // position\n  x: 0,\n  y: 0,\n  cx: 0,\n  cy: 0,\n\n  // size\n  width: 0,\n  height: 0,\n\n  // radius\n  r: 0,\n  rx: 0,\n  ry: 0,\n\n  // gradient\n  offset: 0,\n  'stop-opacity': 1,\n  'stop-color': '#000000',\n\n  // text\n  'text-anchor': 'start'\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/SVGArray.js\n\n\nclass SVGArray extends Array {\n  constructor(...args) {\n    super(...args)\n    this.init(...args)\n  }\n\n  clone() {\n    return new this.constructor(this)\n  }\n\n  init(arr) {\n    // This catches the case, that native map tries to create an array with new Array(1)\n    if (typeof arr === 'number') return this\n    this.length = 0\n    this.push(...this.parse(arr))\n    return this\n  }\n\n  // Parse whitespace separated string\n  parse(array = []) {\n    // If already is an array, no need to parse it\n    if (array instanceof Array) return array\n\n    return array.trim().split(delimiter).map(parseFloat)\n  }\n\n  toArray() {\n    return Array.prototype.concat.apply([], this)\n  }\n\n  toSet() {\n    return new Set(this)\n  }\n\n  toString() {\n    return this.join(' ')\n  }\n\n  // Flattens the array if needed\n  valueOf() {\n    const ret = []\n    ret.push(...this)\n    return ret\n  }\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/SVGNumber.js\n\n\n// Module for unit conversions\nclass SVGNumber {\n  // Initialize\n  constructor(...args) {\n    this.init(...args)\n  }\n\n  convert(unit) {\n    return new SVGNumber(this.value, unit)\n  }\n\n  // Divide number\n  divide(number) {\n    number = new SVGNumber(number)\n    return new SVGNumber(this / number, this.unit || number.unit)\n  }\n\n  init(value, unit) {\n    unit = Array.isArray(value) ? value[1] : unit\n    value = Array.isArray(value) ? value[0] : value\n\n    // initialize defaults\n    this.value = 0\n    this.unit = unit || ''\n\n    // parse value\n    if (typeof value === 'number') {\n      // ensure a valid numeric value\n      this.value = isNaN(value)\n        ? 0\n        : !isFinite(value)\n          ? value < 0\n            ? -3.4e38\n            : +3.4e38\n          : value\n    } else if (typeof value === 'string') {\n      unit = value.match(numberAndUnit)\n\n      if (unit) {\n        // make value numeric\n        this.value = parseFloat(unit[1])\n\n        // normalize\n        if (unit[5] === '%') {\n          this.value /= 100\n        } else if (unit[5] === 's') {\n          this.value *= 1000\n        }\n\n        // store unit\n        this.unit = unit[5]\n      }\n    } else {\n      if (value instanceof SVGNumber) {\n        this.value = value.valueOf()\n        this.unit = value.unit\n      }\n    }\n\n    return this\n  }\n\n  // Subtract number\n  minus(number) {\n    number = new SVGNumber(number)\n    return new SVGNumber(this - number, this.unit || number.unit)\n  }\n\n  // Add number\n  plus(number) {\n    number = new SVGNumber(number)\n    return new SVGNumber(this + number, this.unit || number.unit)\n  }\n\n  // Multiply number\n  times(number) {\n    number = new SVGNumber(number)\n    return new SVGNumber(this * number, this.unit || number.unit)\n  }\n\n  toArray() {\n    return [this.value, this.unit]\n  }\n\n  toJSON() {\n    return this.toString()\n  }\n\n  toString() {\n    return (\n      (this.unit === '%'\n        ? ~~(this.value * 1e8) / 1e6\n        : this.unit === 's'\n          ? this.value / 1e3\n          : this.value) + this.unit\n    )\n  }\n\n  valueOf() {\n    return this.value\n  }\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/attr.js\n\n\n\n\n\n\nconst colorAttributes = new Set([\n  'fill',\n  'stroke',\n  'color',\n  'bgcolor',\n  'stop-color',\n  'flood-color',\n  'lighting-color'\n])\n\nconst hooks = []\nfunction registerAttrHook(fn) {\n  hooks.push(fn)\n}\n\n// Set svg element attribute\nfunction attr(attr, val, ns) {\n  // act as full getter\n  if (attr == null) {\n    // get an object of attributes\n    attr = {}\n    val = this.node.attributes\n\n    for (const node of val) {\n      attr[node.nodeName] = isNumber.test(node.nodeValue)\n        ? parseFloat(node.nodeValue)\n        : node.nodeValue\n    }\n\n    return attr\n  } else if (attr instanceof Array) {\n    // loop through array and get all values\n    return attr.reduce((last, curr) => {\n      last[curr] = this.attr(curr)\n      return last\n    }, {})\n  } else if (typeof attr === 'object' && attr.constructor === Object) {\n    // apply every attribute individually if an object is passed\n    for (val in attr) this.attr(val, attr[val])\n  } else if (val === null) {\n    // remove value\n    this.node.removeAttribute(attr)\n  } else if (val == null) {\n    // act as a getter if the first and only argument is not an object\n    val = this.node.getAttribute(attr)\n    return val == null\n      ? attrs[attr]\n      : isNumber.test(val)\n        ? parseFloat(val)\n        : val\n  } else {\n    // Loop through hooks and execute them to convert value\n    val = hooks.reduce((_val, hook) => {\n      return hook(attr, _val, this)\n    }, val)\n\n    // ensure correct numeric values (also accepts NaN and Infinity)\n    if (typeof val === 'number') {\n      val = new SVGNumber(val)\n    } else if (colorAttributes.has(attr) && Color.isColor(val)) {\n      // ensure full hex color\n      val = new Color(val)\n    } else if (val.constructor === Array) {\n      // Check for plain arrays and parse array values\n      val = new SVGArray(val)\n    }\n\n    // if the passed attribute is leading...\n    if (attr === 'leading') {\n      // ... call the leading method instead\n      if (this.leading) {\n        this.leading(val)\n      }\n    } else {\n      // set given attribute on node\n      typeof ns === 'string'\n        ? this.node.setAttributeNS(ns, attr, val.toString())\n        : this.node.setAttribute(attr, val.toString())\n    }\n\n    // rebuild if required\n    if (this.rebuild && (attr === 'font-size' || attr === 'x')) {\n      this.rebuild()\n    }\n  }\n\n  return this\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Dom.js\n\n\n\n\n\n\n\n\n\nclass Dom extends EventTarget {\n  constructor(node, attrs) {\n    super()\n    this.node = node\n    this.type = node.nodeName\n\n    if (attrs && node !== attrs) {\n      this.attr(attrs)\n    }\n  }\n\n  // Add given element at a position\n  add(element, i) {\n    element = adopter_makeInstance(element)\n\n    // If non-root svg nodes are added we have to remove their namespaces\n    if (\n      element.removeNamespace &&\n      this.node instanceof globals.window.SVGElement\n    ) {\n      element.removeNamespace()\n    }\n\n    if (i == null) {\n      this.node.appendChild(element.node)\n    } else if (element.node !== this.node.childNodes[i]) {\n      this.node.insertBefore(element.node, this.node.childNodes[i])\n    }\n\n    return this\n  }\n\n  // Add element to given container and return self\n  addTo(parent, i) {\n    return adopter_makeInstance(parent).put(this, i)\n  }\n\n  // Returns all child elements\n  children() {\n    return new types_List(\n      map(this.node.children, function (node) {\n        return adopt(node)\n      })\n    )\n  }\n\n  // Remove all elements in this container\n  clear() {\n    // remove children\n    while (this.node.hasChildNodes()) {\n      this.node.removeChild(this.node.lastChild)\n    }\n\n    return this\n  }\n\n  // Clone element\n  clone(deep = true, assignNewIds = true) {\n    // write dom data to the dom so the clone can pickup the data\n    this.writeDataToDom()\n\n    // clone element\n    let nodeClone = this.node.cloneNode(deep)\n    if (assignNewIds) {\n      // assign new id\n      nodeClone = assignNewId(nodeClone)\n    }\n    return new this.constructor(nodeClone)\n  }\n\n  // Iterates over all children and invokes a given block\n  each(block, deep) {\n    const children = this.children()\n    let i, il\n\n    for (i = 0, il = children.length; i < il; i++) {\n      block.apply(children[i], [i, children])\n\n      if (deep) {\n        children[i].each(block, deep)\n      }\n    }\n\n    return this\n  }\n\n  element(nodeName, attrs) {\n    return this.put(new Dom(create(nodeName), attrs))\n  }\n\n  // Get first child\n  first() {\n    return adopt(this.node.firstChild)\n  }\n\n  // Get a element at the given index\n  get(i) {\n    return adopt(this.node.childNodes[i])\n  }\n\n  getEventHolder() {\n    return this.node\n  }\n\n  getEventTarget() {\n    return this.node\n  }\n\n  // Checks if the given element is a child\n  has(element) {\n    return this.index(element) >= 0\n  }\n\n  html(htmlOrFn, outerHTML) {\n    return this.xml(htmlOrFn, outerHTML, html)\n  }\n\n  // Get / set id\n  id(id) {\n    // generate new id if no id set\n    if (typeof id === 'undefined' && !this.node.id) {\n      this.node.id = eid(this.type)\n    }\n\n    // don't set directly with this.node.id to make `null` work correctly\n    return this.attr('id', id)\n  }\n\n  // Gets index of given element\n  index(element) {\n    return [].slice.call(this.node.childNodes).indexOf(element.node)\n  }\n\n  // Get the last child\n  last() {\n    return adopt(this.node.lastChild)\n  }\n\n  // matches the element vs a css selector\n  matches(selector) {\n    const el = this.node\n    const matcher =\n      el.matches ||\n      el.matchesSelector ||\n      el.msMatchesSelector ||\n      el.mozMatchesSelector ||\n      el.webkitMatchesSelector ||\n      el.oMatchesSelector ||\n      null\n    return matcher && matcher.call(el, selector)\n  }\n\n  // Returns the parent element instance\n  parent(type) {\n    let parent = this\n\n    // check for parent\n    if (!parent.node.parentNode) return null\n\n    // get parent element\n    parent = adopt(parent.node.parentNode)\n\n    if (!type) return parent\n\n    // loop through ancestors if type is given\n    do {\n      if (\n        typeof type === 'string' ? parent.matches(type) : parent instanceof type\n      )\n        return parent\n    } while ((parent = adopt(parent.node.parentNode)))\n\n    return parent\n  }\n\n  // Basically does the same as `add()` but returns the added element instead\n  put(element, i) {\n    element = adopter_makeInstance(element)\n    this.add(element, i)\n    return element\n  }\n\n  // Add element to given container and return container\n  putIn(parent, i) {\n    return adopter_makeInstance(parent).add(this, i)\n  }\n\n  // Remove element\n  remove() {\n    if (this.parent()) {\n      this.parent().removeElement(this)\n    }\n\n    return this\n  }\n\n  // Remove a given child\n  removeElement(element) {\n    this.node.removeChild(element.node)\n\n    return this\n  }\n\n  // Replace this with element\n  replace(element) {\n    element = adopter_makeInstance(element)\n\n    if (this.node.parentNode) {\n      this.node.parentNode.replaceChild(element.node, this.node)\n    }\n\n    return element\n  }\n\n  round(precision = 2, map = null) {\n    const factor = 10 ** precision\n    const attrs = this.attr(map)\n\n    for (const i in attrs) {\n      if (typeof attrs[i] === 'number') {\n        attrs[i] = Math.round(attrs[i] * factor) / factor\n      }\n    }\n\n    this.attr(attrs)\n    return this\n  }\n\n  // Import / Export raw svg\n  svg(svgOrFn, outerSVG) {\n    return this.xml(svgOrFn, outerSVG, svg)\n  }\n\n  // Return id on string conversion\n  toString() {\n    return this.id()\n  }\n\n  words(text) {\n    // This is faster than removing all children and adding a new one\n    this.node.textContent = text\n    return this\n  }\n\n  wrap(node) {\n    const parent = this.parent()\n\n    if (!parent) {\n      return this.addTo(node)\n    }\n\n    const position = parent.index(this)\n    return parent.put(node, position).put(this)\n  }\n\n  // write svgjs data to the dom\n  writeDataToDom() {\n    // dump variables recursively\n    this.each(function () {\n      this.writeDataToDom()\n    })\n\n    return this\n  }\n\n  // Import / Export raw svg\n  xml(xmlOrFn, outerXML, ns) {\n    if (typeof xmlOrFn === 'boolean') {\n      ns = outerXML\n      outerXML = xmlOrFn\n      xmlOrFn = null\n    }\n\n    // act as getter if no svg string is given\n    if (xmlOrFn == null || typeof xmlOrFn === 'function') {\n      // The default for exports is, that the outerNode is included\n      outerXML = outerXML == null ? true : outerXML\n\n      // write svgjs data to the dom\n      this.writeDataToDom()\n      let current = this\n\n      // An export modifier was passed\n      if (xmlOrFn != null) {\n        current = adopt(current.node.cloneNode(true))\n\n        // If the user wants outerHTML we need to process this node, too\n        if (outerXML) {\n          const result = xmlOrFn(current)\n          current = result || current\n\n          // The user does not want this node? Well, then he gets nothing\n          if (result === false) return ''\n        }\n\n        // Deep loop through all children and apply modifier\n        current.each(function () {\n          const result = xmlOrFn(this)\n          const _this = result || this\n\n          // If modifier returns false, discard node\n          if (result === false) {\n            this.remove()\n\n            // If modifier returns new node, use it\n          } else if (result && this !== _this) {\n            this.replace(_this)\n          }\n        }, true)\n      }\n\n      // Return outer or inner content\n      return outerXML ? current.node.outerHTML : current.node.innerHTML\n    }\n\n    // Act as setter if we got a string\n\n    // The default for import is, that the current node is not replaced\n    outerXML = outerXML == null ? false : outerXML\n\n    // Create temporary holder\n    const well = create('wrapper', ns)\n    const fragment = globals.document.createDocumentFragment()\n\n    // Dump raw svg\n    well.innerHTML = xmlOrFn\n\n    // Transplant nodes into the fragment\n    for (let len = well.children.length; len--; ) {\n      fragment.appendChild(well.firstElementChild)\n    }\n\n    const parent = this.parent()\n\n    // Add the whole fragment at once\n    return outerXML ? this.replace(fragment) && parent : this.add(fragment)\n  }\n}\n\nextend(Dom, { attr: attr, find: find, findOne: findOne })\nregister(Dom, 'Dom')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Element.js\n\n\n\n\n\n\n\n\n\n\n\nclass Element extends Dom {\n  constructor(node, attrs) {\n    super(node, attrs)\n\n    // initialize data object\n    this.dom = {}\n\n    // create circular reference\n    this.node.instance = this\n\n    if (node.hasAttribute('data-svgjs') || node.hasAttribute('svgjs:data')) {\n      // pull svgjs data from the dom (getAttributeNS doesn't work in html5)\n      this.setData(\n        JSON.parse(node.getAttribute('data-svgjs')) ??\n          JSON.parse(node.getAttribute('svgjs:data')) ??\n          {}\n      )\n    }\n  }\n\n  // Move element by its center\n  center(x, y) {\n    return this.cx(x).cy(y)\n  }\n\n  // Move by center over x-axis\n  cx(x) {\n    return x == null\n      ? this.x() + this.width() / 2\n      : this.x(x - this.width() / 2)\n  }\n\n  // Move by center over y-axis\n  cy(y) {\n    return y == null\n      ? this.y() + this.height() / 2\n      : this.y(y - this.height() / 2)\n  }\n\n  // Get defs\n  defs() {\n    const root = this.root()\n    return root && root.defs()\n  }\n\n  // Relative move over x and y axes\n  dmove(x, y) {\n    return this.dx(x).dy(y)\n  }\n\n  // Relative move over x axis\n  dx(x = 0) {\n    return this.x(new SVGNumber(x).plus(this.x()))\n  }\n\n  // Relative move over y axis\n  dy(y = 0) {\n    return this.y(new SVGNumber(y).plus(this.y()))\n  }\n\n  getEventHolder() {\n    return this\n  }\n\n  // Set height of element\n  height(height) {\n    return this.attr('height', height)\n  }\n\n  // Move element to given x and y values\n  move(x, y) {\n    return this.x(x).y(y)\n  }\n\n  // return array of all ancestors of given type up to the root svg\n  parents(until = this.root()) {\n    const isSelector = typeof until === 'string'\n    if (!isSelector) {\n      until = adopter_makeInstance(until)\n    }\n    const parents = new types_List()\n    let parent = this\n\n    while (\n      (parent = parent.parent()) &&\n      parent.node !== globals.document &&\n      parent.nodeName !== '#document-fragment'\n    ) {\n      parents.push(parent)\n\n      if (!isSelector && parent.node === until.node) {\n        break\n      }\n      if (isSelector && parent.matches(until)) {\n        break\n      }\n      if (parent.node === this.root().node) {\n        // We worked our way to the root and didn't match `until`\n        return null\n      }\n    }\n\n    return parents\n  }\n\n  // Get referenced element form attribute value\n  reference(attr) {\n    attr = this.attr(attr)\n    if (!attr) return null\n\n    const m = (attr + '').match(reference)\n    return m ? adopter_makeInstance(m[1]) : null\n  }\n\n  // Get parent document\n  root() {\n    const p = this.parent(getClass(root))\n    return p && p.root()\n  }\n\n  // set given data to the elements data property\n  setData(o) {\n    this.dom = o\n    return this\n  }\n\n  // Set element size to given width and height\n  size(width, height) {\n    const p = proportionalSize(this, width, height)\n\n    return this.width(new SVGNumber(p.width)).height(new SVGNumber(p.height))\n  }\n\n  // Set width of element\n  width(width) {\n    return this.attr('width', width)\n  }\n\n  // write svgjs data to the dom\n  writeDataToDom() {\n    writeDataToDom(this, this.dom)\n    return super.writeDataToDom()\n  }\n\n  // Move over x-axis\n  x(x) {\n    return this.attr('x', x)\n  }\n\n  // Move over y-axis\n  y(y) {\n    return this.attr('y', y)\n  }\n}\n\nextend(Element, {\n  bbox: bbox,\n  rbox: rbox,\n  inside: inside,\n  point: point,\n  ctm: ctm,\n  screenCTM: screenCTM\n})\n\nregister(Element, 'Element')\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/optional/sugar.js\n\n\n\n\n\n\n\n// Define list of available attributes for stroke and fill\nconst sugar = {\n  stroke: [\n    'color',\n    'width',\n    'opacity',\n    'linecap',\n    'linejoin',\n    'miterlimit',\n    'dasharray',\n    'dashoffset'\n  ],\n  fill: ['color', 'opacity', 'rule'],\n  prefix: function (t, a) {\n    return a === 'color' ? t : t + '-' + a\n  }\n}\n\n// Add sugar for fill and stroke\n;['fill', 'stroke'].forEach(function (m) {\n  const extension = {}\n  let i\n\n  extension[m] = function (o) {\n    if (typeof o === 'undefined') {\n      return this.attr(m)\n    }\n    if (\n      typeof o === 'string' ||\n      o instanceof Color ||\n      Color.isRgb(o) ||\n      o instanceof Element\n    ) {\n      this.attr(m, o)\n    } else {\n      // set all attributes from sugar.fill and sugar.stroke list\n      for (i = sugar[m].length - 1; i >= 0; i--) {\n        if (o[sugar[m][i]] != null) {\n          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]])\n        }\n      }\n    }\n\n    return this\n  }\n\n  registerMethods(['Element', 'Runner'], extension)\n})\n\nregisterMethods(['Element', 'Runner'], {\n  // Let the user set the matrix directly\n  matrix: function (mat, b, c, d, e, f) {\n    // Act as a getter\n    if (mat == null) {\n      return new Matrix(this)\n    }\n\n    // Act as a setter, the user can pass a matrix or a set of numbers\n    return this.attr('transform', new Matrix(mat, b, c, d, e, f))\n  },\n\n  // Map rotation to transform\n  rotate: function (angle, cx, cy) {\n    return this.transform({ rotate: angle, ox: cx, oy: cy }, true)\n  },\n\n  // Map skew to transform\n  skew: function (x, y, cx, cy) {\n    return arguments.length === 1 || arguments.length === 3\n      ? this.transform({ skew: x, ox: y, oy: cx }, true)\n      : this.transform({ skew: [x, y], ox: cx, oy: cy }, true)\n  },\n\n  shear: function (lam, cx, cy) {\n    return this.transform({ shear: lam, ox: cx, oy: cy }, true)\n  },\n\n  // Map scale to transform\n  scale: function (x, y, cx, cy) {\n    return arguments.length === 1 || arguments.length === 3\n      ? this.transform({ scale: x, ox: y, oy: cx }, true)\n      : this.transform({ scale: [x, y], ox: cx, oy: cy }, true)\n  },\n\n  // Map translate to transform\n  translate: function (x, y) {\n    return this.transform({ translate: [x, y] }, true)\n  },\n\n  // Map relative translations to transform\n  relative: function (x, y) {\n    return this.transform({ relative: [x, y] }, true)\n  },\n\n  // Map flip to transform\n  flip: function (direction = 'both', origin = 'center') {\n    if ('xybothtrue'.indexOf(direction) === -1) {\n      origin = direction\n      direction = 'both'\n    }\n\n    return this.transform({ flip: direction, origin: origin }, true)\n  },\n\n  // Opacity\n  opacity: function (value) {\n    return this.attr('opacity', value)\n  }\n})\n\nregisterMethods('radius', {\n  // Add x and y radius\n  radius: function (x, y = x) {\n    const type = (this._element || this).type\n    return type === 'radialGradient'\n      ? this.attr('r', new SVGNumber(x))\n      : this.rx(x).ry(y)\n  }\n})\n\nregisterMethods('Path', {\n  // Get path length\n  length: function () {\n    return this.node.getTotalLength()\n  },\n  // Get point at length\n  pointAt: function (length) {\n    return new Point(this.node.getPointAtLength(length))\n  }\n})\n\nregisterMethods(['Element', 'Runner'], {\n  // Set font\n  font: function (a, v) {\n    if (typeof a === 'object') {\n      for (v in a) this.font(v, a[v])\n      return this\n    }\n\n    return a === 'leading'\n      ? this.leading(v)\n      : a === 'anchor'\n        ? this.attr('text-anchor', v)\n        : a === 'size' ||\n            a === 'family' ||\n            a === 'weight' ||\n            a === 'stretch' ||\n            a === 'variant' ||\n            a === 'style'\n          ? this.attr('font-' + a, v)\n          : this.attr(a, v)\n  }\n})\n\n// Add events to elements\nconst sugar_methods = [\n  'click',\n  'dblclick',\n  'mousedown',\n  'mouseup',\n  'mouseover',\n  'mouseout',\n  'mousemove',\n  'mouseenter',\n  'mouseleave',\n  'touchstart',\n  'touchmove',\n  'touchleave',\n  'touchend',\n  'touchcancel',\n  'contextmenu',\n  'wheel',\n  'pointerdown',\n  'pointermove',\n  'pointerup',\n  'pointerleave',\n  'pointercancel'\n].reduce(function (last, event) {\n  // add event to Element\n  const fn = function (f) {\n    if (f === null) {\n      this.off(event)\n    } else {\n      this.on(event, f)\n    }\n    return this\n  }\n\n  last[event] = fn\n  return last\n}, {})\n\nregisterMethods('Element', sugar_methods)\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/optional/transform.js\n\n\n\n\n\n// Reset all transformations\nfunction untransform() {\n  return this.attr('transform', null)\n}\n\n// merge the whole transformation chain into one matrix and returns it\nfunction matrixify() {\n  const matrix = (this.attr('transform') || '')\n    // split transformations\n    .split(transforms)\n    .slice(0, -1)\n    .map(function (str) {\n      // generate key => value pairs\n      const kv = str.trim().split('(')\n      return [\n        kv[0],\n        kv[1].split(delimiter).map(function (str) {\n          return parseFloat(str)\n        })\n      ]\n    })\n    .reverse()\n    // merge every transformation into one matrix\n    .reduce(function (matrix, transform) {\n      if (transform[0] === 'matrix') {\n        return matrix.lmultiply(Matrix.fromArray(transform[1]))\n      }\n      return matrix[transform[0]].apply(matrix, transform[1])\n    }, new Matrix())\n\n  return matrix\n}\n\n// add an element to another parent without changing the visual representation on the screen\nfunction toParent(parent, i) {\n  if (this === parent) return this\n\n  if (isDescriptive(this.node)) return this.addTo(parent, i)\n\n  const ctm = this.screenCTM()\n  const pCtm = parent.screenCTM().inverse()\n\n  this.addTo(parent, i).untransform().transform(pCtm.multiply(ctm))\n\n  return this\n}\n\n// same as above with parent equals root-svg\nfunction toRoot(i) {\n  return this.toParent(this.root(), i)\n}\n\n// Add transformations\nfunction transform(o, relative) {\n  // Act as a getter if no object was passed\n  if (o == null || typeof o === 'string') {\n    const decomposed = new Matrix(this).decompose()\n    return o == null ? decomposed : decomposed[o]\n  }\n\n  if (!Matrix.isMatrixLike(o)) {\n    // Set the origin according to the defined transform\n    o = { ...o, origin: getOrigin(o, this) }\n  }\n\n  // The user can pass a boolean, an Element or an Matrix or nothing\n  const cleanRelative = relative === true ? this : relative || false\n  const result = new Matrix(cleanRelative).transform(o)\n  return this.attr('transform', result)\n}\n\nregisterMethods('Element', {\n  untransform,\n  matrixify,\n  toParent,\n  toRoot,\n  transform\n})\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Container.js\n\n\n\nclass Container extends Element {\n  flatten() {\n    this.each(function () {\n      if (this instanceof Container) {\n        return this.flatten().ungroup()\n      }\n    })\n\n    return this\n  }\n\n  ungroup(parent = this.parent(), index = parent.index(this)) {\n    // when parent != this, we want append all elements to the end\n    index = index === -1 ? parent.children().length : index\n\n    this.each(function (i, children) {\n      // reverse each\n      return children[children.length - i - 1].toParent(parent, index)\n    })\n\n    return this.remove()\n  }\n}\n\nregister(Container, 'Container')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Defs.js\n\n\n\nclass Defs extends Container {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('defs', node), attrs)\n  }\n\n  flatten() {\n    return this\n  }\n\n  ungroup() {\n    return this\n  }\n}\n\nregister(Defs, 'Defs')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Shape.js\n\n\n\nclass Shape extends Element {}\n\nregister(Shape, 'Shape')\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/circled.js\n\n\n// Radius x value\nfunction rx(rx) {\n  return this.attr('rx', rx)\n}\n\n// Radius y value\nfunction ry(ry) {\n  return this.attr('ry', ry)\n}\n\n// Move over x-axis\nfunction x(x) {\n  return x == null ? this.cx() - this.rx() : this.cx(x + this.rx())\n}\n\n// Move over y-axis\nfunction y(y) {\n  return y == null ? this.cy() - this.ry() : this.cy(y + this.ry())\n}\n\n// Move by center over x-axis\nfunction cx(x) {\n  return this.attr('cx', x)\n}\n\n// Move by center over y-axis\nfunction cy(y) {\n  return this.attr('cy', y)\n}\n\n// Set width of element\nfunction width(width) {\n  return width == null ? this.rx() * 2 : this.rx(new SVGNumber(width).divide(2))\n}\n\n// Set height of element\nfunction height(height) {\n  return height == null\n    ? this.ry() * 2\n    : this.ry(new SVGNumber(height).divide(2))\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Ellipse.js\n\n\n\n\n\n\n\nclass Ellipse extends Shape {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('ellipse', node), attrs)\n  }\n\n  size(width, height) {\n    const p = proportionalSize(this, width, height)\n\n    return this.rx(new SVGNumber(p.width).divide(2)).ry(\n      new SVGNumber(p.height).divide(2)\n    )\n  }\n}\n\nextend(Ellipse, circled_namespaceObject)\n\nregisterMethods('Container', {\n  // Create an ellipse\n  ellipse: wrapWithAttrCheck(function (width = 0, height = width) {\n    return this.put(new Ellipse()).size(width, height).move(0, 0)\n  })\n})\n\nregister(Ellipse, 'Ellipse')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Fragment.js\n\n\n\n\nclass Fragment extends Dom {\n  constructor(node = globals.document.createDocumentFragment()) {\n    super(node)\n  }\n\n  // Import / Export raw xml\n  xml(xmlOrFn, outerXML, ns) {\n    if (typeof xmlOrFn === 'boolean') {\n      ns = outerXML\n      outerXML = xmlOrFn\n      xmlOrFn = null\n    }\n\n    // because this is a fragment we have to put all elements into a wrapper first\n    // before we can get the innerXML from it\n    if (xmlOrFn == null || typeof xmlOrFn === 'function') {\n      const wrapper = new Dom(create('wrapper', ns))\n      wrapper.add(this.node.cloneNode(true))\n\n      return wrapper.xml(false, ns)\n    }\n\n    // Act as setter if we got a string\n    return super.xml(xmlOrFn, false, ns)\n  }\n}\n\nregister(Fragment, 'Fragment')\n\n/* harmony default export */ const elements_Fragment = (Fragment);\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/gradiented.js\n\n\nfunction from(x, y) {\n  return (this._element || this).type === 'radialGradient'\n    ? this.attr({ fx: new SVGNumber(x), fy: new SVGNumber(y) })\n    : this.attr({ x1: new SVGNumber(x), y1: new SVGNumber(y) })\n}\n\nfunction to(x, y) {\n  return (this._element || this).type === 'radialGradient'\n    ? this.attr({ cx: new SVGNumber(x), cy: new SVGNumber(y) })\n    : this.attr({ x2: new SVGNumber(x), y2: new SVGNumber(y) })\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Gradient.js\n\n\n\n\n\n\n\nclass Gradient extends Container {\n  constructor(type, attrs) {\n    super(\n      nodeOrNew(type + 'Gradient', typeof type === 'string' ? null : type),\n      attrs\n    )\n  }\n\n  // custom attr to handle transform\n  attr(a, b, c) {\n    if (a === 'transform') a = 'gradientTransform'\n    return super.attr(a, b, c)\n  }\n\n  bbox() {\n    return new Box()\n  }\n\n  targets() {\n    return baseFind('svg [fill*=' + this.id() + ']')\n  }\n\n  // Alias string conversion to fill\n  toString() {\n    return this.url()\n  }\n\n  // Update gradient\n  update(block) {\n    // remove all stops\n    this.clear()\n\n    // invoke passed block\n    if (typeof block === 'function') {\n      block.call(this, this)\n    }\n\n    return this\n  }\n\n  // Return the fill id\n  url() {\n    return 'url(#' + this.id() + ')'\n  }\n}\n\nextend(Gradient, gradiented_namespaceObject)\n\nregisterMethods({\n  Container: {\n    // Create gradient element in defs\n    gradient(...args) {\n      return this.defs().gradient(...args)\n    }\n  },\n  // define gradient\n  Defs: {\n    gradient: wrapWithAttrCheck(function (type, block) {\n      return this.put(new Gradient(type)).update(block)\n    })\n  }\n})\n\nregister(Gradient, 'Gradient')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Pattern.js\n\n\n\n\n\n\nclass Pattern extends Container {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('pattern', node), attrs)\n  }\n\n  // custom attr to handle transform\n  attr(a, b, c) {\n    if (a === 'transform') a = 'patternTransform'\n    return super.attr(a, b, c)\n  }\n\n  bbox() {\n    return new Box()\n  }\n\n  targets() {\n    return baseFind('svg [fill*=' + this.id() + ']')\n  }\n\n  // Alias string conversion to fill\n  toString() {\n    return this.url()\n  }\n\n  // Update pattern by rebuilding\n  update(block) {\n    // remove content\n    this.clear()\n\n    // invoke passed block\n    if (typeof block === 'function') {\n      block.call(this, this)\n    }\n\n    return this\n  }\n\n  // Return the fill id\n  url() {\n    return 'url(#' + this.id() + ')'\n  }\n}\n\nregisterMethods({\n  Container: {\n    // Create pattern element in defs\n    pattern(...args) {\n      return this.defs().pattern(...args)\n    }\n  },\n  Defs: {\n    pattern: wrapWithAttrCheck(function (width, height, block) {\n      return this.put(new Pattern()).update(block).attr({\n        x: 0,\n        y: 0,\n        width: width,\n        height: height,\n        patternUnits: 'userSpaceOnUse'\n      })\n    })\n  }\n})\n\nregister(Pattern, 'Pattern')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Image.js\n\n\n\n\n\n\n\n\n\n\nclass Image extends Shape {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('image', node), attrs)\n  }\n\n  // (re)load image\n  load(url, callback) {\n    if (!url) return this\n\n    const img = new globals.window.Image()\n\n    on(\n      img,\n      'load',\n      function (e) {\n        const p = this.parent(Pattern)\n\n        // ensure image size\n        if (this.width() === 0 && this.height() === 0) {\n          this.size(img.width, img.height)\n        }\n\n        if (p instanceof Pattern) {\n          // ensure pattern size if not set\n          if (p.width() === 0 && p.height() === 0) {\n            p.size(this.width(), this.height())\n          }\n        }\n\n        if (typeof callback === 'function') {\n          callback.call(this, e)\n        }\n      },\n      this\n    )\n\n    on(img, 'load error', function () {\n      // dont forget to unbind memory leaking events\n      off(img)\n    })\n\n    return this.attr('href', (img.src = url), xlink)\n  }\n}\n\nregisterAttrHook(function (attr, val, _this) {\n  // convert image fill and stroke to patterns\n  if (attr === 'fill' || attr === 'stroke') {\n    if (isImage.test(val)) {\n      val = _this.root().defs().image(val)\n    }\n  }\n\n  if (val instanceof Image) {\n    val = _this\n      .root()\n      .defs()\n      .pattern(0, 0, (pattern) => {\n        pattern.add(val)\n      })\n  }\n\n  return val\n})\n\nregisterMethods({\n  Container: {\n    // create image element, load image and set its size\n    image: wrapWithAttrCheck(function (source, callback) {\n      return this.put(new Image()).size(0, 0).load(source, callback)\n    })\n  }\n})\n\nregister(Image, 'Image')\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/PointArray.js\n\n\n\n\n\nclass PointArray extends SVGArray {\n  // Get bounding box of points\n  bbox() {\n    let maxX = -Infinity\n    let maxY = -Infinity\n    let minX = Infinity\n    let minY = Infinity\n    this.forEach(function (el) {\n      maxX = Math.max(el[0], maxX)\n      maxY = Math.max(el[1], maxY)\n      minX = Math.min(el[0], minX)\n      minY = Math.min(el[1], minY)\n    })\n    return new Box(minX, minY, maxX - minX, maxY - minY)\n  }\n\n  // Move point string\n  move(x, y) {\n    const box = this.bbox()\n\n    // get relative offset\n    x -= box.x\n    y -= box.y\n\n    // move every point\n    if (!isNaN(x) && !isNaN(y)) {\n      for (let i = this.length - 1; i >= 0; i--) {\n        this[i] = [this[i][0] + x, this[i][1] + y]\n      }\n    }\n\n    return this\n  }\n\n  // Parse point string and flat array\n  parse(array = [0, 0]) {\n    const points = []\n\n    // if it is an array, we flatten it and therefore clone it to 1 depths\n    if (array instanceof Array) {\n      array = Array.prototype.concat.apply([], array)\n    } else {\n      // Else, it is considered as a string\n      // parse points\n      array = array.trim().split(delimiter).map(parseFloat)\n    }\n\n    // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints\n    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.\n    if (array.length % 2 !== 0) array.pop()\n\n    // wrap points in two-tuples\n    for (let i = 0, len = array.length; i < len; i = i + 2) {\n      points.push([array[i], array[i + 1]])\n    }\n\n    return points\n  }\n\n  // Resize poly string\n  size(width, height) {\n    let i\n    const box = this.bbox()\n\n    // recalculate position of all points according to new size\n    for (i = this.length - 1; i >= 0; i--) {\n      if (box.width)\n        this[i][0] = ((this[i][0] - box.x) * width) / box.width + box.x\n      if (box.height)\n        this[i][1] = ((this[i][1] - box.y) * height) / box.height + box.y\n    }\n\n    return this\n  }\n\n  // Convert array to line object\n  toLine() {\n    return {\n      x1: this[0][0],\n      y1: this[0][1],\n      x2: this[1][0],\n      y2: this[1][1]\n    }\n  }\n\n  // Convert array to string\n  toString() {\n    const array = []\n    // convert to a poly point string\n    for (let i = 0, il = this.length; i < il; i++) {\n      array.push(this[i].join(','))\n    }\n\n    return array.join(' ')\n  }\n\n  transform(m) {\n    return this.clone().transformO(m)\n  }\n\n  // transform points with matrix (similar to Point.transform)\n  transformO(m) {\n    if (!Matrix.isMatrixLike(m)) {\n      m = new Matrix(m)\n    }\n\n    for (let i = this.length; i--; ) {\n      // Perform the matrix multiplication\n      const [x, y] = this[i]\n      this[i][0] = m.a * x + m.c * y + m.e\n      this[i][1] = m.b * x + m.d * y + m.f\n    }\n\n    return this\n  }\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/pointed.js\n\n\nconst MorphArray = PointArray\n\n// Move by left top corner over x-axis\nfunction pointed_x(x) {\n  return x == null ? this.bbox().x : this.move(x, this.bbox().y)\n}\n\n// Move by left top corner over y-axis\nfunction pointed_y(y) {\n  return y == null ? this.bbox().y : this.move(this.bbox().x, y)\n}\n\n// Set width of element\nfunction pointed_width(width) {\n  const b = this.bbox()\n  return width == null ? b.width : this.size(width, b.height)\n}\n\n// Set height of element\nfunction pointed_height(height) {\n  const b = this.bbox()\n  return height == null ? b.height : this.size(b.width, height)\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Line.js\n\n\n\n\n\n\n\nclass Line extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('line', node), attrs)\n  }\n\n  // Get array\n  array() {\n    return new PointArray([\n      [this.attr('x1'), this.attr('y1')],\n      [this.attr('x2'), this.attr('y2')]\n    ])\n  }\n\n  // Move by left top corner\n  move(x, y) {\n    return this.attr(this.array().move(x, y).toLine())\n  }\n\n  // Overwrite native plot() method\n  plot(x1, y1, x2, y2) {\n    if (x1 == null) {\n      return this.array()\n    } else if (typeof y1 !== 'undefined') {\n      x1 = { x1, y1, x2, y2 }\n    } else {\n      x1 = new PointArray(x1).toLine()\n    }\n\n    return this.attr(x1)\n  }\n\n  // Set element size to given width and height\n  size(width, height) {\n    const p = proportionalSize(this, width, height)\n    return this.attr(this.array().size(p.width, p.height).toLine())\n  }\n}\n\nextend(Line, pointed_namespaceObject)\n\nregisterMethods({\n  Container: {\n    // Create a line element\n    line: wrapWithAttrCheck(function (...args) {\n      // make sure plot is called as a setter\n      // x1 is not necessarily a number, it can also be an array, a string and a PointArray\n      return Line.prototype.plot.apply(\n        this.put(new Line()),\n        args[0] != null ? args : [0, 0, 0, 0]\n      )\n    })\n  }\n})\n\nregister(Line, 'Line')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Marker.js\n\n\n\n\nclass Marker extends Container {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('marker', node), attrs)\n  }\n\n  // Set height of element\n  height(height) {\n    return this.attr('markerHeight', height)\n  }\n\n  orient(orient) {\n    return this.attr('orient', orient)\n  }\n\n  // Set marker refX and refY\n  ref(x, y) {\n    return this.attr('refX', x).attr('refY', y)\n  }\n\n  // Return the fill id\n  toString() {\n    return 'url(#' + this.id() + ')'\n  }\n\n  // Update marker\n  update(block) {\n    // remove all content\n    this.clear()\n\n    // invoke passed block\n    if (typeof block === 'function') {\n      block.call(this, this)\n    }\n\n    return this\n  }\n\n  // Set width of element\n  width(width) {\n    return this.attr('markerWidth', width)\n  }\n}\n\nregisterMethods({\n  Container: {\n    marker(...args) {\n      // Create marker element in defs\n      return this.defs().marker(...args)\n    }\n  },\n  Defs: {\n    // Create marker\n    marker: wrapWithAttrCheck(function (width, height, block) {\n      // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto\n      return this.put(new Marker())\n        .size(width, height)\n        .ref(width / 2, height / 2)\n        .viewbox(0, 0, width, height)\n        .attr('orient', 'auto')\n        .update(block)\n    })\n  },\n  marker: {\n    // Create and attach markers\n    marker(marker, width, height, block) {\n      let attr = ['marker']\n\n      // Build attribute name\n      if (marker !== 'all') attr.push(marker)\n      attr = attr.join('-')\n\n      // Set marker attribute\n      marker =\n        arguments[1] instanceof Marker\n          ? arguments[1]\n          : this.defs().marker(width, height, block)\n\n      return this.attr(attr, marker)\n    }\n  }\n})\n\nregister(Marker, 'Marker')\n\n;// ./node_modules/@svgdotjs/svg.js/src/animation/Controller.js\n\n\n\n/***\nBase Class\n==========\nThe base stepper class that will be\n***/\n\nfunction makeSetterGetter(k, f) {\n  return function (v) {\n    if (v == null) return this[k]\n    this[k] = v\n    if (f) f.call(this)\n    return this\n  }\n}\n\nconst easing = {\n  '-': function (pos) {\n    return pos\n  },\n  '<>': function (pos) {\n    return -Math.cos(pos * Math.PI) / 2 + 0.5\n  },\n  '>': function (pos) {\n    return Math.sin((pos * Math.PI) / 2)\n  },\n  '<': function (pos) {\n    return -Math.cos((pos * Math.PI) / 2) + 1\n  },\n  bezier: function (x1, y1, x2, y2) {\n    // see https://www.w3.org/TR/css-easing-1/#cubic-bezier-algo\n    return function (t) {\n      if (t < 0) {\n        if (x1 > 0) {\n          return (y1 / x1) * t\n        } else if (x2 > 0) {\n          return (y2 / x2) * t\n        } else {\n          return 0\n        }\n      } else if (t > 1) {\n        if (x2 < 1) {\n          return ((1 - y2) / (1 - x2)) * t + (y2 - x2) / (1 - x2)\n        } else if (x1 < 1) {\n          return ((1 - y1) / (1 - x1)) * t + (y1 - x1) / (1 - x1)\n        } else {\n          return 1\n        }\n      } else {\n        return 3 * t * (1 - t) ** 2 * y1 + 3 * t ** 2 * (1 - t) * y2 + t ** 3\n      }\n    }\n  },\n  // see https://www.w3.org/TR/css-easing-1/#step-timing-function-algo\n  steps: function (steps, stepPosition = 'end') {\n    // deal with \"jump-\" prefix\n    stepPosition = stepPosition.split('-').reverse()[0]\n\n    let jumps = steps\n    if (stepPosition === 'none') {\n      --jumps\n    } else if (stepPosition === 'both') {\n      ++jumps\n    }\n\n    // The beforeFlag is essentially useless\n    return (t, beforeFlag = false) => {\n      // Step is called currentStep in referenced url\n      let step = Math.floor(t * steps)\n      const jumping = (t * step) % 1 === 0\n\n      if (stepPosition === 'start' || stepPosition === 'both') {\n        ++step\n      }\n\n      if (beforeFlag && jumping) {\n        --step\n      }\n\n      if (t >= 0 && step < 0) {\n        step = 0\n      }\n\n      if (t <= 1 && step > jumps) {\n        step = jumps\n      }\n\n      return step / jumps\n    }\n  }\n}\n\nclass Stepper {\n  done() {\n    return false\n  }\n}\n\n/***\nEasing Functions\n================\n***/\n\nclass Ease extends Stepper {\n  constructor(fn = timeline.ease) {\n    super()\n    this.ease = easing[fn] || fn\n  }\n\n  step(from, to, pos) {\n    if (typeof from !== 'number') {\n      return pos < 1 ? from : to\n    }\n    return from + (to - from) * this.ease(pos)\n  }\n}\n\n/***\nController Types\n================\n***/\n\nclass Controller extends Stepper {\n  constructor(fn) {\n    super()\n    this.stepper = fn\n  }\n\n  done(c) {\n    return c.done\n  }\n\n  step(current, target, dt, c) {\n    return this.stepper(current, target, dt, c)\n  }\n}\n\nfunction recalculate() {\n  // Apply the default parameters\n  const duration = (this._duration || 500) / 1000\n  const overshoot = this._overshoot || 0\n\n  // Calculate the PID natural response\n  const eps = 1e-10\n  const pi = Math.PI\n  const os = Math.log(overshoot / 100 + eps)\n  const zeta = -os / Math.sqrt(pi * pi + os * os)\n  const wn = 3.9 / (zeta * duration)\n\n  // Calculate the Spring values\n  this.d = 2 * zeta * wn\n  this.k = wn * wn\n}\n\nclass Spring extends Controller {\n  constructor(duration = 500, overshoot = 0) {\n    super()\n    this.duration(duration).overshoot(overshoot)\n  }\n\n  step(current, target, dt, c) {\n    if (typeof current === 'string') return current\n    c.done = dt === Infinity\n    if (dt === Infinity) return target\n    if (dt === 0) return current\n\n    if (dt > 100) dt = 16\n\n    dt /= 1000\n\n    // Get the previous velocity\n    const velocity = c.velocity || 0\n\n    // Apply the control to get the new position and store it\n    const acceleration = -this.d * velocity - this.k * (current - target)\n    const newPosition = current + velocity * dt + (acceleration * dt * dt) / 2\n\n    // Store the velocity\n    c.velocity = velocity + acceleration * dt\n\n    // Figure out if we have converged, and if so, pass the value\n    c.done = Math.abs(target - newPosition) + Math.abs(velocity) < 0.002\n    return c.done ? target : newPosition\n  }\n}\n\nextend(Spring, {\n  duration: makeSetterGetter('_duration', recalculate),\n  overshoot: makeSetterGetter('_overshoot', recalculate)\n})\n\nclass PID extends Controller {\n  constructor(p = 0.1, i = 0.01, d = 0, windup = 1000) {\n    super()\n    this.p(p).i(i).d(d).windup(windup)\n  }\n\n  step(current, target, dt, c) {\n    if (typeof current === 'string') return current\n    c.done = dt === Infinity\n\n    if (dt === Infinity) return target\n    if (dt === 0) return current\n\n    const p = target - current\n    let i = (c.integral || 0) + p * dt\n    const d = (p - (c.error || 0)) / dt\n    const windup = this._windup\n\n    // antiwindup\n    if (windup !== false) {\n      i = Math.max(-windup, Math.min(i, windup))\n    }\n\n    c.error = p\n    c.integral = i\n\n    c.done = Math.abs(p) < 0.001\n\n    return c.done ? target : current + (this.P * p + this.I * i + this.D * d)\n  }\n}\n\nextend(PID, {\n  windup: makeSetterGetter('_windup'),\n  p: makeSetterGetter('P'),\n  i: makeSetterGetter('I'),\n  d: makeSetterGetter('D')\n})\n\n;// ./node_modules/@svgdotjs/svg.js/src/utils/pathParser.js\n\n\n\nconst segmentParameters = {\n  M: 2,\n  L: 2,\n  H: 1,\n  V: 1,\n  C: 6,\n  S: 4,\n  Q: 4,\n  T: 2,\n  A: 7,\n  Z: 0\n}\n\nconst pathHandlers = {\n  M: function (c, p, p0) {\n    p.x = p0.x = c[0]\n    p.y = p0.y = c[1]\n\n    return ['M', p.x, p.y]\n  },\n  L: function (c, p) {\n    p.x = c[0]\n    p.y = c[1]\n    return ['L', c[0], c[1]]\n  },\n  H: function (c, p) {\n    p.x = c[0]\n    return ['H', c[0]]\n  },\n  V: function (c, p) {\n    p.y = c[0]\n    return ['V', c[0]]\n  },\n  C: function (c, p) {\n    p.x = c[4]\n    p.y = c[5]\n    return ['C', c[0], c[1], c[2], c[3], c[4], c[5]]\n  },\n  S: function (c, p) {\n    p.x = c[2]\n    p.y = c[3]\n    return ['S', c[0], c[1], c[2], c[3]]\n  },\n  Q: function (c, p) {\n    p.x = c[2]\n    p.y = c[3]\n    return ['Q', c[0], c[1], c[2], c[3]]\n  },\n  T: function (c, p) {\n    p.x = c[0]\n    p.y = c[1]\n    return ['T', c[0], c[1]]\n  },\n  Z: function (c, p, p0) {\n    p.x = p0.x\n    p.y = p0.y\n    return ['Z']\n  },\n  A: function (c, p) {\n    p.x = c[5]\n    p.y = c[6]\n    return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]]\n  }\n}\n\nconst mlhvqtcsaz = 'mlhvqtcsaz'.split('')\n\nfor (let i = 0, il = mlhvqtcsaz.length; i < il; ++i) {\n  pathHandlers[mlhvqtcsaz[i]] = (function (i) {\n    return function (c, p, p0) {\n      if (i === 'H') c[0] = c[0] + p.x\n      else if (i === 'V') c[0] = c[0] + p.y\n      else if (i === 'A') {\n        c[5] = c[5] + p.x\n        c[6] = c[6] + p.y\n      } else {\n        for (let j = 0, jl = c.length; j < jl; ++j) {\n          c[j] = c[j] + (j % 2 ? p.y : p.x)\n        }\n      }\n\n      return pathHandlers[i](c, p, p0)\n    }\n  })(mlhvqtcsaz[i].toUpperCase())\n}\n\nfunction makeAbsolut(parser) {\n  const command = parser.segment[0]\n  return pathHandlers[command](parser.segment.slice(1), parser.p, parser.p0)\n}\n\nfunction segmentComplete(parser) {\n  return (\n    parser.segment.length &&\n    parser.segment.length - 1 ===\n      segmentParameters[parser.segment[0].toUpperCase()]\n  )\n}\n\nfunction startNewSegment(parser, token) {\n  parser.inNumber && finalizeNumber(parser, false)\n  const pathLetter = isPathLetter.test(token)\n\n  if (pathLetter) {\n    parser.segment = [token]\n  } else {\n    const lastCommand = parser.lastCommand\n    const small = lastCommand.toLowerCase()\n    const isSmall = lastCommand === small\n    parser.segment = [small === 'm' ? (isSmall ? 'l' : 'L') : lastCommand]\n  }\n\n  parser.inSegment = true\n  parser.lastCommand = parser.segment[0]\n\n  return pathLetter\n}\n\nfunction finalizeNumber(parser, inNumber) {\n  if (!parser.inNumber) throw new Error('Parser Error')\n  parser.number && parser.segment.push(parseFloat(parser.number))\n  parser.inNumber = inNumber\n  parser.number = ''\n  parser.pointSeen = false\n  parser.hasExponent = false\n\n  if (segmentComplete(parser)) {\n    finalizeSegment(parser)\n  }\n}\n\nfunction finalizeSegment(parser) {\n  parser.inSegment = false\n  if (parser.absolute) {\n    parser.segment = makeAbsolut(parser)\n  }\n  parser.segments.push(parser.segment)\n}\n\nfunction isArcFlag(parser) {\n  if (!parser.segment.length) return false\n  const isArc = parser.segment[0].toUpperCase() === 'A'\n  const length = parser.segment.length\n\n  return isArc && (length === 4 || length === 5)\n}\n\nfunction isExponential(parser) {\n  return parser.lastToken.toUpperCase() === 'E'\n}\n\nconst pathDelimiters = new Set([' ', ',', '\\t', '\\n', '\\r', '\\f'])\nfunction pathParser(d, toAbsolute = true) {\n  let index = 0\n  let token = ''\n  const parser = {\n    segment: [],\n    inNumber: false,\n    number: '',\n    lastToken: '',\n    inSegment: false,\n    segments: [],\n    pointSeen: false,\n    hasExponent: false,\n    absolute: toAbsolute,\n    p0: new Point(),\n    p: new Point()\n  }\n\n  while (((parser.lastToken = token), (token = d.charAt(index++)))) {\n    if (!parser.inSegment) {\n      if (startNewSegment(parser, token)) {\n        continue\n      }\n    }\n\n    if (token === '.') {\n      if (parser.pointSeen || parser.hasExponent) {\n        finalizeNumber(parser, false)\n        --index\n        continue\n      }\n      parser.inNumber = true\n      parser.pointSeen = true\n      parser.number += token\n      continue\n    }\n\n    if (!isNaN(parseInt(token))) {\n      if (parser.number === '0' || isArcFlag(parser)) {\n        parser.inNumber = true\n        parser.number = token\n        finalizeNumber(parser, true)\n        continue\n      }\n\n      parser.inNumber = true\n      parser.number += token\n      continue\n    }\n\n    if (pathDelimiters.has(token)) {\n      if (parser.inNumber) {\n        finalizeNumber(parser, false)\n      }\n      continue\n    }\n\n    if (token === '-' || token === '+') {\n      if (parser.inNumber && !isExponential(parser)) {\n        finalizeNumber(parser, false)\n        --index\n        continue\n      }\n      parser.number += token\n      parser.inNumber = true\n      continue\n    }\n\n    if (token.toUpperCase() === 'E') {\n      parser.number += token\n      parser.hasExponent = true\n      continue\n    }\n\n    if (isPathLetter.test(token)) {\n      if (parser.inNumber) {\n        finalizeNumber(parser, false)\n      } else if (!segmentComplete(parser)) {\n        throw new Error('parser Error')\n      } else {\n        finalizeSegment(parser)\n      }\n      --index\n    }\n  }\n\n  if (parser.inNumber) {\n    finalizeNumber(parser, false)\n  }\n\n  if (parser.inSegment && segmentComplete(parser)) {\n    finalizeSegment(parser)\n  }\n\n  return parser.segments\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/PathArray.js\n\n\n\n\n\nfunction arrayToString(a) {\n  let s = ''\n  for (let i = 0, il = a.length; i < il; i++) {\n    s += a[i][0]\n\n    if (a[i][1] != null) {\n      s += a[i][1]\n\n      if (a[i][2] != null) {\n        s += ' '\n        s += a[i][2]\n\n        if (a[i][3] != null) {\n          s += ' '\n          s += a[i][3]\n          s += ' '\n          s += a[i][4]\n\n          if (a[i][5] != null) {\n            s += ' '\n            s += a[i][5]\n            s += ' '\n            s += a[i][6]\n\n            if (a[i][7] != null) {\n              s += ' '\n              s += a[i][7]\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return s + ' '\n}\n\nclass PathArray extends SVGArray {\n  // Get bounding box of path\n  bbox() {\n    parser().path.setAttribute('d', this.toString())\n    return new Box(parser.nodes.path.getBBox())\n  }\n\n  // Move path string\n  move(x, y) {\n    // get bounding box of current situation\n    const box = this.bbox()\n\n    // get relative offset\n    x -= box.x\n    y -= box.y\n\n    if (!isNaN(x) && !isNaN(y)) {\n      // move every point\n      for (let l, i = this.length - 1; i >= 0; i--) {\n        l = this[i][0]\n\n        if (l === 'M' || l === 'L' || l === 'T') {\n          this[i][1] += x\n          this[i][2] += y\n        } else if (l === 'H') {\n          this[i][1] += x\n        } else if (l === 'V') {\n          this[i][1] += y\n        } else if (l === 'C' || l === 'S' || l === 'Q') {\n          this[i][1] += x\n          this[i][2] += y\n          this[i][3] += x\n          this[i][4] += y\n\n          if (l === 'C') {\n            this[i][5] += x\n            this[i][6] += y\n          }\n        } else if (l === 'A') {\n          this[i][6] += x\n          this[i][7] += y\n        }\n      }\n    }\n\n    return this\n  }\n\n  // Absolutize and parse path to array\n  parse(d = 'M0 0') {\n    if (Array.isArray(d)) {\n      d = Array.prototype.concat.apply([], d).toString()\n    }\n\n    return pathParser(d)\n  }\n\n  // Resize path string\n  size(width, height) {\n    // get bounding box of current situation\n    const box = this.bbox()\n    let i, l\n\n    // If the box width or height is 0 then we ignore\n    // transformations on the respective axis\n    box.width = box.width === 0 ? 1 : box.width\n    box.height = box.height === 0 ? 1 : box.height\n\n    // recalculate position of all points according to new size\n    for (i = this.length - 1; i >= 0; i--) {\n      l = this[i][0]\n\n      if (l === 'M' || l === 'L' || l === 'T') {\n        this[i][1] = ((this[i][1] - box.x) * width) / box.width + box.x\n        this[i][2] = ((this[i][2] - box.y) * height) / box.height + box.y\n      } else if (l === 'H') {\n        this[i][1] = ((this[i][1] - box.x) * width) / box.width + box.x\n      } else if (l === 'V') {\n        this[i][1] = ((this[i][1] - box.y) * height) / box.height + box.y\n      } else if (l === 'C' || l === 'S' || l === 'Q') {\n        this[i][1] = ((this[i][1] - box.x) * width) / box.width + box.x\n        this[i][2] = ((this[i][2] - box.y) * height) / box.height + box.y\n        this[i][3] = ((this[i][3] - box.x) * width) / box.width + box.x\n        this[i][4] = ((this[i][4] - box.y) * height) / box.height + box.y\n\n        if (l === 'C') {\n          this[i][5] = ((this[i][5] - box.x) * width) / box.width + box.x\n          this[i][6] = ((this[i][6] - box.y) * height) / box.height + box.y\n        }\n      } else if (l === 'A') {\n        // resize radii\n        this[i][1] = (this[i][1] * width) / box.width\n        this[i][2] = (this[i][2] * height) / box.height\n\n        // move position values\n        this[i][6] = ((this[i][6] - box.x) * width) / box.width + box.x\n        this[i][7] = ((this[i][7] - box.y) * height) / box.height + box.y\n      }\n    }\n\n    return this\n  }\n\n  // Convert array to string\n  toString() {\n    return arrayToString(this)\n  }\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/animation/Morphable.js\n\n\n\n\n\n\n\n\nconst getClassForType = (value) => {\n  const type = typeof value\n\n  if (type === 'number') {\n    return SVGNumber\n  } else if (type === 'string') {\n    if (Color.isColor(value)) {\n      return Color\n    } else if (delimiter.test(value)) {\n      return isPathLetter.test(value) ? PathArray : SVGArray\n    } else if (numberAndUnit.test(value)) {\n      return SVGNumber\n    } else {\n      return NonMorphable\n    }\n  } else if (morphableTypes.indexOf(value.constructor) > -1) {\n    return value.constructor\n  } else if (Array.isArray(value)) {\n    return SVGArray\n  } else if (type === 'object') {\n    return ObjectBag\n  } else {\n    return NonMorphable\n  }\n}\n\nclass Morphable {\n  constructor(stepper) {\n    this._stepper = stepper || new Ease('-')\n\n    this._from = null\n    this._to = null\n    this._type = null\n    this._context = null\n    this._morphObj = null\n  }\n\n  at(pos) {\n    return this._morphObj.morph(\n      this._from,\n      this._to,\n      pos,\n      this._stepper,\n      this._context\n    )\n  }\n\n  done() {\n    const complete = this._context.map(this._stepper.done).reduce(function (\n      last,\n      curr\n    ) {\n      return last && curr\n    }, true)\n    return complete\n  }\n\n  from(val) {\n    if (val == null) {\n      return this._from\n    }\n\n    this._from = this._set(val)\n    return this\n  }\n\n  stepper(stepper) {\n    if (stepper == null) return this._stepper\n    this._stepper = stepper\n    return this\n  }\n\n  to(val) {\n    if (val == null) {\n      return this._to\n    }\n\n    this._to = this._set(val)\n    return this\n  }\n\n  type(type) {\n    // getter\n    if (type == null) {\n      return this._type\n    }\n\n    // setter\n    this._type = type\n    return this\n  }\n\n  _set(value) {\n    if (!this._type) {\n      this.type(getClassForType(value))\n    }\n\n    let result = new this._type(value)\n    if (this._type === Color) {\n      result = this._to\n        ? result[this._to[4]]()\n        : this._from\n          ? result[this._from[4]]()\n          : result\n    }\n\n    if (this._type === ObjectBag) {\n      result = this._to\n        ? result.align(this._to)\n        : this._from\n          ? result.align(this._from)\n          : result\n    }\n\n    result = result.toConsumable()\n\n    this._morphObj = this._morphObj || new this._type()\n    this._context =\n      this._context ||\n      Array.apply(null, Array(result.length))\n        .map(Object)\n        .map(function (o) {\n          o.done = true\n          return o\n        })\n    return result\n  }\n}\n\nclass NonMorphable {\n  constructor(...args) {\n    this.init(...args)\n  }\n\n  init(val) {\n    val = Array.isArray(val) ? val[0] : val\n    this.value = val\n    return this\n  }\n\n  toArray() {\n    return [this.value]\n  }\n\n  valueOf() {\n    return this.value\n  }\n}\n\nclass TransformBag {\n  constructor(...args) {\n    this.init(...args)\n  }\n\n  init(obj) {\n    if (Array.isArray(obj)) {\n      obj = {\n        scaleX: obj[0],\n        scaleY: obj[1],\n        shear: obj[2],\n        rotate: obj[3],\n        translateX: obj[4],\n        translateY: obj[5],\n        originX: obj[6],\n        originY: obj[7]\n      }\n    }\n\n    Object.assign(this, TransformBag.defaults, obj)\n    return this\n  }\n\n  toArray() {\n    const v = this\n\n    return [\n      v.scaleX,\n      v.scaleY,\n      v.shear,\n      v.rotate,\n      v.translateX,\n      v.translateY,\n      v.originX,\n      v.originY\n    ]\n  }\n}\n\nTransformBag.defaults = {\n  scaleX: 1,\n  scaleY: 1,\n  shear: 0,\n  rotate: 0,\n  translateX: 0,\n  translateY: 0,\n  originX: 0,\n  originY: 0\n}\n\nconst sortByKey = (a, b) => {\n  return a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0\n}\n\nclass ObjectBag {\n  constructor(...args) {\n    this.init(...args)\n  }\n\n  align(other) {\n    const values = this.values\n    for (let i = 0, il = values.length; i < il; ++i) {\n      // If the type is the same we only need to check if the color is in the correct format\n      if (values[i + 1] === other[i + 1]) {\n        if (values[i + 1] === Color && other[i + 7] !== values[i + 7]) {\n          const space = other[i + 7]\n          const color = new Color(this.values.splice(i + 3, 5))\n            [space]()\n            .toArray()\n          this.values.splice(i + 3, 0, ...color)\n        }\n\n        i += values[i + 2] + 2\n        continue\n      }\n\n      if (!other[i + 1]) {\n        return this\n      }\n\n      // The types differ, so we overwrite the new type with the old one\n      // And initialize it with the types default (e.g. black for color or 0 for number)\n      const defaultObject = new other[i + 1]().toArray()\n\n      // Than we fix the values array\n      const toDelete = values[i + 2] + 3\n\n      values.splice(\n        i,\n        toDelete,\n        other[i],\n        other[i + 1],\n        other[i + 2],\n        ...defaultObject\n      )\n\n      i += values[i + 2] + 2\n    }\n    return this\n  }\n\n  init(objOrArr) {\n    this.values = []\n\n    if (Array.isArray(objOrArr)) {\n      this.values = objOrArr.slice()\n      return\n    }\n\n    objOrArr = objOrArr || {}\n    const entries = []\n\n    for (const i in objOrArr) {\n      const Type = getClassForType(objOrArr[i])\n      const val = new Type(objOrArr[i]).toArray()\n      entries.push([i, Type, val.length, ...val])\n    }\n\n    entries.sort(sortByKey)\n\n    this.values = entries.reduce((last, curr) => last.concat(curr), [])\n    return this\n  }\n\n  toArray() {\n    return this.values\n  }\n\n  valueOf() {\n    const obj = {}\n    const arr = this.values\n\n    // for (var i = 0, len = arr.length; i < len; i += 2) {\n    while (arr.length) {\n      const key = arr.shift()\n      const Type = arr.shift()\n      const num = arr.shift()\n      const values = arr.splice(0, num)\n      obj[key] = new Type(values) // .valueOf()\n    }\n\n    return obj\n  }\n}\n\nconst morphableTypes = [NonMorphable, TransformBag, ObjectBag]\n\nfunction registerMorphableType(type = []) {\n  morphableTypes.push(...[].concat(type))\n}\n\nfunction makeMorphable() {\n  extend(morphableTypes, {\n    to(val) {\n      return new Morphable()\n        .type(this.constructor)\n        .from(this.toArray()) // this.valueOf())\n        .to(val)\n    },\n    fromArray(arr) {\n      this.init(arr)\n      return this\n    },\n    toConsumable() {\n      return this.toArray()\n    },\n    morph(from, to, pos, stepper, context) {\n      const mapper = function (i, index) {\n        return stepper.step(i, to[index], pos, context[index], context)\n      }\n\n      return this.fromArray(from.map(mapper))\n    }\n  })\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Path.js\n\n\n\n\n\n\nclass Path extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('path', node), attrs)\n  }\n\n  // Get array\n  array() {\n    return this._array || (this._array = new PathArray(this.attr('d')))\n  }\n\n  // Clear array cache\n  clear() {\n    delete this._array\n    return this\n  }\n\n  // Set height of element\n  height(height) {\n    return height == null\n      ? this.bbox().height\n      : this.size(this.bbox().width, height)\n  }\n\n  // Move by left top corner\n  move(x, y) {\n    return this.attr('d', this.array().move(x, y))\n  }\n\n  // Plot new path\n  plot(d) {\n    return d == null\n      ? this.array()\n      : this.clear().attr(\n          'd',\n          typeof d === 'string' ? d : (this._array = new PathArray(d))\n        )\n  }\n\n  // Set element size to given width and height\n  size(width, height) {\n    const p = proportionalSize(this, width, height)\n    return this.attr('d', this.array().size(p.width, p.height))\n  }\n\n  // Set width of element\n  width(width) {\n    return width == null\n      ? this.bbox().width\n      : this.size(width, this.bbox().height)\n  }\n\n  // Move by left top corner over x-axis\n  x(x) {\n    return x == null ? this.bbox().x : this.move(x, this.bbox().y)\n  }\n\n  // Move by left top corner over y-axis\n  y(y) {\n    return y == null ? this.bbox().y : this.move(this.bbox().x, y)\n  }\n}\n\n// Define morphable array\nPath.prototype.MorphArray = PathArray\n\n// Add parent method\nregisterMethods({\n  Container: {\n    // Create a wrapped path element\n    path: wrapWithAttrCheck(function (d) {\n      // make sure plot is called as a setter\n      return this.put(new Path()).plot(d || new PathArray())\n    })\n  }\n})\n\nregister(Path, 'Path')\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/poly.js\n\n\n\n// Get array\nfunction array() {\n  return this._array || (this._array = new PointArray(this.attr('points')))\n}\n\n// Clear array cache\nfunction clear() {\n  delete this._array\n  return this\n}\n\n// Move by left top corner\nfunction move(x, y) {\n  return this.attr('points', this.array().move(x, y))\n}\n\n// Plot new path\nfunction plot(p) {\n  return p == null\n    ? this.array()\n    : this.clear().attr(\n        'points',\n        typeof p === 'string' ? p : (this._array = new PointArray(p))\n      )\n}\n\n// Set element size to given width and height\nfunction size(width, height) {\n  const p = proportionalSize(this, width, height)\n  return this.attr('points', this.array().size(p.width, p.height))\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Polygon.js\n\n\n\n\n\n\n\nclass Polygon extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('polygon', node), attrs)\n  }\n}\n\nregisterMethods({\n  Container: {\n    // Create a wrapped polygon element\n    polygon: wrapWithAttrCheck(function (p) {\n      // make sure plot is called as a setter\n      return this.put(new Polygon()).plot(p || new PointArray())\n    })\n  }\n})\n\nextend(Polygon, pointed_namespaceObject)\nextend(Polygon, poly_namespaceObject)\nregister(Polygon, 'Polygon')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Polyline.js\n\n\n\n\n\n\n\nclass Polyline extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('polyline', node), attrs)\n  }\n}\n\nregisterMethods({\n  Container: {\n    // Create a wrapped polygon element\n    polyline: wrapWithAttrCheck(function (p) {\n      // make sure plot is called as a setter\n      return this.put(new Polyline()).plot(p || new PointArray())\n    })\n  }\n})\n\nextend(Polyline, pointed_namespaceObject)\nextend(Polyline, poly_namespaceObject)\nregister(Polyline, 'Polyline')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Rect.js\n\n\n\n\n\nclass Rect extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('rect', node), attrs)\n  }\n}\n\nextend(Rect, { rx: rx, ry: ry })\n\nregisterMethods({\n  Container: {\n    // Create a rect element\n    rect: wrapWithAttrCheck(function (width, height) {\n      return this.put(new Rect()).size(width, height)\n    })\n  }\n})\n\nregister(Rect, 'Rect')\n\n;// ./node_modules/@svgdotjs/svg.js/src/animation/Queue.js\nclass Queue {\n  constructor() {\n    this._first = null\n    this._last = null\n  }\n\n  // Shows us the first item in the list\n  first() {\n    return this._first && this._first.value\n  }\n\n  // Shows us the last item in the list\n  last() {\n    return this._last && this._last.value\n  }\n\n  push(value) {\n    // An item stores an id and the provided value\n    const item =\n      typeof value.next !== 'undefined'\n        ? value\n        : { value: value, next: null, prev: null }\n\n    // Deal with the queue being empty or populated\n    if (this._last) {\n      item.prev = this._last\n      this._last.next = item\n      this._last = item\n    } else {\n      this._last = item\n      this._first = item\n    }\n\n    // Return the current item\n    return item\n  }\n\n  // Removes the item that was returned from the push\n  remove(item) {\n    // Relink the previous item\n    if (item.prev) item.prev.next = item.next\n    if (item.next) item.next.prev = item.prev\n    if (item === this._last) this._last = item.prev\n    if (item === this._first) this._first = item.next\n\n    // Invalidate item\n    item.prev = null\n    item.next = null\n  }\n\n  shift() {\n    // Check if we have a value\n    const remove = this._first\n    if (!remove) return null\n\n    // If we do, remove it and relink things\n    this._first = remove.next\n    if (this._first) this._first.prev = null\n    this._last = this._first ? this._last : null\n    return remove.value\n  }\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/animation/Animator.js\n\n\n\nconst Animator = {\n  nextDraw: null,\n  frames: new Queue(),\n  timeouts: new Queue(),\n  immediates: new Queue(),\n  timer: () => globals.window.performance || globals.window.Date,\n  transforms: [],\n\n  frame(fn) {\n    // Store the node\n    const node = Animator.frames.push({ run: fn })\n\n    // Request an animation frame if we don't have one\n    if (Animator.nextDraw === null) {\n      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw)\n    }\n\n    // Return the node so we can remove it easily\n    return node\n  },\n\n  timeout(fn, delay) {\n    delay = delay || 0\n\n    // Work out when the event should fire\n    const time = Animator.timer().now() + delay\n\n    // Add the timeout to the end of the queue\n    const node = Animator.timeouts.push({ run: fn, time: time })\n\n    // Request another animation frame if we need one\n    if (Animator.nextDraw === null) {\n      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw)\n    }\n\n    return node\n  },\n\n  immediate(fn) {\n    // Add the immediate fn to the end of the queue\n    const node = Animator.immediates.push(fn)\n    // Request another animation frame if we need one\n    if (Animator.nextDraw === null) {\n      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw)\n    }\n\n    return node\n  },\n\n  cancelFrame(node) {\n    node != null && Animator.frames.remove(node)\n  },\n\n  clearTimeout(node) {\n    node != null && Animator.timeouts.remove(node)\n  },\n\n  cancelImmediate(node) {\n    node != null && Animator.immediates.remove(node)\n  },\n\n  _draw(now) {\n    // Run all the timeouts we can run, if they are not ready yet, add them\n    // to the end of the queue immediately! (bad timeouts!!! [sarcasm])\n    let nextTimeout = null\n    const lastTimeout = Animator.timeouts.last()\n    while ((nextTimeout = Animator.timeouts.shift())) {\n      // Run the timeout if its time, or push it to the end\n      if (now >= nextTimeout.time) {\n        nextTimeout.run()\n      } else {\n        Animator.timeouts.push(nextTimeout)\n      }\n\n      // If we hit the last item, we should stop shifting out more items\n      if (nextTimeout === lastTimeout) break\n    }\n\n    // Run all of the animation frames\n    let nextFrame = null\n    const lastFrame = Animator.frames.last()\n    while (nextFrame !== lastFrame && (nextFrame = Animator.frames.shift())) {\n      nextFrame.run(now)\n    }\n\n    let nextImmediate = null\n    while ((nextImmediate = Animator.immediates.shift())) {\n      nextImmediate()\n    }\n\n    // If we have remaining timeouts or frames, draw until we don't anymore\n    Animator.nextDraw =\n      Animator.timeouts.first() || Animator.frames.first()\n        ? globals.window.requestAnimationFrame(Animator._draw)\n        : null\n  }\n}\n\n/* harmony default export */ const animation_Animator = (Animator);\n\n;// ./node_modules/@svgdotjs/svg.js/src/animation/Timeline.js\n\n\n\n\n\nconst makeSchedule = function (runnerInfo) {\n  const start = runnerInfo.start\n  const duration = runnerInfo.runner.duration()\n  const end = start + duration\n  return {\n    start: start,\n    duration: duration,\n    end: end,\n    runner: runnerInfo.runner\n  }\n}\n\nconst defaultSource = function () {\n  const w = globals.window\n  return (w.performance || w.Date).now()\n}\n\nclass Timeline extends EventTarget {\n  // Construct a new timeline on the given element\n  constructor(timeSource = defaultSource) {\n    super()\n\n    this._timeSource = timeSource\n\n    // terminate resets all variables to their initial state\n    this.terminate()\n  }\n\n  active() {\n    return !!this._nextFrame\n  }\n\n  finish() {\n    // Go to end and pause\n    this.time(this.getEndTimeOfTimeline() + 1)\n    return this.pause()\n  }\n\n  // Calculates the end of the timeline\n  getEndTime() {\n    const lastRunnerInfo = this.getLastRunnerInfo()\n    const lastDuration = lastRunnerInfo ? lastRunnerInfo.runner.duration() : 0\n    const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time\n    return lastStartTime + lastDuration\n  }\n\n  getEndTimeOfTimeline() {\n    const endTimes = this._runners.map((i) => i.start + i.runner.duration())\n    return Math.max(0, ...endTimes)\n  }\n\n  getLastRunnerInfo() {\n    return this.getRunnerInfoById(this._lastRunnerId)\n  }\n\n  getRunnerInfoById(id) {\n    return this._runners[this._runnerIds.indexOf(id)] || null\n  }\n\n  pause() {\n    this._paused = true\n    return this._continue()\n  }\n\n  persist(dtOrForever) {\n    if (dtOrForever == null) return this._persist\n    this._persist = dtOrForever\n    return this\n  }\n\n  play() {\n    // Now make sure we are not paused and continue the animation\n    this._paused = false\n    return this.updateTime()._continue()\n  }\n\n  reverse(yes) {\n    const currentSpeed = this.speed()\n    if (yes == null) return this.speed(-currentSpeed)\n\n    const positive = Math.abs(currentSpeed)\n    return this.speed(yes ? -positive : positive)\n  }\n\n  // schedules a runner on the timeline\n  schedule(runner, delay, when) {\n    if (runner == null) {\n      return this._runners.map(makeSchedule)\n    }\n\n    // The start time for the next animation can either be given explicitly,\n    // derived from the current timeline time or it can be relative to the\n    // last start time to chain animations directly\n\n    let absoluteStartTime = 0\n    const endTime = this.getEndTime()\n    delay = delay || 0\n\n    // Work out when to start the animation\n    if (when == null || when === 'last' || when === 'after') {\n      // Take the last time and increment\n      absoluteStartTime = endTime\n    } else if (when === 'absolute' || when === 'start') {\n      absoluteStartTime = delay\n      delay = 0\n    } else if (when === 'now') {\n      absoluteStartTime = this._time\n    } else if (when === 'relative') {\n      const runnerInfo = this.getRunnerInfoById(runner.id)\n      if (runnerInfo) {\n        absoluteStartTime = runnerInfo.start + delay\n        delay = 0\n      }\n    } else if (when === 'with-last') {\n      const lastRunnerInfo = this.getLastRunnerInfo()\n      const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time\n      absoluteStartTime = lastStartTime\n    } else {\n      throw new Error('Invalid value for the \"when\" parameter')\n    }\n\n    // Manage runner\n    runner.unschedule()\n    runner.timeline(this)\n\n    const persist = runner.persist()\n    const runnerInfo = {\n      persist: persist === null ? this._persist : persist,\n      start: absoluteStartTime + delay,\n      runner\n    }\n\n    this._lastRunnerId = runner.id\n\n    this._runners.push(runnerInfo)\n    this._runners.sort((a, b) => a.start - b.start)\n    this._runnerIds = this._runners.map((info) => info.runner.id)\n\n    this.updateTime()._continue()\n    return this\n  }\n\n  seek(dt) {\n    return this.time(this._time + dt)\n  }\n\n  source(fn) {\n    if (fn == null) return this._timeSource\n    this._timeSource = fn\n    return this\n  }\n\n  speed(speed) {\n    if (speed == null) return this._speed\n    this._speed = speed\n    return this\n  }\n\n  stop() {\n    // Go to start and pause\n    this.time(0)\n    return this.pause()\n  }\n\n  time(time) {\n    if (time == null) return this._time\n    this._time = time\n    return this._continue(true)\n  }\n\n  // Remove the runner from this timeline\n  unschedule(runner) {\n    const index = this._runnerIds.indexOf(runner.id)\n    if (index < 0) return this\n\n    this._runners.splice(index, 1)\n    this._runnerIds.splice(index, 1)\n\n    runner.timeline(null)\n    return this\n  }\n\n  // Makes sure, that after pausing the time doesn't jump\n  updateTime() {\n    if (!this.active()) {\n      this._lastSourceTime = this._timeSource()\n    }\n    return this\n  }\n\n  // Checks if we are running and continues the animation\n  _continue(immediateStep = false) {\n    animation_Animator.cancelFrame(this._nextFrame)\n    this._nextFrame = null\n\n    if (immediateStep) return this._stepImmediate()\n    if (this._paused) return this\n\n    this._nextFrame = animation_Animator.frame(this._step)\n    return this\n  }\n\n  _stepFn(immediateStep = false) {\n    // Get the time delta from the last time and update the time\n    const time = this._timeSource()\n    let dtSource = time - this._lastSourceTime\n\n    if (immediateStep) dtSource = 0\n\n    const dtTime = this._speed * dtSource + (this._time - this._lastStepTime)\n    this._lastSourceTime = time\n\n    // Only update the time if we use the timeSource.\n    // Otherwise use the current time\n    if (!immediateStep) {\n      // Update the time\n      this._time += dtTime\n      this._time = this._time < 0 ? 0 : this._time\n    }\n    this._lastStepTime = this._time\n    this.fire('time', this._time)\n\n    // This is for the case that the timeline was seeked so that the time\n    // is now before the startTime of the runner. That is why we need to set\n    // the runner to position 0\n\n    // FIXME:\n    // However, resetting in insertion order leads to bugs. Considering the case,\n    // where 2 runners change the same attribute but in different times,\n    // resetting both of them will lead to the case where the later defined\n    // runner always wins the reset even if the other runner started earlier\n    // and therefore should win the attribute battle\n    // this can be solved by resetting them backwards\n    for (let k = this._runners.length; k--; ) {\n      // Get and run the current runner and ignore it if its inactive\n      const runnerInfo = this._runners[k]\n      const runner = runnerInfo.runner\n\n      // Make sure that we give the actual difference\n      // between runner start time and now\n      const dtToStart = this._time - runnerInfo.start\n\n      // Dont run runner if not started yet\n      // and try to reset it\n      if (dtToStart <= 0) {\n        runner.reset()\n      }\n    }\n\n    // Run all of the runners directly\n    let runnersLeft = false\n    for (let i = 0, len = this._runners.length; i < len; i++) {\n      // Get and run the current runner and ignore it if its inactive\n      const runnerInfo = this._runners[i]\n      const runner = runnerInfo.runner\n      let dt = dtTime\n\n      // Make sure that we give the actual difference\n      // between runner start time and now\n      const dtToStart = this._time - runnerInfo.start\n\n      // Dont run runner if not started yet\n      if (dtToStart <= 0) {\n        runnersLeft = true\n        continue\n      } else if (dtToStart < dt) {\n        // Adjust dt to make sure that animation is on point\n        dt = dtToStart\n      }\n\n      if (!runner.active()) continue\n\n      // If this runner is still going, signal that we need another animation\n      // frame, otherwise, remove the completed runner\n      const finished = runner.step(dt).done\n      if (!finished) {\n        runnersLeft = true\n        // continue\n      } else if (runnerInfo.persist !== true) {\n        // runner is finished. And runner might get removed\n        const endTime = runner.duration() - runner.time() + this._time\n\n        if (endTime + runnerInfo.persist < this._time) {\n          // Delete runner and correct index\n          runner.unschedule()\n          --i\n          --len\n        }\n      }\n    }\n\n    // Basically: we continue when there are runners right from us in time\n    // when --\x3e, and when runners are left from us when <--\n    if (\n      (runnersLeft && !(this._speed < 0 && this._time === 0)) ||\n      (this._runnerIds.length && this._speed < 0 && this._time > 0)\n    ) {\n      this._continue()\n    } else {\n      this.pause()\n      this.fire('finished')\n    }\n\n    return this\n  }\n\n  terminate() {\n    // cleanup memory\n\n    // Store the timing variables\n    this._startTime = 0\n    this._speed = 1.0\n\n    // Determines how long a runner is hold in memory. Can be a dt or true/false\n    this._persist = 0\n\n    // Keep track of the running animations and their starting parameters\n    this._nextFrame = null\n    this._paused = true\n    this._runners = []\n    this._runnerIds = []\n    this._lastRunnerId = -1\n    this._time = 0\n    this._lastSourceTime = 0\n    this._lastStepTime = 0\n\n    // Make sure that step is always called in class context\n    this._step = this._stepFn.bind(this, false)\n    this._stepImmediate = this._stepFn.bind(this, true)\n  }\n}\n\nregisterMethods({\n  Element: {\n    timeline: function (timeline) {\n      if (timeline == null) {\n        this._timeline = this._timeline || new Timeline()\n        return this._timeline\n      } else {\n        this._timeline = timeline\n        return this\n      }\n    }\n  }\n})\n\n;// ./node_modules/@svgdotjs/svg.js/src/animation/Runner.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Runner extends EventTarget {\n  constructor(options) {\n    super()\n\n    // Store a unique id on the runner, so that we can identify it later\n    this.id = Runner.id++\n\n    // Ensure a default value\n    options = options == null ? timeline.duration : options\n\n    // Ensure that we get a controller\n    options = typeof options === 'function' ? new Controller(options) : options\n\n    // Declare all of the variables\n    this._element = null\n    this._timeline = null\n    this.done = false\n    this._queue = []\n\n    // Work out the stepper and the duration\n    this._duration = typeof options === 'number' && options\n    this._isDeclarative = options instanceof Controller\n    this._stepper = this._isDeclarative ? options : new Ease()\n\n    // We copy the current values from the timeline because they can change\n    this._history = {}\n\n    // Store the state of the runner\n    this.enabled = true\n    this._time = 0\n    this._lastTime = 0\n\n    // At creation, the runner is in reset state\n    this._reseted = true\n\n    // Save transforms applied to this runner\n    this.transforms = new Matrix()\n    this.transformId = 1\n\n    // Looping variables\n    this._haveReversed = false\n    this._reverse = false\n    this._loopsDone = 0\n    this._swing = false\n    this._wait = 0\n    this._times = 1\n\n    this._frameId = null\n\n    // Stores how long a runner is stored after being done\n    this._persist = this._isDeclarative ? true : null\n  }\n\n  static sanitise(duration, delay, when) {\n    // Initialise the default parameters\n    let times = 1\n    let swing = false\n    let wait = 0\n    duration = duration ?? timeline.duration\n    delay = delay ?? timeline.delay\n    when = when || 'last'\n\n    // If we have an object, unpack the values\n    if (typeof duration === 'object' && !(duration instanceof Stepper)) {\n      delay = duration.delay ?? delay\n      when = duration.when ?? when\n      swing = duration.swing || swing\n      times = duration.times ?? times\n      wait = duration.wait ?? wait\n      duration = duration.duration ?? timeline.duration\n    }\n\n    return {\n      duration: duration,\n      delay: delay,\n      swing: swing,\n      times: times,\n      wait: wait,\n      when: when\n    }\n  }\n\n  active(enabled) {\n    if (enabled == null) return this.enabled\n    this.enabled = enabled\n    return this\n  }\n\n  /*\n  Private Methods\n  ===============\n  Methods that shouldn't be used externally\n  */\n  addTransform(transform) {\n    this.transforms.lmultiplyO(transform)\n    return this\n  }\n\n  after(fn) {\n    return this.on('finished', fn)\n  }\n\n  animate(duration, delay, when) {\n    const o = Runner.sanitise(duration, delay, when)\n    const runner = new Runner(o.duration)\n    if (this._timeline) runner.timeline(this._timeline)\n    if (this._element) runner.element(this._element)\n    return runner.loop(o).schedule(o.delay, o.when)\n  }\n\n  clearTransform() {\n    this.transforms = new Matrix()\n    return this\n  }\n\n  // TODO: Keep track of all transformations so that deletion is faster\n  clearTransformsFromQueue() {\n    if (\n      !this.done ||\n      !this._timeline ||\n      !this._timeline._runnerIds.includes(this.id)\n    ) {\n      this._queue = this._queue.filter((item) => {\n        return !item.isTransform\n      })\n    }\n  }\n\n  delay(delay) {\n    return this.animate(0, delay)\n  }\n\n  duration() {\n    return this._times * (this._wait + this._duration) - this._wait\n  }\n\n  during(fn) {\n    return this.queue(null, fn)\n  }\n\n  ease(fn) {\n    this._stepper = new Ease(fn)\n    return this\n  }\n  /*\n  Runner Definitions\n  ==================\n  These methods help us define the runtime behaviour of the Runner or they\n  help us make new runners from the current runner\n  */\n\n  element(element) {\n    if (element == null) return this._element\n    this._element = element\n    element._prepareRunner()\n    return this\n  }\n\n  finish() {\n    return this.step(Infinity)\n  }\n\n  loop(times, swing, wait) {\n    // Deal with the user passing in an object\n    if (typeof times === 'object') {\n      swing = times.swing\n      wait = times.wait\n      times = times.times\n    }\n\n    // Sanitise the values and store them\n    this._times = times || Infinity\n    this._swing = swing || false\n    this._wait = wait || 0\n\n    // Allow true to be passed\n    if (this._times === true) {\n      this._times = Infinity\n    }\n\n    return this\n  }\n\n  loops(p) {\n    const loopDuration = this._duration + this._wait\n    if (p == null) {\n      const loopsDone = Math.floor(this._time / loopDuration)\n      const relativeTime = this._time - loopsDone * loopDuration\n      const position = relativeTime / this._duration\n      return Math.min(loopsDone + position, this._times)\n    }\n    const whole = Math.floor(p)\n    const partial = p % 1\n    const time = loopDuration * whole + this._duration * partial\n    return this.time(time)\n  }\n\n  persist(dtOrForever) {\n    if (dtOrForever == null) return this._persist\n    this._persist = dtOrForever\n    return this\n  }\n\n  position(p) {\n    // Get all of the variables we need\n    const x = this._time\n    const d = this._duration\n    const w = this._wait\n    const t = this._times\n    const s = this._swing\n    const r = this._reverse\n    let position\n\n    if (p == null) {\n      /*\n      This function converts a time to a position in the range [0, 1]\n      The full explanation can be found in this desmos demonstration\n        https://www.desmos.com/calculator/u4fbavgche\n      The logic is slightly simplified here because we can use booleans\n      */\n\n      // Figure out the value without thinking about the start or end time\n      const f = function (x) {\n        const swinging = s * Math.floor((x % (2 * (w + d))) / (w + d))\n        const backwards = (swinging && !r) || (!swinging && r)\n        const uncliped =\n          (Math.pow(-1, backwards) * (x % (w + d))) / d + backwards\n        const clipped = Math.max(Math.min(uncliped, 1), 0)\n        return clipped\n      }\n\n      // Figure out the value by incorporating the start time\n      const endTime = t * (w + d) - w\n      position =\n        x <= 0\n          ? Math.round(f(1e-5))\n          : x < endTime\n            ? f(x)\n            : Math.round(f(endTime - 1e-5))\n      return position\n    }\n\n    // Work out the loops done and add the position to the loops done\n    const loopsDone = Math.floor(this.loops())\n    const swingForward = s && loopsDone % 2 === 0\n    const forwards = (swingForward && !r) || (r && swingForward)\n    position = loopsDone + (forwards ? p : 1 - p)\n    return this.loops(position)\n  }\n\n  progress(p) {\n    if (p == null) {\n      return Math.min(1, this._time / this.duration())\n    }\n    return this.time(p * this.duration())\n  }\n\n  /*\n  Basic Functionality\n  ===================\n  These methods allow us to attach basic functions to the runner directly\n  */\n  queue(initFn, runFn, retargetFn, isTransform) {\n    this._queue.push({\n      initialiser: initFn || noop,\n      runner: runFn || noop,\n      retarget: retargetFn,\n      isTransform: isTransform,\n      initialised: false,\n      finished: false\n    })\n    const timeline = this.timeline()\n    timeline && this.timeline()._continue()\n    return this\n  }\n\n  reset() {\n    if (this._reseted) return this\n    this.time(0)\n    this._reseted = true\n    return this\n  }\n\n  reverse(reverse) {\n    this._reverse = reverse == null ? !this._reverse : reverse\n    return this\n  }\n\n  schedule(timeline, delay, when) {\n    // The user doesn't need to pass a timeline if we already have one\n    if (!(timeline instanceof Timeline)) {\n      when = delay\n      delay = timeline\n      timeline = this.timeline()\n    }\n\n    // If there is no timeline, yell at the user...\n    if (!timeline) {\n      throw Error('Runner cannot be scheduled without timeline')\n    }\n\n    // Schedule the runner on the timeline provided\n    timeline.schedule(this, delay, when)\n    return this\n  }\n\n  step(dt) {\n    // If we are inactive, this stepper just gets skipped\n    if (!this.enabled) return this\n\n    // Update the time and get the new position\n    dt = dt == null ? 16 : dt\n    this._time += dt\n    const position = this.position()\n\n    // Figure out if we need to run the stepper in this frame\n    const running = this._lastPosition !== position && this._time >= 0\n    this._lastPosition = position\n\n    // Figure out if we just started\n    const duration = this.duration()\n    const justStarted = this._lastTime <= 0 && this._time > 0\n    const justFinished = this._lastTime < duration && this._time >= duration\n\n    this._lastTime = this._time\n    if (justStarted) {\n      this.fire('start', this)\n    }\n\n    // Work out if the runner is finished set the done flag here so animations\n    // know, that they are running in the last step (this is good for\n    // transformations which can be merged)\n    const declarative = this._isDeclarative\n    this.done = !declarative && !justFinished && this._time >= duration\n\n    // Runner is running. So its not in reset state anymore\n    this._reseted = false\n\n    let converged = false\n    // Call initialise and the run function\n    if (running || declarative) {\n      this._initialise(running)\n\n      // clear the transforms on this runner so they dont get added again and again\n      this.transforms = new Matrix()\n      converged = this._run(declarative ? dt : position)\n\n      this.fire('step', this)\n    }\n    // correct the done flag here\n    // declarative animations itself know when they converged\n    this.done = this.done || (converged && declarative)\n    if (justFinished) {\n      this.fire('finished', this)\n    }\n    return this\n  }\n\n  /*\n  Runner animation methods\n  ========================\n  Control how the animation plays\n  */\n  time(time) {\n    if (time == null) {\n      return this._time\n    }\n    const dt = time - this._time\n    this.step(dt)\n    return this\n  }\n\n  timeline(timeline) {\n    // check explicitly for undefined so we can set the timeline to null\n    if (typeof timeline === 'undefined') return this._timeline\n    this._timeline = timeline\n    return this\n  }\n\n  unschedule() {\n    const timeline = this.timeline()\n    timeline && timeline.unschedule(this)\n    return this\n  }\n\n  // Run each initialise function in the runner if required\n  _initialise(running) {\n    // If we aren't running, we shouldn't initialise when not declarative\n    if (!running && !this._isDeclarative) return\n\n    // Loop through all of the initialisers\n    for (let i = 0, len = this._queue.length; i < len; ++i) {\n      // Get the current initialiser\n      const current = this._queue[i]\n\n      // Determine whether we need to initialise\n      const needsIt = this._isDeclarative || (!current.initialised && running)\n      running = !current.finished\n\n      // Call the initialiser if we need to\n      if (needsIt && running) {\n        current.initialiser.call(this)\n        current.initialised = true\n      }\n    }\n  }\n\n  // Save a morpher to the morpher list so that we can retarget it later\n  _rememberMorpher(method, morpher) {\n    this._history[method] = {\n      morpher: morpher,\n      caller: this._queue[this._queue.length - 1]\n    }\n\n    // We have to resume the timeline in case a controller\n    // is already done without being ever run\n    // This can happen when e.g. this is done:\n    //    anim = el.animate(new SVG.Spring)\n    // and later\n    //    anim.move(...)\n    if (this._isDeclarative) {\n      const timeline = this.timeline()\n      timeline && timeline.play()\n    }\n  }\n\n  // Try to set the target for a morpher if the morpher exists, otherwise\n  // Run each run function for the position or dt given\n  _run(positionOrDt) {\n    // Run all of the _queue directly\n    let allfinished = true\n    for (let i = 0, len = this._queue.length; i < len; ++i) {\n      // Get the current function to run\n      const current = this._queue[i]\n\n      // Run the function if its not finished, we keep track of the finished\n      // flag for the sake of declarative _queue\n      const converged = current.runner.call(this, positionOrDt)\n      current.finished = current.finished || converged === true\n      allfinished = allfinished && current.finished\n    }\n\n    // We report when all of the constructors are finished\n    return allfinished\n  }\n\n  // do nothing and return false\n  _tryRetarget(method, target, extra) {\n    if (this._history[method]) {\n      // if the last method wasn't even initialised, throw it away\n      if (!this._history[method].caller.initialised) {\n        const index = this._queue.indexOf(this._history[method].caller)\n        this._queue.splice(index, 1)\n        return false\n      }\n\n      // for the case of transformations, we use the special retarget function\n      // which has access to the outer scope\n      if (this._history[method].caller.retarget) {\n        this._history[method].caller.retarget.call(this, target, extra)\n        // for everything else a simple morpher change is sufficient\n      } else {\n        this._history[method].morpher.to(target)\n      }\n\n      this._history[method].caller.finished = false\n      const timeline = this.timeline()\n      timeline && timeline.play()\n      return true\n    }\n    return false\n  }\n}\n\nRunner.id = 0\n\nclass FakeRunner {\n  constructor(transforms = new Matrix(), id = -1, done = true) {\n    this.transforms = transforms\n    this.id = id\n    this.done = done\n  }\n\n  clearTransformsFromQueue() {}\n}\n\nextend([Runner, FakeRunner], {\n  mergeWith(runner) {\n    return new FakeRunner(\n      runner.transforms.lmultiply(this.transforms),\n      runner.id\n    )\n  }\n})\n\n// FakeRunner.emptyRunner = new FakeRunner()\n\nconst lmultiply = (last, curr) => last.lmultiplyO(curr)\nconst getRunnerTransform = (runner) => runner.transforms\n\nfunction mergeTransforms() {\n  // Find the matrix to apply to the element and apply it\n  const runners = this._transformationRunners.runners\n  const netTransform = runners\n    .map(getRunnerTransform)\n    .reduce(lmultiply, new Matrix())\n\n  this.transform(netTransform)\n\n  this._transformationRunners.merge()\n\n  if (this._transformationRunners.length() === 1) {\n    this._frameId = null\n  }\n}\n\nclass RunnerArray {\n  constructor() {\n    this.runners = []\n    this.ids = []\n  }\n\n  add(runner) {\n    if (this.runners.includes(runner)) return\n    const id = runner.id + 1\n\n    this.runners.push(runner)\n    this.ids.push(id)\n\n    return this\n  }\n\n  clearBefore(id) {\n    const deleteCnt = this.ids.indexOf(id + 1) || 1\n    this.ids.splice(0, deleteCnt, 0)\n    this.runners\n      .splice(0, deleteCnt, new FakeRunner())\n      .forEach((r) => r.clearTransformsFromQueue())\n    return this\n  }\n\n  edit(id, newRunner) {\n    const index = this.ids.indexOf(id + 1)\n    this.ids.splice(index, 1, id + 1)\n    this.runners.splice(index, 1, newRunner)\n    return this\n  }\n\n  getByID(id) {\n    return this.runners[this.ids.indexOf(id + 1)]\n  }\n\n  length() {\n    return this.ids.length\n  }\n\n  merge() {\n    let lastRunner = null\n    for (let i = 0; i < this.runners.length; ++i) {\n      const runner = this.runners[i]\n\n      const condition =\n        lastRunner &&\n        runner.done &&\n        lastRunner.done &&\n        // don't merge runner when persisted on timeline\n        (!runner._timeline ||\n          !runner._timeline._runnerIds.includes(runner.id)) &&\n        (!lastRunner._timeline ||\n          !lastRunner._timeline._runnerIds.includes(lastRunner.id))\n\n      if (condition) {\n        // the +1 happens in the function\n        this.remove(runner.id)\n        const newRunner = runner.mergeWith(lastRunner)\n        this.edit(lastRunner.id, newRunner)\n        lastRunner = newRunner\n        --i\n      } else {\n        lastRunner = runner\n      }\n    }\n\n    return this\n  }\n\n  remove(id) {\n    const index = this.ids.indexOf(id + 1)\n    this.ids.splice(index, 1)\n    this.runners.splice(index, 1)\n    return this\n  }\n}\n\nregisterMethods({\n  Element: {\n    animate(duration, delay, when) {\n      const o = Runner.sanitise(duration, delay, when)\n      const timeline = this.timeline()\n      return new Runner(o.duration)\n        .loop(o)\n        .element(this)\n        .timeline(timeline.play())\n        .schedule(o.delay, o.when)\n    },\n\n    delay(by, when) {\n      return this.animate(0, by, when)\n    },\n\n    // this function searches for all runners on the element and deletes the ones\n    // which run before the current one. This is because absolute transformations\n    // overwrite anything anyway so there is no need to waste time computing\n    // other runners\n    _clearTransformRunnersBefore(currentRunner) {\n      this._transformationRunners.clearBefore(currentRunner.id)\n    },\n\n    _currentTransform(current) {\n      return (\n        this._transformationRunners.runners\n          // we need the equal sign here to make sure, that also transformations\n          // on the same runner which execute before the current transformation are\n          // taken into account\n          .filter((runner) => runner.id <= current.id)\n          .map(getRunnerTransform)\n          .reduce(lmultiply, new Matrix())\n      )\n    },\n\n    _addRunner(runner) {\n      this._transformationRunners.add(runner)\n\n      // Make sure that the runner merge is executed at the very end of\n      // all Animator functions. That is why we use immediate here to execute\n      // the merge right after all frames are run\n      animation_Animator.cancelImmediate(this._frameId)\n      this._frameId = animation_Animator.immediate(mergeTransforms.bind(this))\n    },\n\n    _prepareRunner() {\n      if (this._frameId == null) {\n        this._transformationRunners = new RunnerArray().add(\n          new FakeRunner(new Matrix(this))\n        )\n      }\n    }\n  }\n})\n\n// Will output the elements from array A that are not in the array B\nconst difference = (a, b) => a.filter((x) => !b.includes(x))\n\nextend(Runner, {\n  attr(a, v) {\n    return this.styleAttr('attr', a, v)\n  },\n\n  // Add animatable styles\n  css(s, v) {\n    return this.styleAttr('css', s, v)\n  },\n\n  styleAttr(type, nameOrAttrs, val) {\n    if (typeof nameOrAttrs === 'string') {\n      return this.styleAttr(type, { [nameOrAttrs]: val })\n    }\n\n    let attrs = nameOrAttrs\n    if (this._tryRetarget(type, attrs)) return this\n\n    let morpher = new Morphable(this._stepper).to(attrs)\n    let keys = Object.keys(attrs)\n\n    this.queue(\n      function () {\n        morpher = morpher.from(this.element()[type](keys))\n      },\n      function (pos) {\n        this.element()[type](morpher.at(pos).valueOf())\n        return morpher.done()\n      },\n      function (newToAttrs) {\n        // Check if any new keys were added\n        const newKeys = Object.keys(newToAttrs)\n        const differences = difference(newKeys, keys)\n\n        // If their are new keys, initialize them and add them to morpher\n        if (differences.length) {\n          // Get the values\n          const addedFromAttrs = this.element()[type](differences)\n\n          // Get the already initialized values\n          const oldFromAttrs = new ObjectBag(morpher.from()).valueOf()\n\n          // Merge old and new\n          Object.assign(oldFromAttrs, addedFromAttrs)\n          morpher.from(oldFromAttrs)\n        }\n\n        // Get the object from the morpher\n        const oldToAttrs = new ObjectBag(morpher.to()).valueOf()\n\n        // Merge in new attributes\n        Object.assign(oldToAttrs, newToAttrs)\n\n        // Change morpher target\n        morpher.to(oldToAttrs)\n\n        // Make sure that we save the work we did so we don't need it to do again\n        keys = newKeys\n        attrs = newToAttrs\n      }\n    )\n\n    this._rememberMorpher(type, morpher)\n    return this\n  },\n\n  zoom(level, point) {\n    if (this._tryRetarget('zoom', level, point)) return this\n\n    let morpher = new Morphable(this._stepper).to(new SVGNumber(level))\n\n    this.queue(\n      function () {\n        morpher = morpher.from(this.element().zoom())\n      },\n      function (pos) {\n        this.element().zoom(morpher.at(pos), point)\n        return morpher.done()\n      },\n      function (newLevel, newPoint) {\n        point = newPoint\n        morpher.to(newLevel)\n      }\n    )\n\n    this._rememberMorpher('zoom', morpher)\n    return this\n  },\n\n  /**\n   ** absolute transformations\n   **/\n\n  //\n  // M v -----|-----(D M v = F v)------|-----\x3e  T v\n  //\n  // 1. define the final state (T) and decompose it (once)\n  //    t = [tx, ty, the, lam, sy, sx]\n  // 2. on every frame: pull the current state of all previous transforms\n  //    (M - m can change)\n  //   and then write this as m = [tx0, ty0, the0, lam0, sy0, sx0]\n  // 3. Find the interpolated matrix F(pos) = m + pos * (t - m)\n  //   - Note F(0) = M\n  //   - Note F(1) = T\n  // 4. Now you get the delta matrix as a result: D = F * inv(M)\n\n  transform(transforms, relative, affine) {\n    // If we have a declarative function, we should retarget it if possible\n    relative = transforms.relative || relative\n    if (\n      this._isDeclarative &&\n      !relative &&\n      this._tryRetarget('transform', transforms)\n    ) {\n      return this\n    }\n\n    // Parse the parameters\n    const isMatrix = Matrix.isMatrixLike(transforms)\n    affine =\n      transforms.affine != null\n        ? transforms.affine\n        : affine != null\n          ? affine\n          : !isMatrix\n\n    // Create a morpher and set its type\n    const morpher = new Morphable(this._stepper).type(\n      affine ? TransformBag : Matrix\n    )\n\n    let origin\n    let element\n    let current\n    let currentAngle\n    let startTransform\n\n    function setup() {\n      // make sure element and origin is defined\n      element = element || this.element()\n      origin = origin || getOrigin(transforms, element)\n\n      startTransform = new Matrix(relative ? undefined : element)\n\n      // add the runner to the element so it can merge transformations\n      element._addRunner(this)\n\n      // Deactivate all transforms that have run so far if we are absolute\n      if (!relative) {\n        element._clearTransformRunnersBefore(this)\n      }\n    }\n\n    function run(pos) {\n      // clear all other transforms before this in case something is saved\n      // on this runner. We are absolute. We dont need these!\n      if (!relative) this.clearTransform()\n\n      const { x, y } = new Point(origin).transform(\n        element._currentTransform(this)\n      )\n\n      let target = new Matrix({ ...transforms, origin: [x, y] })\n      let start = this._isDeclarative && current ? current : startTransform\n\n      if (affine) {\n        target = target.decompose(x, y)\n        start = start.decompose(x, y)\n\n        // Get the current and target angle as it was set\n        const rTarget = target.rotate\n        const rCurrent = start.rotate\n\n        // Figure out the shortest path to rotate directly\n        const possibilities = [rTarget - 360, rTarget, rTarget + 360]\n        const distances = possibilities.map((a) => Math.abs(a - rCurrent))\n        const shortest = Math.min(...distances)\n        const index = distances.indexOf(shortest)\n        target.rotate = possibilities[index]\n      }\n\n      if (relative) {\n        // we have to be careful here not to overwrite the rotation\n        // with the rotate method of Matrix\n        if (!isMatrix) {\n          target.rotate = transforms.rotate || 0\n        }\n        if (this._isDeclarative && currentAngle) {\n          start.rotate = currentAngle\n        }\n      }\n\n      morpher.from(start)\n      morpher.to(target)\n\n      const affineParameters = morpher.at(pos)\n      currentAngle = affineParameters.rotate\n      current = new Matrix(affineParameters)\n\n      this.addTransform(current)\n      element._addRunner(this)\n      return morpher.done()\n    }\n\n    function retarget(newTransforms) {\n      // only get a new origin if it changed since the last call\n      if (\n        (newTransforms.origin || 'center').toString() !==\n        (transforms.origin || 'center').toString()\n      ) {\n        origin = getOrigin(newTransforms, element)\n      }\n\n      // overwrite the old transformations with the new ones\n      transforms = { ...newTransforms, origin }\n    }\n\n    this.queue(setup, run, retarget, true)\n    this._isDeclarative && this._rememberMorpher('transform', morpher)\n    return this\n  },\n\n  // Animatable x-axis\n  x(x) {\n    return this._queueNumber('x', x)\n  },\n\n  // Animatable y-axis\n  y(y) {\n    return this._queueNumber('y', y)\n  },\n\n  ax(x) {\n    return this._queueNumber('ax', x)\n  },\n\n  ay(y) {\n    return this._queueNumber('ay', y)\n  },\n\n  dx(x = 0) {\n    return this._queueNumberDelta('x', x)\n  },\n\n  dy(y = 0) {\n    return this._queueNumberDelta('y', y)\n  },\n\n  dmove(x, y) {\n    return this.dx(x).dy(y)\n  },\n\n  _queueNumberDelta(method, to) {\n    to = new SVGNumber(to)\n\n    // Try to change the target if we have this method already registered\n    if (this._tryRetarget(method, to)) return this\n\n    // Make a morpher and queue the animation\n    const morpher = new Morphable(this._stepper).to(to)\n    let from = null\n    this.queue(\n      function () {\n        from = this.element()[method]()\n        morpher.from(from)\n        morpher.to(from + to)\n      },\n      function (pos) {\n        this.element()[method](morpher.at(pos))\n        return morpher.done()\n      },\n      function (newTo) {\n        morpher.to(from + new SVGNumber(newTo))\n      }\n    )\n\n    // Register the morpher so that if it is changed again, we can retarget it\n    this._rememberMorpher(method, morpher)\n    return this\n  },\n\n  _queueObject(method, to) {\n    // Try to change the target if we have this method already registered\n    if (this._tryRetarget(method, to)) return this\n\n    // Make a morpher and queue the animation\n    const morpher = new Morphable(this._stepper).to(to)\n    this.queue(\n      function () {\n        morpher.from(this.element()[method]())\n      },\n      function (pos) {\n        this.element()[method](morpher.at(pos))\n        return morpher.done()\n      }\n    )\n\n    // Register the morpher so that if it is changed again, we can retarget it\n    this._rememberMorpher(method, morpher)\n    return this\n  },\n\n  _queueNumber(method, value) {\n    return this._queueObject(method, new SVGNumber(value))\n  },\n\n  // Animatable center x-axis\n  cx(x) {\n    return this._queueNumber('cx', x)\n  },\n\n  // Animatable center y-axis\n  cy(y) {\n    return this._queueNumber('cy', y)\n  },\n\n  // Add animatable move\n  move(x, y) {\n    return this.x(x).y(y)\n  },\n\n  amove(x, y) {\n    return this.ax(x).ay(y)\n  },\n\n  // Add animatable center\n  center(x, y) {\n    return this.cx(x).cy(y)\n  },\n\n  // Add animatable size\n  size(width, height) {\n    // animate bbox based size for all other elements\n    let box\n\n    if (!width || !height) {\n      box = this._element.bbox()\n    }\n\n    if (!width) {\n      width = (box.width / box.height) * height\n    }\n\n    if (!height) {\n      height = (box.height / box.width) * width\n    }\n\n    return this.width(width).height(height)\n  },\n\n  // Add animatable width\n  width(width) {\n    return this._queueNumber('width', width)\n  },\n\n  // Add animatable height\n  height(height) {\n    return this._queueNumber('height', height)\n  },\n\n  // Add animatable plot\n  plot(a, b, c, d) {\n    // Lines can be plotted with 4 arguments\n    if (arguments.length === 4) {\n      return this.plot([a, b, c, d])\n    }\n\n    if (this._tryRetarget('plot', a)) return this\n\n    const morpher = new Morphable(this._stepper)\n      .type(this._element.MorphArray)\n      .to(a)\n\n    this.queue(\n      function () {\n        morpher.from(this._element.array())\n      },\n      function (pos) {\n        this._element.plot(morpher.at(pos))\n        return morpher.done()\n      }\n    )\n\n    this._rememberMorpher('plot', morpher)\n    return this\n  },\n\n  // Add leading method\n  leading(value) {\n    return this._queueNumber('leading', value)\n  },\n\n  // Add animatable viewbox\n  viewbox(x, y, width, height) {\n    return this._queueObject('viewbox', new Box(x, y, width, height))\n  },\n\n  update(o) {\n    if (typeof o !== 'object') {\n      return this.update({\n        offset: arguments[0],\n        color: arguments[1],\n        opacity: arguments[2]\n      })\n    }\n\n    if (o.opacity != null) this.attr('stop-opacity', o.opacity)\n    if (o.color != null) this.attr('stop-color', o.color)\n    if (o.offset != null) this.attr('offset', o.offset)\n\n    return this\n  }\n})\n\nextend(Runner, { rx: rx, ry: ry, from: from, to: to })\nregister(Runner, 'Runner')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Svg.js\n\n\n\n\n\n\n\nclass Svg extends Container {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('svg', node), attrs)\n    this.namespace()\n  }\n\n  // Creates and returns defs element\n  defs() {\n    if (!this.isRoot()) return this.root().defs()\n\n    return adopt(this.node.querySelector('defs')) || this.put(new Defs())\n  }\n\n  isRoot() {\n    return (\n      !this.node.parentNode ||\n      (!(this.node.parentNode instanceof globals.window.SVGElement) &&\n        this.node.parentNode.nodeName !== '#document-fragment')\n    )\n  }\n\n  // Add namespaces\n  namespace() {\n    if (!this.isRoot()) return this.root().namespace()\n    return this.attr({ xmlns: svg, version: '1.1' }).attr(\n      'xmlns:xlink',\n      xlink,\n      xmlns\n    )\n  }\n\n  removeNamespace() {\n    return this.attr({ xmlns: null, version: null })\n      .attr('xmlns:xlink', null, xmlns)\n      .attr('xmlns:svgjs', null, xmlns)\n  }\n\n  // Check if this is a root svg\n  // If not, call root() from this element\n  root() {\n    if (this.isRoot()) return this\n    return super.root()\n  }\n}\n\nregisterMethods({\n  Container: {\n    // Create nested svg document\n    nested: wrapWithAttrCheck(function () {\n      return this.put(new Svg())\n    })\n  }\n})\n\nregister(Svg, 'Svg', true)\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Symbol.js\n\n\n\n\nclass Symbol_Symbol extends Container {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('symbol', node), attrs)\n  }\n}\n\nregisterMethods({\n  Container: {\n    symbol: wrapWithAttrCheck(function () {\n      return this.put(new Symbol_Symbol())\n    })\n  }\n})\n\nregister(Symbol_Symbol, 'Symbol')\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/textable.js\n\n\n// Create plain text node\nfunction plain(text) {\n  // clear if build mode is disabled\n  if (this._build === false) {\n    this.clear()\n  }\n\n  // create text node\n  this.node.appendChild(globals.document.createTextNode(text))\n\n  return this\n}\n\n// Get length of text element\nfunction textable_length() {\n  return this.node.getComputedTextLength()\n}\n\n// Move over x-axis\n// Text is moved by its bounding box\n// text-anchor does NOT matter\nfunction textable_x(x, box = this.bbox()) {\n  if (x == null) {\n    return box.x\n  }\n\n  return this.attr('x', this.attr('x') + x - box.x)\n}\n\n// Move over y-axis\nfunction textable_y(y, box = this.bbox()) {\n  if (y == null) {\n    return box.y\n  }\n\n  return this.attr('y', this.attr('y') + y - box.y)\n}\n\nfunction textable_move(x, y, box = this.bbox()) {\n  return this.x(x, box).y(y, box)\n}\n\n// Move center over x-axis\nfunction textable_cx(x, box = this.bbox()) {\n  if (x == null) {\n    return box.cx\n  }\n\n  return this.attr('x', this.attr('x') + x - box.cx)\n}\n\n// Move center over y-axis\nfunction textable_cy(y, box = this.bbox()) {\n  if (y == null) {\n    return box.cy\n  }\n\n  return this.attr('y', this.attr('y') + y - box.cy)\n}\n\nfunction center(x, y, box = this.bbox()) {\n  return this.cx(x, box).cy(y, box)\n}\n\nfunction ax(x) {\n  return this.attr('x', x)\n}\n\nfunction ay(y) {\n  return this.attr('y', y)\n}\n\nfunction amove(x, y) {\n  return this.ax(x).ay(y)\n}\n\n// Enable / disable build mode\nfunction build(build) {\n  this._build = !!build\n  return this\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Text.js\n\n\n\n\n\n\n\n\nclass Text extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('text', node), attrs)\n\n    this.dom.leading = this.dom.leading ?? new SVGNumber(1.3) // store leading value for rebuilding\n    this._rebuild = true // enable automatic updating of dy values\n    this._build = false // disable build mode for adding multiple lines\n  }\n\n  // Set / get leading\n  leading(value) {\n    // act as getter\n    if (value == null) {\n      return this.dom.leading\n    }\n\n    // act as setter\n    this.dom.leading = new SVGNumber(value)\n\n    return this.rebuild()\n  }\n\n  // Rebuild appearance type\n  rebuild(rebuild) {\n    // store new rebuild flag if given\n    if (typeof rebuild === 'boolean') {\n      this._rebuild = rebuild\n    }\n\n    // define position of all lines\n    if (this._rebuild) {\n      const self = this\n      let blankLineOffset = 0\n      const leading = this.dom.leading\n\n      this.each(function (i) {\n        if (isDescriptive(this.node)) return\n\n        const fontSize = globals.window\n          .getComputedStyle(this.node)\n          .getPropertyValue('font-size')\n\n        const dy = leading * new SVGNumber(fontSize)\n\n        if (this.dom.newLined) {\n          this.attr('x', self.attr('x'))\n\n          if (this.text() === '\\n') {\n            blankLineOffset += dy\n          } else {\n            this.attr('dy', i ? dy + blankLineOffset : 0)\n            blankLineOffset = 0\n          }\n        }\n      })\n\n      this.fire('rebuild')\n    }\n\n    return this\n  }\n\n  // overwrite method from parent to set data properly\n  setData(o) {\n    this.dom = o\n    this.dom.leading = new SVGNumber(o.leading || 1.3)\n    return this\n  }\n\n  writeDataToDom() {\n    writeDataToDom(this, this.dom, { leading: 1.3 })\n    return this\n  }\n\n  // Set the text content\n  text(text) {\n    // act as getter\n    if (text === undefined) {\n      const children = this.node.childNodes\n      let firstLine = 0\n      text = ''\n\n      for (let i = 0, len = children.length; i < len; ++i) {\n        // skip textPaths - they are no lines\n        if (children[i].nodeName === 'textPath' || isDescriptive(children[i])) {\n          if (i === 0) firstLine = i + 1\n          continue\n        }\n\n        // add newline if its not the first child and newLined is set to true\n        if (\n          i !== firstLine &&\n          children[i].nodeType !== 3 &&\n          adopt(children[i]).dom.newLined === true\n        ) {\n          text += '\\n'\n        }\n\n        // add content of this node\n        text += children[i].textContent\n      }\n\n      return text\n    }\n\n    // remove existing content\n    this.clear().build(true)\n\n    if (typeof text === 'function') {\n      // call block\n      text.call(this, this)\n    } else {\n      // store text and make sure text is not blank\n      text = (text + '').split('\\n')\n\n      // build new lines\n      for (let j = 0, jl = text.length; j < jl; j++) {\n        this.newLine(text[j])\n      }\n    }\n\n    // disable build mode and rebuild lines\n    return this.build(false).rebuild()\n  }\n}\n\nextend(Text, textable_namespaceObject)\n\nregisterMethods({\n  Container: {\n    // Create text element\n    text: wrapWithAttrCheck(function (text = '') {\n      return this.put(new Text()).text(text)\n    }),\n\n    // Create plain text element\n    plain: wrapWithAttrCheck(function (text = '') {\n      return this.put(new Text()).plain(text)\n    })\n  }\n})\n\nregister(Text, 'Text')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Tspan.js\n\n\n\n\n\n\n\n\nclass Tspan extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('tspan', node), attrs)\n    this._build = false // disable build mode for adding multiple lines\n  }\n\n  // Shortcut dx\n  dx(dx) {\n    return this.attr('dx', dx)\n  }\n\n  // Shortcut dy\n  dy(dy) {\n    return this.attr('dy', dy)\n  }\n\n  // Create new line\n  newLine() {\n    // mark new line\n    this.dom.newLined = true\n\n    // fetch parent\n    const text = this.parent()\n\n    // early return in case we are not in a text element\n    if (!(text instanceof Text)) {\n      return this\n    }\n\n    const i = text.index(this)\n\n    const fontSize = globals.window\n      .getComputedStyle(this.node)\n      .getPropertyValue('font-size')\n    const dy = text.dom.leading * new SVGNumber(fontSize)\n\n    // apply new position\n    return this.dy(i ? dy : 0).attr('x', text.x())\n  }\n\n  // Set text content\n  text(text) {\n    if (text == null)\n      return this.node.textContent + (this.dom.newLined ? '\\n' : '')\n\n    if (typeof text === 'function') {\n      this.clear().build(true)\n      text.call(this, this)\n      this.build(false)\n    } else {\n      this.plain(text)\n    }\n\n    return this\n  }\n}\n\nextend(Tspan, textable_namespaceObject)\n\nregisterMethods({\n  Tspan: {\n    tspan: wrapWithAttrCheck(function (text = '') {\n      const tspan = new Tspan()\n\n      // clear if build mode is disabled\n      if (!this._build) {\n        this.clear()\n      }\n\n      // add new tspan\n      return this.put(tspan).text(text)\n    })\n  },\n  Text: {\n    newLine: function (text = '') {\n      return this.tspan(text).newLine()\n    }\n  }\n})\n\nregister(Tspan, 'Tspan')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Circle.js\n\n\n\n\n\n\nclass Circle extends Shape {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('circle', node), attrs)\n  }\n\n  radius(r) {\n    return this.attr('r', r)\n  }\n\n  // Radius x value\n  rx(rx) {\n    return this.attr('r', rx)\n  }\n\n  // Alias radius x value\n  ry(ry) {\n    return this.rx(ry)\n  }\n\n  size(size) {\n    return this.radius(new SVGNumber(size).divide(2))\n  }\n}\n\nextend(Circle, { x: x, y: y, cx: cx, cy: cy, width: width, height: height })\n\nregisterMethods({\n  Container: {\n    // Create circle element\n    circle: wrapWithAttrCheck(function (size = 0) {\n      return this.put(new Circle()).size(size).move(0, 0)\n    })\n  }\n})\n\nregister(Circle, 'Circle')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/ClipPath.js\n\n\n\n\n\nclass ClipPath extends Container {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('clipPath', node), attrs)\n  }\n\n  // Unclip all clipped elements and remove itself\n  remove() {\n    // unclip all targets\n    this.targets().forEach(function (el) {\n      el.unclip()\n    })\n\n    // remove clipPath from parent\n    return super.remove()\n  }\n\n  targets() {\n    return baseFind('svg [clip-path*=' + this.id() + ']')\n  }\n}\n\nregisterMethods({\n  Container: {\n    // Create clipping element\n    clip: wrapWithAttrCheck(function () {\n      return this.defs().put(new ClipPath())\n    })\n  },\n  Element: {\n    // Distribute clipPath to svg element\n    clipper() {\n      return this.reference('clip-path')\n    },\n\n    clipWith(element) {\n      // use given clip or create a new one\n      const clipper =\n        element instanceof ClipPath\n          ? element\n          : this.parent().clip().add(element)\n\n      // apply mask\n      return this.attr('clip-path', 'url(#' + clipper.id() + ')')\n    },\n\n    // Unclip element\n    unclip() {\n      return this.attr('clip-path', null)\n    }\n  }\n})\n\nregister(ClipPath, 'ClipPath')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/ForeignObject.js\n\n\n\n\nclass ForeignObject extends Element {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('foreignObject', node), attrs)\n  }\n}\n\nregisterMethods({\n  Container: {\n    foreignObject: wrapWithAttrCheck(function (width, height) {\n      return this.put(new ForeignObject()).size(width, height)\n    })\n  }\n})\n\nregister(ForeignObject, 'ForeignObject')\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/containerGeometry.js\n\n\n\n\n\n\nfunction dmove(dx, dy) {\n  this.children().forEach((child) => {\n    let bbox\n\n    // We have to wrap this for elements that dont have a bbox\n    // e.g. title and other descriptive elements\n    try {\n      // Get the childs bbox\n      // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1905039\n      // Because bbox for nested svgs returns the contents bbox in the coordinate space of the svg itself (weird!), we cant use bbox for svgs\n      // Therefore we have to use getBoundingClientRect. But THAT is broken (as explained in the bug).\n      // Funnily enough the broken behavior would work for us but that breaks it in chrome\n      // So we have to replicate the broken behavior of FF by just reading the attributes of the svg itself\n      bbox =\n        child.node instanceof getWindow().SVGSVGElement\n          ? new Box(child.attr(['x', 'y', 'width', 'height']))\n          : child.bbox()\n    } catch (e) {\n      return\n    }\n\n    // Get childs matrix\n    const m = new Matrix(child)\n    // Translate childs matrix by amount and\n    // transform it back into parents space\n    const matrix = m.translate(dx, dy).transform(m.inverse())\n    // Calculate new x and y from old box\n    const p = new Point(bbox.x, bbox.y).transform(matrix)\n    // Move element\n    child.move(p.x, p.y)\n  })\n\n  return this\n}\n\nfunction dx(dx) {\n  return this.dmove(dx, 0)\n}\n\nfunction dy(dy) {\n  return this.dmove(0, dy)\n}\n\nfunction containerGeometry_height(height, box = this.bbox()) {\n  if (height == null) return box.height\n  return this.size(box.width, height, box)\n}\n\nfunction containerGeometry_move(x = 0, y = 0, box = this.bbox()) {\n  const dx = x - box.x\n  const dy = y - box.y\n\n  return this.dmove(dx, dy)\n}\n\nfunction containerGeometry_size(width, height, box = this.bbox()) {\n  const p = proportionalSize(this, width, height, box)\n  const scaleX = p.width / box.width\n  const scaleY = p.height / box.height\n\n  this.children().forEach((child) => {\n    const o = new Point(box).transform(new Matrix(child).inverse())\n    child.scale(scaleX, scaleY, o.x, o.y)\n  })\n\n  return this\n}\n\nfunction containerGeometry_width(width, box = this.bbox()) {\n  if (width == null) return box.width\n  return this.size(width, box.height, box)\n}\n\nfunction containerGeometry_x(x, box = this.bbox()) {\n  if (x == null) return box.x\n  return this.move(x, box.y, box)\n}\n\nfunction containerGeometry_y(y, box = this.bbox()) {\n  if (y == null) return box.y\n  return this.move(box.x, y, box)\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/G.js\n\n\n\n\n\nclass G extends Container {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('g', node), attrs)\n  }\n}\n\nextend(G, containerGeometry_namespaceObject)\n\nregisterMethods({\n  Container: {\n    // Create a group element\n    group: wrapWithAttrCheck(function () {\n      return this.put(new G())\n    })\n  }\n})\n\nregister(G, 'G')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/A.js\n\n\n\n\n\n\nclass A extends Container {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('a', node), attrs)\n  }\n\n  // Link target attribute\n  target(target) {\n    return this.attr('target', target)\n  }\n\n  // Link url\n  to(url) {\n    return this.attr('href', url, xlink)\n  }\n}\n\nextend(A, containerGeometry_namespaceObject)\n\nregisterMethods({\n  Container: {\n    // Create a hyperlink element\n    link: wrapWithAttrCheck(function (url) {\n      return this.put(new A()).to(url)\n    })\n  },\n  Element: {\n    unlink() {\n      const link = this.linker()\n\n      if (!link) return this\n\n      const parent = link.parent()\n\n      if (!parent) {\n        return this.remove()\n      }\n\n      const index = parent.index(link)\n      parent.add(this, index)\n\n      link.remove()\n      return this\n    },\n    linkTo(url) {\n      // reuse old link if possible\n      let link = this.linker()\n\n      if (!link) {\n        link = new A()\n        this.wrap(link)\n      }\n\n      if (typeof url === 'function') {\n        url.call(link, link)\n      } else {\n        link.to(url)\n      }\n\n      return this\n    },\n    linker() {\n      const link = this.parent()\n      if (link && link.node.nodeName.toLowerCase() === 'a') {\n        return link\n      }\n\n      return null\n    }\n  }\n})\n\nregister(A, 'A')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Mask.js\n\n\n\n\n\nclass Mask extends Container {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('mask', node), attrs)\n  }\n\n  // Unmask all masked elements and remove itself\n  remove() {\n    // unmask all targets\n    this.targets().forEach(function (el) {\n      el.unmask()\n    })\n\n    // remove mask from parent\n    return super.remove()\n  }\n\n  targets() {\n    return baseFind('svg [mask*=' + this.id() + ']')\n  }\n}\n\nregisterMethods({\n  Container: {\n    mask: wrapWithAttrCheck(function () {\n      return this.defs().put(new Mask())\n    })\n  },\n  Element: {\n    // Distribute mask to svg element\n    masker() {\n      return this.reference('mask')\n    },\n\n    maskWith(element) {\n      // use given mask or create a new one\n      const masker =\n        element instanceof Mask ? element : this.parent().mask().add(element)\n\n      // apply mask\n      return this.attr('mask', 'url(#' + masker.id() + ')')\n    },\n\n    // Unmask element\n    unmask() {\n      return this.attr('mask', null)\n    }\n  }\n})\n\nregister(Mask, 'Mask')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Stop.js\n\n\n\n\n\nclass Stop extends Element {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('stop', node), attrs)\n  }\n\n  // add color stops\n  update(o) {\n    if (typeof o === 'number' || o instanceof SVGNumber) {\n      o = {\n        offset: arguments[0],\n        color: arguments[1],\n        opacity: arguments[2]\n      }\n    }\n\n    // set attributes\n    if (o.opacity != null) this.attr('stop-opacity', o.opacity)\n    if (o.color != null) this.attr('stop-color', o.color)\n    if (o.offset != null) this.attr('offset', new SVGNumber(o.offset))\n\n    return this\n  }\n}\n\nregisterMethods({\n  Gradient: {\n    // Add a color stop\n    stop: function (offset, color, opacity) {\n      return this.put(new Stop()).update(offset, color, opacity)\n    }\n  }\n})\n\nregister(Stop, 'Stop')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Style.js\n\n\n\n\n\nfunction cssRule(selector, rule) {\n  if (!selector) return ''\n  if (!rule) return selector\n\n  let ret = selector + '{'\n\n  for (const i in rule) {\n    ret += unCamelCase(i) + ':' + rule[i] + ';'\n  }\n\n  ret += '}'\n\n  return ret\n}\n\nclass Style extends Element {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('style', node), attrs)\n  }\n\n  addText(w = '') {\n    this.node.textContent += w\n    return this\n  }\n\n  font(name, src, params = {}) {\n    return this.rule('@font-face', {\n      fontFamily: name,\n      src: src,\n      ...params\n    })\n  }\n\n  rule(selector, obj) {\n    return this.addText(cssRule(selector, obj))\n  }\n}\n\nregisterMethods('Dom', {\n  style(selector, obj) {\n    return this.put(new Style()).rule(selector, obj)\n  },\n  fontface(name, src, params) {\n    return this.put(new Style()).font(name, src, params)\n  }\n})\n\nregister(Style, 'Style')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/TextPath.js\n\n\n\n\n\n\n\n\nclass TextPath extends Text {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('textPath', node), attrs)\n  }\n\n  // return the array of the path track element\n  array() {\n    const track = this.track()\n\n    return track ? track.array() : null\n  }\n\n  // Plot path if any\n  plot(d) {\n    const track = this.track()\n    let pathArray = null\n\n    if (track) {\n      pathArray = track.plot(d)\n    }\n\n    return d == null ? pathArray : this\n  }\n\n  // Get the path element\n  track() {\n    return this.reference('href')\n  }\n}\n\nregisterMethods({\n  Container: {\n    textPath: wrapWithAttrCheck(function (text, path) {\n      // Convert text to instance if needed\n      if (!(text instanceof Text)) {\n        text = this.text(text)\n      }\n\n      return text.path(path)\n    })\n  },\n  Text: {\n    // Create path for text to run on\n    path: wrapWithAttrCheck(function (track, importNodes = true) {\n      const textPath = new TextPath()\n\n      // if track is a path, reuse it\n      if (!(track instanceof Path)) {\n        // create path element\n        track = this.defs().path(track)\n      }\n\n      // link textPath to path and add content\n      textPath.attr('href', '#' + track, xlink)\n\n      // Transplant all nodes from text to textPath\n      let node\n      if (importNodes) {\n        while ((node = this.node.firstChild)) {\n          textPath.node.appendChild(node)\n        }\n      }\n\n      // add textPath element as child node and return textPath\n      return this.put(textPath)\n    }),\n\n    // Get the textPath children\n    textPath() {\n      return this.findOne('textPath')\n    }\n  },\n  Path: {\n    // creates a textPath from this path\n    text: wrapWithAttrCheck(function (text) {\n      // Convert text to instance if needed\n      if (!(text instanceof Text)) {\n        text = new Text().addTo(this.parent()).text(text)\n      }\n\n      // Create textPath from text and path and return\n      return text.path(this)\n    }),\n\n    targets() {\n      return baseFind('svg textPath').filter((node) => {\n        return (node.attr('href') || '').includes(this.id())\n      })\n\n      // Does not work in IE11. Use when IE support is dropped\n      // return baseFind('svg textPath[*|href*=' + this.id() + ']')\n    }\n  }\n})\n\nTextPath.prototype.MorphArray = PathArray\nregister(TextPath, 'TextPath')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Use.js\n\n\n\n\n\nclass Use extends Shape {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('use', node), attrs)\n  }\n\n  // Use element as a reference\n  use(element, file) {\n    // Set lined element\n    return this.attr('href', (file || '') + '#' + element, xlink)\n  }\n}\n\nregisterMethods({\n  Container: {\n    // Create a use element\n    use: wrapWithAttrCheck(function (element, file) {\n      return this.put(new Use()).use(element, file)\n    })\n  }\n})\n\nregister(Use, 'Use')\n\n;// ./node_modules/@svgdotjs/svg.js/src/main.js\n/* Optional Modules */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst SVG = (/* unused pure expression or super */ null && (makeInstance))\n\n\n\n\n\n\n/* Animation Modules */\n\n\n\n\n\n\n/* Types */\n\n\n\n\n\n\n\n\n\n\n\n/* Elements */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextend([Svg, Symbol_Symbol, Image, Pattern, Marker], getMethodsFor('viewbox'))\n\nextend([Line, Polyline, Polygon, Path], getMethodsFor('marker'))\n\nextend(Text, getMethodsFor('Text'))\nextend(Path, getMethodsFor('Path'))\n\nextend(Defs, getMethodsFor('Defs'))\n\nextend([Text, Tspan], getMethodsFor('Tspan'))\n\nextend([Rect, Ellipse, Gradient, Runner], getMethodsFor('radius'))\n\nextend(EventTarget, getMethodsFor('EventTarget'))\nextend(Dom, getMethodsFor('Dom'))\nextend(Element, getMethodsFor('Element'))\nextend(Shape, getMethodsFor('Shape'))\nextend([Container, elements_Fragment], getMethodsFor('Container'))\nextend(Gradient, getMethodsFor('Gradient'))\n\nextend(Runner, getMethodsFor('Runner'))\n\ntypes_List.extend(getMethodNames())\n\nregisterMorphableType([\n  SVGNumber,\n  Color,\n  Box,\n  Matrix,\n  SVGArray,\n  PointArray,\n  PathArray,\n  Point\n])\n\nmakeMorphable()\n\n;// ./src/objects/text-circle.ts\n\n\nclass TextCircle extends G {\n    constructor() {\n        super(...arguments);\n        this.$circle = null;\n        this.$text = null;\n    }\n    init(text, x, y, size, strokeWidth) {\n        this.$circle = this.circle(size)\n            .stroke({ width: strokeWidth })\n            .center(0, 0);\n        this.$text = this.text(text).center(0, 0);\n        if (x && y)\n            this.center(x, y);\n        return this;\n    }\n    getText() {\n        var _a;\n        return ((_a = this.$text) === null || _a === void 0 ? void 0 : _a.text()) || \"\";\n    }\n    setText(text) {\n        var _a;\n        if (text == null)\n            text = \"\";\n        text = `${text}`;\n        if (text === \"\")\n            text = NBSP;\n        (_a = this.$text) === null || _a === void 0 ? void 0 : _a.text(text);\n        return this;\n    }\n    getSize() {\n        const r = this.attr(\"r\");\n        if (typeof r === \"number\")\n            return r * 2;\n        if (typeof r === \"string\" && !isNaN(Number(r)))\n            return Number(r) * 2;\n        return 0;\n    }\n    setSize(diameter, animationDuration = 0) {\n        this.animate(animationDuration).attr(\"r\", String(diameter / 2));\n        return this;\n    }\n    toString() {\n        return this.getText();\n    }\n}\n\n;// ./src/objects/graph-node.ts\n\n\nclass GraphNode extends TextCircle {\n    constructor() {\n        super(...arguments);\n        this.$incoming = {};\n        this.$outgoing = {};\n        this.$nullary = {};\n    }\n    init(text, x, y, size, strokeWidth) {\n        const bgSize = 3 * size;\n        this.rect(bgSize, bgSize).center(0, 0).addClass(\"invisible\");\n        return super.init(text, x, y, size, strokeWidth);\n    }\n    getBend(key) {\n        return 0;\n    }\n    getDirected(key) {\n        return true;\n    }\n    getIncoming(inKey) {\n        return this.$incoming[inKey];\n    }\n    getOutgoing(outKey) {\n        return this.$outgoing[outKey];\n    }\n    getIncomingEdges() {\n        return Object.values(this.$incoming).filter((e) => e !== null);\n    }\n    getOutgoingEdges() {\n        return Object.values(this.$outgoing).filter((e) => e !== null);\n    }\n    getPredecessors() {\n        return Object.values(this.$incoming)\n            .map((e) => e === null || e === void 0 ? void 0 : e.getStart())\n            .filter((e) => e !== undefined && e !== null);\n    }\n    getSuccessors() {\n        return Object.values(this.$outgoing)\n            .map((e) => e === null || e === void 0 ? void 0 : e.getEnd())\n            .filter((e) => e !== undefined && e !== null);\n    }\n    getPredecessor(inKey) {\n        var _a;\n        return ((_a = this.$incoming[inKey]) === null || _a === void 0 ? void 0 : _a.getStart()) || null;\n    }\n    getSuccessor(outKey) {\n        var _a;\n        return ((_a = this.$outgoing[outKey]) === null || _a === void 0 ? void 0 : _a.getEnd()) || null;\n    }\n    setPredecessor(inKey, outKey, predecessor, strokeWidth) {\n        predecessor.setSuccessor(outKey, inKey, this, strokeWidth);\n        return this;\n    }\n    setSuccessor(outKey, inKey, successor, strokeWidth) {\n        const outEdge = this.$outgoing[outKey];\n        if (outEdge) {\n            const oldSuccessor = outEdge.getEnd();\n            const oldIncoming = oldSuccessor === null || oldSuccessor === void 0 ? void 0 : oldSuccessor.$incoming;\n            for (const k in oldIncoming) {\n                if (oldIncoming[k] === outEdge)\n                    delete oldIncoming[k];\n            }\n            outEdge.remove();\n        }\n        if (successor) {\n            const inEdge = successor.$incoming[inKey];\n            if (inEdge) {\n                const oldPredecessor = inEdge.getStart();\n                const oldOutgoing = oldPredecessor === null || oldPredecessor === void 0 ? void 0 : oldPredecessor.$outgoing;\n                for (const k in oldOutgoing) {\n                    if (oldOutgoing[k] === inEdge)\n                        delete oldOutgoing[k];\n                }\n                inEdge.remove();\n            }\n            const edge = this.root().connection(this, successor, strokeWidth, this.getBend(outKey), this.getDirected(outKey));\n            this.$outgoing[outKey] = edge;\n            successor.$incoming[inKey] = edge;\n        }\n        else {\n            delete this.$outgoing[outKey];\n        }\n        this._updateNullary();\n        return this;\n    }\n    _updateNullary() {\n        var _a, _b;\n        for (const node of baseFind(\"g\")) {\n            if (node instanceof GraphNode) {\n                for (const c in node.$nullary) {\n                    const show = !node.$outgoing[c];\n                    if (show)\n                        (_a = node.$nullary[c]) === null || _a === void 0 ? void 0 : _a.removeClass(\"invisible\");\n                    else\n                        (_b = node.$nullary[c]) === null || _b === void 0 ? void 0 : _b.addClass(\"invisible\");\n                }\n            }\n        }\n    }\n    setIncomingHighlight(inKey, high) {\n        var _a;\n        this.setHighlight(high);\n        (_a = this.getIncoming(inKey)) === null || _a === void 0 ? void 0 : _a.setHighlight(high);\n        return this;\n    }\n    getHighlight() {\n        return this.hasClass(\"highlight\");\n    }\n    setOutgoingHighlight(outKey, high) {\n        var _a;\n        this.setHighlight(high);\n        (_a = this.getOutgoing(outKey)) === null || _a === void 0 ? void 0 : _a.setHighlight(high);\n        return this;\n    }\n    remove() {\n        for (const outKey in this.$outgoing) {\n            const outEdge = this.$outgoing[outKey];\n            if (!outEdge)\n                continue;\n            const end = outEdge.getEnd();\n            const incoming = end === null || end === void 0 ? void 0 : end.$incoming;\n            for (const inKey in incoming) {\n                if (outEdge === incoming[inKey]) {\n                    delete incoming[inKey];\n                }\n                outEdge.remove();\n            }\n        }\n        for (const inKey in this.$incoming) {\n            const inEdge = this.$incoming[inKey];\n            if (!inEdge)\n                continue;\n            const start = inEdge.getStart();\n            const outgoing = start === null || start === void 0 ? void 0 : start.$outgoing;\n            for (const outKey in outgoing) {\n                if (inEdge === outgoing[outKey]) {\n                    delete outgoing[outKey];\n                }\n                inEdge.remove();\n            }\n        }\n        super.remove();\n        this._updateNullary();\n        return this;\n    }\n    setCenter(x, y, animationDuration = 0) {\n        super.setCenter(x, y, animationDuration);\n        for (const edge of this.getOutgoingEdges()) {\n            edge.update({ x1: x, y1: y }, animationDuration);\n        }\n        for (const edge of this.getIncomingEdges()) {\n            edge.update({ x2: x, y2: y }, animationDuration);\n        }\n        return this;\n    }\n    setSize(size, animationDuration = 0) {\n        super.setSize(size, animationDuration);\n        for (const edge of this.getIncomingEdges()) {\n            edge.update({ r2: size / 2 }, animationDuration);\n        }\n        return this;\n    }\n}\n\n;// ./src/objects/binary-node.ts\n\nclass BinaryNode extends GraphNode {\n    constructor() {\n        super(...arguments);\n        this.$incoming = {\n            parent: null,\n        };\n        this.$outgoing = {\n            left: null,\n            right: null,\n        };\n        this.$nullary = {\n            left: null,\n            right: null,\n        };\n        this.$edgebends = { left: 0.1, right: -0.1 };\n        this.$leftWidth = 0;\n        this.$rightWidth = 0;\n        this.$width = 0;\n    }\n    init(text, x, y, size, strokeWidth) {\n        const d = size;\n        const nX = 0.5 * d, nY = 0.8 * d, nR = 2 * strokeWidth;\n        const nullpath = (s) => `M 0,0 L ${s * nX},${nY} m ${nR},0 a ${nR},${nR} 0 1,0 ${-2 * nR},0 a ${nR},${nR} 0 1,0 ${2 * nR},0`;\n        this.$nullary.left = this.path(nullpath(-1))\n            .stroke({ width: strokeWidth })\n            .addClass(\"nullnode\");\n        this.$nullary.right = this.path(nullpath(1))\n            .stroke({ width: strokeWidth })\n            .addClass(\"nullnode\");\n        return super.init(text, x, y, size, strokeWidth);\n    }\n    getBend(c) {\n        return this.$edgebends[c];\n    }\n    getParent() {\n        var _a;\n        return ((_a = this.$incoming.parent) === null || _a === void 0 ? void 0 : _a.getStart()) || null;\n    }\n    getLeft() {\n        var _a;\n        return ((_a = this.$outgoing.left) === null || _a === void 0 ? void 0 : _a.getEnd()) || null;\n    }\n    getRight() {\n        var _a;\n        return ((_a = this.$outgoing.right) === null || _a === void 0 ? void 0 : _a.getEnd()) || null;\n    }\n    getChild(c) {\n        var _a;\n        return ((_a = this.$outgoing[c]) === null || _a === void 0 ? void 0 : _a.getEnd()) || null;\n    }\n    getSibling() {\n        const parent = this.getParent();\n        if (!parent)\n            return null;\n        return this === parent.getLeft() ? parent.getRight() : parent.getLeft();\n    }\n    getParentEdge() {\n        return this.$incoming.parent;\n    }\n    getLeftEdge() {\n        return this.$outgoing.left;\n    }\n    getRightEdge() {\n        return this.$outgoing.right;\n    }\n    getChildEdge(c) {\n        return this.$outgoing[c];\n    }\n    isLeaf() {\n        return !(this.getLeft() || this.getRight());\n    }\n    isLeftChild() {\n        var _a;\n        return this === ((_a = this.getParent()) === null || _a === void 0 ? void 0 : _a.getLeft());\n    }\n    isRightChild() {\n        var _a;\n        return this === ((_a = this.getParent()) === null || _a === void 0 ? void 0 : _a.getRight());\n    }\n    isChild(c) {\n        var _a;\n        return this === ((_a = this.getParent()) === null || _a === void 0 ? void 0 : _a.getChild(c));\n    }\n    setLeft(child, strokeWidth) {\n        return this.setChild(\"left\", child, strokeWidth);\n    }\n    setRight(child, strokeWidth) {\n        return this.setChild(\"right\", child, strokeWidth);\n    }\n    setChild(c, child, strokeWidth) {\n        return this.setSuccessor(c, \"parent\", child, strokeWidth);\n    }\n    setParentLeft(parent, strokeWidth) {\n        return this.setParent(\"left\", parent, strokeWidth);\n    }\n    setParentRight(parent, strokeWidth) {\n        return this.setParent(\"right\", parent, strokeWidth);\n    }\n    setParent(c, parent, strokeWidth) {\n        parent.setChild(c, this, strokeWidth);\n        return this;\n    }\n    setParentHighlight(high) {\n        return this.setIncomingHighlight(\"parent\", high);\n    }\n    setRightHighlight(high) {\n        return this.setChildHighlight(\"right\", high);\n    }\n    setLeftHighlight(high) {\n        return this.setChildHighlight(\"left\", high);\n    }\n    setChildHighlight(c, high) {\n        return this.setOutgoingHighlight(c, high);\n    }\n    deepString() {\n        var _a, _b;\n        let s = \"\";\n        if (this.getLeft())\n            s += `(${(_a = this.getLeft()) === null || _a === void 0 ? void 0 : _a.deepString()}) `;\n        s += this.getText();\n        if (this.getRight())\n            s += ` (${(_b = this.getRight()) === null || _b === void 0 ? void 0 : _b.deepString()})`;\n        return s;\n    }\n    resize(startX, startY, svgMargin, nodeSpacing, animationDuration = 0) {\n        this._resizeWidths(nodeSpacing);\n        const svgWidth = this.root().viewbox().width;\n        if (startX + this.$rightWidth > svgWidth - svgMargin)\n            startX = svgWidth - this.$rightWidth - svgMargin;\n        if (startX - this.$leftWidth < svgMargin)\n            startX = this.$leftWidth + svgMargin;\n        this._setNewPositions(startX, startY, nodeSpacing, animationDuration);\n        return this;\n    }\n    _resizeWidths(nodeSpacing) {\n        let width = nodeSpacing;\n        const left = this.getLeft();\n        if (left)\n            width += left._resizeWidths(nodeSpacing);\n        const right = this.getRight();\n        if (right)\n            width += right._resizeWidths(nodeSpacing);\n        width = Math.max(this.getSize(), width);\n        const leftWidth = (left === null || left === void 0 ? void 0 : left.$leftWidth) || 0;\n        const rightWidth = (right === null || right === void 0 ? void 0 : right.$rightWidth) || 0;\n        const mid = width - leftWidth - rightWidth;\n        this.$leftWidth = mid / 2 + leftWidth;\n        this.$rightWidth = mid / 2 + rightWidth;\n        this.$width = width;\n        return width;\n    }\n    _setNewPositions(x, y, nodeSpacing, animationDuration = 0) {\n        this.setCenter(x, y, animationDuration);\n        const ySpacing = nodeSpacing;\n        const nextY = y + this.getSize() + ySpacing;\n        const left = this.getLeft();\n        if (left)\n            left._setNewPositions(x - this.$leftWidth + left.$leftWidth, nextY, nodeSpacing, animationDuration);\n        const right = this.getRight();\n        if (right)\n            right._setNewPositions(x + this.$rightWidth - right.$rightWidth, nextY, nodeSpacing, animationDuration);\n    }\n    validate() {\n        var _a, _b, _c, _d;\n        const parent = (_a = this.$incoming.parent) === null || _a === void 0 ? void 0 : _a.getStart();\n        if (parent) {\n            parent.$incoming;\n            const c = this.isLeftChild() ? \"left\" : \"right\";\n            if (((_b = parent.$outgoing[c]) === null || _b === void 0 ? void 0 : _b.getEnd()) !== this)\n                console.error(\"Parent mismatch\");\n            let n = 0;\n            for (const edge of this.getEdges()) {\n                if (edge.getStart() === parent) {\n                    n++;\n                    if (edge.getEnd() !== this)\n                        console.error(\"Parent edge mismatch\");\n                }\n            }\n            if (n !== 1)\n                console.error(`Wrong n:o parent edges, ${n}`);\n        }\n        for (const c of [\"left\", \"right\"]) {\n            const child = (_c = this.$outgoing[c]) === null || _c === void 0 ? void 0 : _c.getEnd();\n            if (((_d = child === null || child === void 0 ? void 0 : child.$incoming.parent) === null || _d === void 0 ? void 0 : _d.getStart()) !== this)\n                console.error(`${c} child mismatch`);\n            let n = 0;\n            for (const edge of this.getEdges()) {\n                if (edge.getEnd() === child) {\n                    n++;\n                    if (edge.getStart() !== this)\n                        console.error(`${c} child edge mismatch`);\n                }\n            }\n            if (n !== 1)\n                console.error(`Wrong n:o ${c} child edges, ${n}`);\n        }\n    }\n}\n\n;// ./src/objects/avl-node.ts\n\nclass AVLNode extends BinaryNode {\n    constructor() {\n        super(...arguments);\n        this.$height = null;\n    }\n    init(text, x, y, size, strokeWidth) {\n        const d = size;\n        this.$height = this.text(\"1\")\n            .center(-0.6 * d, -0.5 * d)\n            .addClass(\"avlheight\");\n        return super.init(text, x, y, size, strokeWidth);\n    }\n    getHeight() {\n        if (this.$height)\n            return parseInt(this.$height.text());\n        return 1;\n    }\n    setHeight(height) {\n        var _a;\n        (_a = this.$height) === null || _a === void 0 ? void 0 : _a.text(String(height));\n        return this;\n    }\n    updateHeightPosition() {\n        if (!this.$height)\n            return this;\n        const hx = this.$height.cx();\n        const cx = this.cx();\n        if (this.isRightChild() && hx - cx < 0)\n            this.$height.cx(2 * cx - hx);\n        if (this.isLeftChild() && hx - cx > 0)\n            this.$height.cx(2 * cx - hx);\n        return this;\n    }\n    getHeightHighlight() {\n        var _a;\n        return ((_a = this.$height) === null || _a === void 0 ? void 0 : _a.getHighlight()) || false;\n    }\n    setHeightHighlight(high) {\n        var _a;\n        (_a = this.$height) === null || _a === void 0 ? void 0 : _a.setHighlight(high);\n        return this;\n    }\n}\n\n;// ./src/objects/connection.ts\n\nclass Connection extends Path {\n    constructor() {\n        super(...arguments);\n        this.$coords = {\n            r2: 0,\n            x1: 0,\n            x2: 0,\n            y1: 0,\n            y2: 0,\n        };\n        this.$start = null;\n        this.$end = null;\n        this.$bend = 0;\n    }\n    init(start, end, strokeWidth, bend = 0, directed = false) {\n        this.$start = start;\n        this.$end = end;\n        Object.assign(this.$coords, {\n            x1: start.cx(),\n            y1: start.cy(),\n            x2: end.cx(),\n            y2: end.cy(),\n            r2: end.getSize() / 2,\n        });\n        this.stroke({ width: strokeWidth });\n        this.back();\n        this.setBend(bend);\n        if (directed)\n            this._createArrow();\n        this.update(this.$coords);\n        return this;\n    }\n    getBend() {\n        return this.$bend;\n    }\n    setBend(bend) {\n        this.$bend = bend;\n        return this;\n    }\n    isDirected() {\n        return Boolean(this.reference(\"marker-end\"));\n    }\n    update(newCoords, animationDuration = 0) {\n        Object.assign(this.$coords, newCoords);\n        this.animateSVG(animationDuration).plot(this._getPath());\n        if (this.isDirected())\n            this._redrawArrow(animationDuration);\n        return this;\n    }\n    _createArrow() {\n        this.marker(\"end\", 5, 4, function (add) {\n            add.polygon([0, 0, 5, 2, 0, 4]).addClass(\"filled\");\n        });\n    }\n    _redrawArrow(animationDuration = 0) {\n        const marker = this.reference(\"marker-end\");\n        const radius = this.$coords.r2;\n        const stroke = this.attr(\"stroke-width\");\n        marker === null || marker === void 0 ? void 0 : marker.animateSVG(animationDuration).attr({ refX: radius / stroke + 5 });\n    }\n    toString() {\n        return `${this.getStart()} --\x3e ${this.getEnd()}`;\n    }\n    getStart() {\n        return this.$start;\n    }\n    getEnd() {\n        return this.$end;\n    }\n    setStart(start, animationDuration = 0) {\n        if (start === this.$start)\n            return this;\n        this.$start = start;\n        if (start)\n            this.update({ x1: start.cx(), y1: start.cy() }, animationDuration);\n        return this;\n    }\n    setEnd(end, animationDuration = 0) {\n        if (end === this.$end)\n            return this;\n        this.$end = end;\n        if (end)\n            this.update({ x2: end.cx(), y2: end.cy() }, animationDuration);\n        return this;\n    }\n    setHighlight(high) {\n        super.setHighlight(high);\n        const marker = this.reference(\"marker-end\");\n        if (marker)\n            marker.setHighlight(high);\n        return this;\n    }\n    _getPath() {\n        const C = this.$coords;\n        const xControl = (C.x1 + C.x2) / 2 + (C.y1 - C.y2) * this.getBend();\n        const yControl = (C.y1 + C.y2) / 2 + (C.x2 - C.x1) * this.getBend();\n        return `M ${C.x1} ${C.y1} Q ${xControl} ${yControl} ${C.x2} ${C.y2}`;\n    }\n}\n\n;// ./src/objects/btree-connection.ts\n\nclass BTreeConnection extends Connection {\n    constructor() {\n        super(...arguments);\n        this.$maxBend = 0.1;\n        this.$coords = {\n            x1: 0,\n            x2: 0,\n            y1: 0,\n            y2: 0,\n            r2: 0,\n            n: 0,\n            i: 0,\n        };\n    }\n    init(start, end, child, numChildren, strokeWidth) {\n        Object.assign(this.$coords, { i: child, n: numChildren });\n        return super.init(start, end, strokeWidth);\n    }\n    getBend() {\n        if (this.$coords.n <= 1)\n            return 0;\n        return this.$maxBend * (1 - (2 * this.$coords.i) / (this.$coords.n - 1));\n    }\n    _getPath() {\n        const C = this.$coords;\n        let x1 = C.x1 + (2 * C.i - C.n + 1) * C.r2;\n        const y1 = C.y1 + C.r2;\n        if (C.i === 0)\n            x1 += C.r2 / 4;\n        if (C.i === C.n - 1)\n            x1 -= C.r2 / 4;\n        const xControl = (x1 + C.x2) / 2 + (y1 - C.y2) * this.getBend();\n        const yControl = (y1 + C.y2) / 2 + (C.x2 - x1) * this.getBend();\n        return `M ${x1} ${y1} Q ${xControl} ${yControl} ${C.x2} ${C.y2}`;\n    }\n}\n\n;// ./src/objects/btree-node.ts\n\n\nclass BTreeNode extends G {\n    constructor() {\n        super(...arguments);\n        this.$parent = null;\n        this.$children = null;\n        this.$rect = null;\n        this.$values = [];\n        this.$lines = [];\n        this.$rightWidth = 0;\n        this.$leftWidth = 0;\n        this.$childWidths = 0;\n        this.$width = 0;\n    }\n    init(leaf, nvalues, x, y, objectSize, strokeWidth) {\n        if (nvalues < 1)\n            throw new Error(\"BTreeNode: must have at least one value\");\n        this.$children = leaf ? null : Array(nvalues + 1);\n        this.setNumValues(nvalues, objectSize, strokeWidth);\n        if (x && y)\n            this.center(x, y);\n        return this;\n    }\n    toString() {\n        return `[${this.getTexts().join(\" | \")}]`;\n    }\n    numValues() {\n        return this.$values.length;\n    }\n    numChildren() {\n        var _a;\n        return ((_a = this.$children) === null || _a === void 0 ? void 0 : _a.length) || 0;\n    }\n    isLeaf() {\n        return this.$children === null;\n    }\n    setLeaf(leaf, strokeWidth) {\n        if (leaf && this.$children) {\n            for (let i = 0; i < this.$children.length; i++) {\n                this.setChild(i, null, strokeWidth);\n            }\n            this.$children = null;\n        }\n        else {\n            this.$children = Array(this.numValues() + 1);\n        }\n        return this;\n    }\n    insertValue(i, text, objectSize, strokeWidth, leftChildInsert = false) {\n        var _a;\n        if (i < this.numValues()) {\n            const dx = (i / Math.max(1, this.numValues()) - 1) * objectSize;\n            this.dmoveCenter(dx, 0);\n        }\n        this.$values.splice(i, 0);\n        this.$lines.splice(i, 0);\n        if (!this.isLeaf()) {\n            const j = leftChildInsert ? i : i + 1;\n            (_a = this.$children) === null || _a === void 0 ? void 0 : _a.splice(j, 0);\n        }\n        this.setNumValues(this.numValues(), objectSize, strokeWidth);\n        this.setText(i, text);\n        return this;\n    }\n    deleteValue(i, objectSize, strokeWidth, leftChildDelete = true) {\n        var _a;\n        this.$values[i].remove();\n        this.$values.splice(i, 1);\n        const l = Math.max(i, 1);\n        this.$lines[l].remove();\n        this.$lines.splice(l, 1);\n        if (!this.isLeaf()) {\n            const j = leftChildDelete ? i : i + 1;\n            this.setChild(j, null, strokeWidth);\n            (_a = this.$children) === null || _a === void 0 ? void 0 : _a.splice(j, 1);\n        }\n        this.setNumValues(this.numValues(), objectSize, strokeWidth);\n        return this;\n    }\n    setNumValues(nvalues, objectSize, strokeWidth) {\n        var _a, _b, _c, _d, _e;\n        while (nvalues < this.numValues()) {\n            if (!this.isLeaf()) {\n                this.setChild(((_a = this.$children) === null || _a === void 0 ? void 0 : _a.length) || 0 - 1, null, strokeWidth);\n                (_b = this.$children) === null || _b === void 0 ? void 0 : _b.pop();\n            }\n            (_c = this.$values.pop()) === null || _c === void 0 ? void 0 : _c.remove();\n            (_d = this.$lines.pop()) === null || _d === void 0 ? void 0 : _d.remove();\n        }\n        const w0 = objectSize, h = objectSize, stroke = strokeWidth;\n        if (!this.$rect)\n            this.$rect = this.rect(w0 * nvalues, h)\n                .stroke({ width: stroke })\n                .center(0, 0);\n        this.$rect.width(w0 * Math.max(0.5, nvalues)).radius(h / 4);\n        const cx = this.$rect.cx(), cy = this.$rect.cy();\n        for (let i = 0; i < nvalues; i++) {\n            if (!this.$values[i])\n                this.$values[i] = this.text(NBSP);\n            this.$values[i].center(cx + w0 * (i - nvalues / 2 + 0.5), cy);\n            if (i > 0) {\n                const dx = w0 * (i - nvalues / 2), dy = h / 2;\n                if (!this.$lines[i])\n                    this.$lines[i] = this.line(0, cy - dy, 0, cy + dy).stroke({\n                        width: stroke,\n                    });\n                this.$lines[i].cx(cx + dx);\n            }\n        }\n        if (!this.isLeaf() && this.$children) {\n            const n = (this.$children.length = nvalues + 1);\n            for (let i = 0; i < n; i++) {\n                (_e = this.$children[i]) === null || _e === void 0 ? void 0 : _e.update({ i: i, n: n });\n            }\n        }\n        return this;\n    }\n    getCX(i, objectSize) {\n        return this.cx() + objectSize * (i - this.numValues() / 2 + 0.5);\n    }\n    getWidth() {\n        var _a;\n        return Number((_a = this.$rect) === null || _a === void 0 ? void 0 : _a.width()) || 0;\n    }\n    getHeight() {\n        var _a;\n        return Number((_a = this.$rect) === null || _a === void 0 ? void 0 : _a.height()) || 0;\n    }\n    getSize() {\n        return this.getHeight();\n    }\n    getTexts() {\n        return this.$values.map((t) => t.text());\n    }\n    setTexts(texts) {\n        if (texts.length !== this.numValues())\n            throw new Error(`Wrong number of texts: ${texts.length} != ${this.numValues()}`);\n        for (let i = 0; i < texts.length; i++) {\n            this.setText(i, texts[i]);\n        }\n        return this;\n    }\n    getText(c) {\n        return this.$values[c].text();\n    }\n    setText(i, text) {\n        if (text == null)\n            text = \"\";\n        text = `${text}`;\n        if (text === \"\")\n            text = NBSP;\n        this.$values[i].text(text);\n        return this;\n    }\n    getParent() {\n        var _a;\n        return ((_a = this.$parent) === null || _a === void 0 ? void 0 : _a.getStart()) || null;\n    }\n    getChildren() {\n        var _a;\n        return (((_a = this.$children) === null || _a === void 0 ? void 0 : _a.map((e) => e === null || e === void 0 ? void 0 : e.getEnd()).filter((e) => e !== null && e !== undefined)) || []);\n    }\n    getChild(i) {\n        var _a, _b;\n        return ((_b = (_a = this.$children) === null || _a === void 0 ? void 0 : _a[i]) === null || _b === void 0 ? void 0 : _b.getEnd()) || null;\n    }\n    getLeft() {\n        return this.getChild(0);\n    }\n    getRight() {\n        return this.getChild(this.numChildren() - 1);\n    }\n    isChild(c) {\n        var _a;\n        return this === ((_a = this.getParent()) === null || _a === void 0 ? void 0 : _a.getChild(c));\n    }\n    getParentIndex() {\n        const parent = this.getParent();\n        if (!parent)\n            return null;\n        for (let i = 0; i < parent.numChildren(); i++) {\n            if (this === parent.getChild(i))\n                return i;\n        }\n        return null;\n    }\n    getParentEdge() {\n        return this.$parent;\n    }\n    getChildEdge(i) {\n        var _a;\n        return ((_a = this.$children) === null || _a === void 0 ? void 0 : _a[i]) || null;\n    }\n    setChild(i, child, strokeWidth) {\n        var _a, _b, _c, _d;\n        if ((_a = this.$children) === null || _a === void 0 ? void 0 : _a[i]) {\n            const oldChild = this.$children[i].getEnd();\n            oldChild.$parent = null;\n            this.$children[i].remove();\n        }\n        if (!child) {\n            if ((_b = this.$children) === null || _b === void 0 ? void 0 : _b[i])\n                this.$children[i] = null;\n        }\n        else {\n            if (child.$parent) {\n                const oldParent = child.$parent.getStart();\n                (_c = oldParent === null || oldParent === void 0 ? void 0 : oldParent.$children) === null || _c === void 0 ? void 0 : _c.forEach((oldParentChild) => {\n                    if (child.$parent === oldParentChild) {\n                        oldParentChild = null;\n                    }\n                });\n                child.$parent.remove();\n            }\n            const edge = this.root().bTreeConnection(this, child, i, this.numChildren(), strokeWidth);\n            if ((_d = this.$children) === null || _d === void 0 ? void 0 : _d[i])\n                this.$children[i] = edge;\n            child.$parent = edge;\n        }\n        return this;\n    }\n    setParent(c, parent, strokeWidth) {\n        parent.setChild(c, this, strokeWidth);\n        return this;\n    }\n    setParentHighlight(high) {\n        var _a;\n        this.setHighlight(high);\n        (_a = this.getParent()) === null || _a === void 0 ? void 0 : _a.setHighlight(high);\n        return this;\n    }\n    setChildHighlight(i, high) {\n        var _a;\n        this.setHighlight(high);\n        (_a = this.getChild(i)) === null || _a === void 0 ? void 0 : _a.setHighlight(high);\n        return this;\n    }\n    remove() {\n        var _a, _b, _c;\n        if (!this.isLeaf()) {\n            (_a = this.$children) === null || _a === void 0 ? void 0 : _a.forEach((child) => {\n                if (!child)\n                    return;\n                child.remove();\n                child = null;\n            });\n        }\n        if (this.$parent) {\n            const i = this.getParentIndex();\n            if (i && ((_c = (_b = this.$parent.getStart()) === null || _b === void 0 ? void 0 : _b.$children) === null || _c === void 0 ? void 0 : _c[i]))\n                this.$parent.getStart().$children[i] = null;\n            this.$parent.remove();\n            this.$parent = null;\n        }\n        super.remove();\n        return this;\n    }\n    setCenter(x, y, animationDuration = 0) {\n        var _a, _b;\n        super.setCenter(x, y, animationDuration);\n        (_a = this.$children) === null || _a === void 0 ? void 0 : _a.forEach((child) => {\n            child === null || child === void 0 ? void 0 : child.update({ x1: x, y1: y }, animationDuration);\n        });\n        (_b = this.$parent) === null || _b === void 0 ? void 0 : _b.update({ x2: x, y2: y }, animationDuration);\n        return this;\n    }\n    resize(startX, startY, svgMargin, nodeSpacing, animationDuration = 0) {\n        this._resizeWidths(nodeSpacing);\n        const svgWidth = this.root().viewbox().width;\n        if (startX + this.$rightWidth > svgWidth - svgMargin)\n            startX = svgWidth - this.$rightWidth - svgMargin;\n        if (startX - this.$leftWidth < svgMargin)\n            startX = this.$leftWidth + svgMargin;\n        this._setNewPositions(startX, startY, animationDuration);\n        return this;\n    }\n    _resizeWidths(nodeSpacing) {\n        var _a, _b;\n        let left = 0, right = 0;\n        this.$childWidths = 0;\n        this.$width = this.getWidth();\n        if (!this.isLeaf()) {\n            for (const child of this.getChildren()) {\n                this.$childWidths += (child === null || child === void 0 ? void 0 : child._resizeWidths(nodeSpacing)) || 0;\n            }\n            const xSpacing = nodeSpacing;\n            this.$width = Math.max(this.$width, this.$childWidths + this.numValues() * xSpacing);\n            left = ((_a = this.getLeft()) === null || _a === void 0 ? void 0 : _a.$leftWidth) || 0;\n            right = ((_b = this.getRight()) === null || _b === void 0 ? void 0 : _b.$rightWidth) || 0;\n        }\n        const mid = this.$width - left - right;\n        this.$leftWidth = mid / 2 + left;\n        this.$rightWidth = mid / 2 + right;\n        return this.$width;\n    }\n    _setNewPositions(x, y, nodeSpacing, animationDuration = 0) {\n        this.setCenter(x, y, animationDuration);\n        if (this.isLeaf())\n            return;\n        x -= this.$leftWidth;\n        const xSpacing = (this.$width - this.$childWidths) / this.numValues();\n        const ySpacing = nodeSpacing;\n        const nextY = y + this.getHeight() + ySpacing;\n        for (const child of this.getChildren()) {\n            child === null || child === void 0 ? void 0 : child._setNewPositions(x + child.$leftWidth, nextY, animationDuration);\n            x += ((child === null || child === void 0 ? void 0 : child.$width) || 0) + xSpacing;\n        }\n    }\n}\n\n;// ./src/objects/highlight-circle.ts\n\nclass HighlightCircle extends Circle {\n    init(x, y, radius, strokeWidth) {\n        return this.radius(radius)\n            .stroke({ width: strokeWidth })\n            .center(x, y)\n            .addClass(\"highlight-circle\");\n    }\n    getSize() {\n        const r = this.attr(\"r\");\n        if (typeof r === \"number\")\n            return r * 2;\n        if (typeof r === \"string\" && !isNaN(Number(r)))\n            return Number(r) * 2;\n        return 0;\n    }\n    setSize(diameter, animationDuration) {\n        this.animate(animationDuration).attr(\"r\", String(diameter / 2));\n        return this;\n    }\n}\n\n;// ./src/objects/index.ts\n\n\n\n\n\n\n\n\n\nextend(Element, {\n    getHighlight() {\n        return this.hasClass(\"highlight\");\n    },\n    setHighlight(high) {\n        if (high == null)\n            this.toggleClass(\"highlight\");\n        else if (high)\n            this.addClass(\"highlight\");\n        else\n            this.removeClass(\"highlight\");\n        return this;\n    },\n    getCenter() {\n        return [this.cx(), this.cy()];\n    },\n    setCenter(x, y, animationDuration = 0) {\n        this.animateSVG(animationDuration).center(x, y);\n        return this;\n    },\n    dmoveCenter(dx, dy, animationDuration = 0) {\n        this.setCenter(this.cx() + dx, this.cy() + dy, animationDuration);\n        return this;\n    },\n    animateSVG(duration) {\n        this.animate(duration, 0, \"now\");\n        return this;\n    },\n});\nextend(Container, {\n    highlightCircle(x, y, radius, strokeWidth) {\n        return this.put(new HighlightCircle()).init(x, y, radius, strokeWidth);\n    },\n    textCircle(text, x, y, size, strokeWidth) {\n        return this.put(new TextCircle()).init(text, x, y, size, strokeWidth);\n    },\n    graphNode(text, x, y, size, strokeWidth) {\n        return this.put(new GraphNode()).init(text, x, y, size, strokeWidth);\n    },\n    binaryNode(text, x, y, size, strokeWidth) {\n        return this.put(new BinaryNode()).init(text, x, y, size, strokeWidth);\n    },\n    avlNode(text, x, y, size, strokeWidth) {\n        return this.put(new AVLNode()).init(text, x, y, size, strokeWidth);\n    },\n    connection(start, end, strokeWidth, bend, directed) {\n        return this.put(new Connection()).init(start, end, strokeWidth, bend, directed);\n    },\n    bTreeNode(leaf, nvalues, x, y, objectSize, strokeWidth) {\n        return this.put(new BTreeNode()).init(leaf, nvalues, x, y, objectSize, strokeWidth);\n    },\n    bTreeConnection(start, end, child, numChildren, strokeWidth) {\n        return this.put(new BTreeConnection()).init(start, end, child, numChildren, strokeWidth);\n    },\n});\n\n\n;// ./src/engine.ts\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nclass Engine {\n    getAnimationSpeed() {\n        var _a;\n        if (this.toolbar.animationSpeed)\n            return parseInt((_a = this.toolbar.animationSpeed) === null || _a === void 0 ? void 0 : _a.value);\n        return this.$Svg.animationSpeed;\n    }\n    getObjectSize() {\n        var _a;\n        if (this.toolbar.objectSize)\n            return parseInt((_a = this.toolbar.objectSize) === null || _a === void 0 ? void 0 : _a.value);\n        return this.$Svg.objectSize;\n    }\n    getNodeSpacing() {\n        return this.getObjectSize();\n    }\n    getStrokeWidth() {\n        return this.getObjectSize() / 12;\n    }\n    getNodeStart() {\n        return [this.$Svg.margin + this.getObjectSize() / 2, this.$Svg.margin * 4];\n    }\n    getTreeRoot() {\n        return [\n            this.Svg.viewbox().width / 2,\n            2 * this.$Svg.margin + this.getObjectSize() / 2,\n        ];\n    }\n    constructor(containerSelector, defaults = {}) {\n        this.$Svg = {\n            width: 1000,\n            height: 600,\n            margin: 30,\n            objectSize: 40,\n            animationSpeed: 1000,\n        };\n        this.$CookieExpireDays = 30;\n        this.$Cookies = {\n            animationSpeed: {\n                getCookie: (value) => {\n                    if (this.toolbar.animationSpeed)\n                        this.toolbar.animationSpeed.value = value;\n                },\n                setCookie: () => this.getAnimationSpeed(),\n            },\n            objectSize: {\n                getCookie: (value) => {\n                    if (this.toolbar.objectSize)\n                        this.toolbar.objectSize.value = value;\n                },\n                setCookie: () => this.getObjectSize(),\n            },\n        };\n        this.actions = [];\n        this.CurrentAction = 0;\n        this.CurrentStep = 0;\n        this.DEBUG = true;\n        this.State = {\n            resetting: false,\n            animating: false,\n        };\n        this.Info = {\n            title: undefined,\n            body: undefined,\n            printer: undefined,\n            status: undefined,\n        };\n        this.EventListeners = {\n            stepForward: {},\n            stepBackward: {},\n            fastForward: {},\n            fastBackward: {},\n            toggleRunner: {},\n        };\n        this.$IdleListeners = {\n            stepBackward: {\n                type: \"click\",\n                condition: () => this.actions.length > 0,\n                handler: () => {\n                    this.setRunning(false);\n                    const action = this.actions.pop();\n                    this.execute(action.oper, action.args, action.nsteps - 1);\n                },\n            },\n            fastBackward: {\n                type: \"click\",\n                condition: () => this.actions.length > 0,\n                handler: () => {\n                    this.actions.pop();\n                    if (this.actions.length > 0) {\n                        const action = this.actions.pop();\n                        this.execute(action.oper, action.args, action.nsteps);\n                    }\n                    else {\n                        this.reset();\n                    }\n                },\n            },\n            objectSize: {\n                type: \"change\",\n                condition: () => true,\n                handler: () => {\n                    if (this.actions.length > 0) {\n                        const action = this.actions.pop();\n                        this.execute(action.oper, action.args, action.nsteps);\n                    }\n                    else {\n                        this.reset();\n                    }\n                },\n            },\n        };\n        this.$AsyncListeners = {\n            stepForward: {\n                type: \"click\",\n                handler: (resolve, reject) => {\n                    this.setRunning(false);\n                    this.stepForward(resolve, reject);\n                },\n            },\n            fastForward: {\n                type: \"click\",\n                handler: (resolve, reject) => {\n                    this.actions[this.CurrentAction].nsteps = Number.MAX_SAFE_INTEGER;\n                    this.fastForward(resolve, reject);\n                },\n            },\n            toggleRunner: {\n                type: \"click\",\n                handler: (resolve, reject) => {\n                    this.toggleRunner();\n                    if (this.isRunning()) {\n                        this.stepForward(resolve, reject);\n                    }\n                    else {\n                        this.CurrentStep++;\n                        resolve(undefined);\n                    }\n                },\n            },\n            stepBackward: {\n                type: \"click\",\n                handler: (resolve, reject) => reject({ until: this.CurrentStep - 1, running: false }),\n            },\n            fastBackward: {\n                type: \"click\",\n                handler: (resolve, reject) => reject({ until: 0 }),\n            },\n            objectSize: {\n                type: \"change\",\n                handler: (resolve, reject) => reject({ until: this.CurrentStep }),\n            },\n        };\n        for (const key in defaults) {\n            if (!key.startsWith(\"$\"))\n                throw new TypeError(`Invalid default key: ${key}`);\n        }\n        updateDefault(this, defaults, true);\n        const container = document.querySelector(containerSelector);\n        if (!container)\n            throw new Error(\"No container found\");\n        this.container = container;\n        this.toolbar = this.getToolbar();\n        const svgContainer = this.container.querySelector(\"svg\");\n        if (!svgContainer)\n            throw new Error(\"No svg element found\");\n        this.Svg = new Svg(svgContainer);\n        this.Svg.viewbox(0, 0, this.$Svg.width, this.$Svg.height);\n        const debugParam = new URLSearchParams(window.location.href).get(\"debug\");\n        this.DEBUG = Boolean(debugParam || false);\n        if (this.DEBUG)\n            this.Svg.addClass(\"debug\");\n    }\n    getToolbar() {\n        const generalControls = this.container.querySelector(\"fieldset.generalControls\");\n        const algorithmControls = this.container.querySelector(\"fieldset.algorithmControls\");\n        const stepForward = this.container.querySelector(\"button.stepForward\");\n        const stepBackward = this.container.querySelector(\"button.stepBackward\");\n        const toggleRunner = this.container.querySelector(\"button.toggleRunner\");\n        const fastForward = this.container.querySelector(\"button.fastForward\");\n        const fastBackward = this.container.querySelector(\"button.fastBackward\");\n        const objectSize = this.container.querySelector(\"select.objectSize\");\n        const animationSpeed = this.container.querySelector(\"select.animationSpeed\");\n        if (!generalControls)\n            throw new Error(\"Missing general controls fieldset\");\n        if (!algorithmControls)\n            throw new Error(\"Missing algorithm controls fieldset\");\n        if (!stepForward)\n            throw new Error(\"Missing step forward button\");\n        if (!stepBackward)\n            throw new Error(\"Missing step backward button\");\n        if (!toggleRunner)\n            throw new Error(\"Missing toggle runner button\");\n        if (!fastForward)\n            throw new Error(\"Missing fast forward button\");\n        if (!fastBackward)\n            throw new Error(\"Missing fast backward button\");\n        if (!objectSize)\n            throw new Error(\"Missing object size select\");\n        if (!animationSpeed)\n            throw new Error(\"Missing animation speed select\");\n        return {\n            generalControls,\n            algorithmControls,\n            stepForward,\n            stepBackward,\n            toggleRunner,\n            fastForward,\n            fastBackward,\n            objectSize,\n            animationSpeed,\n        };\n    }\n    initialise() {\n        this.initToolbar();\n        this.resetAll();\n        this.setRunning(true);\n    }\n    initToolbar() {\n        this.toolbar.animationSpeed.addEventListener(\"change\", () => this.saveCookies());\n    }\n    resetAll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.actions = [];\n            this.loadCookies();\n            yield this.reset();\n        });\n    }\n    confirmResetAll() {\n        if (confirm(\"This clears the canvas and your history!\")) {\n            this.resetAll();\n            return true;\n        }\n        return false;\n    }\n    reset() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.clearCanvas();\n            yield this.resetAlgorithm();\n            this.resetListeners(false);\n        });\n    }\n    resetAlgorithm() {\n        return __awaiter(this, void 0, void 0, function* () { });\n    }\n    clearCanvas() {\n        this.Svg.clear();\n        const w = this.Svg.viewbox().width;\n        const h = this.Svg.viewbox().height;\n        if (this.DEBUG) {\n            for (let x = 1; x < w / 100; x++)\n                this.Svg.line(x * 100, 0, x * 100, h).addClass(\"gridline\");\n            for (let y = 1; y < h / 100; y++)\n                this.Svg.line(0, y * 100, w, y * 100).addClass(\"gridline\");\n        }\n        const margin = this.$Svg.margin;\n        this.Info.title = this.Svg.text(NBSP).addClass(\"title\").x(margin).y(margin);\n        this.Info.body = this.Svg.text(NBSP)\n            .addClass(\"message\")\n            .x(margin)\n            .y(2 * margin);\n        this.Info.printer = this.Svg.text(NBSP)\n            .addClass(\"printer\")\n            .x(margin)\n            .cy(h - 2 * margin);\n        this.Info.status = this.Svg.text(NBSP)\n            .addClass(\"status-report\")\n            .x(margin)\n            .cy(h - margin);\n        this.updateCSSVariables();\n    }\n    updateCSSVariables() {\n        const relativeSize = Math.round((100 * this.getObjectSize()) / this.$Svg.objectSize);\n        document.documentElement.style.setProperty(\"--node-font-size\", `${relativeSize}%`);\n    }\n    setStatus(status, timeout = 10) {\n        const currentStatus = this.Info.status;\n        if (currentStatus === undefined)\n            return;\n        setTimeout(() => {\n            if (status === \"running\") {\n                currentStatus\n                    .text(\"Animating\")\n                    .removeClass(\"paused\")\n                    .addClass(\"running\");\n            }\n            else if (status === \"paused\") {\n                currentStatus.text(\"Paused\").addClass(\"paused\").removeClass(\"running\");\n            }\n            else {\n                currentStatus.text(\"Idle\").removeClass(\"paused\").removeClass(\"running\");\n            }\n        }, timeout);\n    }\n    setIdleTitle() {\n        if (this.Info.title !== undefined)\n            this.Info.title.text(\"Select an action from the menu above\");\n        if (this.Info.body !== undefined)\n            this.Info.body.text(NBSP);\n    }\n    disableWhenRunning(disabled) {\n        for (const elem of this.container.querySelectorAll(\".disableWhenRunning\"))\n            elem.disabled = disabled;\n    }\n    resetListeners(isRunning) {\n        this.saveCookies();\n        this.removeAllListeners();\n        if (this.constructor === Engine) {\n            this.disableWhenRunning(true);\n            return;\n        }\n        this.addListener(\"toggleRunner\", \"click\", () => this.toggleRunner());\n        if (isRunning) {\n            this.disableWhenRunning(true);\n            this.setStatus(\"paused\");\n            return;\n        }\n        this.disableWhenRunning(false);\n        this.setIdleTitle();\n        this.setStatus(\"inactive\");\n        for (const id in this.$IdleListeners) {\n            const listener = this.$IdleListeners[id];\n            if (listener.condition()) {\n                if (this.DEBUG)\n                    this.addListener(id, listener.type, () => {\n                        console.log(`${id} ${listener.type}: ${JSON.stringify(this.actions)}`);\n                        listener.handler();\n                    });\n                else\n                    this.addListener(id, listener.type, listener.handler);\n            }\n        }\n    }\n    addListener(id, type, handler) {\n        const listeners = this.EventListeners;\n        if (!listeners[id])\n            listeners[id] = {};\n        const elem = this.toolbar[id];\n        if (!elem)\n            throw new Error(\"Could not find element to add listener to\");\n        const oldHandler = listeners[id][type];\n        if (oldHandler)\n            elem.removeEventListener(type, oldHandler);\n        listeners[id][type] = handler;\n        elem.addEventListener(type, handler);\n        elem.disabled = false;\n    }\n    removeAllListeners() {\n        const listeners = this.EventListeners;\n        for (const id in listeners) {\n            const elem = this.toolbar[id];\n            if (!elem)\n                throw new Error(\"Could not find element to remove listener from\");\n            elem.disabled = true;\n            for (const type in listeners[id])\n                elem.removeEventListener(type, listeners[id][type]);\n            listeners[id] = {};\n        }\n    }\n    submit(method, field) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const rawValue = field.value;\n                field.value = \"\";\n                const values = parseValues(rawValue);\n                if (values)\n                    yield this.execute(method, values);\n                return true;\n            }\n            catch (error) {\n                console.error(error);\n            }\n            return false;\n        });\n    }\n    execute(operation_1) {\n        return __awaiter(this, arguments, void 0, function* (operation, args = [], until = 0) {\n            yield this.reset();\n            this.actions.push({ oper: operation, args: args, nsteps: until });\n            if (this.DEBUG)\n                console.log(`EXEC ${until}: ${operation} ${args.join(\", \")}, ${JSON.stringify(this.actions)}`);\n            try {\n                yield this.runActionsLoop();\n                this.actions[this.actions.length - 1].nsteps = this.CurrentStep || 0;\n                if (this.DEBUG)\n                    console.log(`DONE / ${this.CurrentStep}: ${JSON.stringify(this.actions)}`);\n                this.resetListeners(false);\n            }\n            catch (reason) {\n                if (typeof reason !== \"object\" ||\n                    reason === null ||\n                    \"until\" in reason === false ||\n                    typeof reason.until !== \"number\") {\n                    console.error(reason);\n                    this.resetListeners(false);\n                    return;\n                }\n                this.actions.pop();\n                if (\"running\" in reason && typeof reason.running === \"boolean\")\n                    this.setRunning(reason.running);\n                until = reason.until;\n                if (this.DEBUG)\n                    console.log(`RERUN ${until} / ${this.CurrentStep}: ${JSON.stringify(this.actions)}`);\n                if (until <= 0 && this.actions.length > 0) {\n                    const action = this.actions.pop();\n                    (operation = action.oper),\n                        (args = action.args),\n                        (until = action.nsteps);\n                }\n                if (until > 0) {\n                    this.execute(operation, args, until);\n                }\n                else {\n                    this.reset();\n                }\n            }\n        });\n    }\n    runActionsLoop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            for (let nAction = 0; nAction < this.actions.length; nAction++) {\n                this.resetListeners(true);\n                const action = this.actions[nAction];\n                this.CurrentAction = nAction;\n                this.CurrentStep = 0;\n                const messageArr = action.oper.match(/[A-Za-z][a-z]*/g) || [];\n                let message = messageArr.join(\" \");\n                message = `${message.charAt(0).toUpperCase() + message.substring(1)} ${action.args.join(\", \")}`;\n                if (this.DEBUG)\n                    console.log(`CALL ${nAction}: ${message}, ${JSON.stringify(this.actions)}`);\n                (_a = this.Info.title) === null || _a === void 0 ? void 0 : _a.text(message);\n                yield this.pause(\"\");\n                if (!(action.oper in this &&\n                    typeof this[action.oper] === \"function\"))\n                    throw new Error(\"Cannot call action that does not exist\");\n                yield this[action.oper](...action.args);\n            }\n        });\n    }\n    pause(message, ...args) {\n        const title = this.getMessage(message, ...args);\n        if (this.DEBUG)\n            console.log(`${this.CurrentStep}. Doing: ${title} (running: ${this.isRunning()}), ${JSON.stringify(this.actions)}`);\n        if (this.State.resetting)\n            return null;\n        if (title !== null && this.Info.body !== undefined) {\n            this.Info.body.text(title);\n        }\n        return new Promise((resolve, reject) => {\n            const action = this.actions[this.CurrentAction];\n            if (action.nsteps != null && this.CurrentStep < action.nsteps) {\n                this.fastForward(resolve, reject);\n            }\n            else {\n                let runnerTimer = undefined;\n                for (const id in this.$AsyncListeners) {\n                    const listener = this.$AsyncListeners[id];\n                    this.addListener(id, listener.type, () => {\n                        clearTimeout(runnerTimer);\n                        listener.handler(resolve, reject);\n                    });\n                }\n                if (this.isRunning()) {\n                    this.setStatus(\"running\");\n                    runnerTimer = setTimeout(() => this.stepForward(resolve, reject), this.getAnimationSpeed() * 1.1);\n                }\n            }\n        });\n    }\n    getMessage(message, ...args) {\n        if (Array.isArray(message))\n            [message, ...args] = [...message, ...args];\n        if (typeof message !== \"string\") {\n            if (args.length > 0)\n                console.error(\"Unknown message:\", message, ...args);\n            return message;\n        }\n        if (!message)\n            return args.join(\"\\n\");\n        let title = this.messages || this.constructor.messages || {};\n        const keys = message.split(\".\");\n        if (!(keys[0] in title))\n            return [message, ...args].join(\"\\n\");\n        for (const key of keys) {\n            if (!(typeof title === \"object\" && key in title)) {\n                console.error(\"Unknown message:\", message, ...args);\n                return [message, ...args].join(\"\\n\");\n            }\n            title = title[key];\n        }\n        if (typeof title === \"function\")\n            title = title(...args);\n        if (Array.isArray(title))\n            title = title.join(\"\\n\");\n        if (typeof title === \"object\") {\n            console.error(\"Unknown message:\", message, ...args);\n            return [message, ...args].join(\"\\n\");\n        }\n        if (title === \"\")\n            title = NBSP;\n        return title;\n    }\n    stepForward(resolve, reject) {\n        this.CurrentStep++;\n        this.State.animating = true;\n        resolve(undefined);\n    }\n    fastForward(resolve, reject) {\n        const action = this.actions[this.CurrentAction];\n        if (this.CurrentStep >= action.nsteps) {\n            action.nsteps = this.CurrentStep;\n        }\n        this.CurrentStep++;\n        this.State.animating = false;\n        if (this.DEBUG)\n            setTimeout(resolve, 10);\n        else\n            resolve(undefined);\n    }\n    isRunning() {\n        var _a;\n        return ((_a = this.toolbar.toggleRunner) === null || _a === void 0 ? void 0 : _a.classList.contains(\"selected\")) || false;\n    }\n    setRunning(running) {\n        var _a;\n        const classes = (_a = this.toolbar.toggleRunner) === null || _a === void 0 ? void 0 : _a.classList;\n        if (classes === undefined)\n            throw new Error(\"Can not access toggleRunner\");\n        if (running)\n            classes.add(\"selected\");\n        else\n            classes.remove(\"selected\");\n        return this;\n    }\n    toggleRunner() {\n        return this.setRunning(!this.isRunning());\n    }\n    loadCookies() {\n        if (this.DEBUG)\n            console.log(\"Loading cookies\", document.cookie);\n        const allCookies = document.cookie.split(\";\");\n        for (const cookieName in this.$Cookies) {\n            for (const cookie of allCookies) {\n                const [cookieName0, value0] = cookie.split(\"=\", 2);\n                if (cookieName0.trim() === cookieName) {\n                    const value = decodeURIComponent(value0);\n                    this.$Cookies[cookieName].getCookie(value);\n                    break;\n                }\n            }\n        }\n    }\n    saveCookies() {\n        let expires = \"\";\n        if (this.$CookieExpireDays > 0) {\n            const exdate = new Date();\n            exdate.setDate(exdate.getDate() + this.$CookieExpireDays);\n            expires = `;expires=${exdate.toUTCString()}`;\n        }\n        for (const cookieName in this.$Cookies) {\n            const value = encodeURIComponent(this.$Cookies[cookieName].setCookie());\n            document.cookie = `${cookieName}=${value}${expires}`;\n        }\n        if (this.DEBUG)\n            console.log(\"Setting cookies\", document.cookie);\n    }\n    animate(elem, animate = true) {\n        if (this.State.animating && animate) {\n            this.setStatus(\"running\");\n            this.setStatus(\"paused\", this.getAnimationSpeed());\n            return elem.animate(this.getAnimationSpeed(), 0, \"now\");\n        }\n        else {\n            return elem;\n        }\n    }\n}\nfunction normalizeNumber(input) {\n    input = input.trim();\n    return input === \"\" || isNaN(Number(input)) ? input : Number(input);\n}\nfunction parseValues(values) {\n    if (!values)\n        return [];\n    if (typeof values === \"string\") {\n        values = values.trim().split(/\\s+/);\n    }\n    return values.map((v) => normalizeNumber(v));\n}\nfunction addReturnSubmit(field, allowed, action) {\n    allowed =\n        allowed === \"int\"\n            ? \"0-9\"\n            : allowed === \"int+\"\n                ? \"0-9 \"\n                : allowed === \"float\"\n                    ? \"-.0-9\"\n                    : allowed === \"float+\"\n                        ? \"-.0-9 \"\n                        : allowed === \"ALPHA\"\n                            ? \"A-Z\"\n                            : allowed === \"ALPHA+\"\n                                ? \"A-Z \"\n                                : allowed === \"alpha\"\n                                    ? \"a-zA-Z\"\n                                    : allowed === \"alpha+\"\n                                        ? \"a-zA-Z \"\n                                        : allowed === \"ALPHANUM\"\n                                            ? \"A-Z0-9\"\n                                            : allowed === \"ALPHANUM+\"\n                                                ? \"A-Z0-9 \"\n                                                : allowed === \"alphanum\"\n                                                    ? \"a-zA-Z0-9\"\n                                                    : allowed === \"alphanum+\"\n                                                        ? \"a-zA-Z0-9 \"\n                                                        : allowed;\n    const regex = new RegExp(`[^${allowed}]`, \"g\");\n    const transform = allowed === allowed.toUpperCase()\n        ? (s) => s.toUpperCase()\n        : allowed === allowed.toLowerCase()\n            ? (s) => s.toLowerCase()\n            : (s) => s;\n    field.oninput = (event) => {\n        let pos = field.selectionStart || 0;\n        let value = transform(field.value);\n        if (regex.test(value)) {\n            value = value.replace(regex, \"\");\n            pos--;\n        }\n        field.value = value;\n        field.setSelectionRange(pos, pos);\n    };\n    if (action) {\n        field.onkeydown = (event) => {\n            if (event.key === \"Enter\") {\n                event.preventDefault();\n                action();\n            }\n        };\n    }\n}\nfunction updateDefault(obj, defaultObj, override = false) {\n    for (const key in defaultObj) {\n        if (!(key in obj)) {\n            obj[key] = defaultObj[key];\n        }\n        else if (typeof obj[key] === \"object\" &&\n            obj[key] !== null &&\n            typeof defaultObj[key] === \"object\" &&\n            defaultObj[key] !== null) {\n            updateDefault(obj[key], defaultObj[key], override);\n        }\n        else if (override) {\n            obj[key] = defaultObj[key];\n        }\n    }\n}\nfunction modulo(n, d) {\n    const rem = n % d;\n    return rem < 0 ? rem + d : rem;\n}\nconst NBSP = \"\\u00A0\";\nfunction compare(a, b) {\n    if (a === NBSP)\n        a = \"\";\n    if (b === NBSP)\n        b = \"\";\n    if (isNaN(Number(a)) === isNaN(Number(b))) {\n        if (!isNaN(Number(a))) {\n            a = Number(a);\n            b = Number(b);\n        }\n        return a === b ? 0 : a < b ? -1 : 1;\n    }\n    else {\n        return isNaN(Number(a)) ? 1 : -1;\n    }\n}\n\n;// ./src/trees/BST.ts\nvar BST_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nclass BST extends Engine {\n    constructor(containerSelector) {\n        super(containerSelector);\n        this.messages = BSTMessages;\n        this.initialValues = [];\n        this.treeRoot = null;\n        this.toolbar = this.getToolbar();\n    }\n    getToolbar() {\n        const toolbar = super.getToolbar();\n        toolbar.generalControls.insertAdjacentHTML(\"beforeend\", `<span class=\"formgroup\"><label>\r\n        <input class=\"showNullNodes\" type=\"checkbox\"/> Show null nodes\r\n       </label></span>`);\n        const showNullNodes = this.container.querySelector(\"input.showNullNodes\");\n        if (!showNullNodes)\n            throw new Error(\"Could not find show null nodes input\");\n        return Object.assign(Object.assign({}, toolbar), { showNullNodes });\n    }\n    initialise(initialValues = null) {\n        this.initialValues = parseValues(initialValues);\n        super.initialise();\n        return this;\n    }\n    resetAlgorithm() {\n        const _super = Object.create(null, {\n            resetAlgorithm: { get: () => super.resetAlgorithm }\n        });\n        return BST_awaiter(this, void 0, void 0, function* () {\n            yield _super.resetAlgorithm.call(this);\n            this.treeRoot = null;\n            if (this.initialValues) {\n                this.State.resetting = true;\n                yield this.insert(...this.initialValues);\n                this.State.resetting = false;\n            }\n        });\n    }\n    initToolbar() {\n        super.initToolbar();\n        this.toolbar.showNullNodes.addEventListener(\"change\", () => this.toggleNullNodes(null));\n        this.toggleNullNodes(true);\n    }\n    toggleNullNodes(show) {\n        if (show == null)\n            show = this.toolbar.showNullNodes.checked;\n        this.toolbar.showNullNodes.checked = show;\n        if (show)\n            this.Svg.addClass(\"shownullnodes\");\n        else\n            this.Svg.removeClass(\"shownullnodes\");\n        return this;\n    }\n    newNode(text) {\n        return this.Svg.binaryNode(text, ...this.getNodeStart(), this.getObjectSize(), this.getStrokeWidth());\n    }\n    resizeTree() {\n        var _a;\n        const animate = !this.State.resetting;\n        (_a = this.treeRoot) === null || _a === void 0 ? void 0 : _a.resize(...this.getTreeRoot(), this.$Svg.margin, this.getNodeSpacing(), animate ? this.$Svg.animationSpeed : 0);\n        return this;\n    }\n    insert(...values) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            for (const val of values)\n                yield this.insertOne(val);\n        });\n    }\n    find(value) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            if (!this.treeRoot) {\n                yield this.pause(\"general.empty\");\n                return { success: false, node: null };\n            }\n            yield this.pause(\"find.start\", value);\n            const found = yield this.findHelper(value);\n            (_a = found.node) === null || _a === void 0 ? void 0 : _a.setHighlight(true);\n            const path = found.success ? \"find.found\" : \"find.notfound\";\n            yield this.pause(path, value);\n            (_b = found.node) === null || _b === void 0 ? void 0 : _b.setHighlight(false);\n            return found;\n        });\n    }\n    findHelper(value) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            let parent = null;\n            let node = this.treeRoot;\n            const pointer = this.Svg.highlightCircle((node === null || node === void 0 ? void 0 : node.cx()) || 0, (node === null || node === void 0 ? void 0 : node.cy()) || 0, this.getObjectSize(), this.getStrokeWidth());\n            while (node) {\n                node.setHighlight(true);\n                const cmp = compare(value, node.getText());\n                if (cmp === 0) {\n                    pointer.remove();\n                    node.setHighlight(false);\n                    return { success: true, node: node };\n                }\n                const direction = cmp < 0 ? \"left\" : \"right\";\n                node.setChildHighlight(direction, true);\n                parent = node;\n                node = parent.getChild(direction);\n                if (node)\n                    pointer.setCenter(node.cx(), node.cy(), this.getAnimationSpeed());\n                yield this.pause(\"find.look\", direction);\n                parent.setChildHighlight(direction, false);\n            }\n            pointer.remove();\n            return { success: false, node: parent };\n        });\n    }\n    insertOne(value) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d, _e, _f;\n            if (!this.treeRoot) {\n                this.treeRoot = this.newNode(value);\n                yield this.pause(\"insert.newroot\", value);\n                this.resizeTree();\n                yield this.pause(undefined);\n                return { success: true, node: this.treeRoot };\n            }\n            yield this.pause(\"insert.search\", value);\n            const found = yield this.findHelper(value);\n            if (found.success) {\n                (_a = found.node) === null || _a === void 0 ? void 0 : _a.setHighlight(true);\n                yield this.pause(\"insert.exists\", found.node);\n                (_b = found.node) === null || _b === void 0 ? void 0 : _b.setHighlight(false);\n                return { success: false, node: found.node };\n            }\n            const child = this.newNode(value);\n            const cmp = compare(value, ((_c = found.node) === null || _c === void 0 ? void 0 : _c.getText()) || \"\");\n            const direction = cmp < 0 ? \"left\" : \"right\";\n            (_d = found.node) === null || _d === void 0 ? void 0 : _d.setChild(direction, child, this.getStrokeWidth());\n            child.setHighlight(true);\n            (_e = found.node) === null || _e === void 0 ? void 0 : _e.setChildHighlight(direction, true);\n            yield this.pause(\"insert.child\", value, direction);\n            (_f = found.node) === null || _f === void 0 ? void 0 : _f.setChildHighlight(direction, false);\n            child.setHighlight(false);\n            this.resizeTree();\n            yield this.pause(undefined);\n            return { success: true, node: child };\n        });\n    }\n    delete(value) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d;\n            if (!this.treeRoot) {\n                yield this.pause(\"general.empty\");\n                return null;\n            }\n            yield this.pause(\"delete.search\", value);\n            const found = yield this.findHelper(value);\n            if (!found.success) {\n                (_a = found.node) === null || _a === void 0 ? void 0 : _a.setHighlight(true);\n                yield this.pause(\"delete.notexists\", value);\n                (_b = found.node) === null || _b === void 0 ? void 0 : _b.setHighlight(false);\n                const direction = compare(value, ((_c = found.node) === null || _c === void 0 ? void 0 : _c.getText()) || \"\") < 0 ? \"left\" : \"right\";\n                return { success: false, direction: direction, parent: found.node };\n            }\n            (_d = found.node) === null || _d === void 0 ? void 0 : _d.setHighlight(true);\n            yield this.pause(\"delete.found\", value);\n            return yield this.deleteHelper(found.node);\n        });\n    }\n    deleteHelper(node) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            if (!((node === null || node === void 0 ? void 0 : node.getLeft()) && (node === null || node === void 0 ? void 0 : node.getRight()))) {\n                return yield this.deleteNode(node);\n            }\n            const pointer = this.Svg.highlightCircle(node.cx(), node.cy(), this.getObjectSize(), this.getStrokeWidth());\n            node.setHighlight(false);\n            node.addClass(\"marked\");\n            yield this.pause(\"delete.predecessor.search\", node);\n            let predecessor = node.getLeft();\n            while (true) {\n                predecessor === null || predecessor === void 0 ? void 0 : predecessor.setParentHighlight(true);\n                pointer.setCenter((predecessor === null || predecessor === void 0 ? void 0 : predecessor.cx()) || 0, (predecessor === null || predecessor === void 0 ? void 0 : predecessor.cy()) || 0, this.getAnimationSpeed());\n                yield this.pause(undefined);\n                predecessor === null || predecessor === void 0 ? void 0 : predecessor.setParentHighlight(false);\n                if (!(predecessor === null || predecessor === void 0 ? void 0 : predecessor.getRight()))\n                    break;\n                predecessor = predecessor.getRight();\n            }\n            predecessor === null || predecessor === void 0 ? void 0 : predecessor.setHighlight(true);\n            pointer.remove();\n            const newText = predecessor === null || predecessor === void 0 ? void 0 : predecessor.getText();\n            const moving = this.Svg.textCircle(newText || \"\", (predecessor === null || predecessor === void 0 ? void 0 : predecessor.cx()) || 0, (predecessor === null || predecessor === void 0 ? void 0 : predecessor.cy()) || 0, this.getObjectSize(), this.getStrokeWidth());\n            moving.addClass(\"unfilled\");\n            moving.setHighlight(true);\n            yield this.pause(\"delete.predecessor.replace\", node, predecessor);\n            moving.setCenter(node.cx(), node.cy(), this.getAnimationSpeed());\n            node.setText(\"\");\n            yield this.pause(undefined);\n            node.setText(newText || \"\");\n            moving.remove();\n            node.removeClass(\"marked\");\n            yield this.pause(\"delete.predecessor.delete\", predecessor);\n            return yield this.deleteNode(predecessor);\n        });\n    }\n    deleteNode(node) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            const child = (node === null || node === void 0 ? void 0 : node.getLeft()) || (node === null || node === void 0 ? void 0 : node.getRight());\n            const parent = node === null || node === void 0 ? void 0 : node.getParent();\n            if (!parent) {\n                if (!child) {\n                    this.treeRoot = null;\n                    yield this.pause(\"delete.root.singleton\", node);\n                }\n                else {\n                    this.treeRoot = child;\n                    yield this.pause(\"delete.root.onechild\", child, node);\n                }\n                node === null || node === void 0 ? void 0 : node.remove();\n                this.resizeTree();\n                yield this.pause(undefined);\n                return { success: true, direction: null, parent: null };\n            }\n            const direction = parent.getLeft() === node ? \"left\" : \"right\";\n            if (child) {\n                node === null || node === void 0 ? void 0 : node.setHighlight(false);\n                if (child === ((_a = parent.getLeft()) === null || _a === void 0 ? void 0 : _a.getLeft()))\n                    node === null || node === void 0 ? void 0 : node.dmoveCenter(-node.getSize(), -node.getSize() / 2, this.getAnimationSpeed());\n                if (child === ((_b = parent.getRight()) === null || _b === void 0 ? void 0 : _b.getRight()))\n                    node === null || node === void 0 ? void 0 : node.dmoveCenter(node.getSize(), -node.getSize() / 2, this.getAnimationSpeed());\n                parent.setChild(direction, child, this.getStrokeWidth());\n                child.setHighlight(true);\n                parent.setChildHighlight(direction, true);\n                yield this.pause(\"delete.redirect\", parent, child);\n                parent.setChildHighlight(direction, false);\n                child.setHighlight(false);\n                node === null || node === void 0 ? void 0 : node.setHighlight(true);\n                yield this.pause(\"delete.node\", node);\n            }\n            else {\n                yield this.pause(\"delete.leaf\", node);\n            }\n            node === null || node === void 0 ? void 0 : node.remove();\n            this.resizeTree();\n            yield this.pause(undefined);\n            return { success: true, direction: direction, parent: parent };\n        });\n    }\n    print() {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            var _a;\n            if (!this.treeRoot) {\n                yield this.pause(\"general.empty\");\n                return;\n            }\n            const { x, y } = ((_a = this.Info.printer) === null || _a === void 0 ? void 0 : _a.bbox()) || { x: 0, y: 0 };\n            const printed = [\n                this.Svg.text(\"Printed nodes: \").addClass(\"printer\").x(x).y(y),\n            ];\n            const pointer = this.Svg.highlightCircle(...this.getNodeStart(), this.getObjectSize(), this.getStrokeWidth());\n            yield this.printHelper(this.treeRoot, pointer, printed);\n            pointer.remove();\n            yield this.pause(undefined);\n            for (const lbl of printed)\n                lbl.remove();\n        });\n    }\n    printHelper(node, pointer, printed) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            pointer.setCenter(node.cx(), node.cy(), this.getAnimationSpeed());\n            yield this.pause(undefined);\n            if (node.getLeft()) {\n                yield this.printHelper(node.getLeft(), pointer, printed);\n                pointer.setCenter(node.cx(), node.cy(), this.getAnimationSpeed());\n                yield this.pause(undefined);\n            }\n            const lbl = this.Svg.text(node.getText()).center(node.cx(), node.cy());\n            yield this.pause(undefined);\n            const last = printed[printed.length - 1];\n            const spacing = this.getNodeSpacing() / 2;\n            this.animate(lbl)\n                .cy(last.cy())\n                .x(last.bbox().x2 + spacing);\n            printed.push(lbl);\n            yield this.pause(undefined);\n            if (node.getRight()) {\n                yield this.printHelper(node.getRight(), pointer, printed);\n                this.animate(pointer);\n                pointer.setCenter(node.cx(), node.cy(), this.getAnimationSpeed());\n                yield this.pause(undefined);\n            }\n        });\n    }\n    resetHeight(node) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n        });\n    }\n    doubleRotate(firstDir, node) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            const secondDir = firstDir === \"left\" ? \"right\" : \"left\";\n            const child = node.getChild(secondDir);\n            if (child === undefined || child === null)\n                throw new Error(\"Invalid B node in singleRotate\");\n            yield this.pause(\"rotate.zigzag\", child, secondDir, node, firstDir);\n            yield this.singleRotate(secondDir, child);\n            return yield this.singleRotate(firstDir, node);\n        });\n    }\n    singleRotate(firstDir, node) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            const secondDir = firstDir === \"left\" ? \"right\" : \"left\";\n            const A = node;\n            const B = A.getChild(secondDir);\n            if (B === undefined || B === null)\n                throw new Error(\"Invalid B node in singleRotate\");\n            const C = B.getChild(firstDir);\n            A.setChildHighlight(secondDir, true);\n            B === null || B === void 0 ? void 0 : B.setHighlight(true);\n            yield this.pause(\"rotate.single\", A, firstDir);\n            const parent = A.getParent();\n            if (parent) {\n                const direction = parent.getLeft() === A ? \"left\" : \"right\";\n                B === null || B === void 0 ? void 0 : B.setParent(direction, parent, this.getStrokeWidth());\n            }\n            else {\n                this.treeRoot = B;\n            }\n            A.setChild(secondDir, C, this.getStrokeWidth());\n            B.setChild(firstDir, A, this.getStrokeWidth());\n            B.setChildHighlight(firstDir, true);\n            A.setHighlight(true);\n            yield this.pause(undefined);\n            this.resizeTree();\n            yield this.pause(undefined);\n            B.setChildHighlight(firstDir, false);\n            A.setHighlight(false);\n            yield this.resetHeight(A);\n            yield this.resetHeight(B);\n            return B;\n        });\n    }\n}\nconst BSTMessages = {\n    general: {\n        empty: \"Tree is empty\",\n    },\n    find: {\n        start: (value) => `Searching for ${value}`,\n        found: (value) => `Found ${value}`,\n        notfound: (value) => `Did not find ${value}`,\n        look: (direction) => `Look into ${direction} child`,\n    },\n    insert: {\n        newroot: (value) => `Create a new tree root ${value}`,\n        search: (value) => `Searching for node to insert ${value}`,\n        exists: (node) => `There is already a node ${node}`,\n        child: (value, direction) => `Insert ${value} as ${direction} child`,\n    },\n    delete: {\n        search: (value) => `Searching for node to delete ${value}`,\n        notexists: (value) => `There is no node ${value}`,\n        found: (value) => `Found node ${value} to delete`,\n        predecessor: {\n            search: (node) => `Finding the predecessor node of ${node}`,\n            replace: (node, predecessor) => `Replace the value of ${node} with ${predecessor}`,\n            delete: (predecessor) => `Now delete the predecessor ${predecessor}`,\n        },\n        redirect: (parent, child) => `Redirect parent ${parent} to child ${child}`,\n        root: {\n            singleton: (root) => `Remove the root node ${root}`,\n            onechild: (child, root) => [\n                `Make the child ${child} the new root,`,\n                `and remove node ${root}`,\n            ],\n        },\n        node: (node) => `Remove node ${node}`,\n        leaf: (node) => `Remove leaf node ${node}`,\n    },\n    rotate: {\n        single: (node, dir) => `Rotate ${node} ${dir}`,\n        zigzag: (child, dir1, node, dir2) => `Zig-zag: Rotate ${child} ${dir1}, then rotate ${node} ${dir2}`,\n    },\n};\n\n;// ./src/trees/AVL.ts\nvar AVL_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nclass AVL extends BST {\n    constructor() {\n        super(...arguments);\n        this.messages = updateDefault(AVLmessages, BSTMessages);\n        this.treeRoot = null;\n        this.pointer = null;\n    }\n    newNode(text) {\n        return this.Svg.avlNode(text, ...this.getNodeStart(), this.getObjectSize(), this.getStrokeWidth());\n    }\n    getHeight(node) {\n        return node ? node.getHeight() : 0;\n    }\n    insertOne(value) {\n        const _super = Object.create(null, {\n            insertOne: { get: () => super.insertOne }\n        });\n        return AVL_awaiter(this, void 0, void 0, function* () {\n            const result = yield _super.insertOne.call(this, value);\n            if (result.success && result.node) {\n                result.node.updateHeightPosition();\n                yield this.updateHeights(result.node, undefined);\n                yield this.updateHeightPositions();\n            }\n            return result;\n        });\n    }\n    delete(value) {\n        const _super = Object.create(null, {\n            delete: { get: () => super.delete }\n        });\n        return AVL_awaiter(this, void 0, void 0, function* () {\n            const result = yield _super.delete.call(this, value);\n            if (result === null || result === void 0 ? void 0 : result.success) {\n                if (result.parent) {\n                    yield this.updateHeights(result.parent, result.direction);\n                }\n                yield this.updateHeightPositions();\n            }\n            return result;\n        });\n    }\n    updateHeightPositions() {\n        return AVL_awaiter(this, void 0, void 0, function* () {\n            this.Svg.find(\"g\").forEach((node) => {\n                if (node instanceof AVLNode)\n                    node.updateHeightPosition();\n            });\n        });\n    }\n    updateHeights(node, fromchild) {\n        return AVL_awaiter(this, void 0, void 0, function* () {\n            const child = (fromchild && node.getChild(fromchild)) || node;\n            this.pointer = this.Svg.highlightCircle(child.cx(), child.cy(), this.getObjectSize(), this.getStrokeWidth());\n            while (node) {\n                this.pointer.setCenter(node.cx(), node.cy(), this.getAnimationSpeed());\n                yield this.pause(\"node.updateHeight\");\n                const leftHeight = this.getHeight(node.getLeft()), rightHeight = this.getHeight(node.getRight());\n                const height = 1 + Math.max(leftHeight, rightHeight);\n                if (height !== this.getHeight(node)) {\n                    node.setHeightHighlight(true);\n                    node.setHeight(height);\n                    yield this.pause(undefined);\n                    node.setHeightHighlight(false);\n                }\n                node = yield this.rebalance(node);\n                node = node.getParent();\n            }\n            this.pointer.remove();\n        });\n    }\n    rebalance(node) {\n        return AVL_awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const leftHeight = this.getHeight(node.getLeft()), rightHeight = this.getHeight(node.getRight());\n            if (Math.abs(leftHeight - rightHeight) <= 1)\n                return node;\n            yield this.pause(\"node.unbalanced\");\n            const left = leftHeight < rightHeight ? \"left\" : \"right\";\n            const right = left === \"left\" ? \"right\" : \"left\";\n            const child = node.getChild(right);\n            const childLeft = this.getHeight(child === null || child === void 0 ? void 0 : child.getChild(left)), childRight = this.getHeight(child === null || child === void 0 ? void 0 : child.getChild(right));\n            (_a = this.pointer) === null || _a === void 0 ? void 0 : _a.hide();\n            if (childLeft <= childRight) {\n                node = (yield this.singleRotate(left, node));\n            }\n            else {\n                node = (yield this.doubleRotate(left, node));\n            }\n            this.pointer = this.Svg.highlightCircle(node.cx(), node.cy(), this.getObjectSize(), this.getStrokeWidth());\n            yield this.pause(\"node.balanced\");\n            return node;\n        });\n    }\n    resetHeight(node) {\n        return AVL_awaiter(this, void 0, void 0, function* () {\n            const height = 1 +\n                Math.max(this.getHeight(node.getLeft()), this.getHeight(node.getRight()));\n            if (height !== this.getHeight(node)) {\n                node.setHeight(height);\n            }\n        });\n    }\n}\nconst AVLmessages = {\n    node: {\n        updateHeight: \"Update node heights\",\n        unbalanced: \"Node is unbalanced!\",\n        balanced: \"Node is now balanced\",\n    },\n};\n\n;// ./src/trees/BTree.ts\nvar BTree_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nclass BTree extends Engine {\n    constructor(containerSelector) {\n        super(containerSelector);\n        this.initialValues = [];\n        this.treeRoot = null;\n        this.messages = BTreeMessages;\n        this.toolbar = this.getToolbar();\n    }\n    getToolbar() {\n        const toolbar = super.getToolbar();\n        this.toolbar.algorithmControls.insertAdjacentHTML(\"beforeend\", `<span class=\"formgroup\"><label>\r\n        Max degree:\r\n        <select class=\"maxDegree disableWhenRunning\">\r\n          <option value=\"3\">2/3-tree</option>\r\n          <option value=\"4\">2/3/4-tree</option>\r\n          <option value=\"5\">Max degree 5</option>\r\n          <option value=\"6\">Max degree 6</option>\r\n        </select>\r\n      </label></span>`);\n        const maxDegree = this.container.querySelector(\"select.maxDegree\");\n        if (!maxDegree)\n            throw new Error(\"Could not find max degree select element\");\n        return Object.assign(Object.assign({}, toolbar), { maxDegree });\n    }\n    initialise(initialValues = null) {\n        this.initialValues = parseValues(initialValues);\n        super.initialise();\n    }\n    resetAlgorithm() {\n        const _super = Object.create(null, {\n            resetAlgorithm: { get: () => super.resetAlgorithm }\n        });\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            yield _super.resetAlgorithm.call(this);\n            this.treeRoot = null;\n            if (this.initialValues) {\n                this.State.resetting = true;\n                yield this.insert(...this.initialValues);\n                this.State.resetting = false;\n            }\n        });\n    }\n    initToolbar() {\n        var _a;\n        super.initToolbar();\n        (_a = this.toolbar.maxDegree) === null || _a === void 0 ? void 0 : _a.addEventListener(\"change\", () => this.confirmResetAll());\n    }\n    getMaxDegree() {\n        var _a;\n        return parseInt(((_a = this.toolbar.maxDegree) === null || _a === void 0 ? void 0 : _a.value) || \"0\");\n    }\n    getMaxKeys() {\n        return this.getMaxDegree() - 1;\n    }\n    getMinKeys() {\n        return Math.floor((this.getMaxDegree() + 1) / 2) - 1;\n    }\n    getSplitIndex() {\n        return Math.floor((this.getMaxDegree() - 1) / 2);\n    }\n    resizeTree(svgMargin, nodeSpacing) {\n        var _a;\n        const animate = !this.State.resetting;\n        (_a = this.treeRoot) === null || _a === void 0 ? void 0 : _a.resize(...this.getTreeRoot(), svgMargin, nodeSpacing, animate ? this.getAnimationSpeed() : 0);\n    }\n    insert(...values) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            for (const val of values)\n                yield this.insertOne(val);\n        });\n    }\n    find(value) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            if (!this.treeRoot) {\n                yield this.pause(\"general.empty\");\n                return;\n            }\n            yield this.pause(\"find.start\", value);\n            const found = yield this.findHelper(value);\n            (_a = found.node) === null || _a === void 0 ? void 0 : _a.setHighlight(true);\n            const path = found.success ? \"find.found\" : \"find.notfound\";\n            yield this.pause(path, value);\n            (_b = found.node) === null || _b === void 0 ? void 0 : _b.setHighlight(false);\n        });\n    }\n    findHelper(value_1) {\n        return BTree_awaiter(this, arguments, void 0, function* (value, findLeaf = false) {\n            let parent = null;\n            let node = this.treeRoot;\n            const pointer = this.Svg.highlightCircle(...this.getNodeStart(), this.getObjectSize(), this.getStrokeWidth());\n            while (node) {\n                pointer.setCenter(node.getCX(0, this.getObjectSize()), node.cy(), this.getAnimationSpeed());\n                node.setHighlight(true);\n                yield this.pause(undefined);\n                let i = 0;\n                let cmpStr = String(value);\n                while (i < node.numValues()) {\n                    const txt = node.getText(i);\n                    const cmp = compare(value, txt);\n                    if (cmp === 0) {\n                        cmpStr = `${txt} = ${value}`;\n                        break;\n                    }\n                    else if (cmp < 0) {\n                        cmpStr = `${cmpStr} < ${txt}`;\n                        break;\n                    }\n                    cmpStr = `${txt} < ${value}`;\n                    i++;\n                }\n                const found = i < node.numValues() && compare(value, node.getText(i)) === 0;\n                pointer.setCenter(node.getCX(i - (found ? 0 : 0.5), this.getObjectSize()), node.cy(), this.getAnimationSpeed());\n                if (node.isLeaf() || (found && !findLeaf)) {\n                    yield this.pause(cmpStr);\n                    pointer.remove();\n                    node.setHighlight(false);\n                    return { success: found, node: node, i: i };\n                }\n                if (found)\n                    i++;\n                yield this.pause(`${cmpStr}: ${this.getMessage(\"node.lookNthChild\", this.getOrdinal(i, node.numChildren()))}`);\n                node.setHighlight(false);\n                parent = node;\n                node = parent.getChild(i);\n            }\n            pointer.remove();\n            return { success: false, node: parent, i: null };\n        });\n    }\n    insertOne(value) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            if (this.treeRoot) {\n                yield this.insertBottomup(value);\n            }\n            else {\n                this.treeRoot = this.Svg.bTreeNode(true, 1, ...this.getNodeStart(), this.getObjectSize(), this.getStrokeWidth());\n                this.treeRoot.setText(0, String(value));\n                yield this.pause(\"insert.newroot\", value);\n                this.resizeTree(this.$Svg.margin, this.getNodeSpacing());\n                yield this.pause(undefined);\n            }\n        });\n    }\n    insertBottomup(value) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            yield this.pause(\"insert.search\", value);\n            const found = yield this.findHelper(value);\n            const node = found.node;\n            if (!node)\n                return;\n            node.setHighlight(true);\n            if (found.success) {\n                yield this.pause(\"insert.exists\", found.node);\n                node.setHighlight(false);\n            }\n            else {\n                node.insertValue(found.i || 0, String(value), this.getObjectSize(), this.getStrokeWidth());\n                this.resizeTree(this.$Svg.margin, this.getNodeSpacing());\n                yield this.pause(\"insert.nth\", value, this.getOrdinal(found.i || 0, node === null || node === void 0 ? void 0 : node.numValues()));\n                node === null || node === void 0 ? void 0 : node.setHighlight(false);\n                yield this.insertRepair(node);\n                yield this.pause(undefined);\n            }\n        });\n    }\n    insertRepair(node) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            if (node.numValues() > this.getMaxKeys()) {\n                if (!node.getParent()) {\n                    this.treeRoot = yield this.split(node);\n                }\n                else {\n                    const newNode = yield this.split(node);\n                    yield this.insertRepair(newNode);\n                }\n            }\n        });\n    }\n    split(node) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            node.setHighlight(true);\n            yield this.pause(\"node.split\", node);\n            const parent = node.getParent();\n            const parentIndex = node.getParentIndex();\n            const risingValue = node.getText(this.getSplitIndex());\n            const rightSplit = this.getSplitIndex() + 1;\n            const risingX = node.getCX(rightSplit - 1, this.getObjectSize());\n            const risingNode = this.Svg.bTreeNode(false, 1, risingX, node.cy(), this.getObjectSize(), this.getStrokeWidth());\n            risingNode.setHighlight(true);\n            risingNode.setText(0, risingValue);\n            const rightValues = node.numValues() - rightSplit;\n            const rightX = node.getCX(rightSplit + rightValues / 2 - 0.5, this.getObjectSize());\n            const rightNode = this.Svg.bTreeNode(node.isLeaf(), rightValues, rightX, node.cy(), this.getObjectSize(), this.getStrokeWidth());\n            rightNode.setHighlight(true);\n            for (let i = rightSplit; i < node.numValues(); i++) {\n                const j = i - rightSplit;\n                rightNode.setText(j, node.getText(i));\n            }\n            if (!node.isLeaf()) {\n                for (let i = rightSplit; i < node.numChildren(); i++) {\n                    const j = i - rightSplit;\n                    rightNode.setChild(j, node.getChild(i), this.getStrokeWidth());\n                }\n            }\n            node.setNumValues(this.getSplitIndex(), this.getObjectSize(), this.getStrokeWidth());\n            risingNode.setChild(0, node, this.getStrokeWidth());\n            risingNode.setChild(1, rightNode, this.getStrokeWidth());\n            if (parent && parentIndex !== null) {\n                parent.setChild(parentIndex, risingNode, this.getStrokeWidth());\n                yield this.pause(undefined);\n                risingNode.setCenter(parent.getCX(parentIndex - 0.5, this.getObjectSize()), parent.cy(), this.getAnimationSpeed());\n                node.setHighlight(false);\n                rightNode.setHighlight(false);\n                yield this.pause(undefined);\n                parent.insertValue(parentIndex, risingValue, this.getObjectSize(), this.getStrokeWidth());\n                parent.setChild(parentIndex, node, this.getStrokeWidth());\n                parent.setChild(parentIndex + 1, rightNode, this.getStrokeWidth());\n                risingNode.remove();\n                this.resizeTree(this.$Svg.margin, this.getNodeSpacing());\n                return parent;\n            }\n            this.treeRoot = risingNode;\n            this.resizeTree(this.$Svg.margin, this.getNodeSpacing());\n            this.treeRoot.setHighlight(false);\n            node.setHighlight(false);\n            rightNode.setHighlight(false);\n            return this.treeRoot;\n        });\n    }\n    getOrdinal(i, n) {\n        if (n === 1) {\n            return \"only\";\n        }\n        else if (n <= 3) {\n            return i === 0 ? \"left\" : i === n - 1 ? \"right\" : \"middle\";\n        }\n        else {\n            return i === 0\n                ? \"first\"\n                : i === 1\n                    ? \"second\"\n                    : i === n - 1\n                        ? \"last\"\n                        : `${i}rd`;\n        }\n    }\n    print() {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            if (!this.treeRoot) {\n                yield this.pause(\"general.empty\");\n                return;\n            }\n            if (!this.Info.printer)\n                throw new Error(\"No info printer\");\n            const { x, y } = this.Info.printer.bbox();\n            const printed = [\n                this.Svg.text(\"Printed nodes: \").addClass(\"printer\").x(x).y(y),\n            ];\n            const pointer = this.Svg.highlightCircle(...this.getNodeStart(), this.getObjectSize(), this.getStrokeWidth());\n            yield this.printHelper(this.treeRoot, pointer, printed);\n            pointer.remove();\n            yield this.pause(undefined);\n            for (const lbl of printed)\n                lbl.remove();\n        });\n    }\n    printHelper(node, pointer, printed) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            if (node.isLeaf()) {\n                for (let i = 0; i < node.numValues(); i++) {\n                    pointer.setCenter(node.getCX(i, this.getObjectSize()), node.cy(), this.getAnimationSpeed());\n                    yield this.printOneLabel(node, i, printed);\n                }\n            }\n            else {\n                for (let i = 0; i < node.numChildren(); i++) {\n                    pointer.setCenter(node.getCX(i - 0.5, this.getObjectSize()), Number(node.y()) + Number(node.height()), this.getAnimationSpeed());\n                    yield this.pause(undefined);\n                    yield this.printHelper(node.getChild(i), pointer, printed);\n                    if (i < node.numValues()) {\n                        pointer.setCenter(node.getCX(i, this.getObjectSize()), node.cy(), this.getAnimationSpeed());\n                        yield this.printOneLabel(node, i, printed);\n                    }\n                    else {\n                        pointer.setCenter(node.getCX(i - 0.5, this.getObjectSize()), node.cy(), this.getAnimationSpeed());\n                        yield this.pause(undefined);\n                    }\n                }\n            }\n        });\n    }\n    printOneLabel(node, i, printed) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            const lbl = this.Svg.text(node.getText(i)).center(node.getCX(i, this.getObjectSize()), node.cy());\n            yield this.pause(undefined);\n            const last = printed[printed.length - 1];\n            const spacing = this.getNodeSpacing() / 2;\n            this.animate(lbl)\n                .cy(last.cy())\n                .x(last.bbox().x2 + spacing);\n            printed.push(lbl);\n            yield this.pause(undefined);\n        });\n    }\n    delete(value) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d, _e;\n            if (!this.treeRoot) {\n                yield this.pause(\"general.empty\");\n                return;\n            }\n            yield this.pause(\"delete.search\", value);\n            const found = yield this.findHelper(value);\n            if (!found.success) {\n                (_a = found.node) === null || _a === void 0 ? void 0 : _a.setHighlight(true);\n                yield this.pause(\"delete.notexists\", value);\n                (_b = found.node) === null || _b === void 0 ? void 0 : _b.setHighlight(false);\n                return;\n            }\n            (_c = found.node) === null || _c === void 0 ? void 0 : _c.setHighlight(true);\n            yield this.pause(\"delete.found\", value);\n            (_d = found.node) === null || _d === void 0 ? void 0 : _d.setHighlight(false);\n            if ((_e = found.node) === null || _e === void 0 ? void 0 : _e.isLeaf()) {\n                yield this.deleteLeaf(found.node, found.i || 0);\n            }\n            else {\n                yield this.deleteNonleaf(found.node, found.i || 0);\n            }\n            if (this.treeRoot.numValues() === 0) {\n                this.treeRoot.setHighlight(true);\n                yield this.pause(\"delete.root.empty\");\n                const newRoot = this.treeRoot.isLeaf() ? null : this.treeRoot.getLeft();\n                this.treeRoot.remove();\n                this.treeRoot = newRoot;\n                this.resizeTree(this.$Svg.margin, this.getNodeSpacing());\n            }\n        });\n    }\n    deleteLeaf(node, i) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            node.setHighlight(true);\n            yield this.pause(\"delete.leaf.nth\", node, this.getOrdinal(i, node.numValues()));\n            node.deleteValue(i, this.getObjectSize(), this.getStrokeWidth());\n            this.resizeTree(this.$Svg.margin, this.getNodeSpacing());\n            node.setHighlight(false);\n            yield this.repairAfterDelete(node);\n        });\n    }\n    deleteNonleaf(node, i) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            node.addClass(\"marked\");\n            const pointer = this.Svg.highlightCircle(node.getCX(i, this.getObjectSize()), node.cy(), this.getObjectSize(), this.getStrokeWidth());\n            yield this.pause(\"find.predecessor\", node.getText(i));\n            let maxNode = node.getChild(i);\n            let j;\n            while (true) {\n                j = ((maxNode === null || maxNode === void 0 ? void 0 : maxNode.numValues()) || 0) - 1;\n                pointer.setCenter((maxNode === null || maxNode === void 0 ? void 0 : maxNode.getCX(j, this.getObjectSize())) || 0, (maxNode === null || maxNode === void 0 ? void 0 : maxNode.cy()) || 0, this.getAnimationSpeed());\n                yield this.pause(undefined);\n                if (maxNode === null || maxNode === void 0 ? void 0 : maxNode.isLeaf())\n                    break;\n                maxNode = (maxNode === null || maxNode === void 0 ? void 0 : maxNode.getRight()) || null;\n            }\n            const maxValue = maxNode.getText(j);\n            const risingNode = this.Svg.bTreeNode(false, 1, maxNode.getCX(j, this.getObjectSize()), maxNode.cy(), this.getObjectSize(), this.getStrokeWidth());\n            risingNode.setHighlight(true);\n            risingNode.setText(0, maxValue);\n            yield this.pause(\"delete.replace\", node.getText(i), maxValue);\n            pointer.remove();\n            risingNode.setCenter(node.getCX(i, this.getObjectSize()), node.cy(), this.getAnimationSpeed());\n            node.setText(i, \"\");\n            yield this.pause(undefined);\n            node.setText(i, maxValue);\n            risingNode.remove();\n            node.removeClass(\"marked\");\n            maxNode.setHighlight(true);\n            yield this.pause(\"delete.leaf.value\", maxValue, maxNode);\n            yield this.deleteLeaf(maxNode, j);\n        });\n    }\n    repairAfterDelete(node) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            if (node.numValues() >= this.getMinKeys())\n                return;\n            const parent = node.getParent();\n            if (!parent)\n                return;\n            node.setHighlight(true);\n            yield this.pause(\"node.tooFew\", node);\n            const i = node.getParentIndex() || 0;\n            if (i > 0 &&\n                parent.getChild(i - 1) !== null &&\n                parent.getChild(i - 1).numValues() > this.getMinKeys()) {\n                yield this.stealFromLeft(node, i);\n            }\n            else if (i < parent.numValues() &&\n                parent.getChild(i + 1) !== null &&\n                parent.getChild(i + 1).numValues() > this.getMinKeys()) {\n                yield this.stealFromRight(node, i);\n            }\n            else if (i < parent.numChildren() - 1) {\n                const nextNode = yield this.mergeRight(node);\n                yield this.repairAfterDelete(nextNode.getParent());\n            }\n            else {\n                const nextNode = yield this.mergeRight(parent.getChild(i - 1));\n                yield this.repairAfterDelete(nextNode.getParent());\n            }\n        });\n    }\n    mergeRight(node) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            const parent = node.getParent();\n            const parentIndex = node.getParentIndex();\n            if (!parent || parentIndex === null)\n                throw new Error(\"Invalid parent\");\n            const parentValue = parent === null || parent === void 0 ? void 0 : parent.getText(parentIndex);\n            const rightSib = parent.getChild(parentIndex + 1);\n            node.setHighlight(true);\n            parent.setHighlight(true);\n            rightSib === null || rightSib === void 0 ? void 0 : rightSib.setHighlight(true);\n            yield this.pause(\"node.mergeRight\", node, parentValue, rightSib);\n            const sinkingNode = this.Svg.bTreeNode(false, 1, parent.getCX(parentIndex, this.getObjectSize()), parent.cy(), this.getObjectSize(), this.getStrokeWidth());\n            sinkingNode.setHighlight(true);\n            sinkingNode.setText(0, parentValue);\n            parent.setText(parentIndex, \"\");\n            const sinkingX = (Number(node.x()) + Number(node.width()) + Number(rightSib === null || rightSib === void 0 ? void 0 : rightSib.x())) / 2;\n            sinkingNode.setCenter(sinkingX, node.cy(), this.getAnimationSpeed());\n            node.setCenter(sinkingX - (this.getObjectSize() + Number(node.width())) / 2, node.cy(), this.getAnimationSpeed());\n            rightSib === null || rightSib === void 0 ? void 0 : rightSib.setCenter(sinkingX + (this.getObjectSize() + Number(rightSib.width())) / 2, node.cy(), this.getAnimationSpeed());\n            yield this.pause(undefined);\n            const nodeSize = node.numValues();\n            const textsToInsert = [parentValue].concat((rightSib === null || rightSib === void 0 ? void 0 : rightSib.getTexts()) || []);\n            node.setNumValues(nodeSize + textsToInsert.length, this.getObjectSize(), this.getStrokeWidth());\n            for (let i = 0; i < textsToInsert.length; i++) {\n                node.setText(nodeSize + i, textsToInsert[i]);\n                if (!node.isLeaf()) {\n                    node.setChild(nodeSize + i + 1, rightSib === null || rightSib === void 0 ? void 0 : rightSib.getChild(i), this.getStrokeWidth());\n                }\n            }\n            parent.deleteValue(parentIndex, this.getObjectSize(), this.getStrokeWidth(), false);\n            sinkingNode.remove();\n            rightSib === null || rightSib === void 0 ? void 0 : rightSib.remove();\n            this.resizeTree(this.$Svg.margin, this.getNodeSpacing());\n            yield this.pause(undefined);\n            node.setHighlight(false);\n            parent.setHighlight(false);\n            return node;\n        });\n    }\n    stealFromRight(node, parentIndex) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            const parent = node.getParent();\n            const rightSib = parent === null || parent === void 0 ? void 0 : parent.getChild(parentIndex + 1);\n            if (!parent || !rightSib)\n                throw new Error(\"Can not steal from right, missing parent or right sibling\");\n            node.setHighlight(true);\n            parent.setHighlight(true);\n            rightSib.setHighlight(true);\n            const leftValue = parent.getText(parentIndex);\n            const rightValue = rightSib.getText(0);\n            yield this.pause(\"node.steal.right\", node, leftValue, rightValue);\n            const leftNode = this.Svg.bTreeNode(false, 1, parent === null || parent === void 0 ? void 0 : parent.getCX(parentIndex, this.getObjectSize()), parent === null || parent === void 0 ? void 0 : parent.cy(), this.getObjectSize(), this.getStrokeWidth());\n            leftNode.setText(0, leftValue || \"\");\n            leftNode.setHighlight(true);\n            const rightNode = this.Svg.bTreeNode(false, 1, rightSib === null || rightSib === void 0 ? void 0 : rightSib.getCX(0, this.getObjectSize()), rightSib === null || rightSib === void 0 ? void 0 : rightSib.cy(), this.getObjectSize(), this.getStrokeWidth());\n            rightNode.setText(0, rightValue || \"\");\n            rightNode.setHighlight(true);\n            node.insertValue(node.numValues(), \"\", this.getObjectSize(), this.getStrokeWidth());\n            parent.setText(parentIndex, \"\");\n            rightSib.setText(0, \"\");\n            leftNode.setCenter(node.getCX(node.numValues() - 1, this.getObjectSize()), node.cy(), this.getAnimationSpeed());\n            rightNode.setCenter(parent.getCX(parentIndex, this.getObjectSize()), parent.cy(), this.getAnimationSpeed());\n            if (!node.isLeaf())\n                node.setChild(node.numChildren() - 1, rightSib.getChild(0), this.getStrokeWidth());\n            yield this.pause(undefined);\n            leftNode.remove();\n            rightNode.remove();\n            rightSib.deleteValue(0, this.getObjectSize(), this.getStrokeWidth());\n            parent.setText(parentIndex, rightValue);\n            node.setText(node.numValues() - 1, leftValue);\n            this.resizeTree(this.$Svg.margin, this.getNodeSpacing());\n            yield this.pause(undefined);\n            node.setHighlight(false);\n            parent.setHighlight(false);\n            rightSib.setHighlight(false);\n            return node;\n        });\n    }\n    stealFromLeft(node, parentIndex) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            parentIndex--;\n            const parent = node.getParent();\n            const leftSib = parent === null || parent === void 0 ? void 0 : parent.getChild(parentIndex);\n            if (!parent || !leftSib)\n                throw new Error(\"Can not steal from left, missing parent or left sibling\");\n            node.setHighlight(true);\n            parent.setHighlight(true);\n            leftSib.setHighlight(true);\n            const rightValue = parent.getText(parentIndex);\n            const leftValue = leftSib.getText(leftSib.numValues() - 1);\n            yield this.pause(\"node.steal.left\", node, leftValue, rightValue);\n            const rightNode = this.Svg.bTreeNode(false, 1, parent.getCX(parentIndex, this.getObjectSize()), parent.cy(), this.getObjectSize(), this.getStrokeWidth());\n            rightNode.setText(0, rightValue);\n            rightNode.setHighlight(true);\n            const leftNode = this.Svg.bTreeNode(false, 1, leftSib.getCX(leftSib.numValues() - 1, this.getObjectSize()), leftSib.cy(), this.getObjectSize(), this.getStrokeWidth());\n            leftNode.setText(0, leftValue);\n            leftNode.setHighlight(true);\n            node.insertValue(0, \"\", this.getObjectSize(), this.getStrokeWidth(), true);\n            parent.setText(parentIndex, \"\");\n            leftSib.setText(leftSib.numValues() - 1, \"\");\n            rightNode.setCenter(node.getCX(0, this.getObjectSize()), node.cy(), this.getAnimationSpeed());\n            leftNode.setCenter(parent.getCX(parentIndex, this.getObjectSize()), parent.cy(), this.getAnimationSpeed());\n            if (!node.isLeaf())\n                node.setChild(0, leftSib.getChild(leftSib.numChildren() - 1), this.getStrokeWidth());\n            yield this.pause(undefined);\n            rightNode.remove();\n            leftNode.remove();\n            leftSib.deleteValue(leftSib.numValues() - 1, this.getObjectSize(), this.getStrokeWidth(), false);\n            parent.setText(parentIndex, leftValue);\n            node.setText(0, rightValue);\n            this.resizeTree(this.$Svg.margin, this.getNodeSpacing());\n            yield this.pause(undefined);\n            node.setHighlight(false);\n            parent.setHighlight(false);\n            leftSib.setHighlight(false);\n            return node;\n        });\n    }\n}\nconst BTreeMessages = {\n    find: {\n        predecessor: (val) => `Find the predecessor value of ${val}`,\n    },\n    insert: {\n        nth: (val, nth) => `Insert ${val} as ${nth} value in the node`,\n    },\n    delete: {\n        root: {\n            empty: \"Remove empty tree root\",\n        },\n        leaf: {\n            nth: (leaf, nth) => `Delete the ${nth} value in leaf ${leaf}`,\n            value: (val, leaf) => `Now delete ${val} in the leaf node ${leaf}`,\n        },\n        replace: (val, newVal) => `Replace the value ${val} with ${newVal}`,\n    },\n    node: {\n        lookNthChild: (nth) => `Look into ${nth} child`,\n        split: (node) => `Splitting node ${node}`,\n        tooFew: (node) => `Node ${node} has too few values`,\n        mergeRight: (node, parent, rightSib) => [\n            \"Merging nodes:\",\n            `${node} + [${parent}] + ${rightSib}`,\n        ],\n        steal: {\n            right: (node, left, right) => [\n                \"Stealing from right sibling:\",\n                `${node} ← [${left}] ← [${right}]`,\n            ],\n            left: (node, left, right) => [\n                \"Stealing from left sibling:\",\n                `[${left}] → [${right}] → ${node}`,\n            ],\n        },\n    },\n};\n\n;// ./src/trees/RedBlack.ts\nvar RedBlack_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nclass RedBlack extends BST {\n    constructor() {\n        super(...arguments);\n        this.messages = Object.assign(Object.assign(Object.assign({}, BSTMessages), RedBlackMessages), { rotate: Object.assign(Object.assign({}, BSTMessages.rotate), RedBlackMessages.rotate) });\n    }\n    newNode(text) {\n        return super.newNode(text).addClass(\"red\");\n    }\n    insertOne(value) {\n        const _super = Object.create(null, {\n            insertOne: { get: () => super.insertOne }\n        });\n        return RedBlack_awaiter(this, void 0, void 0, function* () {\n            const result = yield _super.insertOne.call(this, value);\n            if ((result === null || result === void 0 ? void 0 : result.success) && result.node) {\n                yield this.fixDoubleRed(result.node);\n                if (this.treeRoot && this.isRed(this.treeRoot)) {\n                    yield this.pause(\"color.redRootBlack\");\n                    this.colorBlack(this.treeRoot);\n                }\n            }\n            return result;\n        });\n    }\n    fixDoubleRed(node) {\n        return RedBlack_awaiter(this, void 0, void 0, function* () {\n            let parent = node.getParent();\n            if (!parent)\n                return;\n            if (!this.isRed(parent))\n                return;\n            let grandparent = parent.getParent();\n            if (!grandparent)\n                return;\n            const pibling = parent.getSibling();\n            if (pibling && this.isRed(pibling)) {\n                node.setHighlight(true);\n                parent.setHighlight(true);\n                pibling.setHighlight(true);\n                yield this.pause(\"color.pushDownBlack\", node, parent, pibling);\n                node.setHighlight(false);\n                parent.setHighlight(false);\n                pibling.setHighlight(false);\n                this.colorBlack(pibling);\n                this.colorBlack(parent);\n                this.colorRed(grandparent);\n                yield this.pause(undefined);\n                yield this.fixDoubleRed(grandparent);\n                return;\n            }\n            let side = node.isLeftChild() ? \"left\" : \"right\";\n            let rotate = parent.isLeftChild() ? \"left\" : \"right\";\n            if (side !== rotate) {\n                node.setHighlight(true);\n                parent.setHighlight(true);\n                grandparent.setHighlight(true);\n                yield this.pause(\"rotate.parent\", node, side, rotate, parent),\n                    node.setHighlight(false);\n                parent.setHighlight(false);\n                grandparent.setHighlight(false);\n                node = (yield this.singleRotate(rotate, parent)).getChild(rotate);\n            }\n            side = node.isLeftChild() ? \"left\" : \"right\";\n            rotate = side === \"left\" ? \"right\" : \"left\";\n            parent = node.getParent();\n            grandparent = (parent === null || parent === void 0 ? void 0 : parent.getParent()) || null;\n            if (!parent || !grandparent)\n                throw new Error(\"Missing parent or grandparent\");\n            node.setHighlight(true);\n            parent.setHighlight(true);\n            grandparent === null || grandparent === void 0 ? void 0 : grandparent.setHighlight(true);\n            yield this.pause(\"rotate.grandparent\", node, side, grandparent, rotate);\n            node.setHighlight(false);\n            parent.setHighlight(false);\n            grandparent === null || grandparent === void 0 ? void 0 : grandparent.setHighlight(false);\n            this.colorBlack(parent);\n            this.colorRed(grandparent);\n            yield this.singleRotate(rotate, grandparent);\n        });\n    }\n    delete(value) {\n        const _super = Object.create(null, {\n            delete: { get: () => super.delete }\n        });\n        return RedBlack_awaiter(this, void 0, void 0, function* () {\n            const result = yield _super.delete.call(this, value);\n            if (result === null || result === void 0 ? void 0 : result.success) {\n                if (result.parent && result.direction) {\n                    yield this.fixDeleteImbalance(result.parent, result.direction);\n                }\n                if (this.treeRoot && this.isRed(this.treeRoot)) {\n                    this.colorBlack(this.treeRoot);\n                    yield this.pause(\"color.rootBlack\");\n                }\n            }\n            return result;\n        });\n    }\n    fixDeleteImbalance(parent, dir) {\n        return RedBlack_awaiter(this, void 0, void 0, function* () {\n            const child = parent.getChild(dir);\n            if (child && this.isRed(child)) {\n                this.colorBlack(child);\n                child.setHighlight(true);\n                yield this.pause(\"color.nodeBlack\", child);\n                child.setHighlight(false);\n            }\n            else if (!parent.isLeaf()) {\n                yield this.fixDoubleBlack(parent, dir);\n            }\n        });\n    }\n    fixDoubleBlack(parent, left) {\n        return RedBlack_awaiter(this, void 0, void 0, function* () {\n            const right = left === \"left\" ? \"right\" : \"left\";\n            const rightChild = parent.getChild(right);\n            const rightGrandchild = rightChild === null || rightChild === void 0 ? void 0 : rightChild.getChild(right);\n            const leftGrandchild = rightChild === null || rightChild === void 0 ? void 0 : rightChild.getChild(left);\n            parent.setHighlight(true);\n            yield this.pause(\"balancing.parentImbalanced\", parent);\n            if (rightChild && this.isRed(rightChild)) {\n                parent.setChildHighlight(right, true);\n                rightChild.setHighlight(true);\n                yield this.pause(\"rotate.redSibling\", parent, right, rightChild, left);\n                parent.setChildHighlight(right, false);\n                rightChild.setHighlight(false);\n                this.colorBlack(rightChild);\n                this.colorRed(parent);\n                yield this.singleRotate(left, parent);\n                yield this.fixDoubleBlack(parent, left);\n                return;\n            }\n            if (rightGrandchild && this.isRed(rightGrandchild)) {\n                parent.setChildHighlight(right, true);\n                rightChild === null || rightChild === void 0 ? void 0 : rightChild.setChildHighlight(right, true);\n                rightGrandchild.setHighlight(true);\n                yield this.pause(\"rotate.redDistantChild\", right, rightChild, left);\n                parent.setChildHighlight(right, false);\n                rightChild === null || rightChild === void 0 ? void 0 : rightChild.setChildHighlight(right, false);\n                rightGrandchild.setHighlight(false);\n                if (this.isBlack(parent))\n                    this.colorBlack(rightChild);\n                else\n                    this.colorRed(rightChild);\n                this.colorBlack(parent);\n                this.colorBlack(rightGrandchild);\n                yield this.singleRotate(left, parent);\n                return;\n            }\n            if (rightChild && leftGrandchild && this.isRed(leftGrandchild)) {\n                parent.setChildHighlight(right, true);\n                rightChild.setChildHighlight(left, true);\n                leftGrandchild.setHighlight(true);\n                yield this.pause(\"rotate.redCloseChild\", right, rightChild, left);\n                parent.setChildHighlight(right, false);\n                rightChild.setChildHighlight(left, false);\n                leftGrandchild.setHighlight(false);\n                this.colorRed(rightChild);\n                this.colorBlack(leftGrandchild);\n                yield this.singleRotate(right, rightChild);\n                yield this.fixDoubleBlack(parent, left);\n                return;\n            }\n            if (this.isRed(parent)) {\n                parent.setChildHighlight(right, true);\n                rightChild === null || rightChild === void 0 ? void 0 : rightChild.setHighlight(true);\n                yield this.pause(\"color.switch\", parent, right, rightChild);\n                parent.setChildHighlight(right, false);\n                rightChild === null || rightChild === void 0 ? void 0 : rightChild.setHighlight(false);\n                this.colorBlack(parent);\n                this.colorRed(rightChild);\n                return;\n            }\n            parent.setChildHighlight(right, true);\n            rightChild === null || rightChild === void 0 ? void 0 : rightChild.setHighlight(true);\n            yield this.pause(\"color.childRed\", parent, right, rightChild);\n            parent.setChildHighlight(right, false);\n            rightChild === null || rightChild === void 0 ? void 0 : rightChild.setHighlight(false);\n            this.colorRed(rightChild);\n            const grandparent = parent.getParent();\n            if (grandparent) {\n                const direction = parent === grandparent.getLeft() ? \"left\" : \"right\";\n                yield this.fixDoubleBlack(grandparent, direction);\n            }\n        });\n    }\n    isBlack(node) {\n        return !node || node.hasClass(\"black\");\n    }\n    isRed(node) {\n        return !this.isBlack(node);\n    }\n    colorBlack(node) {\n        node.addClass(\"black\");\n    }\n    colorRed(node) {\n        node.removeClass(\"black\");\n    }\n}\nconst RedBlackMessages = {\n    color: {\n        redRootBlack: \"Tree root is red: Color it black\",\n        rootBlack: \"Color the root black\",\n        nodeBlack: (n) => `Color node ${n} black`,\n        pushDownBlack: (node, parent, pibling) => [\n            `Node ${node}, parent ${parent} and parent's sibling ${pibling} are all red`,\n            \"Push blackness down from grandparent\",\n        ],\n        switch: (parent, dir, dirChild) => [\n            `Parent ${parent} is red,`,\n            `${dir} child ${dirChild} and its children are black:`,\n            \"Switch colors\",\n        ],\n        childRed: (parent, dir, dirChild) => [\n            `Parent ${parent}, ${dir} child ${dirChild} and its children are black:`,\n            `Color ${dir} child red`,\n        ],\n    },\n    balancing: {\n        parentImbalanced: (parent) => `Parent ${parent} is imbalanced`,\n    },\n    rotate: {\n        parent: (node, side, rotate, parent) => [\n            `Node ${node} is a red ${side} child of a red ${rotate} child`,\n            `Rotate parent ${parent} ${rotate}`,\n        ],\n        grandparent: (node, side, grandparent, rotate) => [\n            `Node ${node} is a red ${side} child of a red ${side} child`,\n            `Switch colors and rotate grandparent ${grandparent} ${rotate}`,\n        ],\n        redSibling: (parent, right, rightChild, left) => [\n            `Parent ${parent} is black, and its ${right} child ${rightChild} is red:`,\n            `Switch colors and rotate ${left}`,\n        ],\n        redDistantChild: (right, rightChild, left) => [\n            `${right} child ${rightChild} is black, its ${right} child is red:`,\n            `Switch colors and rotate ${left}`,\n        ],\n        redCloseChild: (right, rightChild, left) => [\n            `${right} child ${rightChild} is black, its ${left} child is red:`,\n            `Switch colors and rotate child ${right}`,\n        ],\n    },\n};\n\n;// ./src/trees/SplayTree.ts\nvar SplayTree_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nclass SplayTree extends BST {\n    constructor() {\n        super(...arguments);\n        this.messages = Object.assign(Object.assign(Object.assign({}, BSTMessages), SplayTreeMessages), { rotate: Object.assign(Object.assign({}, BSTMessages.rotate), SplayTreeMessages.rotate), delete: Object.assign(Object.assign({}, BSTMessages.delete), SplayTreeMessages.delete) });\n    }\n    find(value) {\n        const _super = Object.create(null, {\n            find: { get: () => super.find }\n        });\n        return SplayTree_awaiter(this, void 0, void 0, function* () {\n            const found = yield _super.find.call(this, value);\n            if (found === null || found === void 0 ? void 0 : found.node) {\n                yield this.splayUp(found.node);\n            }\n            return found;\n        });\n    }\n    insertOne(value) {\n        const _super = Object.create(null, {\n            insertOne: { get: () => super.insertOne }\n        });\n        return SplayTree_awaiter(this, void 0, void 0, function* () {\n            const result = yield _super.insertOne.call(this, value);\n            if (result === null || result === void 0 ? void 0 : result.node) {\n                if (!result.success)\n                    yield this.pause(\"insert.exists\", result.node);\n                yield this.splayUp(result.node);\n            }\n            return result;\n        });\n    }\n    delete(value) {\n        return SplayTree_awaiter(this, void 0, void 0, function* () {\n            var _a;\n            if (!this.treeRoot)\n                return { success: false, direction: null, parent: null };\n            yield this.find(value);\n            if (compare(value, (_a = this.treeRoot) === null || _a === void 0 ? void 0 : _a.getText()) !== 0) {\n                yield this.pause(\"delete.notexists\", value);\n                return { success: false, parent: null, direction: null };\n            }\n            this.treeRoot.setHighlight(true);\n            yield this.pause(\"delete.root\");\n            if (!(this.treeRoot.getLeft() && this.treeRoot.getRight())) {\n                const left = this.treeRoot.getLeft() ? \"left\" : \"right\";\n                const right = left === \"left\" ? \"right\" : \"left\";\n                const child = this.treeRoot.getLeft() || this.treeRoot.getRight();\n                const newRoot = child.setHighlight(true);\n                yield this.pause(\"delete.singleChild\", right, left);\n                this.treeRoot.remove();\n                this.treeRoot = newRoot;\n                this.resizeTree();\n                yield this.pause(undefined);\n                return { success: true, parent: this.treeRoot, direction: left };\n            }\n            const right = this.treeRoot.getRight();\n            const left = this.treeRoot.getLeft();\n            this.treeRoot.remove();\n            yield this.pause(\"delete.splayLargest\");\n            let largestLeft = left;\n            largestLeft.setHighlight(true);\n            yield this.pause(undefined);\n            if (largestLeft.getRight()) {\n                while (largestLeft.getRight()) {\n                    largestLeft.setHighlight(false);\n                    largestLeft = largestLeft.getRight();\n                    largestLeft.setHighlight(true);\n                    yield this.pause(undefined);\n                }\n            }\n            largestLeft.setHighlight(false);\n            yield this.splayUp(largestLeft);\n            yield this.pause(\"delete.connectLeftRight\");\n            largestLeft.setHighlight(true);\n            yield this.pause(undefined);\n            largestLeft.setHighlight(false);\n            largestLeft.setRight(right, this.getStrokeWidth());\n            this.treeRoot = largestLeft;\n            this.resizeTree();\n            yield this.pause(undefined);\n            return { success: true, parent: this.treeRoot, direction: null };\n        });\n    }\n    splayUp(node) {\n        return SplayTree_awaiter(this, void 0, void 0, function* () {\n            if (node === this.treeRoot)\n                return;\n            node.setHighlight(true);\n            yield this.pause(\"rotate.splayUp\", node);\n            node.setHighlight(false);\n            while (node.getParent()) {\n                const parent = node.getParent();\n                const left = node.isLeftChild() ? \"left\" : \"right\";\n                const right = left === \"left\" ? \"right\" : \"left\";\n                if (!parent.getParent()) {\n                    node = yield this.singleRotate(right, parent);\n                }\n                else if (parent.isChild(right)) {\n                    node = yield this.doubleRotate(left, parent.getParent());\n                }\n                else {\n                    node = yield this.zigZig(right, parent.getParent());\n                }\n            }\n        });\n    }\n    splayHelper(node) {\n        return SplayTree_awaiter(this, void 0, void 0, function* () {\n            const parent = node.getParent();\n            if (!parent)\n                return;\n            const left = node.isLeftChild() ? \"left\" : \"right\";\n            const right = left === \"left\" ? \"right\" : \"left\";\n            if (!(parent === null || parent === void 0 ? void 0 : parent.getParent())) {\n                this.singleRotate(left, parent);\n            }\n            else if (parent.isChild(right)) {\n                this.doubleRotate(left, parent.getParent());\n                this.splayHelper(node);\n            }\n            else {\n                this.zigZig(right, parent.getParent());\n                this.splayHelper(node);\n            }\n        });\n    }\n    zigZig(left, node) {\n        return SplayTree_awaiter(this, void 0, void 0, function* () {\n            const right = left === \"left\" ? \"right\" : \"left\";\n            const child = node.getChild(right);\n            if (!child)\n                return node;\n            yield this.pause(\"rotate.zigzig\", node, left, child);\n            yield this.singleRotate(left, node);\n            return yield this.singleRotate(left, child);\n        });\n    }\n}\nconst SplayTreeMessages = {\n    delete: {\n        root: \"Remove root, leaving left and right trees\",\n        singleChild: (right, left) => `No ${right} tree, make ${left} tree the root`,\n        splayLargest: \"Splay largest element in left tree to root\",\n        connectLeftRight: \"Left tree now has no right subtree, connect left and right trees\",\n    },\n    rotate: {\n        splayUp: (node) => `Now splaying ${node} up to the root`,\n        zigzig: (node, left, child) => `Zig-zig: Rotate ${node} ${left}, then rotate ${child} ${left}`,\n    },\n};\n\n;// ./src/collections.ts\n\n\n\n\n\n\nconst COLLECTIONS = {\n    BST: BST,\n    AVL: AVL,\n    RedBlack: RedBlack,\n    SplayTree: SplayTree,\n    BTree: BTree,\n};\ninitialiseCollections(\"#collectionsContainer\");\nfunction initialiseCollections(containerID) {\n    const algoSelector = document.querySelector(`${containerID} select.algorithmSelector`);\n    if (!algoSelector)\n        throw new Error(\"Could not find algo selector\");\n    algoSelector.addEventListener(\"change\", () => {\n        const searchParams = new URLSearchParams();\n        if (algoSelector.value in COLLECTIONS)\n            searchParams.set(\"algorithm\", algoSelector.value);\n        else\n            searchParams.delete(\"algorithm\");\n        if (CollectionEngine.DEBUG)\n            searchParams.set(\"debug\", \"true\");\n        else\n            searchParams.delete(\"debug\");\n        const url = `${window.location.pathname}?${searchParams}`;\n        window.history.replaceState(\"\", \"\", url);\n        window.location.reload();\n    });\n    let algo = new URL(window.location.href).searchParams.get(\"algorithm\");\n    if (!(algo && /^[\\w.]+$/.test(algo) && algo in COLLECTIONS)) {\n        algo = \"\";\n    }\n    const algoClass = algo;\n    algoSelector.value = algo;\n    const Collection = algoClass ? COLLECTIONS[algoClass] : Engine;\n    const CollectionEngine = new Collection(containerID);\n    CollectionEngine.initialise();\n    const toolbar = getCollectionsToolbar(CollectionEngine.container);\n    toolbar.insertSelect.addEventListener(\"change\", () => {\n        toolbar.insertField.value = toolbar.insertSelect.value;\n        toolbar.insertSelect.value = \"\";\n    });\n    addReturnSubmit(toolbar.insertField, \"ALPHANUM+\", () => CollectionEngine.submit(\"insert\", toolbar.insertField));\n    toolbar.insertSubmit.addEventListener(\"click\", () => {\n        CollectionEngine.submit(\"insert\", toolbar.insertField);\n    });\n    addReturnSubmit(toolbar.findField, \"ALPHANUM\", () => CollectionEngine.submit(\"find\", toolbar.findField));\n    toolbar.findSubmit.addEventListener(\"click\", () => CollectionEngine.submit(\"find\", toolbar.findField));\n    addReturnSubmit(toolbar.deleteField, \"ALPHANUM\", () => CollectionEngine.submit(\"delete\", toolbar.deleteField));\n    toolbar.deleteSubmit.addEventListener(\"click\", () => CollectionEngine.submit(\"delete\", toolbar.deleteField));\n    toolbar.printSubmit.addEventListener(\"click\", () => CollectionEngine.submit(\"print\", toolbar.printSubmit));\n    toolbar.clearSubmit.addEventListener(\"click\", () => CollectionEngine.confirmResetAll());\n}\nfunction getCollectionsToolbar(container) {\n    const insertSelect = container.querySelector(\"select.insertSelect\");\n    const insertField = container.querySelector(\"input.insertField\");\n    const insertSubmit = container.querySelector(\"input.insertSubmit\");\n    const findField = container.querySelector(\"input.findField\");\n    const findSubmit = container.querySelector(\"input.findSubmit\");\n    const deleteField = container.querySelector(\"input.deleteField\");\n    const deleteSubmit = container.querySelector(\"input.deleteSubmit\");\n    const printSubmit = container.querySelector(\"input.printSubmit\");\n    const clearSubmit = container.querySelector(\"input.clearSubmit\");\n    if (!insertSelect)\n        throw new Error(\"Missing insert select\");\n    if (!insertField)\n        throw new Error(\"Missing insert field\");\n    if (!insertSubmit)\n        throw new Error(\"Missing insert submit\");\n    if (!findField)\n        throw new Error(\"Missing find field\");\n    if (!findSubmit)\n        throw new Error(\"Missing find submit\");\n    if (!deleteField)\n        throw new Error(\"Missing delete field\");\n    if (!deleteSubmit)\n        throw new Error(\"Missing delete submit\");\n    if (!printSubmit)\n        throw new Error(\"Missing print submit\");\n    if (!clearSubmit)\n        throw new Error(\"Missing clear submit\");\n    return {\n        insertSelect,\n        insertField,\n        insertSubmit,\n        findField,\n        findSubmit,\n        deleteField,\n        deleteSubmit,\n        printSubmit,\n        clearSubmit,\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsT0FBTzs7QUFFZjtBQUNBOztBQUVBLFlBQVksbUJBQW1COztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLG1CQUFtQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksbUJBQW1COztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsT0FBTztBQUNmLFFBQVEsT0FBTzs7QUFFZjtBQUNBOztBQUVBLFlBQVksbUJBQW1COztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUN0T3NEO0FBQ2xCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixZQUFZOztBQUVqQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakIsV0FBVyxLQUFLO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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O0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkM7QUFDQSw0QkFBNEIsS0FBSztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQLEVBQUUsTUFBTTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxrQkFBUTtBQUNaOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLGtCQUFRO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEtBQUs7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUM3VjBEO0FBQ0w7QUFDRTtBQUNYO0FBQ2U7QUFDUDtBQUNGO0FBQ2Y7QUFDSDtBQUNnQjtBQUNWO0FBQzRCO0FBQzlCO0FBQ1E7QUFDVDs7QUFFckIscUJBQXFCLFdBQVc7QUFDL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLFFBQVE7O0FBRXhDO0FBQ0Esa0RBQWtELFVBQVU7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QyxVQUFVO0FBQ3ZELHdEQUF3RCxJQUFJOztBQUU1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DLHFCQUFxQixRQUFRO0FBQzdCOztBQUVBO0FBQ0EsOERBQThELE9BQU87QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLElBQUk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixJQUFJO0FBQ2pDLHVCQUF1QixJQUFJO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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LElBQUksS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUM7SUFDeEQsSUFBSSxDQUFDLFdBQVc7UUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUM7SUFDMUQsSUFBSSxDQUFDLFlBQVk7UUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHVCQUF1QixDQUFDLENBQUM7SUFDNUQsSUFBSSxDQUFDLFdBQVc7UUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUM7SUFDMUQsSUFBSSxDQUFDLFdBQVc7UUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUM7SUFFMUQsT0FBTztRQUNMLFlBQVk7UUFDWixXQUFXO1FBQ1gsWUFBWTtRQUNaLFNBQVM7UUFDVCxVQUFVO1FBQ1YsV0FBVztRQUNYLFlBQVk7UUFDWixXQUFXO1FBQ1gsV0FBVztLQUNaLENBQUM7QUFDSixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvdXRpbHMvbWV0aG9kcy5qcz80ZjE1Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3V0aWxzL3V0aWxzLmpzPzIwOWQiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9jb3JlL25hbWVzcGFjZXMuanM/MjU1NyIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy91dGlscy93aW5kb3cuanM/YjFkMiIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy90eXBlcy9CYXNlLmpzPzZlNDIiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvdXRpbHMvYWRvcHRlci5qcz8wMGZlIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvb3B0aW9uYWwvYXJyYW5nZS5qcz9hYWM4Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvY29yZS9yZWdleC5qcz9iY2Q2Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvb3B0aW9uYWwvY2xhc3MuanM/YmFjMiIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL29wdGlvbmFsL2Nzcy5qcz85NjFmIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvb3B0aW9uYWwvZGF0YS5qcz9mYzBhIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvb3B0aW9uYWwvbWVtb3J5LmpzP2NhZjQiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvdHlwZXMvQ29sb3IuanM/MDMyMCIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy90eXBlcy9Qb2ludC5qcz9kZDU0Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3R5cGVzL01hdHJpeC5qcz9mZWU2Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvY29yZS9wYXJzZXIuanM/NmM5ZSIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy90eXBlcy9Cb3guanM/NzhkZSIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy90eXBlcy9MaXN0LmpzP2U2NTMiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9jb3JlL3NlbGVjdG9yLmpzP2Y2NDYiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9jb3JlL2V2ZW50LmpzPzEyYTkiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvdHlwZXMvRXZlbnRUYXJnZXQuanM/YTJmYSIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL2NvcmUvZGVmYXVsdHMuanM/Y2UzMSIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy90eXBlcy9TVkdBcnJheS5qcz9kY2E3Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3R5cGVzL1NWR051bWJlci5qcz81NTBhIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvY29yZS9hdHRyLmpzP2UzM2EiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvRG9tLmpzP2I2OGMiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvRWxlbWVudC5qcz8zOWYyIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvb3B0aW9uYWwvc3VnYXIuanM/Njc0NSIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL29wdGlvbmFsL3RyYW5zZm9ybS5qcz85NDU2Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0NvbnRhaW5lci5qcz9kZjI0Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0RlZnMuanM/YjdkOSIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9TaGFwZS5qcz83ZmY5Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvY29yZS9jaXJjbGVkLmpzPzVkMjMiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvRWxsaXBzZS5qcz9mMzA2Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0ZyYWdtZW50LmpzPzVkYzEiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9jb3JlL2dyYWRpZW50ZWQuanM/ZmE4ZiIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9HcmFkaWVudC5qcz8yNWJjIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1BhdHRlcm4uanM/ZmY1MyIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9JbWFnZS5qcz8wYmU3Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3R5cGVzL1BvaW50QXJyYXkuanM/MmQxYiIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL2NvcmUvcG9pbnRlZC5qcz9mNzE2Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0xpbmUuanM/Zjg5YiIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9NYXJrZXIuanM/YjNhOCIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9hbmltYXRpb24vQ29udHJvbGxlci5qcz9mMzk2Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3V0aWxzL3BhdGhQYXJzZXIuanM/NGM1OCIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy90eXBlcy9QYXRoQXJyYXkuanM/MWZjYSIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9hbmltYXRpb24vTW9ycGhhYmxlLmpzPzc3MDEiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvUGF0aC5qcz8yMjA0Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvY29yZS9wb2x5LmpzP2ZmOTUiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvUG9seWdvbi5qcz9lZTg5Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1BvbHlsaW5lLmpzPzE2NDYiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvUmVjdC5qcz83NTcwIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2FuaW1hdGlvbi9RdWV1ZS5qcz85NzYwIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2FuaW1hdGlvbi9BbmltYXRvci5qcz8yMzdjIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2FuaW1hdGlvbi9UaW1lbGluZS5qcz9kODNkIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2FuaW1hdGlvbi9SdW5uZXIuanM/NDVhMSIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9TdmcuanM/MzYxYyIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9TeW1ib2wuanM/YjdkZSIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL2NvcmUvdGV4dGFibGUuanM/YmIwNCIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9UZXh0LmpzPzdmNDkiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvVHNwYW4uanM/NzdkNyIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9DaXJjbGUuanM/ODg4MyIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9DbGlwUGF0aC5qcz8wNTFjIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0ZvcmVpZ25PYmplY3QuanM/Y2MzZSIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL2NvcmUvY29udGFpbmVyR2VvbWV0cnkuanM/OTg2MiIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9HLmpzPzQ1NDIiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvQS5qcz9mNzljIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL01hc2suanM/NTNlNiIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9TdG9wLmpzPzE2NTYiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvU3R5bGUuanM/ZDI4MyIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9UZXh0UGF0aC5qcz85ZTE2Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1VzZS5qcz81MzY3Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21haW4uanM/MTM2MiIsIndlYnBhY2s6Ly9kc3Zpcy8uL3NyYy9vYmplY3RzL3RleHQtY2lyY2xlLnRzP2RhZDAiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9zcmMvb2JqZWN0cy9ncmFwaC1ub2RlLnRzP2NkOGEiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9zcmMvb2JqZWN0cy9iaW5hcnktbm9kZS50cz8xN2UwIiwid2VicGFjazovL2RzdmlzLy4vc3JjL29iamVjdHMvYXZsLW5vZGUudHM/ZWRmZSIsIndlYnBhY2s6Ly9kc3Zpcy8uL3NyYy9vYmplY3RzL2Nvbm5lY3Rpb24udHM/ZDkyMiIsIndlYnBhY2s6Ly9kc3Zpcy8uL3NyYy9vYmplY3RzL2J0cmVlLWNvbm5lY3Rpb24udHM/MDRiZCIsIndlYnBhY2s6Ly9kc3Zpcy8uL3NyYy9vYmplY3RzL2J0cmVlLW5vZGUudHM/Zjk3ZiIsIndlYnBhY2s6Ly9kc3Zpcy8uL3NyYy9vYmplY3RzL2hpZ2hsaWdodC1jaXJjbGUudHM/NTAyYiIsIndlYnBhY2s6Ly9kc3Zpcy8uL3NyYy9vYmplY3RzL2luZGV4LnRzPzQ0ZTMiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9zcmMvZW5naW5lLnRzPzIyZWMiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9zcmMvdHJlZXMvQlNULnRzP2I5YTIiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9zcmMvdHJlZXMvQVZMLnRzPzlhN2YiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9zcmMvdHJlZXMvQlRyZWUudHM/NDYxOCIsIndlYnBhY2s6Ly9kc3Zpcy8uL3NyYy90cmVlcy9SZWRCbGFjay50cz9lNGU0Iiwid2VicGFjazovL2RzdmlzLy4vc3JjL3RyZWVzL1NwbGF5VHJlZS50cz80NTdlIiwid2VicGFjazovL2RzdmlzLy4vc3JjL2NvbGxlY3Rpb25zLnRzP2I1OWQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgbWV0aG9kcyA9IHt9XG5jb25zdCBuYW1lcyA9IFtdXG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3Rlck1ldGhvZHMobmFtZSwgbSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgIGZvciAoY29uc3QgX25hbWUgb2YgbmFtZSkge1xuICAgICAgcmVnaXN0ZXJNZXRob2RzKF9uYW1lLCBtKVxuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKGNvbnN0IF9uYW1lIGluIG5hbWUpIHtcbiAgICAgIHJlZ2lzdGVyTWV0aG9kcyhfbmFtZSwgbmFtZVtfbmFtZV0pXG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgYWRkTWV0aG9kTmFtZXMoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobSkpXG4gIG1ldGhvZHNbbmFtZV0gPSBPYmplY3QuYXNzaWduKG1ldGhvZHNbbmFtZV0gfHwge30sIG0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNZXRob2RzRm9yKG5hbWUpIHtcbiAgcmV0dXJuIG1ldGhvZHNbbmFtZV0gfHwge31cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1ldGhvZE5hbWVzKCkge1xuICByZXR1cm4gWy4uLm5ldyBTZXQobmFtZXMpXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkTWV0aG9kTmFtZXMoX25hbWVzKSB7XG4gIG5hbWVzLnB1c2goLi4uX25hbWVzKVxufVxuIiwiLy8gTWFwIGZ1bmN0aW9uXG5leHBvcnQgZnVuY3Rpb24gbWFwKGFycmF5LCBibG9jaykge1xuICBsZXQgaVxuICBjb25zdCBpbCA9IGFycmF5Lmxlbmd0aFxuICBjb25zdCByZXN1bHQgPSBbXVxuXG4gIGZvciAoaSA9IDA7IGkgPCBpbDsgaSsrKSB7XG4gICAgcmVzdWx0LnB1c2goYmxvY2soYXJyYXlbaV0pKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vLyBGaWx0ZXIgZnVuY3Rpb25cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXIoYXJyYXksIGJsb2NrKSB7XG4gIGxldCBpXG4gIGNvbnN0IGlsID0gYXJyYXkubGVuZ3RoXG4gIGNvbnN0IHJlc3VsdCA9IFtdXG5cbiAgZm9yIChpID0gMDsgaSA8IGlsOyBpKyspIHtcbiAgICBpZiAoYmxvY2soYXJyYXlbaV0pKSB7XG4gICAgICByZXN1bHQucHVzaChhcnJheVtpXSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIERlZ3JlZXMgdG8gcmFkaWFuc1xuZXhwb3J0IGZ1bmN0aW9uIHJhZGlhbnMoZCkge1xuICByZXR1cm4gKChkICUgMzYwKSAqIE1hdGguUEkpIC8gMTgwXG59XG5cbi8vIFJhZGlhbnMgdG8gZGVncmVlc1xuZXhwb3J0IGZ1bmN0aW9uIGRlZ3JlZXMocikge1xuICByZXR1cm4gKChyICogMTgwKSAvIE1hdGguUEkpICUgMzYwXG59XG5cbi8vIENvbnZlcnQgY2FtZWwgY2FzZWQgc3RyaW5nIHRvIGRhc2ggc2VwYXJhdGVkXG5leHBvcnQgZnVuY3Rpb24gdW5DYW1lbENhc2Uocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uIChtLCBnKSB7XG4gICAgcmV0dXJuICctJyArIGcudG9Mb3dlckNhc2UoKVxuICB9KVxufVxuXG4vLyBDYXBpdGFsaXplIGZpcnN0IGxldHRlciBvZiBhIHN0cmluZ1xuZXhwb3J0IGZ1bmN0aW9uIGNhcGl0YWxpemUocykge1xuICByZXR1cm4gcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSlcbn1cblxuLy8gQ2FsY3VsYXRlIHByb3BvcnRpb25hbCB3aWR0aCBhbmQgaGVpZ2h0IHZhbHVlcyB3aGVuIG5lY2Vzc2FyeVxuZXhwb3J0IGZ1bmN0aW9uIHByb3BvcnRpb25hbFNpemUoZWxlbWVudCwgd2lkdGgsIGhlaWdodCwgYm94KSB7XG4gIGlmICh3aWR0aCA9PSBudWxsIHx8IGhlaWdodCA9PSBudWxsKSB7XG4gICAgYm94ID0gYm94IHx8IGVsZW1lbnQuYmJveCgpXG5cbiAgICBpZiAod2lkdGggPT0gbnVsbCkge1xuICAgICAgd2lkdGggPSAoYm94LndpZHRoIC8gYm94LmhlaWdodCkgKiBoZWlnaHRcbiAgICB9IGVsc2UgaWYgKGhlaWdodCA9PSBudWxsKSB7XG4gICAgICBoZWlnaHQgPSAoYm94LmhlaWdodCAvIGJveC53aWR0aCkgKiB3aWR0aFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFkZHMgc3VwcG9ydCBmb3Igc3RyaW5nIG9yaWdpbnMuXG4gKiBJdCBzZWFyY2hlcyBmb3IgYW4gb3JpZ2luIGluIG8ub3JpZ2luIG8ub3ggYW5kIG8ub3JpZ2luWC5cbiAqIFRoaXMgd2F5LCBvcmlnaW46IHt4OiAnY2VudGVyJywgeTogNTB9IGNhbiBiZSBwYXNzZWQgYXMgd2VsbCBhcyBveDogJ2NlbnRlcicsIG95OiA1MFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9yaWdpbihvLCBlbGVtZW50KSB7XG4gIGNvbnN0IG9yaWdpbiA9IG8ub3JpZ2luXG4gIC8vIEZpcnN0IGNoZWNrIGlmIG9yaWdpbiBpcyBpbiBveCBvciBvcmlnaW5YXG4gIGxldCBveCA9IG8ub3ggIT0gbnVsbCA/IG8ub3ggOiBvLm9yaWdpblggIT0gbnVsbCA/IG8ub3JpZ2luWCA6ICdjZW50ZXInXG4gIGxldCBveSA9IG8ub3kgIT0gbnVsbCA/IG8ub3kgOiBvLm9yaWdpblkgIT0gbnVsbCA/IG8ub3JpZ2luWSA6ICdjZW50ZXInXG5cbiAgLy8gVGhlbiBjaGVjayBpZiBvcmlnaW4gd2FzIHVzZWQgYW5kIG92ZXJ3cml0ZSBpbiB0aGF0IGNhc2VcbiAgaWYgKG9yaWdpbiAhPSBudWxsKSB7XG4gICAgO1tveCwgb3ldID0gQXJyYXkuaXNBcnJheShvcmlnaW4pXG4gICAgICA/IG9yaWdpblxuICAgICAgOiB0eXBlb2Ygb3JpZ2luID09PSAnb2JqZWN0J1xuICAgICAgICA/IFtvcmlnaW4ueCwgb3JpZ2luLnldXG4gICAgICAgIDogW29yaWdpbiwgb3JpZ2luXVxuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHRvIG9ubHkgY2FsbCBiYm94IHdoZW4gYWN0dWFsbHkgbmVlZGVkXG4gIGNvbnN0IGNvbmRYID0gdHlwZW9mIG94ID09PSAnc3RyaW5nJ1xuICBjb25zdCBjb25kWSA9IHR5cGVvZiBveSA9PT0gJ3N0cmluZydcbiAgaWYgKGNvbmRYIHx8IGNvbmRZKSB7XG4gICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoLCB4LCB5IH0gPSBlbGVtZW50LmJib3goKVxuXG4gICAgLy8gQW5kIG9ubHkgb3ZlcndyaXRlIGlmIHN0cmluZyB3YXMgcGFzc2VkIGZvciB0aGlzIHNwZWNpZmljIGF4aXNcbiAgICBpZiAoY29uZFgpIHtcbiAgICAgIG94ID0gb3guaW5jbHVkZXMoJ2xlZnQnKVxuICAgICAgICA/IHhcbiAgICAgICAgOiBveC5pbmNsdWRlcygncmlnaHQnKVxuICAgICAgICAgID8geCArIHdpZHRoXG4gICAgICAgICAgOiB4ICsgd2lkdGggLyAyXG4gICAgfVxuXG4gICAgaWYgKGNvbmRZKSB7XG4gICAgICBveSA9IG95LmluY2x1ZGVzKCd0b3AnKVxuICAgICAgICA/IHlcbiAgICAgICAgOiBveS5pbmNsdWRlcygnYm90dG9tJylcbiAgICAgICAgICA/IHkgKyBoZWlnaHRcbiAgICAgICAgICA6IHkgKyBoZWlnaHQgLyAyXG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSBvcmlnaW4gYXMgaXQgaXMgaWYgaXQgd2Fzbid0IGEgc3RyaW5nXG4gIHJldHVybiBbb3gsIG95XVxufVxuXG5jb25zdCBkZXNjcmlwdGl2ZUVsZW1lbnRzID0gbmV3IFNldChbJ2Rlc2MnLCAnbWV0YWRhdGEnLCAndGl0bGUnXSlcbmV4cG9ydCBjb25zdCBpc0Rlc2NyaXB0aXZlID0gKGVsZW1lbnQpID0+XG4gIGRlc2NyaXB0aXZlRWxlbWVudHMuaGFzKGVsZW1lbnQubm9kZU5hbWUpXG5cbmV4cG9ydCBjb25zdCB3cml0ZURhdGFUb0RvbSA9IChlbGVtZW50LCBkYXRhLCBkZWZhdWx0cyA9IHt9KSA9PiB7XG4gIGNvbnN0IGNsb25lZCA9IHsgLi4uZGF0YSB9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gY2xvbmVkKSB7XG4gICAgaWYgKGNsb25lZFtrZXldLnZhbHVlT2YoKSA9PT0gZGVmYXVsdHNba2V5XSkge1xuICAgICAgZGVsZXRlIGNsb25lZFtrZXldXG4gICAgfVxuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKGNsb25lZCkubGVuZ3RoKSB7XG4gICAgZWxlbWVudC5ub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1zdmdqcycsIEpTT04uc3RyaW5naWZ5KGNsb25lZCkpIC8vIHNlZSAjNDI4XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5ub2RlLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1zdmdqcycpXG4gICAgZWxlbWVudC5ub2RlLnJlbW92ZUF0dHJpYnV0ZSgnc3ZnanM6ZGF0YScpXG4gIH1cbn1cbiIsIi8vIERlZmF1bHQgbmFtZXNwYWNlc1xuZXhwb3J0IGNvbnN0IHN2ZyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZydcbmV4cG9ydCBjb25zdCBodG1sID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnXG5leHBvcnQgY29uc3QgeG1sbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nXG5leHBvcnQgY29uc3QgeGxpbmsgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaydcbiIsImV4cG9ydCBjb25zdCBnbG9iYWxzID0ge1xuICB3aW5kb3c6IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdyxcbiAgZG9jdW1lbnQ6IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogZG9jdW1lbnRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyV2luZG93KHdpbiA9IG51bGwsIGRvYyA9IG51bGwpIHtcbiAgZ2xvYmFscy53aW5kb3cgPSB3aW5cbiAgZ2xvYmFscy5kb2N1bWVudCA9IGRvY1xufVxuXG5jb25zdCBzYXZlID0ge31cblxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVXaW5kb3coKSB7XG4gIHNhdmUud2luZG93ID0gZ2xvYmFscy53aW5kb3dcbiAgc2F2ZS5kb2N1bWVudCA9IGdsb2JhbHMuZG9jdW1lbnRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVXaW5kb3coKSB7XG4gIGdsb2JhbHMud2luZG93ID0gc2F2ZS53aW5kb3dcbiAgZ2xvYmFscy5kb2N1bWVudCA9IHNhdmUuZG9jdW1lbnRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhXaW5kb3cod2luLCBmbikge1xuICBzYXZlV2luZG93KClcbiAgcmVnaXN0ZXJXaW5kb3cod2luLCB3aW4uZG9jdW1lbnQpXG4gIGZuKHdpbiwgd2luLmRvY3VtZW50KVxuICByZXN0b3JlV2luZG93KClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFdpbmRvdygpIHtcbiAgcmV0dXJuIGdsb2JhbHMud2luZG93XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlIHtcbiAgLy8gY29uc3RydWN0b3IgKG5vZGUvKiwge2V4dGVuc2lvbnMgPSBbXX0gKi8pIHtcbiAgLy8gICAvLyB0aGlzLnRhZ3MgPSBbXVxuICAvLyAgIC8vXG4gIC8vICAgLy8gZm9yIChsZXQgZXh0ZW5zaW9uIG9mIGV4dGVuc2lvbnMpIHtcbiAgLy8gICAvLyAgIGV4dGVuc2lvbi5zZXR1cC5jYWxsKHRoaXMsIG5vZGUpXG4gIC8vICAgLy8gICB0aGlzLnRhZ3MucHVzaChleHRlbnNpb24ubmFtZSlcbiAgLy8gICAvLyB9XG4gIC8vIH1cbn1cbiIsImltcG9ydCB7IGFkZE1ldGhvZE5hbWVzIH0gZnJvbSAnLi9tZXRob2RzLmpzJ1xuaW1wb3J0IHsgY2FwaXRhbGl6ZSB9IGZyb20gJy4vdXRpbHMuanMnXG5pbXBvcnQgeyBzdmcgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvbmFtZXNwYWNlcy5qcydcbmltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi91dGlscy93aW5kb3cuanMnXG5pbXBvcnQgQmFzZSBmcm9tICcuLi90eXBlcy9CYXNlLmpzJ1xuXG5jb25zdCBlbGVtZW50cyA9IHt9XG5leHBvcnQgY29uc3Qgcm9vdCA9ICdfX19TWU1CT0xfX19ST09UX19fJ1xuXG4vLyBNZXRob2QgZm9yIGVsZW1lbnQgY3JlYXRpb25cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUobmFtZSwgbnMgPSBzdmcpIHtcbiAgLy8gY3JlYXRlIGVsZW1lbnRcbiAgcmV0dXJuIGdsb2JhbHMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCBuYW1lKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZUluc3RhbmNlKGVsZW1lbnQsIGlzSFRNTCA9IGZhbHNlKSB7XG4gIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQmFzZSkgcmV0dXJuIGVsZW1lbnRcblxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGFkb3B0ZXIoZWxlbWVudClcbiAgfVxuXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbmV3IGVsZW1lbnRzW3Jvb3RdKClcbiAgfVxuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgJiYgZWxlbWVudC5jaGFyQXQoMCkgIT09ICc8Jykge1xuICAgIHJldHVybiBhZG9wdGVyKGdsb2JhbHMuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbGVtZW50KSlcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSwgdGhhdCBIVE1MIGVsZW1lbnRzIGFyZSBjcmVhdGVkIHdpdGggdGhlIGNvcnJlY3QgbmFtZXNwYWNlXG4gIGNvbnN0IHdyYXBwZXIgPSBpc0hUTUwgPyBnbG9iYWxzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogY3JlYXRlKCdzdmcnKVxuICB3cmFwcGVyLmlubmVySFRNTCA9IGVsZW1lbnRcblxuICAvLyBXZSBjYW4gdXNlIGZpcnN0Q2hpbGQgaGVyZSBiZWNhdXNlIHdlIGtub3csXG4gIC8vIHRoYXQgdGhlIGZpcnN0IGNoYXIgaXMgPCBhbmQgdGh1cyBhbiBlbGVtZW50XG4gIGVsZW1lbnQgPSBhZG9wdGVyKHdyYXBwZXIuZmlyc3RDaGlsZClcblxuICAvLyBtYWtlIHN1cmUsIHRoYXQgZWxlbWVudCBkb2Vzbid0IGhhdmUgaXRzIHdyYXBwZXIgYXR0YWNoZWRcbiAgd3JhcHBlci5yZW1vdmVDaGlsZCh3cmFwcGVyLmZpcnN0Q2hpbGQpXG4gIHJldHVybiBlbGVtZW50XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub2RlT3JOZXcobmFtZSwgbm9kZSkge1xuICByZXR1cm4gbm9kZSAmJlxuICAgIChub2RlIGluc3RhbmNlb2YgZ2xvYmFscy53aW5kb3cuTm9kZSB8fFxuICAgICAgKG5vZGUub3duZXJEb2N1bWVudCAmJlxuICAgICAgICBub2RlIGluc3RhbmNlb2Ygbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3Lk5vZGUpKVxuICAgID8gbm9kZVxuICAgIDogY3JlYXRlKG5hbWUpXG59XG5cbi8vIEFkb3B0IGV4aXN0aW5nIHN2ZyBlbGVtZW50c1xuZXhwb3J0IGZ1bmN0aW9uIGFkb3B0KG5vZGUpIHtcbiAgLy8gY2hlY2sgZm9yIHByZXNlbmNlIG9mIG5vZGVcbiAgaWYgKCFub2RlKSByZXR1cm4gbnVsbFxuXG4gIC8vIG1ha2Ugc3VyZSBhIG5vZGUgaXNuJ3QgYWxyZWFkeSBhZG9wdGVkXG4gIGlmIChub2RlLmluc3RhbmNlIGluc3RhbmNlb2YgQmFzZSkgcmV0dXJuIG5vZGUuaW5zdGFuY2VcblxuICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJyNkb2N1bWVudC1mcmFnbWVudCcpIHtcbiAgICByZXR1cm4gbmV3IGVsZW1lbnRzLkZyYWdtZW50KG5vZGUpXG4gIH1cblxuICAvLyBpbml0aWFsaXplIHZhcmlhYmxlc1xuICBsZXQgY2xhc3NOYW1lID0gY2FwaXRhbGl6ZShub2RlLm5vZGVOYW1lIHx8ICdEb20nKVxuXG4gIC8vIE1ha2Ugc3VyZSB0aGF0IGdyYWRpZW50cyBhcmUgYWRvcHRlZCBjb3JyZWN0bHlcbiAgaWYgKGNsYXNzTmFtZSA9PT0gJ0xpbmVhckdyYWRpZW50JyB8fCBjbGFzc05hbWUgPT09ICdSYWRpYWxHcmFkaWVudCcpIHtcbiAgICBjbGFzc05hbWUgPSAnR3JhZGllbnQnXG5cbiAgICAvLyBGYWxsYmFjayB0byBEb20gaWYgZWxlbWVudCBpcyBub3Qga25vd25cbiAgfSBlbHNlIGlmICghZWxlbWVudHNbY2xhc3NOYW1lXSkge1xuICAgIGNsYXNzTmFtZSA9ICdEb20nXG4gIH1cblxuICByZXR1cm4gbmV3IGVsZW1lbnRzW2NsYXNzTmFtZV0obm9kZSlcbn1cblxubGV0IGFkb3B0ZXIgPSBhZG9wdFxuXG5leHBvcnQgZnVuY3Rpb24gbW9ja0Fkb3B0KG1vY2sgPSBhZG9wdCkge1xuICBhZG9wdGVyID0gbW9ja1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXIoZWxlbWVudCwgbmFtZSA9IGVsZW1lbnQubmFtZSwgYXNSb290ID0gZmFsc2UpIHtcbiAgZWxlbWVudHNbbmFtZV0gPSBlbGVtZW50XG4gIGlmIChhc1Jvb3QpIGVsZW1lbnRzW3Jvb3RdID0gZWxlbWVudFxuXG4gIGFkZE1ldGhvZE5hbWVzKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVsZW1lbnQucHJvdG90eXBlKSlcblxuICByZXR1cm4gZWxlbWVudFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xhc3MobmFtZSkge1xuICByZXR1cm4gZWxlbWVudHNbbmFtZV1cbn1cblxuLy8gRWxlbWVudCBpZCBzZXF1ZW5jZVxubGV0IGRpZCA9IDEwMDBcblxuLy8gR2V0IG5leHQgbmFtZWQgZWxlbWVudCBpZFxuZXhwb3J0IGZ1bmN0aW9uIGVpZChuYW1lKSB7XG4gIHJldHVybiAnU3ZnanMnICsgY2FwaXRhbGl6ZShuYW1lKSArIGRpZCsrXG59XG5cbi8vIERlZXAgbmV3IGlkIGFzc2lnbm1lbnRcbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25OZXdJZChub2RlKSB7XG4gIC8vIGRvIHRoZSBzYW1lIGZvciBTVkcgY2hpbGQgbm9kZXMgYXMgd2VsbFxuICBmb3IgKGxldCBpID0gbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGFzc2lnbk5ld0lkKG5vZGUuY2hpbGRyZW5baV0pXG4gIH1cblxuICBpZiAobm9kZS5pZCkge1xuICAgIG5vZGUuaWQgPSBlaWQobm9kZS5ub2RlTmFtZSlcbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgcmV0dXJuIG5vZGVcbn1cblxuLy8gTWV0aG9kIGZvciBleHRlbmRpbmcgb2JqZWN0c1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChtb2R1bGVzLCBtZXRob2RzKSB7XG4gIGxldCBrZXksIGlcblxuICBtb2R1bGVzID0gQXJyYXkuaXNBcnJheShtb2R1bGVzKSA/IG1vZHVsZXMgOiBbbW9kdWxlc11cblxuICBmb3IgKGkgPSBtb2R1bGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgbW9kdWxlc1tpXS5wcm90b3R5cGVba2V5XSA9IG1ldGhvZHNba2V5XVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcFdpdGhBdHRyQ2hlY2soZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgY29uc3QgbyA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXVxuXG4gICAgaWYgKG8gJiYgby5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmICEobyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3Muc2xpY2UoMCwgLTEpKS5hdHRyKG8pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgbWFrZUluc3RhbmNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uLy4uL3V0aWxzL21ldGhvZHMuanMnXG5cbi8vIEdldCBhbGwgc2libGluZ3MsIGluY2x1ZGluZyBteXNlbGZcbmV4cG9ydCBmdW5jdGlvbiBzaWJsaW5ncygpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50KCkuY2hpbGRyZW4oKVxufVxuXG4vLyBHZXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gc2libGluZ3NcbmV4cG9ydCBmdW5jdGlvbiBwb3NpdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50KCkuaW5kZXgodGhpcylcbn1cblxuLy8gR2V0IHRoZSBuZXh0IGVsZW1lbnQgKHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlcmUgaXMgbm9uZSlcbmV4cG9ydCBmdW5jdGlvbiBuZXh0KCkge1xuICByZXR1cm4gdGhpcy5zaWJsaW5ncygpW3RoaXMucG9zaXRpb24oKSArIDFdXG59XG5cbi8vIEdldCB0aGUgbmV4dCBlbGVtZW50ICh3aWxsIHJldHVybiBudWxsIGlmIHRoZXJlIGlzIG5vbmUpXG5leHBvcnQgZnVuY3Rpb24gcHJldigpIHtcbiAgcmV0dXJuIHRoaXMuc2libGluZ3MoKVt0aGlzLnBvc2l0aW9uKCkgLSAxXVxufVxuXG4vLyBTZW5kIGdpdmVuIGVsZW1lbnQgb25lIHN0ZXAgZm9yd2FyZFxuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmQoKSB7XG4gIGNvbnN0IGkgPSB0aGlzLnBvc2l0aW9uKClcbiAgY29uc3QgcCA9IHRoaXMucGFyZW50KClcblxuICAvLyBtb3ZlIG5vZGUgb25lIHN0ZXAgZm9yd2FyZFxuICBwLmFkZCh0aGlzLnJlbW92ZSgpLCBpICsgMSlcblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBTZW5kIGdpdmVuIGVsZW1lbnQgb25lIHN0ZXAgYmFja3dhcmRcbmV4cG9ydCBmdW5jdGlvbiBiYWNrd2FyZCgpIHtcbiAgY29uc3QgaSA9IHRoaXMucG9zaXRpb24oKVxuICBjb25zdCBwID0gdGhpcy5wYXJlbnQoKVxuXG4gIHAuYWRkKHRoaXMucmVtb3ZlKCksIGkgPyBpIC0gMSA6IDApXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gU2VuZCBnaXZlbiBlbGVtZW50IGFsbCB0aGUgd2F5IHRvIHRoZSBmcm9udFxuZXhwb3J0IGZ1bmN0aW9uIGZyb250KCkge1xuICBjb25zdCBwID0gdGhpcy5wYXJlbnQoKVxuXG4gIC8vIE1vdmUgbm9kZSBmb3J3YXJkXG4gIHAuYWRkKHRoaXMucmVtb3ZlKCkpXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gU2VuZCBnaXZlbiBlbGVtZW50IGFsbCB0aGUgd2F5IHRvIHRoZSBiYWNrXG5leHBvcnQgZnVuY3Rpb24gYmFjaygpIHtcbiAgY29uc3QgcCA9IHRoaXMucGFyZW50KClcblxuICAvLyBNb3ZlIG5vZGUgYmFja1xuICBwLmFkZCh0aGlzLnJlbW92ZSgpLCAwKVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEluc2VydHMgYSBnaXZlbiBlbGVtZW50IGJlZm9yZSB0aGUgdGFyZ2V0ZWQgZWxlbWVudFxuZXhwb3J0IGZ1bmN0aW9uIGJlZm9yZShlbGVtZW50KSB7XG4gIGVsZW1lbnQgPSBtYWtlSW5zdGFuY2UoZWxlbWVudClcbiAgZWxlbWVudC5yZW1vdmUoKVxuXG4gIGNvbnN0IGkgPSB0aGlzLnBvc2l0aW9uKClcblxuICB0aGlzLnBhcmVudCgpLmFkZChlbGVtZW50LCBpKVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEluc2VydHMgYSBnaXZlbiBlbGVtZW50IGFmdGVyIHRoZSB0YXJnZXRlZCBlbGVtZW50XG5leHBvcnQgZnVuY3Rpb24gYWZ0ZXIoZWxlbWVudCkge1xuICBlbGVtZW50ID0gbWFrZUluc3RhbmNlKGVsZW1lbnQpXG4gIGVsZW1lbnQucmVtb3ZlKClcblxuICBjb25zdCBpID0gdGhpcy5wb3NpdGlvbigpXG5cbiAgdGhpcy5wYXJlbnQoKS5hZGQoZWxlbWVudCwgaSArIDEpXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluc2VydEJlZm9yZShlbGVtZW50KSB7XG4gIGVsZW1lbnQgPSBtYWtlSW5zdGFuY2UoZWxlbWVudClcbiAgZWxlbWVudC5iZWZvcmUodGhpcylcbiAgcmV0dXJuIHRoaXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluc2VydEFmdGVyKGVsZW1lbnQpIHtcbiAgZWxlbWVudCA9IG1ha2VJbnN0YW5jZShlbGVtZW50KVxuICBlbGVtZW50LmFmdGVyKHRoaXMpXG4gIHJldHVybiB0aGlzXG59XG5cbnJlZ2lzdGVyTWV0aG9kcygnRG9tJywge1xuICBzaWJsaW5ncyxcbiAgcG9zaXRpb24sXG4gIG5leHQsXG4gIHByZXYsXG4gIGZvcndhcmQsXG4gIGJhY2t3YXJkLFxuICBmcm9udCxcbiAgYmFjayxcbiAgYmVmb3JlLFxuICBhZnRlcixcbiAgaW5zZXJ0QmVmb3JlLFxuICBpbnNlcnRBZnRlclxufSlcbiIsIi8vIFBhcnNlIHVuaXQgdmFsdWVcbmV4cG9ydCBjb25zdCBudW1iZXJBbmRVbml0ID1cbiAgL14oWystXT8oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/KShbYS16JV0qKSQvaVxuXG4vLyBQYXJzZSBoZXggdmFsdWVcbmV4cG9ydCBjb25zdCBoZXggPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pXG5cbi8vIFBhcnNlIHJnYiB2YWx1ZVxuZXhwb3J0IGNvbnN0IHJnYiA9IC9yZ2JcXCgoXFxkKyksKFxcZCspLChcXGQrKVxcKS9cblxuLy8gUGFyc2UgcmVmZXJlbmNlIGlkXG5leHBvcnQgY29uc3QgcmVmZXJlbmNlID0gLygjW2Etel9dW2EtejAtOVxcLV9dKikvaVxuXG4vLyBzcGxpdHMgYSB0cmFuc2Zvcm1hdGlvbiBjaGFpblxuZXhwb3J0IGNvbnN0IHRyYW5zZm9ybXMgPSAvXFwpXFxzKiw/XFxzKi9cblxuLy8gV2hpdGVzcGFjZVxuZXhwb3J0IGNvbnN0IHdoaXRlc3BhY2UgPSAvXFxzL2dcblxuLy8gVGVzdCBoZXggdmFsdWVcbmV4cG9ydCBjb25zdCBpc0hleCA9IC9eI1thLWYwLTldezN9JHxeI1thLWYwLTldezZ9JC9pXG5cbi8vIFRlc3QgcmdiIHZhbHVlXG5leHBvcnQgY29uc3QgaXNSZ2IgPSAvXnJnYlxcKC9cblxuLy8gVGVzdCBmb3IgYmxhbmsgc3RyaW5nXG5leHBvcnQgY29uc3QgaXNCbGFuayA9IC9eKFxccyspPyQvXG5cbi8vIFRlc3QgZm9yIG51bWVyaWMgc3RyaW5nXG5leHBvcnQgY29uc3QgaXNOdW1iZXIgPSAvXlsrLV0/KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPyQvaVxuXG4vLyBUZXN0IGZvciBpbWFnZSB1cmxcbmV4cG9ydCBjb25zdCBpc0ltYWdlID0gL1xcLihqcGd8anBlZ3xwbmd8Z2lmfHN2ZykoXFw/W149XSsuKik/L2lcblxuLy8gc3BsaXQgYXQgd2hpdGVzcGFjZSBhbmQgY29tbWFcbmV4cG9ydCBjb25zdCBkZWxpbWl0ZXIgPSAvW1xccyxdKy9cblxuLy8gVGVzdCBmb3IgcGF0aCBsZXR0ZXJcbmV4cG9ydCBjb25zdCBpc1BhdGhMZXR0ZXIgPSAvW01MSFZDU1FUQVpdL2lcbiIsImltcG9ydCB7IGRlbGltaXRlciB9IGZyb20gJy4uL2NvcmUvcmVnZXguanMnXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi8uLi91dGlscy9tZXRob2RzLmpzJ1xuXG4vLyBSZXR1cm4gYXJyYXkgb2YgY2xhc3NlcyBvbiB0aGUgbm9kZVxuZXhwb3J0IGZ1bmN0aW9uIGNsYXNzZXMoKSB7XG4gIGNvbnN0IGF0dHIgPSB0aGlzLmF0dHIoJ2NsYXNzJylcbiAgcmV0dXJuIGF0dHIgPT0gbnVsbCA/IFtdIDogYXR0ci50cmltKCkuc3BsaXQoZGVsaW1pdGVyKVxufVxuXG4vLyBSZXR1cm4gdHJ1ZSBpZiBjbGFzcyBleGlzdHMgb24gdGhlIG5vZGUsIGZhbHNlIG90aGVyd2lzZVxuZXhwb3J0IGZ1bmN0aW9uIGhhc0NsYXNzKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuY2xhc3NlcygpLmluZGV4T2YobmFtZSkgIT09IC0xXG59XG5cbi8vIEFkZCBjbGFzcyB0byB0aGUgbm9kZVxuZXhwb3J0IGZ1bmN0aW9uIGFkZENsYXNzKG5hbWUpIHtcbiAgaWYgKCF0aGlzLmhhc0NsYXNzKG5hbWUpKSB7XG4gICAgY29uc3QgYXJyYXkgPSB0aGlzLmNsYXNzZXMoKVxuICAgIGFycmF5LnB1c2gobmFtZSlcbiAgICB0aGlzLmF0dHIoJ2NsYXNzJywgYXJyYXkuam9pbignICcpKVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gUmVtb3ZlIGNsYXNzIGZyb20gdGhlIG5vZGVcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDbGFzcyhuYW1lKSB7XG4gIGlmICh0aGlzLmhhc0NsYXNzKG5hbWUpKSB7XG4gICAgdGhpcy5hdHRyKFxuICAgICAgJ2NsYXNzJyxcbiAgICAgIHRoaXMuY2xhc3NlcygpXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICByZXR1cm4gYyAhPT0gbmFtZVxuICAgICAgICB9KVxuICAgICAgICAuam9pbignICcpXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gVG9nZ2xlIHRoZSBwcmVzZW5jZSBvZiBhIGNsYXNzIG9uIHRoZSBub2RlXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlQ2xhc3MobmFtZSkge1xuICByZXR1cm4gdGhpcy5oYXNDbGFzcyhuYW1lKSA/IHRoaXMucmVtb3ZlQ2xhc3MobmFtZSkgOiB0aGlzLmFkZENsYXNzKG5hbWUpXG59XG5cbnJlZ2lzdGVyTWV0aG9kcygnRG9tJywge1xuICBjbGFzc2VzLFxuICBoYXNDbGFzcyxcbiAgYWRkQ2xhc3MsXG4gIHJlbW92ZUNsYXNzLFxuICB0b2dnbGVDbGFzc1xufSlcbiIsImltcG9ydCB7IGlzQmxhbmsgfSBmcm9tICcuLi9jb3JlL3JlZ2V4LmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vLi4vdXRpbHMvbWV0aG9kcy5qcydcblxuLy8gRHluYW1pYyBzdHlsZSBnZW5lcmF0b3JcbmV4cG9ydCBmdW5jdGlvbiBjc3Moc3R5bGUsIHZhbCkge1xuICBjb25zdCByZXQgPSB7fVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIGdldCBmdWxsIHN0eWxlIGFzIG9iamVjdFxuICAgIHRoaXMubm9kZS5zdHlsZS5jc3NUZXh0XG4gICAgICAuc3BsaXQoL1xccyo7XFxzKi8pXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gISFlbC5sZW5ndGhcbiAgICAgIH0pXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgY29uc3QgdCA9IGVsLnNwbGl0KC9cXHMqOlxccyovKVxuICAgICAgICByZXRbdFswXV0gPSB0WzFdXG4gICAgICB9KVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIC8vIGdldCBzdHlsZSBwcm9wZXJ0aWVzIGFzIGFycmF5XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUpKSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygc3R5bGUpIHtcbiAgICAgICAgY29uc3QgY2FzZWQgPSBuYW1lXG4gICAgICAgIHJldFtuYW1lXSA9IHRoaXMubm9kZS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKGNhc2VkKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldFxuICAgIH1cblxuICAgIC8vIGdldCBzdHlsZSBmb3IgcHJvcGVydHlcbiAgICBpZiAodHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHN0eWxlKVxuICAgIH1cblxuICAgIC8vIHNldCBzdHlsZXMgaW4gb2JqZWN0XG4gICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBzdHlsZSkge1xuICAgICAgICAvLyBzZXQgZW1wdHkgc3RyaW5nIGlmIG51bGwvdW5kZWZpbmVkLycnIHdhcyBnaXZlblxuICAgICAgICB0aGlzLm5vZGUuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBzdHlsZVtuYW1lXSA9PSBudWxsIHx8IGlzQmxhbmsudGVzdChzdHlsZVtuYW1lXSkgPyAnJyA6IHN0eWxlW25hbWVdXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBzZXQgc3R5bGUgZm9yIHByb3BlcnR5XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdGhpcy5ub2RlLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgc3R5bGUsXG4gICAgICB2YWwgPT0gbnVsbCB8fCBpc0JsYW5rLnRlc3QodmFsKSA/ICcnIDogdmFsXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gU2hvdyBlbGVtZW50XG5leHBvcnQgZnVuY3Rpb24gc2hvdygpIHtcbiAgcmV0dXJuIHRoaXMuY3NzKCdkaXNwbGF5JywgJycpXG59XG5cbi8vIEhpZGUgZWxlbWVudFxuZXhwb3J0IGZ1bmN0aW9uIGhpZGUoKSB7XG4gIHJldHVybiB0aGlzLmNzcygnZGlzcGxheScsICdub25lJylcbn1cblxuLy8gSXMgZWxlbWVudCB2aXNpYmxlP1xuZXhwb3J0IGZ1bmN0aW9uIHZpc2libGUoKSB7XG4gIHJldHVybiB0aGlzLmNzcygnZGlzcGxheScpICE9PSAnbm9uZSdcbn1cblxucmVnaXN0ZXJNZXRob2RzKCdEb20nLCB7XG4gIGNzcyxcbiAgc2hvdyxcbiAgaGlkZSxcbiAgdmlzaWJsZVxufSlcbiIsImltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uLy4uL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgeyBmaWx0ZXIsIG1hcCB9IGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzLmpzJ1xuXG4vLyBTdG9yZSBkYXRhIHZhbHVlcyBvbiBzdmcgbm9kZXNcbmV4cG9ydCBmdW5jdGlvbiBkYXRhKGEsIHYsIHIpIHtcbiAgaWYgKGEgPT0gbnVsbCkge1xuICAgIC8vIGdldCBhbiBvYmplY3Qgb2YgYXR0cmlidXRlc1xuICAgIHJldHVybiB0aGlzLmRhdGEoXG4gICAgICBtYXAoXG4gICAgICAgIGZpbHRlcihcbiAgICAgICAgICB0aGlzLm5vZGUuYXR0cmlidXRlcyxcbiAgICAgICAgICAoZWwpID0+IGVsLm5vZGVOYW1lLmluZGV4T2YoJ2RhdGEtJykgPT09IDBcbiAgICAgICAgKSxcbiAgICAgICAgKGVsKSA9PiBlbC5ub2RlTmFtZS5zbGljZSg1KVxuICAgICAgKVxuICAgIClcbiAgfSBlbHNlIGlmIChhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBjb25zdCBkYXRhID0ge31cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBhKSB7XG4gICAgICBkYXRhW2tleV0gPSB0aGlzLmRhdGEoa2V5KVxuICAgIH1cbiAgICByZXR1cm4gZGF0YVxuICB9IGVsc2UgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAodiBpbiBhKSB7XG4gICAgICB0aGlzLmRhdGEodiwgYVt2XSlcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy5hdHRyKCdkYXRhLScgKyBhKSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdkYXRhLScgKyBhKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmF0dHIoXG4gICAgICAnZGF0YS0nICsgYSxcbiAgICAgIHYgPT09IG51bGxcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogciA9PT0gdHJ1ZSB8fCB0eXBlb2YgdiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInXG4gICAgICAgICAgPyB2XG4gICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh2KVxuICAgIClcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbnJlZ2lzdGVyTWV0aG9kcygnRG9tJywgeyBkYXRhIH0pXG4iLCJpbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi8uLi91dGlscy9tZXRob2RzLmpzJ1xuXG4vLyBSZW1lbWJlciBhcmJpdHJhcnkgZGF0YVxuZXhwb3J0IGZ1bmN0aW9uIHJlbWVtYmVyKGssIHYpIHtcbiAgLy8gcmVtZW1iZXIgZXZlcnkgaXRlbSBpbiBhbiBvYmplY3QgaW5kaXZpZHVhbGx5XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGspIHtcbiAgICAgIHRoaXMucmVtZW1iZXIoa2V5LCBrW2tleV0pXG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAvLyByZXRyaWV2ZSBtZW1vcnlcbiAgICByZXR1cm4gdGhpcy5tZW1vcnkoKVtrXVxuICB9IGVsc2Uge1xuICAgIC8vIHN0b3JlIG1lbW9yeVxuICAgIHRoaXMubWVtb3J5KClba10gPSB2XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBFcmFzZSBhIGdpdmVuIG1lbW9yeVxuZXhwb3J0IGZ1bmN0aW9uIGZvcmdldCgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLl9tZW1vcnkgPSB7fVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLm1lbW9yeSgpW2FyZ3VtZW50c1tpXV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gVGhpcyB0cmlnZ2VycyBjcmVhdGlvbiBvZiBhIG5ldyBoaWRkZW4gY2xhc3Mgd2hpY2ggaXMgbm90IHBlcmZvcm1hbnRcbi8vIEhvd2V2ZXIsIHRoaXMgZnVuY3Rpb24gaXMgbm90IHJhcmVseSB1c2VkIHNvIGl0IHdpbGwgbm90IGhhcHBlbiBmcmVxdWVudGx5XG4vLyBSZXR1cm4gbG9jYWwgbWVtb3J5IG9iamVjdFxuZXhwb3J0IGZ1bmN0aW9uIG1lbW9yeSgpIHtcbiAgcmV0dXJuICh0aGlzLl9tZW1vcnkgPSB0aGlzLl9tZW1vcnkgfHwge30pXG59XG5cbnJlZ2lzdGVyTWV0aG9kcygnRG9tJywgeyByZW1lbWJlciwgZm9yZ2V0LCBtZW1vcnkgfSlcbiIsImltcG9ydCB7IGhleCwgaXNIZXgsIGlzUmdiLCByZ2IsIHdoaXRlc3BhY2UgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcmVnZXguanMnXG5cbmZ1bmN0aW9uIHNpeERpZ2l0SGV4KGhleCkge1xuICByZXR1cm4gaGV4Lmxlbmd0aCA9PT0gNFxuICAgID8gW1xuICAgICAgICAnIycsXG4gICAgICAgIGhleC5zdWJzdHJpbmcoMSwgMiksXG4gICAgICAgIGhleC5zdWJzdHJpbmcoMSwgMiksXG4gICAgICAgIGhleC5zdWJzdHJpbmcoMiwgMyksXG4gICAgICAgIGhleC5zdWJzdHJpbmcoMiwgMyksXG4gICAgICAgIGhleC5zdWJzdHJpbmcoMywgNCksXG4gICAgICAgIGhleC5zdWJzdHJpbmcoMywgNClcbiAgICAgIF0uam9pbignJylcbiAgICA6IGhleFxufVxuXG5mdW5jdGlvbiBjb21wb25lbnRIZXgoY29tcG9uZW50KSB7XG4gIGNvbnN0IGludGVnZXIgPSBNYXRoLnJvdW5kKGNvbXBvbmVudClcbiAgY29uc3QgYm91bmRlZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgaW50ZWdlcikpXG4gIGNvbnN0IGhleCA9IGJvdW5kZWQudG9TdHJpbmcoMTYpXG4gIHJldHVybiBoZXgubGVuZ3RoID09PSAxID8gJzAnICsgaGV4IDogaGV4XG59XG5cbmZ1bmN0aW9uIGlzKG9iamVjdCwgc3BhY2UpIHtcbiAgZm9yIChsZXQgaSA9IHNwYWNlLmxlbmd0aDsgaS0tOyApIHtcbiAgICBpZiAob2JqZWN0W3NwYWNlW2ldXSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2V0UGFyYW1ldGVycyhhLCBiKSB7XG4gIGNvbnN0IHBhcmFtcyA9IGlzKGEsICdyZ2InKVxuICAgID8geyBfYTogYS5yLCBfYjogYS5nLCBfYzogYS5iLCBfZDogMCwgc3BhY2U6ICdyZ2InIH1cbiAgICA6IGlzKGEsICd4eXonKVxuICAgICAgPyB7IF9hOiBhLngsIF9iOiBhLnksIF9jOiBhLnosIF9kOiAwLCBzcGFjZTogJ3h5eicgfVxuICAgICAgOiBpcyhhLCAnaHNsJylcbiAgICAgICAgPyB7IF9hOiBhLmgsIF9iOiBhLnMsIF9jOiBhLmwsIF9kOiAwLCBzcGFjZTogJ2hzbCcgfVxuICAgICAgICA6IGlzKGEsICdsYWInKVxuICAgICAgICAgID8geyBfYTogYS5sLCBfYjogYS5hLCBfYzogYS5iLCBfZDogMCwgc3BhY2U6ICdsYWInIH1cbiAgICAgICAgICA6IGlzKGEsICdsY2gnKVxuICAgICAgICAgICAgPyB7IF9hOiBhLmwsIF9iOiBhLmMsIF9jOiBhLmgsIF9kOiAwLCBzcGFjZTogJ2xjaCcgfVxuICAgICAgICAgICAgOiBpcyhhLCAnY215aycpXG4gICAgICAgICAgICAgID8geyBfYTogYS5jLCBfYjogYS5tLCBfYzogYS55LCBfZDogYS5rLCBzcGFjZTogJ2NteWsnIH1cbiAgICAgICAgICAgICAgOiB7IF9hOiAwLCBfYjogMCwgX2M6IDAsIHNwYWNlOiAncmdiJyB9XG5cbiAgcGFyYW1zLnNwYWNlID0gYiB8fCBwYXJhbXMuc3BhY2VcbiAgcmV0dXJuIHBhcmFtc1xufVxuXG5mdW5jdGlvbiBjaWVTcGFjZShzcGFjZSkge1xuICBpZiAoc3BhY2UgPT09ICdsYWInIHx8IHNwYWNlID09PSAneHl6JyB8fCBzcGFjZSA9PT0gJ2xjaCcpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGh1ZVRvUmdiKHAsIHEsIHQpIHtcbiAgaWYgKHQgPCAwKSB0ICs9IDFcbiAgaWYgKHQgPiAxKSB0IC09IDFcbiAgaWYgKHQgPCAxIC8gNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHRcbiAgaWYgKHQgPCAxIC8gMikgcmV0dXJuIHFcbiAgaWYgKHQgPCAyIC8gMykgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2XG4gIHJldHVybiBwXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbG9yIHtcbiAgY29uc3RydWN0b3IoLi4uaW5wdXRzKSB7XG4gICAgdGhpcy5pbml0KC4uLmlucHV0cylcbiAgfVxuXG4gIC8vIFRlc3QgaWYgZ2l2ZW4gdmFsdWUgaXMgYSBjb2xvclxuICBzdGF0aWMgaXNDb2xvcihjb2xvcikge1xuICAgIHJldHVybiAoXG4gICAgICBjb2xvciAmJiAoY29sb3IgaW5zdGFuY2VvZiBDb2xvciB8fCB0aGlzLmlzUmdiKGNvbG9yKSB8fCB0aGlzLnRlc3QoY29sb3IpKVxuICAgIClcbiAgfVxuXG4gIC8vIFRlc3QgaWYgZ2l2ZW4gdmFsdWUgaXMgYW4gcmdiIG9iamVjdFxuICBzdGF0aWMgaXNSZ2IoY29sb3IpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY29sb3IgJiZcbiAgICAgIHR5cGVvZiBjb2xvci5yID09PSAnbnVtYmVyJyAmJlxuICAgICAgdHlwZW9mIGNvbG9yLmcgPT09ICdudW1iZXInICYmXG4gICAgICB0eXBlb2YgY29sb3IuYiA9PT0gJ251bWJlcidcbiAgICApXG4gIH1cblxuICAvKlxuICBHZW5lcmF0aW5nIHJhbmRvbSBjb2xvcnNcbiAgKi9cbiAgc3RhdGljIHJhbmRvbShtb2RlID0gJ3ZpYnJhbnQnLCB0KSB7XG4gICAgLy8gR2V0IHRoZSBtYXRoIG1vZHVsZXNcbiAgICBjb25zdCB7IHJhbmRvbSwgcm91bmQsIHNpbiwgUEk6IHBpIH0gPSBNYXRoXG5cbiAgICAvLyBSdW4gdGhlIGNvcnJlY3QgZ2VuZXJhdG9yXG4gICAgaWYgKG1vZGUgPT09ICd2aWJyYW50Jykge1xuICAgICAgY29uc3QgbCA9ICg4MSAtIDU3KSAqIHJhbmRvbSgpICsgNTdcbiAgICAgIGNvbnN0IGMgPSAoODMgLSA0NSkgKiByYW5kb20oKSArIDQ1XG4gICAgICBjb25zdCBoID0gMzYwICogcmFuZG9tKClcbiAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGwsIGMsIGgsICdsY2gnKVxuICAgICAgcmV0dXJuIGNvbG9yXG4gICAgfSBlbHNlIGlmIChtb2RlID09PSAnc2luZScpIHtcbiAgICAgIHQgPSB0ID09IG51bGwgPyByYW5kb20oKSA6IHRcbiAgICAgIGNvbnN0IHIgPSByb3VuZCg4MCAqIHNpbigoMiAqIHBpICogdCkgLyAwLjUgKyAwLjAxKSArIDE1MClcbiAgICAgIGNvbnN0IGcgPSByb3VuZCg1MCAqIHNpbigoMiAqIHBpICogdCkgLyAwLjUgKyA0LjYpICsgMjAwKVxuICAgICAgY29uc3QgYiA9IHJvdW5kKDEwMCAqIHNpbigoMiAqIHBpICogdCkgLyAwLjUgKyAyLjMpICsgMTUwKVxuICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IociwgZywgYilcbiAgICAgIHJldHVybiBjb2xvclxuICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ3Bhc3RlbCcpIHtcbiAgICAgIGNvbnN0IGwgPSAoOTQgLSA4NikgKiByYW5kb20oKSArIDg2XG4gICAgICBjb25zdCBjID0gKDI2IC0gOSkgKiByYW5kb20oKSArIDlcbiAgICAgIGNvbnN0IGggPSAzNjAgKiByYW5kb20oKVxuICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IobCwgYywgaCwgJ2xjaCcpXG4gICAgICByZXR1cm4gY29sb3JcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdkYXJrJykge1xuICAgICAgY29uc3QgbCA9IDEwICsgMTAgKiByYW5kb20oKVxuICAgICAgY29uc3QgYyA9ICgxMjUgLSA3NSkgKiByYW5kb20oKSArIDg2XG4gICAgICBjb25zdCBoID0gMzYwICogcmFuZG9tKClcbiAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGwsIGMsIGgsICdsY2gnKVxuICAgICAgcmV0dXJuIGNvbG9yXG4gICAgfSBlbHNlIGlmIChtb2RlID09PSAncmdiJykge1xuICAgICAgY29uc3QgciA9IDI1NSAqIHJhbmRvbSgpXG4gICAgICBjb25zdCBnID0gMjU1ICogcmFuZG9tKClcbiAgICAgIGNvbnN0IGIgPSAyNTUgKiByYW5kb20oKVxuICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IociwgZywgYilcbiAgICAgIHJldHVybiBjb2xvclxuICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2xhYicpIHtcbiAgICAgIGNvbnN0IGwgPSAxMDAgKiByYW5kb20oKVxuICAgICAgY29uc3QgYSA9IDI1NiAqIHJhbmRvbSgpIC0gMTI4XG4gICAgICBjb25zdCBiID0gMjU2ICogcmFuZG9tKCkgLSAxMjhcbiAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGwsIGEsIGIsICdsYWInKVxuICAgICAgcmV0dXJuIGNvbG9yXG4gICAgfSBlbHNlIGlmIChtb2RlID09PSAnZ3JleScpIHtcbiAgICAgIGNvbnN0IGdyZXkgPSAyNTUgKiByYW5kb20oKVxuICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IoZ3JleSwgZ3JleSwgZ3JleSlcbiAgICAgIHJldHVybiBjb2xvclxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHJhbmRvbSBjb2xvciBtb2RlJylcbiAgICB9XG4gIH1cblxuICAvLyBUZXN0IGlmIGdpdmVuIHZhbHVlIGlzIGEgY29sb3Igc3RyaW5nXG4gIHN0YXRpYyB0ZXN0KGNvbG9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycgJiYgKGlzSGV4LnRlc3QoY29sb3IpIHx8IGlzUmdiLnRlc3QoY29sb3IpKVxuICB9XG5cbiAgY215aygpIHtcbiAgICAvLyBHZXQgdGhlIHJnYiB2YWx1ZXMgZm9yIHRoZSBjdXJyZW50IGNvbG9yXG4gICAgY29uc3QgeyBfYSwgX2IsIF9jIH0gPSB0aGlzLnJnYigpXG4gICAgY29uc3QgW3IsIGcsIGJdID0gW19hLCBfYiwgX2NdLm1hcCgodikgPT4gdiAvIDI1NSlcblxuICAgIC8vIEdldCB0aGUgY215ayB2YWx1ZXMgaW4gYW4gdW5ib3VuZGVkIGZvcm1hdFxuICAgIGNvbnN0IGsgPSBNYXRoLm1pbigxIC0gciwgMSAtIGcsIDEgLSBiKVxuXG4gICAgaWYgKGsgPT09IDEpIHtcbiAgICAgIC8vIENhdGNoIHRoZSBibGFjayBjYXNlXG4gICAgICByZXR1cm4gbmV3IENvbG9yKDAsIDAsIDAsIDEsICdjbXlrJylcbiAgICB9XG5cbiAgICBjb25zdCBjID0gKDEgLSByIC0gaykgLyAoMSAtIGspXG4gICAgY29uc3QgbSA9ICgxIC0gZyAtIGspIC8gKDEgLSBrKVxuICAgIGNvbnN0IHkgPSAoMSAtIGIgLSBrKSAvICgxIC0gaylcblxuICAgIC8vIENvbnN0cnVjdCB0aGUgbmV3IGNvbG9yXG4gICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IoYywgbSwgeSwgaywgJ2NteWsnKVxuICAgIHJldHVybiBjb2xvclxuICB9XG5cbiAgaHNsKCkge1xuICAgIC8vIEdldCB0aGUgcmdiIHZhbHVlc1xuICAgIGNvbnN0IHsgX2EsIF9iLCBfYyB9ID0gdGhpcy5yZ2IoKVxuICAgIGNvbnN0IFtyLCBnLCBiXSA9IFtfYSwgX2IsIF9jXS5tYXAoKHYpID0+IHYgLyAyNTUpXG5cbiAgICAvLyBGaW5kIHRoZSBtYXhpbXVtIGFuZCBtaW5pbXVtIHZhbHVlcyB0byBnZXQgdGhlIGxpZ2h0bmVzc1xuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpXG4gICAgY29uc3QgbWluID0gTWF0aC5taW4ociwgZywgYilcbiAgICBjb25zdCBsID0gKG1heCArIG1pbikgLyAyXG5cbiAgICAvLyBJZiB0aGUgciwgZywgdiB2YWx1ZXMgYXJlIGlkZW50aWNhbCB0aGVuIHdlIGFyZSBncmV5XG4gICAgY29uc3QgaXNHcmV5ID0gbWF4ID09PSBtaW5cblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgaHVlIGFuZCBzYXR1cmF0aW9uXG4gICAgY29uc3QgZGVsdGEgPSBtYXggLSBtaW5cbiAgICBjb25zdCBzID0gaXNHcmV5XG4gICAgICA/IDBcbiAgICAgIDogbCA+IDAuNVxuICAgICAgICA/IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pXG4gICAgICAgIDogZGVsdGEgLyAobWF4ICsgbWluKVxuICAgIGNvbnN0IGggPSBpc0dyZXlcbiAgICAgID8gMFxuICAgICAgOiBtYXggPT09IHJcbiAgICAgICAgPyAoKGcgLSBiKSAvIGRlbHRhICsgKGcgPCBiID8gNiA6IDApKSAvIDZcbiAgICAgICAgOiBtYXggPT09IGdcbiAgICAgICAgICA/ICgoYiAtIHIpIC8gZGVsdGEgKyAyKSAvIDZcbiAgICAgICAgICA6IG1heCA9PT0gYlxuICAgICAgICAgICAgPyAoKHIgLSBnKSAvIGRlbHRhICsgNCkgLyA2XG4gICAgICAgICAgICA6IDBcblxuICAgIC8vIENvbnN0cnVjdCBhbmQgcmV0dXJuIHRoZSBuZXcgY29sb3JcbiAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcigzNjAgKiBoLCAxMDAgKiBzLCAxMDAgKiBsLCAnaHNsJylcbiAgICByZXR1cm4gY29sb3JcbiAgfVxuXG4gIGluaXQoYSA9IDAsIGIgPSAwLCBjID0gMCwgZCA9IDAsIHNwYWNlID0gJ3JnYicpIHtcbiAgICAvLyBUaGlzIGNhdGNoZXMgdGhlIGNhc2Ugd2hlbiBhIGZhbHN5IHZhbHVlIGlzIHBhc3NlZCBsaWtlICcnXG4gICAgYSA9ICFhID8gMCA6IGFcblxuICAgIC8vIFJlc2V0IGFsbCB2YWx1ZXMgaW4gY2FzZSB0aGUgaW5pdCBmdW5jdGlvbiBpcyByZXJ1biB3aXRoIG5ldyBjb2xvciBzcGFjZVxuICAgIGlmICh0aGlzLnNwYWNlKSB7XG4gICAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBpbiB0aGlzLnNwYWNlKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzW3RoaXMuc3BhY2VbY29tcG9uZW50XV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGEgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBBbGxvdyBmb3IgdGhlIGNhc2UgdGhhdCB3ZSBkb24ndCBuZWVkIGQuLi5cbiAgICAgIHNwYWNlID0gdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gZCA6IHNwYWNlXG4gICAgICBkID0gdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gMCA6IGRcblxuICAgICAgLy8gQXNzaWduIHRoZSB2YWx1ZXMgc3RyYWlnaHQgdG8gdGhlIGNvbG9yXG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgX2E6IGEsIF9iOiBiLCBfYzogYywgX2Q6IGQsIHNwYWNlIH0pXG4gICAgICAvLyBJZiB0aGUgdXNlciBnYXZlIHVzIGFuIGFycmF5LCBtYWtlIHRoZSBjb2xvciBmcm9tIGl0XG4gICAgfSBlbHNlIGlmIChhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHRoaXMuc3BhY2UgPSBiIHx8ICh0eXBlb2YgYVszXSA9PT0gJ3N0cmluZycgPyBhWzNdIDogYVs0XSkgfHwgJ3JnYidcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBfYTogYVswXSwgX2I6IGFbMV0sIF9jOiBhWzJdLCBfZDogYVszXSB8fCAwIH0pXG4gICAgfSBlbHNlIGlmIChhIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAvLyBTZXQgdGhlIG9iamVjdCB1cCBhbmQgYXNzaWduIGl0cyB2YWx1ZXMgZGlyZWN0bHlcbiAgICAgIGNvbnN0IHZhbHVlcyA9IGdldFBhcmFtZXRlcnMoYSwgYilcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgdmFsdWVzKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoaXNSZ2IudGVzdChhKSkge1xuICAgICAgICBjb25zdCBub1doaXRlc3BhY2UgPSBhLnJlcGxhY2Uod2hpdGVzcGFjZSwgJycpXG4gICAgICAgIGNvbnN0IFtfYSwgX2IsIF9jXSA9IHJnYlxuICAgICAgICAgIC5leGVjKG5vV2hpdGVzcGFjZSlcbiAgICAgICAgICAuc2xpY2UoMSwgNClcbiAgICAgICAgICAubWFwKCh2KSA9PiBwYXJzZUludCh2KSlcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IF9hLCBfYiwgX2MsIF9kOiAwLCBzcGFjZTogJ3JnYicgfSlcbiAgICAgIH0gZWxzZSBpZiAoaXNIZXgudGVzdChhKSkge1xuICAgICAgICBjb25zdCBoZXhQYXJzZSA9ICh2KSA9PiBwYXJzZUludCh2LCAxNilcbiAgICAgICAgY29uc3QgWywgX2EsIF9iLCBfY10gPSBoZXguZXhlYyhzaXhEaWdpdEhleChhKSkubWFwKGhleFBhcnNlKVxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgX2EsIF9iLCBfYywgX2Q6IDAsIHNwYWNlOiAncmdiJyB9KVxuICAgICAgfSBlbHNlIHRocm93IEVycm9yKFwiVW5zdXBwb3J0ZWQgc3RyaW5nIGZvcm1hdCwgY2FuJ3QgY29uc3RydWN0IENvbG9yXCIpXG4gICAgfVxuXG4gICAgLy8gTm93IGFkZCB0aGUgY29tcG9uZW50cyBhcyBhIGNvbnZlbmllbmNlXG4gICAgY29uc3QgeyBfYSwgX2IsIF9jLCBfZCB9ID0gdGhpc1xuICAgIGNvbnN0IGNvbXBvbmVudHMgPVxuICAgICAgdGhpcy5zcGFjZSA9PT0gJ3JnYidcbiAgICAgICAgPyB7IHI6IF9hLCBnOiBfYiwgYjogX2MgfVxuICAgICAgICA6IHRoaXMuc3BhY2UgPT09ICd4eXonXG4gICAgICAgICAgPyB7IHg6IF9hLCB5OiBfYiwgejogX2MgfVxuICAgICAgICAgIDogdGhpcy5zcGFjZSA9PT0gJ2hzbCdcbiAgICAgICAgICAgID8geyBoOiBfYSwgczogX2IsIGw6IF9jIH1cbiAgICAgICAgICAgIDogdGhpcy5zcGFjZSA9PT0gJ2xhYidcbiAgICAgICAgICAgICAgPyB7IGw6IF9hLCBhOiBfYiwgYjogX2MgfVxuICAgICAgICAgICAgICA6IHRoaXMuc3BhY2UgPT09ICdsY2gnXG4gICAgICAgICAgICAgICAgPyB7IGw6IF9hLCBjOiBfYiwgaDogX2MgfVxuICAgICAgICAgICAgICAgIDogdGhpcy5zcGFjZSA9PT0gJ2NteWsnXG4gICAgICAgICAgICAgICAgICA/IHsgYzogX2EsIG06IF9iLCB5OiBfYywgazogX2QgfVxuICAgICAgICAgICAgICAgICAgOiB7fVxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgY29tcG9uZW50cylcbiAgfVxuXG4gIGxhYigpIHtcbiAgICAvLyBHZXQgdGhlIHh5eiBjb2xvclxuICAgIGNvbnN0IHsgeCwgeSwgeiB9ID0gdGhpcy54eXooKVxuXG4gICAgLy8gR2V0IHRoZSBsYWIgY29tcG9uZW50c1xuICAgIGNvbnN0IGwgPSAxMTYgKiB5IC0gMTZcbiAgICBjb25zdCBhID0gNTAwICogKHggLSB5KVxuICAgIGNvbnN0IGIgPSAyMDAgKiAoeSAtIHopXG5cbiAgICAvLyBDb25zdHJ1Y3QgYW5kIHJldHVybiBhIG5ldyBjb2xvclxuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGwsIGEsIGIsICdsYWInKVxuICAgIHJldHVybiBjb2xvclxuICB9XG5cbiAgbGNoKCkge1xuICAgIC8vIEdldCB0aGUgbGFiIGNvbG9yIGRpcmVjdGx5XG4gICAgY29uc3QgeyBsLCBhLCBiIH0gPSB0aGlzLmxhYigpXG5cbiAgICAvLyBHZXQgdGhlIGNocm9tYXRpY2l0eSBhbmQgdGhlIGh1ZSB1c2luZyBwb2xhciBjb29yZGluYXRlc1xuICAgIGNvbnN0IGMgPSBNYXRoLnNxcnQoYSAqKiAyICsgYiAqKiAyKVxuICAgIGxldCBoID0gKDE4MCAqIE1hdGguYXRhbjIoYiwgYSkpIC8gTWF0aC5QSVxuICAgIGlmIChoIDwgMCkge1xuICAgICAgaCAqPSAtMVxuICAgICAgaCA9IDM2MCAtIGhcbiAgICB9XG5cbiAgICAvLyBNYWtlIGEgbmV3IGNvbG9yIGFuZCByZXR1cm4gaXRcbiAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihsLCBjLCBoLCAnbGNoJylcbiAgICByZXR1cm4gY29sb3JcbiAgfVxuICAvKlxuICBDb252ZXJzaW9uIE1ldGhvZHNcbiAgKi9cblxuICByZ2IoKSB7XG4gICAgaWYgKHRoaXMuc3BhY2UgPT09ICdyZ2InKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0gZWxzZSBpZiAoY2llU3BhY2UodGhpcy5zcGFjZSkpIHtcbiAgICAgIC8vIENvbnZlcnQgdG8gdGhlIHh5eiBjb2xvciBzcGFjZVxuICAgICAgbGV0IHsgeCwgeSwgeiB9ID0gdGhpc1xuICAgICAgaWYgKHRoaXMuc3BhY2UgPT09ICdsYWInIHx8IHRoaXMuc3BhY2UgPT09ICdsY2gnKSB7XG4gICAgICAgIC8vIEdldCB0aGUgdmFsdWVzIGluIHRoZSBsYWIgc3BhY2VcbiAgICAgICAgbGV0IHsgbCwgYSwgYiB9ID0gdGhpc1xuICAgICAgICBpZiAodGhpcy5zcGFjZSA9PT0gJ2xjaCcpIHtcbiAgICAgICAgICBjb25zdCB7IGMsIGggfSA9IHRoaXNcbiAgICAgICAgICBjb25zdCBkVG9SID0gTWF0aC5QSSAvIDE4MFxuICAgICAgICAgIGEgPSBjICogTWF0aC5jb3MoZFRvUiAqIGgpXG4gICAgICAgICAgYiA9IGMgKiBNYXRoLnNpbihkVG9SICogaClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVuZG8gdGhlIG5vbmxpbmVhciBmdW5jdGlvblxuICAgICAgICBjb25zdCB5TCA9IChsICsgMTYpIC8gMTE2XG4gICAgICAgIGNvbnN0IHhMID0gYSAvIDUwMCArIHlMXG4gICAgICAgIGNvbnN0IHpMID0geUwgLSBiIC8gMjAwXG5cbiAgICAgICAgLy8gR2V0IHRoZSB4eXogdmFsdWVzXG4gICAgICAgIGNvbnN0IGN0ID0gMTYgLyAxMTZcbiAgICAgICAgY29uc3QgbXggPSAwLjAwODg1NlxuICAgICAgICBjb25zdCBubSA9IDcuNzg3XG4gICAgICAgIHggPSAwLjk1MDQ3ICogKHhMICoqIDMgPiBteCA/IHhMICoqIDMgOiAoeEwgLSBjdCkgLyBubSlcbiAgICAgICAgeSA9IDEuMCAqICh5TCAqKiAzID4gbXggPyB5TCAqKiAzIDogKHlMIC0gY3QpIC8gbm0pXG4gICAgICAgIHogPSAxLjA4ODgzICogKHpMICoqIDMgPiBteCA/IHpMICoqIDMgOiAoekwgLSBjdCkgLyBubSlcbiAgICAgIH1cblxuICAgICAgLy8gQ29udmVydCB4eXogdG8gdW5ib3VuZGVkIHJnYiB2YWx1ZXNcbiAgICAgIGNvbnN0IHJVID0geCAqIDMuMjQwNiArIHkgKiAtMS41MzcyICsgeiAqIC0wLjQ5ODZcbiAgICAgIGNvbnN0IGdVID0geCAqIC0wLjk2ODkgKyB5ICogMS44NzU4ICsgeiAqIDAuMDQxNVxuICAgICAgY29uc3QgYlUgPSB4ICogMC4wNTU3ICsgeSAqIC0wLjIwNCArIHogKiAxLjA1N1xuXG4gICAgICAvLyBDb252ZXJ0IHRoZSB2YWx1ZXMgdG8gdHJ1ZSByZ2IgdmFsdWVzXG4gICAgICBjb25zdCBwb3cgPSBNYXRoLnBvd1xuICAgICAgY29uc3QgYmQgPSAwLjAwMzEzMDhcbiAgICAgIGNvbnN0IHIgPSByVSA+IGJkID8gMS4wNTUgKiBwb3coclUsIDEgLyAyLjQpIC0gMC4wNTUgOiAxMi45MiAqIHJVXG4gICAgICBjb25zdCBnID0gZ1UgPiBiZCA/IDEuMDU1ICogcG93KGdVLCAxIC8gMi40KSAtIDAuMDU1IDogMTIuOTIgKiBnVVxuICAgICAgY29uc3QgYiA9IGJVID4gYmQgPyAxLjA1NSAqIHBvdyhiVSwgMSAvIDIuNCkgLSAwLjA1NSA6IDEyLjkyICogYlVcblxuICAgICAgLy8gTWFrZSBhbmQgcmV0dXJuIHRoZSBjb2xvclxuICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IoMjU1ICogciwgMjU1ICogZywgMjU1ICogYilcbiAgICAgIHJldHVybiBjb2xvclxuICAgIH0gZWxzZSBpZiAodGhpcy5zcGFjZSA9PT0gJ2hzbCcpIHtcbiAgICAgIC8vIGh0dHBzOi8vYmdyaW5zLmdpdGh1Yi5pby9UaW55Q29sb3IvZG9jcy90aW55Y29sb3IuaHRtbFxuICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGhzbCB2YWx1ZXNcbiAgICAgIGxldCB7IGgsIHMsIGwgfSA9IHRoaXNcbiAgICAgIGggLz0gMzYwXG4gICAgICBzIC89IDEwMFxuICAgICAgbCAvPSAxMDBcblxuICAgICAgLy8gSWYgd2UgYXJlIGdyZXksIHRoZW4ganVzdCBtYWtlIHRoZSBjb2xvciBkaXJlY3RseVxuICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgbCAqPSAyNTVcbiAgICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IobCwgbCwgbClcbiAgICAgICAgcmV0dXJuIGNvbG9yXG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE8gSSBoYXZlIG5vIGlkZWEgd2hhdCB0aGlzIGRvZXMgOkQgSWYgeW91IGZpZ3VyZSBpdCBvdXQsIHRlbGwgbWUhXG4gICAgICBjb25zdCBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogc1xuICAgICAgY29uc3QgcCA9IDIgKiBsIC0gcVxuXG4gICAgICAvLyBHZXQgdGhlIHJnYiB2YWx1ZXNcbiAgICAgIGNvbnN0IHIgPSAyNTUgKiBodWVUb1JnYihwLCBxLCBoICsgMSAvIDMpXG4gICAgICBjb25zdCBnID0gMjU1ICogaHVlVG9SZ2IocCwgcSwgaClcbiAgICAgIGNvbnN0IGIgPSAyNTUgKiBodWVUb1JnYihwLCBxLCBoIC0gMSAvIDMpXG5cbiAgICAgIC8vIE1ha2UgYSBuZXcgY29sb3JcbiAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKHIsIGcsIGIpXG4gICAgICByZXR1cm4gY29sb3JcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3BhY2UgPT09ICdjbXlrJykge1xuICAgICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZmVsaXBlc2FiaW5vLzUwNjYzMzZcbiAgICAgIC8vIEdldCB0aGUgbm9ybWFsaXNlZCBjbXlrIHZhbHVlc1xuICAgICAgY29uc3QgeyBjLCBtLCB5LCBrIH0gPSB0aGlzXG5cbiAgICAgIC8vIEdldCB0aGUgcmdiIHZhbHVlc1xuICAgICAgY29uc3QgciA9IDI1NSAqICgxIC0gTWF0aC5taW4oMSwgYyAqICgxIC0gaykgKyBrKSlcbiAgICAgIGNvbnN0IGcgPSAyNTUgKiAoMSAtIE1hdGgubWluKDEsIG0gKiAoMSAtIGspICsgaykpXG4gICAgICBjb25zdCBiID0gMjU1ICogKDEgLSBNYXRoLm1pbigxLCB5ICogKDEgLSBrKSArIGspKVxuXG4gICAgICAvLyBGb3JtIHRoZSBjb2xvciBhbmQgcmV0dXJuIGl0XG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihyLCBnLCBiKVxuICAgICAgcmV0dXJuIGNvbG9yXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICB9XG5cbiAgdG9BcnJheSgpIHtcbiAgICBjb25zdCB7IF9hLCBfYiwgX2MsIF9kLCBzcGFjZSB9ID0gdGhpc1xuICAgIHJldHVybiBbX2EsIF9iLCBfYywgX2QsIHNwYWNlXVxuICB9XG5cbiAgdG9IZXgoKSB7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5fY2xhbXBlZCgpLm1hcChjb21wb25lbnRIZXgpXG4gICAgcmV0dXJuIGAjJHtyfSR7Z30ke2J9YFxuICB9XG5cbiAgdG9SZ2IoKSB7XG4gICAgY29uc3QgW3JWLCBnViwgYlZdID0gdGhpcy5fY2xhbXBlZCgpXG4gICAgY29uc3Qgc3RyaW5nID0gYHJnYigke3JWfSwke2dWfSwke2JWfSlgXG4gICAgcmV0dXJuIHN0cmluZ1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9IZXgoKVxuICB9XG5cbiAgeHl6KCkge1xuICAgIC8vIE5vcm1hbGlzZSB0aGUgcmVkLCBncmVlbiBhbmQgYmx1ZSB2YWx1ZXNcbiAgICBjb25zdCB7IF9hOiByMjU1LCBfYjogZzI1NSwgX2M6IGIyNTUgfSA9IHRoaXMucmdiKClcbiAgICBjb25zdCBbciwgZywgYl0gPSBbcjI1NSwgZzI1NSwgYjI1NV0ubWFwKCh2KSA9PiB2IC8gMjU1KVxuXG4gICAgLy8gQ29udmVydCB0byB0aGUgbGFiIHJnYiBzcGFjZVxuICAgIGNvbnN0IHJMID0gciA+IDAuMDQwNDUgPyBNYXRoLnBvdygociArIDAuMDU1KSAvIDEuMDU1LCAyLjQpIDogciAvIDEyLjkyXG4gICAgY29uc3QgZ0wgPSBnID4gMC4wNDA0NSA/IE1hdGgucG93KChnICsgMC4wNTUpIC8gMS4wNTUsIDIuNCkgOiBnIC8gMTIuOTJcbiAgICBjb25zdCBiTCA9IGIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKGIgKyAwLjA1NSkgLyAxLjA1NSwgMi40KSA6IGIgLyAxMi45MlxuXG4gICAgLy8gQ29udmVydCB0byB0aGUgeHl6IGNvbG9yIHNwYWNlIHdpdGhvdXQgYm91bmRpbmcgdGhlIHZhbHVlc1xuICAgIGNvbnN0IHhVID0gKHJMICogMC40MTI0ICsgZ0wgKiAwLjM1NzYgKyBiTCAqIDAuMTgwNSkgLyAwLjk1MDQ3XG4gICAgY29uc3QgeVUgPSAockwgKiAwLjIxMjYgKyBnTCAqIDAuNzE1MiArIGJMICogMC4wNzIyKSAvIDEuMFxuICAgIGNvbnN0IHpVID0gKHJMICogMC4wMTkzICsgZ0wgKiAwLjExOTIgKyBiTCAqIDAuOTUwNSkgLyAxLjA4ODgzXG5cbiAgICAvLyBHZXQgdGhlIHByb3BlciB4eXogdmFsdWVzIGJ5IGFwcGx5aW5nIHRoZSBib3VuZGluZ1xuICAgIGNvbnN0IHggPSB4VSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeFUsIDEgLyAzKSA6IDcuNzg3ICogeFUgKyAxNiAvIDExNlxuICAgIGNvbnN0IHkgPSB5VSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeVUsIDEgLyAzKSA6IDcuNzg3ICogeVUgKyAxNiAvIDExNlxuICAgIGNvbnN0IHogPSB6VSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coelUsIDEgLyAzKSA6IDcuNzg3ICogelUgKyAxNiAvIDExNlxuXG4gICAgLy8gTWFrZSBhbmQgcmV0dXJuIHRoZSBjb2xvclxuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKHgsIHksIHosICd4eXonKVxuICAgIHJldHVybiBjb2xvclxuICB9XG5cbiAgLypcbiAgSW5wdXQgYW5kIE91dHB1dCBtZXRob2RzXG4gICovXG5cbiAgX2NsYW1wZWQoKSB7XG4gICAgY29uc3QgeyBfYSwgX2IsIF9jIH0gPSB0aGlzLnJnYigpXG4gICAgY29uc3QgeyBtYXgsIG1pbiwgcm91bmQgfSA9IE1hdGhcbiAgICBjb25zdCBmb3JtYXQgPSAodikgPT4gbWF4KDAsIG1pbihyb3VuZCh2KSwgMjU1KSlcbiAgICByZXR1cm4gW19hLCBfYiwgX2NdLm1hcChmb3JtYXQpXG4gIH1cblxuICAvKlxuICBDb25zdHJ1Y3RpbmcgY29sb3JzXG4gICovXG59XG4iLCJpbXBvcnQgTWF0cml4IGZyb20gJy4vTWF0cml4LmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2ludCB7XG4gIC8vIEluaXRpYWxpemVcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHRoaXMuaW5pdCguLi5hcmdzKVxuICB9XG5cbiAgLy8gQ2xvbmUgcG9pbnRcbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzKVxuICB9XG5cbiAgaW5pdCh4LCB5KSB7XG4gICAgY29uc3QgYmFzZSA9IHsgeDogMCwgeTogMCB9XG5cbiAgICAvLyBlbnN1cmUgc291cmNlIGFzIG9iamVjdFxuICAgIGNvbnN0IHNvdXJjZSA9IEFycmF5LmlzQXJyYXkoeClcbiAgICAgID8geyB4OiB4WzBdLCB5OiB4WzFdIH1cbiAgICAgIDogdHlwZW9mIHggPT09ICdvYmplY3QnXG4gICAgICAgID8geyB4OiB4LngsIHk6IHgueSB9XG4gICAgICAgIDogeyB4OiB4LCB5OiB5IH1cblxuICAgIC8vIG1lcmdlIHNvdXJjZVxuICAgIHRoaXMueCA9IHNvdXJjZS54ID09IG51bGwgPyBiYXNlLnggOiBzb3VyY2UueFxuICAgIHRoaXMueSA9IHNvdXJjZS55ID09IG51bGwgPyBiYXNlLnkgOiBzb3VyY2UueVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIFt0aGlzLngsIHRoaXMueV1cbiAgfVxuXG4gIHRyYW5zZm9ybShtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS50cmFuc2Zvcm1PKG0pXG4gIH1cblxuICAvLyBUcmFuc2Zvcm0gcG9pbnQgd2l0aCBtYXRyaXhcbiAgdHJhbnNmb3JtTyhtKSB7XG4gICAgaWYgKCFNYXRyaXguaXNNYXRyaXhMaWtlKG0pKSB7XG4gICAgICBtID0gbmV3IE1hdHJpeChtKVxuICAgIH1cblxuICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpc1xuXG4gICAgLy8gUGVyZm9ybSB0aGUgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgdGhpcy54ID0gbS5hICogeCArIG0uYyAqIHkgKyBtLmVcbiAgICB0aGlzLnkgPSBtLmIgKiB4ICsgbS5kICogeSArIG0uZlxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICByZXR1cm4gbmV3IFBvaW50KHgsIHkpLnRyYW5zZm9ybU8odGhpcy5zY3JlZW5DVE0oKS5pbnZlcnNlTygpKVxufVxuIiwiaW1wb3J0IHsgZGVsaW1pdGVyIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3JlZ2V4LmpzJ1xuaW1wb3J0IHsgcmFkaWFucyB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXIgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vZWxlbWVudHMvRWxlbWVudC5qcydcbmltcG9ydCBQb2ludCBmcm9tICcuL1BvaW50LmpzJ1xuXG5mdW5jdGlvbiBjbG9zZUVub3VnaChhLCBiLCB0aHJlc2hvbGQpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGIgLSBhKSA8ICh0aHJlc2hvbGQgfHwgMWUtNilcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF0cml4IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHRoaXMuaW5pdCguLi5hcmdzKVxuICB9XG5cbiAgc3RhdGljIGZvcm1hdFRyYW5zZm9ybXMobykge1xuICAgIC8vIEdldCBhbGwgb2YgdGhlIHBhcmFtZXRlcnMgcmVxdWlyZWQgdG8gZm9ybSB0aGUgbWF0cml4XG4gICAgY29uc3QgZmxpcEJvdGggPSBvLmZsaXAgPT09ICdib3RoJyB8fCBvLmZsaXAgPT09IHRydWVcbiAgICBjb25zdCBmbGlwWCA9IG8uZmxpcCAmJiAoZmxpcEJvdGggfHwgby5mbGlwID09PSAneCcpID8gLTEgOiAxXG4gICAgY29uc3QgZmxpcFkgPSBvLmZsaXAgJiYgKGZsaXBCb3RoIHx8IG8uZmxpcCA9PT0gJ3knKSA/IC0xIDogMVxuICAgIGNvbnN0IHNrZXdYID1cbiAgICAgIG8uc2tldyAmJiBvLnNrZXcubGVuZ3RoXG4gICAgICAgID8gby5za2V3WzBdXG4gICAgICAgIDogaXNGaW5pdGUoby5za2V3KVxuICAgICAgICAgID8gby5za2V3XG4gICAgICAgICAgOiBpc0Zpbml0ZShvLnNrZXdYKVxuICAgICAgICAgICAgPyBvLnNrZXdYXG4gICAgICAgICAgICA6IDBcbiAgICBjb25zdCBza2V3WSA9XG4gICAgICBvLnNrZXcgJiYgby5za2V3Lmxlbmd0aFxuICAgICAgICA/IG8uc2tld1sxXVxuICAgICAgICA6IGlzRmluaXRlKG8uc2tldylcbiAgICAgICAgICA/IG8uc2tld1xuICAgICAgICAgIDogaXNGaW5pdGUoby5za2V3WSlcbiAgICAgICAgICAgID8gby5za2V3WVxuICAgICAgICAgICAgOiAwXG4gICAgY29uc3Qgc2NhbGVYID1cbiAgICAgIG8uc2NhbGUgJiYgby5zY2FsZS5sZW5ndGhcbiAgICAgICAgPyBvLnNjYWxlWzBdICogZmxpcFhcbiAgICAgICAgOiBpc0Zpbml0ZShvLnNjYWxlKVxuICAgICAgICAgID8gby5zY2FsZSAqIGZsaXBYXG4gICAgICAgICAgOiBpc0Zpbml0ZShvLnNjYWxlWClcbiAgICAgICAgICAgID8gby5zY2FsZVggKiBmbGlwWFxuICAgICAgICAgICAgOiBmbGlwWFxuICAgIGNvbnN0IHNjYWxlWSA9XG4gICAgICBvLnNjYWxlICYmIG8uc2NhbGUubGVuZ3RoXG4gICAgICAgID8gby5zY2FsZVsxXSAqIGZsaXBZXG4gICAgICAgIDogaXNGaW5pdGUoby5zY2FsZSlcbiAgICAgICAgICA/IG8uc2NhbGUgKiBmbGlwWVxuICAgICAgICAgIDogaXNGaW5pdGUoby5zY2FsZVkpXG4gICAgICAgICAgICA/IG8uc2NhbGVZICogZmxpcFlcbiAgICAgICAgICAgIDogZmxpcFlcbiAgICBjb25zdCBzaGVhciA9IG8uc2hlYXIgfHwgMFxuICAgIGNvbnN0IHRoZXRhID0gby5yb3RhdGUgfHwgby50aGV0YSB8fCAwXG4gICAgY29uc3Qgb3JpZ2luID0gbmV3IFBvaW50KFxuICAgICAgby5vcmlnaW4gfHwgby5hcm91bmQgfHwgby5veCB8fCBvLm9yaWdpblgsXG4gICAgICBvLm95IHx8IG8ub3JpZ2luWVxuICAgIClcbiAgICBjb25zdCBveCA9IG9yaWdpbi54XG4gICAgY29uc3Qgb3kgPSBvcmlnaW4ueVxuICAgIC8vIFdlIG5lZWQgUG9pbnQgdG8gYmUgaW52YWxpZCBpZiBub3RoaW5nIHdhcyBwYXNzZWQgYmVjYXVzZSB3ZSBjYW5ub3QgZGVmYXVsdCB0byAwIGhlcmUuIFRoYXQgaXMgd2h5IE5hTlxuICAgIGNvbnN0IHBvc2l0aW9uID0gbmV3IFBvaW50KFxuICAgICAgby5wb3NpdGlvbiB8fCBvLnB4IHx8IG8ucG9zaXRpb25YIHx8IE5hTixcbiAgICAgIG8ucHkgfHwgby5wb3NpdGlvblkgfHwgTmFOXG4gICAgKVxuICAgIGNvbnN0IHB4ID0gcG9zaXRpb24ueFxuICAgIGNvbnN0IHB5ID0gcG9zaXRpb24ueVxuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IG5ldyBQb2ludChcbiAgICAgIG8udHJhbnNsYXRlIHx8IG8udHggfHwgby50cmFuc2xhdGVYLFxuICAgICAgby50eSB8fCBvLnRyYW5zbGF0ZVlcbiAgICApXG4gICAgY29uc3QgdHggPSB0cmFuc2xhdGUueFxuICAgIGNvbnN0IHR5ID0gdHJhbnNsYXRlLnlcbiAgICBjb25zdCByZWxhdGl2ZSA9IG5ldyBQb2ludChcbiAgICAgIG8ucmVsYXRpdmUgfHwgby5yeCB8fCBvLnJlbGF0aXZlWCxcbiAgICAgIG8ucnkgfHwgby5yZWxhdGl2ZVlcbiAgICApXG4gICAgY29uc3QgcnggPSByZWxhdGl2ZS54XG4gICAgY29uc3QgcnkgPSByZWxhdGl2ZS55XG5cbiAgICAvLyBQb3B1bGF0ZSBhbGwgb2YgdGhlIHZhbHVlc1xuICAgIHJldHVybiB7XG4gICAgICBzY2FsZVgsXG4gICAgICBzY2FsZVksXG4gICAgICBza2V3WCxcbiAgICAgIHNrZXdZLFxuICAgICAgc2hlYXIsXG4gICAgICB0aGV0YSxcbiAgICAgIHJ4LFxuICAgICAgcnksXG4gICAgICB0eCxcbiAgICAgIHR5LFxuICAgICAgb3gsXG4gICAgICBveSxcbiAgICAgIHB4LFxuICAgICAgcHlcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZnJvbUFycmF5KGEpIHtcbiAgICByZXR1cm4geyBhOiBhWzBdLCBiOiBhWzFdLCBjOiBhWzJdLCBkOiBhWzNdLCBlOiBhWzRdLCBmOiBhWzVdIH1cbiAgfVxuXG4gIHN0YXRpYyBpc01hdHJpeExpa2Uobykge1xuICAgIHJldHVybiAoXG4gICAgICBvLmEgIT0gbnVsbCB8fFxuICAgICAgby5iICE9IG51bGwgfHxcbiAgICAgIG8uYyAhPSBudWxsIHx8XG4gICAgICBvLmQgIT0gbnVsbCB8fFxuICAgICAgby5lICE9IG51bGwgfHxcbiAgICAgIG8uZiAhPSBudWxsXG4gICAgKVxuICB9XG5cbiAgLy8gbGVmdCBtYXRyaXgsIHJpZ2h0IG1hdHJpeCwgdGFyZ2V0IG1hdHJpeCB3aGljaCBpcyBvdmVyd3JpdHRlblxuICBzdGF0aWMgbWF0cml4TXVsdGlwbHkobCwgciwgbykge1xuICAgIC8vIFdvcmsgb3V0IHRoZSBwcm9kdWN0IGRpcmVjdGx5XG4gICAgY29uc3QgYSA9IGwuYSAqIHIuYSArIGwuYyAqIHIuYlxuICAgIGNvbnN0IGIgPSBsLmIgKiByLmEgKyBsLmQgKiByLmJcbiAgICBjb25zdCBjID0gbC5hICogci5jICsgbC5jICogci5kXG4gICAgY29uc3QgZCA9IGwuYiAqIHIuYyArIGwuZCAqIHIuZFxuICAgIGNvbnN0IGUgPSBsLmUgKyBsLmEgKiByLmUgKyBsLmMgKiByLmZcbiAgICBjb25zdCBmID0gbC5mICsgbC5iICogci5lICsgbC5kICogci5mXG5cbiAgICAvLyBtYWtlIHN1cmUgdG8gdXNlIGxvY2FsIHZhcmlhYmxlcyBiZWNhdXNlIGwvciBhbmQgbyBjb3VsZCBiZSB0aGUgc2FtZVxuICAgIG8uYSA9IGFcbiAgICBvLmIgPSBiXG4gICAgby5jID0gY1xuICAgIG8uZCA9IGRcbiAgICBvLmUgPSBlXG4gICAgby5mID0gZlxuXG4gICAgcmV0dXJuIG9cbiAgfVxuXG4gIGFyb3VuZChjeCwgY3ksIG1hdHJpeCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuYXJvdW5kTyhjeCwgY3ksIG1hdHJpeClcbiAgfVxuXG4gIC8vIFRyYW5zZm9ybSBhcm91bmQgYSBjZW50ZXIgcG9pbnRcbiAgYXJvdW5kTyhjeCwgY3ksIG1hdHJpeCkge1xuICAgIGNvbnN0IGR4ID0gY3ggfHwgMFxuICAgIGNvbnN0IGR5ID0gY3kgfHwgMFxuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZU8oLWR4LCAtZHkpLmxtdWx0aXBseU8obWF0cml4KS50cmFuc2xhdGVPKGR4LCBkeSlcbiAgfVxuXG4gIC8vIENsb25lcyB0aGlzIG1hdHJpeFxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeCh0aGlzKVxuICB9XG5cbiAgLy8gRGVjb21wb3NlcyB0aGlzIG1hdHJpeCBpbnRvIGl0cyBhZmZpbmUgcGFyYW1ldGVyc1xuICBkZWNvbXBvc2UoY3ggPSAwLCBjeSA9IDApIHtcbiAgICAvLyBHZXQgdGhlIHBhcmFtZXRlcnMgZnJvbSB0aGUgbWF0cml4XG4gICAgY29uc3QgYSA9IHRoaXMuYVxuICAgIGNvbnN0IGIgPSB0aGlzLmJcbiAgICBjb25zdCBjID0gdGhpcy5jXG4gICAgY29uc3QgZCA9IHRoaXMuZFxuICAgIGNvbnN0IGUgPSB0aGlzLmVcbiAgICBjb25zdCBmID0gdGhpcy5mXG5cbiAgICAvLyBGaWd1cmUgb3V0IGlmIHRoZSB3aW5kaW5nIGRpcmVjdGlvbiBpcyBjbG9ja3dpc2Ugb3IgY291bnRlcmNsb2Nrd2lzZVxuICAgIGNvbnN0IGRldGVybWluYW50ID0gYSAqIGQgLSBiICogY1xuICAgIGNvbnN0IGNjdyA9IGRldGVybWluYW50ID4gMCA/IDEgOiAtMVxuXG4gICAgLy8gU2luY2Ugd2Ugb25seSBzaGVhciBpbiB4LCB3ZSBjYW4gdXNlIHRoZSB4IGJhc2lzIHRvIGdldCB0aGUgeCBzY2FsZVxuICAgIC8vIGFuZCB0aGUgcm90YXRpb24gb2YgdGhlIHJlc3VsdGluZyBtYXRyaXhcbiAgICBjb25zdCBzeCA9IGNjdyAqIE1hdGguc3FydChhICogYSArIGIgKiBiKVxuICAgIGNvbnN0IHRoZXRhUmFkID0gTWF0aC5hdGFuMihjY3cgKiBiLCBjY3cgKiBhKVxuICAgIGNvbnN0IHRoZXRhID0gKDE4MCAvIE1hdGguUEkpICogdGhldGFSYWRcbiAgICBjb25zdCBjdCA9IE1hdGguY29zKHRoZXRhUmFkKVxuICAgIGNvbnN0IHN0ID0gTWF0aC5zaW4odGhldGFSYWQpXG5cbiAgICAvLyBXZSBjYW4gdGhlbiBzb2x2ZSB0aGUgeSBiYXNpcyB2ZWN0b3Igc2ltdWx0YW5lb3VzbHkgdG8gZ2V0IHRoZSBvdGhlclxuICAgIC8vIHR3byBhZmZpbmUgcGFyYW1ldGVycyBkaXJlY3RseSBmcm9tIHRoZXNlIHBhcmFtZXRlcnNcbiAgICBjb25zdCBsYW0gPSAoYSAqIGMgKyBiICogZCkgLyBkZXRlcm1pbmFudFxuICAgIGNvbnN0IHN5ID0gKGMgKiBzeCkgLyAobGFtICogYSAtIGIpIHx8IChkICogc3gpIC8gKGxhbSAqIGIgKyBhKVxuXG4gICAgLy8gVXNlIHRoZSB0cmFuc2xhdGlvbnNcbiAgICBjb25zdCB0eCA9IGUgLSBjeCArIGN4ICogY3QgKiBzeCArIGN5ICogKGxhbSAqIGN0ICogc3ggLSBzdCAqIHN5KVxuICAgIGNvbnN0IHR5ID0gZiAtIGN5ICsgY3ggKiBzdCAqIHN4ICsgY3kgKiAobGFtICogc3QgKiBzeCArIGN0ICogc3kpXG5cbiAgICAvLyBDb25zdHJ1Y3QgdGhlIGRlY29tcG9zaXRpb24gYW5kIHJldHVybiBpdFxuICAgIHJldHVybiB7XG4gICAgICAvLyBSZXR1cm4gdGhlIGFmZmluZSBwYXJhbWV0ZXJzXG4gICAgICBzY2FsZVg6IHN4LFxuICAgICAgc2NhbGVZOiBzeSxcbiAgICAgIHNoZWFyOiBsYW0sXG4gICAgICByb3RhdGU6IHRoZXRhLFxuICAgICAgdHJhbnNsYXRlWDogdHgsXG4gICAgICB0cmFuc2xhdGVZOiB0eSxcbiAgICAgIG9yaWdpblg6IGN4LFxuICAgICAgb3JpZ2luWTogY3ksXG5cbiAgICAgIC8vIFJldHVybiB0aGUgbWF0cml4IHBhcmFtZXRlcnNcbiAgICAgIGE6IHRoaXMuYSxcbiAgICAgIGI6IHRoaXMuYixcbiAgICAgIGM6IHRoaXMuYyxcbiAgICAgIGQ6IHRoaXMuZCxcbiAgICAgIGU6IHRoaXMuZSxcbiAgICAgIGY6IHRoaXMuZlxuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrIGlmIHR3byBtYXRyaWNlcyBhcmUgZXF1YWxcbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKG90aGVyID09PSB0aGlzKSByZXR1cm4gdHJ1ZVxuICAgIGNvbnN0IGNvbXAgPSBuZXcgTWF0cml4KG90aGVyKVxuICAgIHJldHVybiAoXG4gICAgICBjbG9zZUVub3VnaCh0aGlzLmEsIGNvbXAuYSkgJiZcbiAgICAgIGNsb3NlRW5vdWdoKHRoaXMuYiwgY29tcC5iKSAmJlxuICAgICAgY2xvc2VFbm91Z2godGhpcy5jLCBjb21wLmMpICYmXG4gICAgICBjbG9zZUVub3VnaCh0aGlzLmQsIGNvbXAuZCkgJiZcbiAgICAgIGNsb3NlRW5vdWdoKHRoaXMuZSwgY29tcC5lKSAmJlxuICAgICAgY2xvc2VFbm91Z2godGhpcy5mLCBjb21wLmYpXG4gICAgKVxuICB9XG5cbiAgLy8gRmxpcCBtYXRyaXggb24geCBvciB5LCBhdCBhIGdpdmVuIG9mZnNldFxuICBmbGlwKGF4aXMsIGFyb3VuZCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuZmxpcE8oYXhpcywgYXJvdW5kKVxuICB9XG5cbiAgZmxpcE8oYXhpcywgYXJvdW5kKSB7XG4gICAgcmV0dXJuIGF4aXMgPT09ICd4J1xuICAgICAgPyB0aGlzLnNjYWxlTygtMSwgMSwgYXJvdW5kLCAwKVxuICAgICAgOiBheGlzID09PSAneSdcbiAgICAgICAgPyB0aGlzLnNjYWxlTygxLCAtMSwgMCwgYXJvdW5kKVxuICAgICAgICA6IHRoaXMuc2NhbGVPKC0xLCAtMSwgYXhpcywgYXJvdW5kIHx8IGF4aXMpIC8vIERlZmluZSBhbiB4LCB5IGZsaXAgcG9pbnRcbiAgfVxuXG4gIC8vIEluaXRpYWxpemVcbiAgaW5pdChzb3VyY2UpIHtcbiAgICBjb25zdCBiYXNlID0gTWF0cml4LmZyb21BcnJheShbMSwgMCwgMCwgMSwgMCwgMF0pXG5cbiAgICAvLyBlbnN1cmUgc291cmNlIGFzIG9iamVjdFxuICAgIHNvdXJjZSA9XG4gICAgICBzb3VyY2UgaW5zdGFuY2VvZiBFbGVtZW50XG4gICAgICAgID8gc291cmNlLm1hdHJpeGlmeSgpXG4gICAgICAgIDogdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICA/IE1hdHJpeC5mcm9tQXJyYXkoc291cmNlLnNwbGl0KGRlbGltaXRlcikubWFwKHBhcnNlRmxvYXQpKVxuICAgICAgICAgIDogQXJyYXkuaXNBcnJheShzb3VyY2UpXG4gICAgICAgICAgICA/IE1hdHJpeC5mcm9tQXJyYXkoc291cmNlKVxuICAgICAgICAgICAgOiB0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0JyAmJiBNYXRyaXguaXNNYXRyaXhMaWtlKHNvdXJjZSlcbiAgICAgICAgICAgICAgPyBzb3VyY2VcbiAgICAgICAgICAgICAgOiB0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgICAgID8gbmV3IE1hdHJpeCgpLnRyYW5zZm9ybShzb3VyY2UpXG4gICAgICAgICAgICAgICAgOiBhcmd1bWVudHMubGVuZ3RoID09PSA2XG4gICAgICAgICAgICAgICAgICA/IE1hdHJpeC5mcm9tQXJyYXkoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICAgOiBiYXNlXG5cbiAgICAvLyBNZXJnZSB0aGUgc291cmNlIG1hdHJpeCB3aXRoIHRoZSBiYXNlIG1hdHJpeFxuICAgIHRoaXMuYSA9IHNvdXJjZS5hICE9IG51bGwgPyBzb3VyY2UuYSA6IGJhc2UuYVxuICAgIHRoaXMuYiA9IHNvdXJjZS5iICE9IG51bGwgPyBzb3VyY2UuYiA6IGJhc2UuYlxuICAgIHRoaXMuYyA9IHNvdXJjZS5jICE9IG51bGwgPyBzb3VyY2UuYyA6IGJhc2UuY1xuICAgIHRoaXMuZCA9IHNvdXJjZS5kICE9IG51bGwgPyBzb3VyY2UuZCA6IGJhc2UuZFxuICAgIHRoaXMuZSA9IHNvdXJjZS5lICE9IG51bGwgPyBzb3VyY2UuZSA6IGJhc2UuZVxuICAgIHRoaXMuZiA9IHNvdXJjZS5mICE9IG51bGwgPyBzb3VyY2UuZiA6IGJhc2UuZlxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGludmVyc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbnZlcnNlTygpXG4gIH1cblxuICAvLyBJbnZlcnNlcyBtYXRyaXhcbiAgaW52ZXJzZU8oKSB7XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IHBhcmFtZXRlcnMgb3V0IG9mIHRoZSBtYXRyaXhcbiAgICBjb25zdCBhID0gdGhpcy5hXG4gICAgY29uc3QgYiA9IHRoaXMuYlxuICAgIGNvbnN0IGMgPSB0aGlzLmNcbiAgICBjb25zdCBkID0gdGhpcy5kXG4gICAgY29uc3QgZSA9IHRoaXMuZVxuICAgIGNvbnN0IGYgPSB0aGlzLmZcblxuICAgIC8vIEludmVydCB0aGUgMngyIG1hdHJpeCBpbiB0aGUgdG9wIGxlZnRcbiAgICBjb25zdCBkZXQgPSBhICogZCAtIGIgKiBjXG4gICAgaWYgKCFkZXQpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludmVydCAnICsgdGhpcylcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgdG9wIDJ4MiBtYXRyaXhcbiAgICBjb25zdCBuYSA9IGQgLyBkZXRcbiAgICBjb25zdCBuYiA9IC1iIC8gZGV0XG4gICAgY29uc3QgbmMgPSAtYyAvIGRldFxuICAgIGNvbnN0IG5kID0gYSAvIGRldFxuXG4gICAgLy8gQXBwbHkgdGhlIGludmVydGVkIG1hdHJpeCB0byB0aGUgdG9wIHJpZ2h0XG4gICAgY29uc3QgbmUgPSAtKG5hICogZSArIG5jICogZilcbiAgICBjb25zdCBuZiA9IC0obmIgKiBlICsgbmQgKiBmKVxuXG4gICAgLy8gQ29uc3RydWN0IHRoZSBpbnZlcnRlZCBtYXRyaXhcbiAgICB0aGlzLmEgPSBuYVxuICAgIHRoaXMuYiA9IG5iXG4gICAgdGhpcy5jID0gbmNcbiAgICB0aGlzLmQgPSBuZFxuICAgIHRoaXMuZSA9IG5lXG4gICAgdGhpcy5mID0gbmZcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBsbXVsdGlwbHkobWF0cml4KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sbXVsdGlwbHlPKG1hdHJpeClcbiAgfVxuXG4gIGxtdWx0aXBseU8obWF0cml4KSB7XG4gICAgY29uc3QgciA9IHRoaXNcbiAgICBjb25zdCBsID0gbWF0cml4IGluc3RhbmNlb2YgTWF0cml4ID8gbWF0cml4IDogbmV3IE1hdHJpeChtYXRyaXgpXG5cbiAgICByZXR1cm4gTWF0cml4Lm1hdHJpeE11bHRpcGx5KGwsIHIsIHRoaXMpXG4gIH1cblxuICAvLyBMZWZ0IG11bHRpcGxpZXMgYnkgdGhlIGdpdmVuIG1hdHJpeFxuICBtdWx0aXBseShtYXRyaXgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLm11bHRpcGx5TyhtYXRyaXgpXG4gIH1cblxuICBtdWx0aXBseU8obWF0cml4KSB7XG4gICAgLy8gR2V0IHRoZSBtYXRyaWNlc1xuICAgIGNvbnN0IGwgPSB0aGlzXG4gICAgY29uc3QgciA9IG1hdHJpeCBpbnN0YW5jZW9mIE1hdHJpeCA/IG1hdHJpeCA6IG5ldyBNYXRyaXgobWF0cml4KVxuXG4gICAgcmV0dXJuIE1hdHJpeC5tYXRyaXhNdWx0aXBseShsLCByLCB0aGlzKVxuICB9XG5cbiAgLy8gUm90YXRlIG1hdHJpeFxuICByb3RhdGUociwgY3gsIGN5KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5yb3RhdGVPKHIsIGN4LCBjeSlcbiAgfVxuXG4gIHJvdGF0ZU8ociwgY3ggPSAwLCBjeSA9IDApIHtcbiAgICAvLyBDb252ZXJ0IGRlZ3JlZXMgdG8gcmFkaWFuc1xuICAgIHIgPSByYWRpYW5zKHIpXG5cbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhyKVxuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKHIpXG5cbiAgICBjb25zdCB7IGEsIGIsIGMsIGQsIGUsIGYgfSA9IHRoaXNcblxuICAgIHRoaXMuYSA9IGEgKiBjb3MgLSBiICogc2luXG4gICAgdGhpcy5iID0gYiAqIGNvcyArIGEgKiBzaW5cbiAgICB0aGlzLmMgPSBjICogY29zIC0gZCAqIHNpblxuICAgIHRoaXMuZCA9IGQgKiBjb3MgKyBjICogc2luXG4gICAgdGhpcy5lID0gZSAqIGNvcyAtIGYgKiBzaW4gKyBjeSAqIHNpbiAtIGN4ICogY29zICsgY3hcbiAgICB0aGlzLmYgPSBmICogY29zICsgZSAqIHNpbiAtIGN4ICogc2luIC0gY3kgKiBjb3MgKyBjeVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIFNjYWxlIG1hdHJpeFxuICBzY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnNjYWxlTyguLi5hcmd1bWVudHMpXG4gIH1cblxuICBzY2FsZU8oeCwgeSA9IHgsIGN4ID0gMCwgY3kgPSAwKSB7XG4gICAgLy8gU3VwcG9ydCB1bmlmb3JtIHNjYWxpbmdcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgY3kgPSBjeFxuICAgICAgY3ggPSB5XG4gICAgICB5ID0geFxuICAgIH1cblxuICAgIGNvbnN0IHsgYSwgYiwgYywgZCwgZSwgZiB9ID0gdGhpc1xuXG4gICAgdGhpcy5hID0gYSAqIHhcbiAgICB0aGlzLmIgPSBiICogeVxuICAgIHRoaXMuYyA9IGMgKiB4XG4gICAgdGhpcy5kID0gZCAqIHlcbiAgICB0aGlzLmUgPSBlICogeCAtIGN4ICogeCArIGN4XG4gICAgdGhpcy5mID0gZiAqIHkgLSBjeSAqIHkgKyBjeVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIFNoZWFyIG1hdHJpeFxuICBzaGVhcihhLCBjeCwgY3kpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnNoZWFyTyhhLCBjeCwgY3kpXG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgc2hlYXJPKGx4LCBjeCA9IDAsIGN5ID0gMCkge1xuICAgIGNvbnN0IHsgYSwgYiwgYywgZCwgZSwgZiB9ID0gdGhpc1xuXG4gICAgdGhpcy5hID0gYSArIGIgKiBseFxuICAgIHRoaXMuYyA9IGMgKyBkICogbHhcbiAgICB0aGlzLmUgPSBlICsgZiAqIGx4IC0gY3kgKiBseFxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIFNrZXcgTWF0cml4XG4gIHNrZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5za2V3TyguLi5hcmd1bWVudHMpXG4gIH1cblxuICBza2V3Tyh4LCB5ID0geCwgY3ggPSAwLCBjeSA9IDApIHtcbiAgICAvLyBzdXBwb3J0IHVuaWZvcm1hbCBza2V3XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGN5ID0gY3hcbiAgICAgIGN4ID0geVxuICAgICAgeSA9IHhcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGRlZ3JlZXMgdG8gcmFkaWFuc1xuICAgIHggPSByYWRpYW5zKHgpXG4gICAgeSA9IHJhZGlhbnMoeSlcblxuICAgIGNvbnN0IGx4ID0gTWF0aC50YW4oeClcbiAgICBjb25zdCBseSA9IE1hdGgudGFuKHkpXG5cbiAgICBjb25zdCB7IGEsIGIsIGMsIGQsIGUsIGYgfSA9IHRoaXNcblxuICAgIHRoaXMuYSA9IGEgKyBiICogbHhcbiAgICB0aGlzLmIgPSBiICsgYSAqIGx5XG4gICAgdGhpcy5jID0gYyArIGQgKiBseFxuICAgIHRoaXMuZCA9IGQgKyBjICogbHlcbiAgICB0aGlzLmUgPSBlICsgZiAqIGx4IC0gY3kgKiBseFxuICAgIHRoaXMuZiA9IGYgKyBlICogbHkgLSBjeCAqIGx5XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gU2tld1hcbiAgc2tld1goeCwgY3gsIGN5KSB7XG4gICAgcmV0dXJuIHRoaXMuc2tldyh4LCAwLCBjeCwgY3kpXG4gIH1cblxuICAvLyBTa2V3WVxuICBza2V3WSh5LCBjeCwgY3kpIHtcbiAgICByZXR1cm4gdGhpcy5za2V3KDAsIHksIGN4LCBjeSlcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB0aGlzLmQsIHRoaXMuZSwgdGhpcy5mXVxuICB9XG5cbiAgLy8gQ29udmVydCBtYXRyaXggdG8gc3RyaW5nXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAoXG4gICAgICAnbWF0cml4KCcgK1xuICAgICAgdGhpcy5hICtcbiAgICAgICcsJyArXG4gICAgICB0aGlzLmIgK1xuICAgICAgJywnICtcbiAgICAgIHRoaXMuYyArXG4gICAgICAnLCcgK1xuICAgICAgdGhpcy5kICtcbiAgICAgICcsJyArXG4gICAgICB0aGlzLmUgK1xuICAgICAgJywnICtcbiAgICAgIHRoaXMuZiArXG4gICAgICAnKSdcbiAgICApXG4gIH1cblxuICAvLyBUcmFuc2Zvcm0gYSBtYXRyaXggaW50byBhbm90aGVyIG1hdHJpeCBieSBtYW5pcHVsYXRpbmcgdGhlIHNwYWNlXG4gIHRyYW5zZm9ybShvKSB7XG4gICAgLy8gQ2hlY2sgaWYgbyBpcyBhIG1hdHJpeCBhbmQgdGhlbiBsZWZ0IG11bHRpcGx5IGl0IGRpcmVjdGx5XG4gICAgaWYgKE1hdHJpeC5pc01hdHJpeExpa2UobykpIHtcbiAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXgobylcbiAgICAgIHJldHVybiBtYXRyaXgubXVsdGlwbHlPKHRoaXMpXG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBwcm9wb3NlZCB0cmFuc2Zvcm1hdGlvbnMgYW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uc1xuICAgIGNvbnN0IHQgPSBNYXRyaXguZm9ybWF0VHJhbnNmb3JtcyhvKVxuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzXG4gICAgY29uc3QgeyB4OiBveCwgeTogb3kgfSA9IG5ldyBQb2ludCh0Lm94LCB0Lm95KS50cmFuc2Zvcm0oY3VycmVudClcblxuICAgIC8vIENvbnN0cnVjdCB0aGUgcmVzdWx0aW5nIG1hdHJpeFxuICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gbmV3IE1hdHJpeCgpXG4gICAgICAudHJhbnNsYXRlTyh0LnJ4LCB0LnJ5KVxuICAgICAgLmxtdWx0aXBseU8oY3VycmVudClcbiAgICAgIC50cmFuc2xhdGVPKC1veCwgLW95KVxuICAgICAgLnNjYWxlTyh0LnNjYWxlWCwgdC5zY2FsZVkpXG4gICAgICAuc2tld08odC5za2V3WCwgdC5za2V3WSlcbiAgICAgIC5zaGVhck8odC5zaGVhcilcbiAgICAgIC5yb3RhdGVPKHQudGhldGEpXG4gICAgICAudHJhbnNsYXRlTyhveCwgb3kpXG5cbiAgICAvLyBJZiB3ZSB3YW50IHRoZSBvcmlnaW4gYXQgYSBwYXJ0aWN1bGFyIHBsYWNlLCB3ZSBmb3JjZSBpdCB0aGVyZVxuICAgIGlmIChpc0Zpbml0ZSh0LnB4KSB8fCBpc0Zpbml0ZSh0LnB5KSkge1xuICAgICAgY29uc3Qgb3JpZ2luID0gbmV3IFBvaW50KG94LCBveSkudHJhbnNmb3JtKHRyYW5zZm9ybWVyKVxuICAgICAgLy8gVE9ETzogUmVwbGFjZSB0LnB4IHdpdGggaXNGaW5pdGUodC5weClcbiAgICAgIC8vIERvZXNuJ3Qgd29yayBiZWNhdXNlIHQucHggaXMgYWxzbyAwIGlmIGl0IHdhc24ndCBwYXNzZWRcbiAgICAgIGNvbnN0IGR4ID0gaXNGaW5pdGUodC5weCkgPyB0LnB4IC0gb3JpZ2luLnggOiAwXG4gICAgICBjb25zdCBkeSA9IGlzRmluaXRlKHQucHkpID8gdC5weSAtIG9yaWdpbi55IDogMFxuICAgICAgdHJhbnNmb3JtZXIudHJhbnNsYXRlTyhkeCwgZHkpXG4gICAgfVxuXG4gICAgLy8gVHJhbnNsYXRlIG5vdyBhZnRlciBwb3NpdGlvbmluZ1xuICAgIHRyYW5zZm9ybWVyLnRyYW5zbGF0ZU8odC50eCwgdC50eSlcbiAgICByZXR1cm4gdHJhbnNmb3JtZXJcbiAgfVxuXG4gIC8vIFRyYW5zbGF0ZSBtYXRyaXhcbiAgdHJhbnNsYXRlKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnRyYW5zbGF0ZU8oeCwgeSlcbiAgfVxuXG4gIHRyYW5zbGF0ZU8oeCwgeSkge1xuICAgIHRoaXMuZSArPSB4IHx8IDBcbiAgICB0aGlzLmYgKz0geSB8fCAwXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGE6IHRoaXMuYSxcbiAgICAgIGI6IHRoaXMuYixcbiAgICAgIGM6IHRoaXMuYyxcbiAgICAgIGQ6IHRoaXMuZCxcbiAgICAgIGU6IHRoaXMuZSxcbiAgICAgIGY6IHRoaXMuZlxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3RtKCkge1xuICByZXR1cm4gbmV3IE1hdHJpeCh0aGlzLm5vZGUuZ2V0Q1RNKCkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzY3JlZW5DVE0oKSB7XG4gIHRyeSB7XG4gICAgLyogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM0NDUzN1xuICAgICAgIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgRkYgZG9lcyBub3QgcmV0dXJuIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICAgICBmb3IgdGhlIGlubmVyIGNvb3JkaW5hdGUgc3lzdGVtIHdoZW4gZ2V0U2NyZWVuQ1RNKCkgaXMgY2FsbGVkIG9uIG5lc3RlZCBzdmdzLlxuICAgICAgIEhvd2V2ZXIgYWxsIG90aGVyIEJyb3dzZXJzIGRvIHRoYXQgKi9cbiAgICBpZiAodHlwZW9mIHRoaXMuaXNSb290ID09PSAnZnVuY3Rpb24nICYmICF0aGlzLmlzUm9vdCgpKSB7XG4gICAgICBjb25zdCByZWN0ID0gdGhpcy5yZWN0KDEsIDEpXG4gICAgICBjb25zdCBtID0gcmVjdC5ub2RlLmdldFNjcmVlbkNUTSgpXG4gICAgICByZWN0LnJlbW92ZSgpXG4gICAgICByZXR1cm4gbmV3IE1hdHJpeChtKVxuICAgIH1cbiAgICByZXR1cm4gbmV3IE1hdHJpeCh0aGlzLm5vZGUuZ2V0U2NyZWVuQ1RNKCkpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgQ2Fubm90IGdldCBDVE0gZnJvbSBTVkcgbm9kZSAke3RoaXMubm9kZS5ub2RlTmFtZX0uIElzIHRoZSBlbGVtZW50IHJlbmRlcmVkP2BcbiAgICApXG4gICAgcmV0dXJuIG5ldyBNYXRyaXgoKVxuICB9XG59XG5cbnJlZ2lzdGVyKE1hdHJpeCwgJ01hdHJpeCcpXG4iLCJpbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vLi4vdXRpbHMvd2luZG93LmpzJ1xuaW1wb3J0IHsgbWFrZUluc3RhbmNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvYWRvcHRlci5qcydcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFyc2VyKCkge1xuICAvLyBSZXVzZSBjYWNoZWQgZWxlbWVudCBpZiBwb3NzaWJsZVxuICBpZiAoIXBhcnNlci5ub2Rlcykge1xuICAgIGNvbnN0IHN2ZyA9IG1ha2VJbnN0YW5jZSgpLnNpemUoMiwgMClcbiAgICBzdmcubm9kZS5zdHlsZS5jc3NUZXh0ID0gW1xuICAgICAgJ29wYWNpdHk6IDAnLFxuICAgICAgJ3Bvc2l0aW9uOiBhYnNvbHV0ZScsXG4gICAgICAnbGVmdDogLTEwMCUnLFxuICAgICAgJ3RvcDogLTEwMCUnLFxuICAgICAgJ292ZXJmbG93OiBoaWRkZW4nXG4gICAgXS5qb2luKCc7JylcblxuICAgIHN2Zy5hdHRyKCdmb2N1c2FibGUnLCAnZmFsc2UnKVxuICAgIHN2Zy5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJylcblxuICAgIGNvbnN0IHBhdGggPSBzdmcucGF0aCgpLm5vZGVcblxuICAgIHBhcnNlci5ub2RlcyA9IHsgc3ZnLCBwYXRoIH1cbiAgfVxuXG4gIGlmICghcGFyc2VyLm5vZGVzLnN2Zy5ub2RlLnBhcmVudE5vZGUpIHtcbiAgICBjb25zdCBiID0gZ2xvYmFscy5kb2N1bWVudC5ib2R5IHx8IGdsb2JhbHMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XG4gICAgcGFyc2VyLm5vZGVzLnN2Zy5hZGRUbyhiKVxuICB9XG5cbiAgcmV0dXJuIHBhcnNlci5ub2Rlc1xufVxuIiwiaW1wb3J0IHsgZGVsaW1pdGVyIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3JlZ2V4LmpzJ1xuaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4uL3V0aWxzL3dpbmRvdy5qcydcbmltcG9ydCB7IHJlZ2lzdGVyIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgTWF0cml4IGZyb20gJy4vTWF0cml4LmpzJ1xuaW1wb3J0IFBvaW50IGZyb20gJy4vUG9pbnQuanMnXG5pbXBvcnQgcGFyc2VyIGZyb20gJy4uL21vZHVsZXMvY29yZS9wYXJzZXIuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bGxlZEJveChib3gpIHtcbiAgcmV0dXJuICFib3gud2lkdGggJiYgIWJveC5oZWlnaHQgJiYgIWJveC54ICYmICFib3gueVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZG9tQ29udGFpbnMobm9kZSkge1xuICByZXR1cm4gKFxuICAgIG5vZGUgPT09IGdsb2JhbHMuZG9jdW1lbnQgfHxcbiAgICAoXG4gICAgICBnbG9iYWxzLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyB8fFxuICAgICAgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBJRSAtIGl0IGRvZXMgbm90IHN1cHBvcnQgY29udGFpbnMoKSBmb3IgdG9wLWxldmVsIFNWR3NcbiAgICAgICAgd2hpbGUgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZSA9PT0gZ2xvYmFscy5kb2N1bWVudFxuICAgICAgfVxuICAgICkuY2FsbChnbG9iYWxzLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSlcbiAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCb3gge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgdGhpcy5pbml0KC4uLmFyZ3MpXG4gIH1cblxuICBhZGRPZmZzZXQoKSB7XG4gICAgLy8gb2Zmc2V0IGJ5IHdpbmRvdyBzY3JvbGwgcG9zaXRpb24sIGJlY2F1c2UgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGNoYW5nZXMgd2hlbiB3aW5kb3cgaXMgc2Nyb2xsZWRcbiAgICB0aGlzLnggKz0gZ2xvYmFscy53aW5kb3cucGFnZVhPZmZzZXRcbiAgICB0aGlzLnkgKz0gZ2xvYmFscy53aW5kb3cucGFnZVlPZmZzZXRcbiAgICByZXR1cm4gbmV3IEJveCh0aGlzKVxuICB9XG5cbiAgaW5pdChzb3VyY2UpIHtcbiAgICBjb25zdCBiYXNlID0gWzAsIDAsIDAsIDBdXG4gICAgc291cmNlID1cbiAgICAgIHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnXG4gICAgICAgID8gc291cmNlLnNwbGl0KGRlbGltaXRlcikubWFwKHBhcnNlRmxvYXQpXG4gICAgICAgIDogQXJyYXkuaXNBcnJheShzb3VyY2UpXG4gICAgICAgICAgPyBzb3VyY2VcbiAgICAgICAgICA6IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnXG4gICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICBzb3VyY2UubGVmdCAhPSBudWxsID8gc291cmNlLmxlZnQgOiBzb3VyY2UueCxcbiAgICAgICAgICAgICAgICBzb3VyY2UudG9wICE9IG51bGwgPyBzb3VyY2UudG9wIDogc291cmNlLnksXG4gICAgICAgICAgICAgICAgc291cmNlLndpZHRoLFxuICAgICAgICAgICAgICAgIHNvdXJjZS5oZWlnaHRcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgOiBhcmd1bWVudHMubGVuZ3RoID09PSA0XG4gICAgICAgICAgICAgID8gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgICAgICAgICAgIDogYmFzZVxuXG4gICAgdGhpcy54ID0gc291cmNlWzBdIHx8IDBcbiAgICB0aGlzLnkgPSBzb3VyY2VbMV0gfHwgMFxuICAgIHRoaXMud2lkdGggPSB0aGlzLncgPSBzb3VyY2VbMl0gfHwgMFxuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5oID0gc291cmNlWzNdIHx8IDBcblxuICAgIC8vIEFkZCBtb3JlIGJvdW5kaW5nIGJveCBwcm9wZXJ0aWVzXG4gICAgdGhpcy54MiA9IHRoaXMueCArIHRoaXMud1xuICAgIHRoaXMueTIgPSB0aGlzLnkgKyB0aGlzLmhcbiAgICB0aGlzLmN4ID0gdGhpcy54ICsgdGhpcy53IC8gMlxuICAgIHRoaXMuY3kgPSB0aGlzLnkgKyB0aGlzLmggLyAyXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgaXNOdWxsZWQoKSB7XG4gICAgcmV0dXJuIGlzTnVsbGVkQm94KHRoaXMpXG4gIH1cblxuICAvLyBNZXJnZSByZWN0IGJveCB3aXRoIGFub3RoZXIsIHJldHVybiBhIG5ldyBpbnN0YW5jZVxuICBtZXJnZShib3gpIHtcbiAgICBjb25zdCB4ID0gTWF0aC5taW4odGhpcy54LCBib3gueClcbiAgICBjb25zdCB5ID0gTWF0aC5taW4odGhpcy55LCBib3gueSlcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsIGJveC54ICsgYm94LndpZHRoKSAtIHhcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heCh0aGlzLnkgKyB0aGlzLmhlaWdodCwgYm94LnkgKyBib3guaGVpZ2h0KSAtIHlcblxuICAgIHJldHVybiBuZXcgQm94KHgsIHksIHdpZHRoLCBoZWlnaHQpXG4gIH1cblxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XVxuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMueCArICcgJyArIHRoaXMueSArICcgJyArIHRoaXMud2lkdGggKyAnICcgKyB0aGlzLmhlaWdodFxuICB9XG5cbiAgdHJhbnNmb3JtKG0pIHtcbiAgICBpZiAoIShtIGluc3RhbmNlb2YgTWF0cml4KSkge1xuICAgICAgbSA9IG5ldyBNYXRyaXgobSlcbiAgICB9XG5cbiAgICBsZXQgeE1pbiA9IEluZmluaXR5XG4gICAgbGV0IHhNYXggPSAtSW5maW5pdHlcbiAgICBsZXQgeU1pbiA9IEluZmluaXR5XG4gICAgbGV0IHlNYXggPSAtSW5maW5pdHlcblxuICAgIGNvbnN0IHB0cyA9IFtcbiAgICAgIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSksXG4gICAgICBuZXcgUG9pbnQodGhpcy54MiwgdGhpcy55KSxcbiAgICAgIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueTIpLFxuICAgICAgbmV3IFBvaW50KHRoaXMueDIsIHRoaXMueTIpXG4gICAgXVxuXG4gICAgcHRzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgIHAgPSBwLnRyYW5zZm9ybShtKVxuICAgICAgeE1pbiA9IE1hdGgubWluKHhNaW4sIHAueClcbiAgICAgIHhNYXggPSBNYXRoLm1heCh4TWF4LCBwLngpXG4gICAgICB5TWluID0gTWF0aC5taW4oeU1pbiwgcC55KVxuICAgICAgeU1heCA9IE1hdGgubWF4KHlNYXgsIHAueSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIG5ldyBCb3goeE1pbiwgeU1pbiwgeE1heCAtIHhNaW4sIHlNYXggLSB5TWluKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJveChlbCwgZ2V0QkJveEZuLCByZXRyeSkge1xuICBsZXQgYm94XG5cbiAgdHJ5IHtcbiAgICAvLyBUcnkgdG8gZ2V0IHRoZSBib3ggd2l0aCB0aGUgcHJvdmlkZWQgZnVuY3Rpb25cbiAgICBib3ggPSBnZXRCQm94Rm4oZWwubm9kZSlcblxuICAgIC8vIElmIHRoZSBib3ggaXMgd29ydGhsZXNzIGFuZCBub3QgZXZlbiBpbiB0aGUgZG9tLCByZXRyeVxuICAgIC8vIGJ5IHRocm93aW5nIGFuIGVycm9yIGhlcmUuLi5cbiAgICBpZiAoaXNOdWxsZWRCb3goYm94KSAmJiAhZG9tQ29udGFpbnMoZWwubm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRWxlbWVudCBub3QgaW4gdGhlIGRvbScpXG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gLi4uIGFuZCBjYWxsaW5nIHRoZSByZXRyeSBoYW5kbGVyIGhlcmVcbiAgICBib3ggPSByZXRyeShlbClcbiAgfVxuXG4gIHJldHVybiBib3hcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJib3goKSB7XG4gIC8vIEZ1bmN0aW9uIHRvIGdldCBiYm94IGlzIGdldEJCb3goKVxuICBjb25zdCBnZXRCQm94ID0gKG5vZGUpID0+IG5vZGUuZ2V0QkJveCgpXG5cbiAgLy8gVGFrZSBhbGwgbWVhc3VyZXMgc28gdGhhdCBhIHN0dXBpZCBicm93c2VyIHJlbmRlcnMgdGhlIGVsZW1lbnRcbiAgLy8gc28gd2UgY2FuIGdldCB0aGUgYmJveCBmcm9tIGl0IHdoZW4gd2UgdHJ5IGFnYWluXG4gIGNvbnN0IHJldHJ5ID0gKGVsKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNsb25lID0gZWwuY2xvbmUoKS5hZGRUbyhwYXJzZXIoKS5zdmcpLnNob3coKVxuICAgICAgY29uc3QgYm94ID0gY2xvbmUubm9kZS5nZXRCQm94KClcbiAgICAgIGNsb25lLnJlbW92ZSgpXG4gICAgICByZXR1cm4gYm94XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gV2UgZ2l2ZSB1cC4uLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgR2V0dGluZyBiYm94IG9mIGVsZW1lbnQgXCIke1xuICAgICAgICAgIGVsLm5vZGUubm9kZU5hbWVcbiAgICAgICAgfVwiIGlzIG5vdCBwb3NzaWJsZTogJHtlLnRvU3RyaW5nKCl9YFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJveCA9IGdldEJveCh0aGlzLCBnZXRCQm94LCByZXRyeSlcbiAgY29uc3QgYmJveCA9IG5ldyBCb3goYm94KVxuXG4gIHJldHVybiBiYm94XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByYm94KGVsKSB7XG4gIGNvbnN0IGdldFJCb3ggPSAobm9kZSkgPT4gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICBjb25zdCByZXRyeSA9IChlbCkgPT4ge1xuICAgIC8vIFRoZXJlIGlzIG5vIHBvaW50IGluIHRyeWluZyB0cmlja3MgaGVyZSBiZWNhdXNlIGlmIHdlIGluc2VydCB0aGUgZWxlbWVudCBpbnRvIHRoZSBkb20gb3Vyc2VsdmVzXG4gICAgLy8gaXQgb2J2aW91c2x5IHdpbGwgYmUgYXQgdGhlIHdyb25nIHBvc2l0aW9uXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEdldHRpbmcgcmJveCBvZiBlbGVtZW50IFwiJHtlbC5ub2RlLm5vZGVOYW1lfVwiIGlzIG5vdCBwb3NzaWJsZWBcbiAgICApXG4gIH1cblxuICBjb25zdCBib3ggPSBnZXRCb3godGhpcywgZ2V0UkJveCwgcmV0cnkpXG4gIGNvbnN0IHJib3ggPSBuZXcgQm94KGJveClcblxuICAvLyBJZiBhbiBlbGVtZW50IHdhcyBwYXNzZWQsIHdlIHdhbnQgdGhlIGJib3ggaW4gdGhlIGNvb3JkaW5hdGUgc3lzdGVtIG9mIHRoYXQgZWxlbWVudFxuICBpZiAoZWwpIHtcbiAgICByZXR1cm4gcmJveC50cmFuc2Zvcm0oZWwuc2NyZWVuQ1RNKCkuaW52ZXJzZU8oKSlcbiAgfVxuXG4gIC8vIEVsc2Ugd2Ugd2FudCBpdCBpbiBhYnNvbHV0ZSBzY3JlZW4gY29vcmRpbmF0ZXNcbiAgLy8gVGhlcmVmb3JlIHdlIG5lZWQgdG8gYWRkIHRoZSBzY3JvbGxPZmZzZXRcbiAgcmV0dXJuIHJib3guYWRkT2Zmc2V0KClcbn1cblxuLy8gQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHBvaW50IGlzIGluc2lkZSB0aGUgYm91bmRpbmcgYm94XG5leHBvcnQgZnVuY3Rpb24gaW5zaWRlKHgsIHkpIHtcbiAgY29uc3QgYm94ID0gdGhpcy5iYm94KClcblxuICByZXR1cm4gKFxuICAgIHggPiBib3gueCAmJiB5ID4gYm94LnkgJiYgeCA8IGJveC54ICsgYm94LndpZHRoICYmIHkgPCBib3gueSArIGJveC5oZWlnaHRcbiAgKVxufVxuXG5yZWdpc3Rlck1ldGhvZHMoe1xuICB2aWV3Ym94OiB7XG4gICAgdmlld2JveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAvLyBhY3QgYXMgZ2V0dGVyXG4gICAgICBpZiAoeCA9PSBudWxsKSByZXR1cm4gbmV3IEJveCh0aGlzLmF0dHIoJ3ZpZXdCb3gnKSlcblxuICAgICAgLy8gYWN0IGFzIHNldHRlclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cigndmlld0JveCcsIG5ldyBCb3goeCwgeSwgd2lkdGgsIGhlaWdodCkpXG4gICAgfSxcblxuICAgIHpvb20obGV2ZWwsIHBvaW50KSB7XG4gICAgICAvLyBJdHMgYmVzdCB0byByZWx5IG9uIHRoZSBhdHRyaWJ1dGVzIGhlcmUgYW5kIGhlcmUgaXMgd2h5OlxuICAgICAgLy8gY2xpZW50WFlaOiBEb2Vzbid0IHdvcmsgb24gbm9uLXJvb3Qgc3ZncyBiZWNhdXNlIHRoZXkgZG9udCBoYXZlIGEgQ1NTQm94IChzaWxseSEpXG4gICAgICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6IERvZXNuJ3Qgd29yayBiZWNhdXNlIENocm9tZSBqdXN0IGlnbm9yZXMgd2lkdGggYW5kIGhlaWdodCBvZiBuZXN0ZWQgc3ZncyBjb21wbGV0ZWx5XG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgbWVhbnMsIHRoZWlyIGNsaWVudFJlY3QgaXMgYWx3YXlzIGFzIGJpZyBhcyB0aGUgY29udGVudC5cbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgRnVydGhlcm1vcmUgdGhpcyBzaXplIGlzIGluY29ycmVjdCBpZiB0aGUgZWxlbWVudCBpcyBmdXJ0aGVyIHRyYW5zZm9ybWVkIGJ5IGl0cyBwYXJlbnRzXG4gICAgICAvLyBjb21wdXRlZFN0eWxlOiBPbmx5IHJldHVybnMgbWVhbmluZ2Z1bCB2YWx1ZXMgaWYgY3NzIHdhcyB1c2VkIHdpdGggcHguIFdlIGRvbnQgZ28gdGhpcyByb3V0ZSBoZXJlIVxuICAgICAgLy8gZ2V0QkJveDogcmV0dXJucyB0aGUgYm91bmRpbmcgYm94IG9mIGl0cyBjb250ZW50IC0gdGhhdCBkb2Vzbid0IGhlbHAhXG4gICAgICBsZXQgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLmF0dHIoWyd3aWR0aCcsICdoZWlnaHQnXSlcblxuICAgICAgLy8gV2lkdGggYW5kIGhlaWdodCBpcyBhIHN0cmluZyB3aGVuIGEgbnVtYmVyIHdpdGggYSB1bml0IGlzIHByZXNlbnQgd2hpY2ggd2UgY2FuJ3QgdXNlXG4gICAgICAvLyBTbyB3ZSB0cnkgY2xpZW50WFlaXG4gICAgICBpZiAoXG4gICAgICAgICghd2lkdGggJiYgIWhlaWdodCkgfHxcbiAgICAgICAgdHlwZW9mIHdpZHRoID09PSAnc3RyaW5nJyB8fFxuICAgICAgICB0eXBlb2YgaGVpZ2h0ID09PSAnc3RyaW5nJ1xuICAgICAgKSB7XG4gICAgICAgIHdpZHRoID0gdGhpcy5ub2RlLmNsaWVudFdpZHRoXG4gICAgICAgIGhlaWdodCA9IHRoaXMubm9kZS5jbGllbnRIZWlnaHRcbiAgICAgIH1cblxuICAgICAgLy8gR2l2aW5nIHVwLi4uXG4gICAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdJbXBvc3NpYmxlIHRvIGdldCBhYnNvbHV0ZSB3aWR0aCBhbmQgaGVpZ2h0LiBQbGVhc2UgcHJvdmlkZSBhbiBhYnNvbHV0ZSB3aWR0aCBhbmQgaGVpZ2h0IGF0dHJpYnV0ZSBvbiB0aGUgem9vbWluZyBlbGVtZW50J1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHYgPSB0aGlzLnZpZXdib3goKVxuXG4gICAgICBjb25zdCB6b29tWCA9IHdpZHRoIC8gdi53aWR0aFxuICAgICAgY29uc3Qgem9vbVkgPSBoZWlnaHQgLyB2LmhlaWdodFxuICAgICAgY29uc3Qgem9vbSA9IE1hdGgubWluKHpvb21YLCB6b29tWSlcblxuICAgICAgaWYgKGxldmVsID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHpvb21cbiAgICAgIH1cblxuICAgICAgbGV0IHpvb21BbW91bnQgPSB6b29tIC8gbGV2ZWxcblxuICAgICAgLy8gU2V0IHRoZSB6b29tQW1vdW50IHRvIHRoZSBoaWdoZXN0IHZhbHVlIHdoaWNoIGlzIHNhZmUgdG8gcHJvY2VzcyBhbmQgcmVjb3ZlciBmcm9tXG4gICAgICAvLyBUaGUgKiAxMDAgaXMgYSBiaXQgb2Ygd2lnZ2xlIHJvb20gZm9yIHRoZSBtYXRyaXggdHJhbnNmb3JtYXRpb25cbiAgICAgIGlmICh6b29tQW1vdW50ID09PSBJbmZpbml0eSkgem9vbUFtb3VudCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIC8gMTAwXG5cbiAgICAgIHBvaW50ID1cbiAgICAgICAgcG9pbnQgfHwgbmV3IFBvaW50KHdpZHRoIC8gMiAvIHpvb21YICsgdi54LCBoZWlnaHQgLyAyIC8gem9vbVkgKyB2LnkpXG5cbiAgICAgIGNvbnN0IGJveCA9IG5ldyBCb3godikudHJhbnNmb3JtKFxuICAgICAgICBuZXcgTWF0cml4KHsgc2NhbGU6IHpvb21BbW91bnQsIG9yaWdpbjogcG9pbnQgfSlcbiAgICAgIClcblxuICAgICAgcmV0dXJuIHRoaXMudmlld2JveChib3gpXG4gICAgfVxuICB9XG59KVxuXG5yZWdpc3RlcihCb3gsICdCb3gnKVxuIiwiaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbi8vIGltcG9ydCB7IHN1YkNsYXNzQXJyYXkgfSBmcm9tICcuL0FycmF5UG9seWZpbGwuanMnXG5cbmNsYXNzIExpc3QgZXh0ZW5kcyBBcnJheSB7XG4gIGNvbnN0cnVjdG9yKGFyciA9IFtdLCAuLi5hcmdzKSB7XG4gICAgc3VwZXIoYXJyLCAuLi5hcmdzKVxuICAgIGlmICh0eXBlb2YgYXJyID09PSAnbnVtYmVyJykgcmV0dXJuIHRoaXNcbiAgICB0aGlzLmxlbmd0aCA9IDBcbiAgICB0aGlzLnB1c2goLi4uYXJyKVxuICB9XG59XG5cbi8qID0gc3ViQ2xhc3NBcnJheSgnTGlzdCcsIEFycmF5LCBmdW5jdGlvbiAoYXJyID0gW10pIHtcbiAgLy8gVGhpcyBjYXRjaGVzIHRoZSBjYXNlLCB0aGF0IG5hdGl2ZSBtYXAgdHJpZXMgdG8gY3JlYXRlIGFuIGFycmF5IHdpdGggbmV3IEFycmF5KDEpXG4gIGlmICh0eXBlb2YgYXJyID09PSAnbnVtYmVyJykgcmV0dXJuIHRoaXNcbiAgdGhpcy5sZW5ndGggPSAwXG4gIHRoaXMucHVzaCguLi5hcnIpXG59KSAqL1xuXG5leHBvcnQgZGVmYXVsdCBMaXN0XG5cbmV4dGVuZChbTGlzdF0sIHtcbiAgZWFjaChmbk9yTWV0aG9kTmFtZSwgLi4uYXJncykge1xuICAgIGlmICh0eXBlb2YgZm5Pck1ldGhvZE5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcCgoZWwsIGksIGFycikgPT4ge1xuICAgICAgICByZXR1cm4gZm5Pck1ldGhvZE5hbWUuY2FsbChlbCwgZWwsIGksIGFycilcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcCgoZWwpID0+IHtcbiAgICAgICAgcmV0dXJuIGVsW2ZuT3JNZXRob2ROYW1lXSguLi5hcmdzKVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG5cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgdGhpcylcbiAgfVxufSlcblxuY29uc3QgcmVzZXJ2ZWQgPSBbJ3RvQXJyYXknLCAnY29uc3RydWN0b3InLCAnZWFjaCddXG5cbkxpc3QuZXh0ZW5kID0gZnVuY3Rpb24gKG1ldGhvZHMpIHtcbiAgbWV0aG9kcyA9IG1ldGhvZHMucmVkdWNlKChvYmosIG5hbWUpID0+IHtcbiAgICAvLyBEb24ndCBvdmVyd3JpdGUgb3duIG1ldGhvZHNcbiAgICBpZiAocmVzZXJ2ZWQuaW5jbHVkZXMobmFtZSkpIHJldHVybiBvYmpcblxuICAgIC8vIERvbid0IGFkZCBwcml2YXRlIG1ldGhvZHNcbiAgICBpZiAobmFtZVswXSA9PT0gJ18nKSByZXR1cm4gb2JqXG5cbiAgICAvLyBBbGxvdyBhY2Nlc3MgdG8gb3JpZ2luYWwgQXJyYXkgbWV0aG9kcyB0aHJvdWdoIGEgcHJlZml4XG4gICAgaWYgKG5hbWUgaW4gQXJyYXkucHJvdG90eXBlKSB7XG4gICAgICBvYmpbJyQnICsgbmFtZV0gPSBBcnJheS5wcm90b3R5cGVbbmFtZV1cbiAgICB9XG5cbiAgICAvLyBSZWxheSBldmVyeSBjYWxsIHRvIGVhY2goKVxuICAgIG9ialtuYW1lXSA9IGZ1bmN0aW9uICguLi5hdHRycykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChuYW1lLCAuLi5hdHRycylcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9LCB7fSlcblxuICBleHRlbmQoW0xpc3RdLCBtZXRob2RzKVxufVxuIiwiaW1wb3J0IHsgYWRvcHQgfSBmcm9tICcuLi8uLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4uLy4uL3V0aWxzL3dpbmRvdy5qcydcbmltcG9ydCB7IG1hcCB9IGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzLmpzJ1xuaW1wb3J0IExpc3QgZnJvbSAnLi4vLi4vdHlwZXMvTGlzdC5qcydcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmFzZUZpbmQocXVlcnksIHBhcmVudCkge1xuICByZXR1cm4gbmV3IExpc3QoXG4gICAgbWFwKChwYXJlbnQgfHwgZ2xvYmFscy5kb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChxdWVyeSksIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gYWRvcHQobm9kZSlcbiAgICB9KVxuICApXG59XG5cbi8vIFNjb3BlZCBmaW5kIG1ldGhvZFxuZXhwb3J0IGZ1bmN0aW9uIGZpbmQocXVlcnkpIHtcbiAgcmV0dXJuIGJhc2VGaW5kKHF1ZXJ5LCB0aGlzLm5vZGUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kT25lKHF1ZXJ5KSB7XG4gIHJldHVybiBhZG9wdCh0aGlzLm5vZGUucXVlcnlTZWxlY3RvcihxdWVyeSkpXG59XG4iLCJpbXBvcnQgeyBkZWxpbWl0ZXIgfSBmcm9tICcuL3JlZ2V4LmpzJ1xuaW1wb3J0IHsgbWFrZUluc3RhbmNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi8uLi91dGlscy93aW5kb3cuanMnXG5cbmxldCBsaXN0ZW5lcklkID0gMFxuZXhwb3J0IGNvbnN0IHdpbmRvd0V2ZW50cyA9IHt9XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFdmVudHMoaW5zdGFuY2UpIHtcbiAgbGV0IG4gPSBpbnN0YW5jZS5nZXRFdmVudEhvbGRlcigpXG5cbiAgLy8gV2UgZG9udCB3YW50IHRvIHNhdmUgZXZlbnRzIGluIGdsb2JhbCBzcGFjZVxuICBpZiAobiA9PT0gZ2xvYmFscy53aW5kb3cpIG4gPSB3aW5kb3dFdmVudHNcbiAgaWYgKCFuLmV2ZW50cykgbi5ldmVudHMgPSB7fVxuICByZXR1cm4gbi5ldmVudHNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZS5nZXRFdmVudFRhcmdldCgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckV2ZW50cyhpbnN0YW5jZSkge1xuICBsZXQgbiA9IGluc3RhbmNlLmdldEV2ZW50SG9sZGVyKClcbiAgaWYgKG4gPT09IGdsb2JhbHMud2luZG93KSBuID0gd2luZG93RXZlbnRzXG4gIGlmIChuLmV2ZW50cykgbi5ldmVudHMgPSB7fVxufVxuXG4vLyBBZGQgZXZlbnQgYmluZGVyIGluIHRoZSBTVkcgbmFtZXNwYWNlXG5leHBvcnQgZnVuY3Rpb24gb24obm9kZSwgZXZlbnRzLCBsaXN0ZW5lciwgYmluZGluZywgb3B0aW9ucykge1xuICBjb25zdCBsID0gbGlzdGVuZXIuYmluZChiaW5kaW5nIHx8IG5vZGUpXG4gIGNvbnN0IGluc3RhbmNlID0gbWFrZUluc3RhbmNlKG5vZGUpXG4gIGNvbnN0IGJhZyA9IGdldEV2ZW50cyhpbnN0YW5jZSlcbiAgY29uc3QgbiA9IGdldEV2ZW50VGFyZ2V0KGluc3RhbmNlKVxuXG4gIC8vIGV2ZW50cyBjYW4gYmUgYW4gYXJyYXkgb2YgZXZlbnRzIG9yIGEgc3RyaW5nIG9mIGV2ZW50c1xuICBldmVudHMgPSBBcnJheS5pc0FycmF5KGV2ZW50cykgPyBldmVudHMgOiBldmVudHMuc3BsaXQoZGVsaW1pdGVyKVxuXG4gIC8vIGFkZCBpZCB0byBsaXN0ZW5lclxuICBpZiAoIWxpc3RlbmVyLl9zdmdqc0xpc3RlbmVySWQpIHtcbiAgICBsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkID0gKytsaXN0ZW5lcklkXG4gIH1cblxuICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBjb25zdCBldiA9IGV2ZW50LnNwbGl0KCcuJylbMF1cbiAgICBjb25zdCBucyA9IGV2ZW50LnNwbGl0KCcuJylbMV0gfHwgJyonXG5cbiAgICAvLyBlbnN1cmUgdmFsaWQgb2JqZWN0XG4gICAgYmFnW2V2XSA9IGJhZ1tldl0gfHwge31cbiAgICBiYWdbZXZdW25zXSA9IGJhZ1tldl1bbnNdIHx8IHt9XG5cbiAgICAvLyByZWZlcmVuY2UgbGlzdGVuZXJcbiAgICBiYWdbZXZdW25zXVtsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkXSA9IGxcblxuICAgIC8vIGFkZCBsaXN0ZW5lclxuICAgIG4uYWRkRXZlbnRMaXN0ZW5lcihldiwgbCwgb3B0aW9ucyB8fCBmYWxzZSlcbiAgfSlcbn1cblxuLy8gQWRkIGV2ZW50IHVuYmluZGVyIGluIHRoZSBTVkcgbmFtZXNwYWNlXG5leHBvcnQgZnVuY3Rpb24gb2ZmKG5vZGUsIGV2ZW50cywgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBtYWtlSW5zdGFuY2Uobm9kZSlcbiAgY29uc3QgYmFnID0gZ2V0RXZlbnRzKGluc3RhbmNlKVxuICBjb25zdCBuID0gZ2V0RXZlbnRUYXJnZXQoaW5zdGFuY2UpXG5cbiAgLy8gbGlzdGVuZXIgY2FuIGJlIGEgZnVuY3Rpb24gb3IgYSBudW1iZXJcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGxpc3RlbmVyID0gbGlzdGVuZXIuX3N2Z2pzTGlzdGVuZXJJZFxuICAgIGlmICghbGlzdGVuZXIpIHJldHVyblxuICB9XG5cbiAgLy8gZXZlbnRzIGNhbiBiZSBhbiBhcnJheSBvZiBldmVudHMgb3IgYSBzdHJpbmcgb3IgdW5kZWZpbmVkXG4gIGV2ZW50cyA9IEFycmF5LmlzQXJyYXkoZXZlbnRzKSA/IGV2ZW50cyA6IChldmVudHMgfHwgJycpLnNwbGl0KGRlbGltaXRlcilcblxuICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBjb25zdCBldiA9IGV2ZW50ICYmIGV2ZW50LnNwbGl0KCcuJylbMF1cbiAgICBjb25zdCBucyA9IGV2ZW50ICYmIGV2ZW50LnNwbGl0KCcuJylbMV1cbiAgICBsZXQgbmFtZXNwYWNlLCBsXG5cbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIC8vIHJlbW92ZSBsaXN0ZW5lciByZWZlcmVuY2VcbiAgICAgIGlmIChiYWdbZXZdICYmIGJhZ1tldl1bbnMgfHwgJyonXSkge1xuICAgICAgICAvLyByZW1vdmVMaXN0ZW5lclxuICAgICAgICBuLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgZXYsXG4gICAgICAgICAgYmFnW2V2XVtucyB8fCAnKiddW2xpc3RlbmVyXSxcbiAgICAgICAgICBvcHRpb25zIHx8IGZhbHNlXG4gICAgICAgIClcblxuICAgICAgICBkZWxldGUgYmFnW2V2XVtucyB8fCAnKiddW2xpc3RlbmVyXVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXYgJiYgbnMpIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciBhIG5hbWVzcGFjZWQgZXZlbnRcbiAgICAgIGlmIChiYWdbZXZdICYmIGJhZ1tldl1bbnNdKSB7XG4gICAgICAgIGZvciAobCBpbiBiYWdbZXZdW25zXSkge1xuICAgICAgICAgIG9mZihuLCBbZXYsIG5zXS5qb2luKCcuJyksIGwpXG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgYmFnW2V2XVtuc11cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5zKSB7XG4gICAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgYSBzcGVjaWZpYyBuYW1lc3BhY2VcbiAgICAgIGZvciAoZXZlbnQgaW4gYmFnKSB7XG4gICAgICAgIGZvciAobmFtZXNwYWNlIGluIGJhZ1tldmVudF0pIHtcbiAgICAgICAgICBpZiAobnMgPT09IG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgb2ZmKG4sIFtldmVudCwgbnNdLmpvaW4oJy4nKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV2KSB7XG4gICAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgdGhlIGV2ZW50XG4gICAgICBpZiAoYmFnW2V2XSkge1xuICAgICAgICBmb3IgKG5hbWVzcGFjZSBpbiBiYWdbZXZdKSB7XG4gICAgICAgICAgb2ZmKG4sIFtldiwgbmFtZXNwYWNlXS5qb2luKCcuJykpXG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgYmFnW2V2XVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBvbiBhIGdpdmVuIG5vZGVcbiAgICAgIGZvciAoZXZlbnQgaW4gYmFnKSB7XG4gICAgICAgIG9mZihuLCBldmVudClcbiAgICAgIH1cblxuICAgICAgY2xlYXJFdmVudHMoaW5zdGFuY2UpXG4gICAgfVxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzcGF0Y2gobm9kZSwgZXZlbnQsIGRhdGEsIG9wdGlvbnMpIHtcbiAgY29uc3QgbiA9IGdldEV2ZW50VGFyZ2V0KG5vZGUpXG5cbiAgLy8gRGlzcGF0Y2ggZXZlbnRcbiAgaWYgKGV2ZW50IGluc3RhbmNlb2YgZ2xvYmFscy53aW5kb3cuRXZlbnQpIHtcbiAgICBuLmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gIH0gZWxzZSB7XG4gICAgZXZlbnQgPSBuZXcgZ2xvYmFscy53aW5kb3cuQ3VzdG9tRXZlbnQoZXZlbnQsIHtcbiAgICAgIGRldGFpbDogZGF0YSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSlcbiAgICBuLmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gIH1cbiAgcmV0dXJuIGV2ZW50XG59XG4iLCJpbXBvcnQgeyBkaXNwYXRjaCwgb2ZmLCBvbiB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9ldmVudC5qcydcbmltcG9ydCB7IHJlZ2lzdGVyIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCBCYXNlIGZyb20gJy4vQmFzZS5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRUYXJnZXQgZXh0ZW5kcyBCYXNlIHtcbiAgYWRkRXZlbnRMaXN0ZW5lcigpIHt9XG5cbiAgZGlzcGF0Y2goZXZlbnQsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2godGhpcywgZXZlbnQsIGRhdGEsIG9wdGlvbnMpXG4gIH1cblxuICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgYmFnID0gdGhpcy5nZXRFdmVudEhvbGRlcigpLmV2ZW50c1xuICAgIGlmICghYmFnKSByZXR1cm4gdHJ1ZVxuXG4gICAgY29uc3QgZXZlbnRzID0gYmFnW2V2ZW50LnR5cGVdXG5cbiAgICBmb3IgKGNvbnN0IGkgaW4gZXZlbnRzKSB7XG4gICAgICBmb3IgKGNvbnN0IGogaW4gZXZlbnRzW2ldKSB7XG4gICAgICAgIGV2ZW50c1tpXVtqXShldmVudClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWRcbiAgfVxuXG4gIC8vIEZpcmUgZ2l2ZW4gZXZlbnRcbiAgZmlyZShldmVudCwgZGF0YSwgb3B0aW9ucykge1xuICAgIHRoaXMuZGlzcGF0Y2goZXZlbnQsIGRhdGEsIG9wdGlvbnMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldEV2ZW50SG9sZGVyKCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXRFdmVudFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gVW5iaW5kIGV2ZW50IGZyb20gbGlzdGVuZXJcbiAgb2ZmKGV2ZW50LCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIG9mZih0aGlzLCBldmVudCwgbGlzdGVuZXIsIG9wdGlvbnMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEJpbmQgZ2l2ZW4gZXZlbnQgdG8gbGlzdGVuZXJcbiAgb24oZXZlbnQsIGxpc3RlbmVyLCBiaW5kaW5nLCBvcHRpb25zKSB7XG4gICAgb24odGhpcywgZXZlbnQsIGxpc3RlbmVyLCBiaW5kaW5nLCBvcHRpb25zKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByZW1vdmVFdmVudExpc3RlbmVyKCkge31cbn1cblxucmVnaXN0ZXIoRXZlbnRUYXJnZXQsICdFdmVudFRhcmdldCcpXG4iLCJleHBvcnQgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8vIERlZmF1bHQgYW5pbWF0aW9uIHZhbHVlc1xuZXhwb3J0IGNvbnN0IHRpbWVsaW5lID0ge1xuICBkdXJhdGlvbjogNDAwLFxuICBlYXNlOiAnPicsXG4gIGRlbGF5OiAwXG59XG5cbi8vIERlZmF1bHQgYXR0cmlidXRlIHZhbHVlc1xuZXhwb3J0IGNvbnN0IGF0dHJzID0ge1xuICAvLyBmaWxsIGFuZCBzdHJva2VcbiAgJ2ZpbGwtb3BhY2l0eSc6IDEsXG4gICdzdHJva2Utb3BhY2l0eSc6IDEsXG4gICdzdHJva2Utd2lkdGgnOiAwLFxuICAnc3Ryb2tlLWxpbmVqb2luJzogJ21pdGVyJyxcbiAgJ3N0cm9rZS1saW5lY2FwJzogJ2J1dHQnLFxuICBmaWxsOiAnIzAwMDAwMCcsXG4gIHN0cm9rZTogJyMwMDAwMDAnLFxuICBvcGFjaXR5OiAxLFxuXG4gIC8vIHBvc2l0aW9uXG4gIHg6IDAsXG4gIHk6IDAsXG4gIGN4OiAwLFxuICBjeTogMCxcblxuICAvLyBzaXplXG4gIHdpZHRoOiAwLFxuICBoZWlnaHQ6IDAsXG5cbiAgLy8gcmFkaXVzXG4gIHI6IDAsXG4gIHJ4OiAwLFxuICByeTogMCxcblxuICAvLyBncmFkaWVudFxuICBvZmZzZXQ6IDAsXG4gICdzdG9wLW9wYWNpdHknOiAxLFxuICAnc3RvcC1jb2xvcic6ICcjMDAwMDAwJyxcblxuICAvLyB0ZXh0XG4gICd0ZXh0LWFuY2hvcic6ICdzdGFydCdcbn1cbiIsImltcG9ydCB7IGRlbGltaXRlciB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9yZWdleC5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU1ZHQXJyYXkgZXh0ZW5kcyBBcnJheSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuICAgIHRoaXMuaW5pdCguLi5hcmdzKVxuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpXG4gIH1cblxuICBpbml0KGFycikge1xuICAgIC8vIFRoaXMgY2F0Y2hlcyB0aGUgY2FzZSwgdGhhdCBuYXRpdmUgbWFwIHRyaWVzIHRvIGNyZWF0ZSBhbiBhcnJheSB3aXRoIG5ldyBBcnJheSgxKVxuICAgIGlmICh0eXBlb2YgYXJyID09PSAnbnVtYmVyJykgcmV0dXJuIHRoaXNcbiAgICB0aGlzLmxlbmd0aCA9IDBcbiAgICB0aGlzLnB1c2goLi4udGhpcy5wYXJzZShhcnIpKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBQYXJzZSB3aGl0ZXNwYWNlIHNlcGFyYXRlZCBzdHJpbmdcbiAgcGFyc2UoYXJyYXkgPSBbXSkge1xuICAgIC8vIElmIGFscmVhZHkgaXMgYW4gYXJyYXksIG5vIG5lZWQgdG8gcGFyc2UgaXRcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIGFycmF5XG5cbiAgICByZXR1cm4gYXJyYXkudHJpbSgpLnNwbGl0KGRlbGltaXRlcikubWFwKHBhcnNlRmxvYXQpXG4gIH1cblxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCB0aGlzKVxuICB9XG5cbiAgdG9TZXQoKSB7XG4gICAgcmV0dXJuIG5ldyBTZXQodGhpcylcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmpvaW4oJyAnKVxuICB9XG5cbiAgLy8gRmxhdHRlbnMgdGhlIGFycmF5IGlmIG5lZWRlZFxuICB2YWx1ZU9mKCkge1xuICAgIGNvbnN0IHJldCA9IFtdXG4gICAgcmV0LnB1c2goLi4udGhpcylcbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cbiIsImltcG9ydCB7IG51bWJlckFuZFVuaXQgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcmVnZXguanMnXG5cbi8vIE1vZHVsZSBmb3IgdW5pdCBjb252ZXJzaW9uc1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU1ZHTnVtYmVyIHtcbiAgLy8gSW5pdGlhbGl6ZVxuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgdGhpcy5pbml0KC4uLmFyZ3MpXG4gIH1cblxuICBjb252ZXJ0KHVuaXQpIHtcbiAgICByZXR1cm4gbmV3IFNWR051bWJlcih0aGlzLnZhbHVlLCB1bml0KVxuICB9XG5cbiAgLy8gRGl2aWRlIG51bWJlclxuICBkaXZpZGUobnVtYmVyKSB7XG4gICAgbnVtYmVyID0gbmV3IFNWR051bWJlcihudW1iZXIpXG4gICAgcmV0dXJuIG5ldyBTVkdOdW1iZXIodGhpcyAvIG51bWJlciwgdGhpcy51bml0IHx8IG51bWJlci51bml0KVxuICB9XG5cbiAgaW5pdCh2YWx1ZSwgdW5pdCkge1xuICAgIHVuaXQgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzFdIDogdW5pdFxuICAgIHZhbHVlID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZVswXSA6IHZhbHVlXG5cbiAgICAvLyBpbml0aWFsaXplIGRlZmF1bHRzXG4gICAgdGhpcy52YWx1ZSA9IDBcbiAgICB0aGlzLnVuaXQgPSB1bml0IHx8ICcnXG5cbiAgICAvLyBwYXJzZSB2YWx1ZVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBlbnN1cmUgYSB2YWxpZCBudW1lcmljIHZhbHVlXG4gICAgICB0aGlzLnZhbHVlID0gaXNOYU4odmFsdWUpXG4gICAgICAgID8gMFxuICAgICAgICA6ICFpc0Zpbml0ZSh2YWx1ZSlcbiAgICAgICAgICA/IHZhbHVlIDwgMFxuICAgICAgICAgICAgPyAtMy40ZTM4XG4gICAgICAgICAgICA6ICszLjRlMzhcbiAgICAgICAgICA6IHZhbHVlXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB1bml0ID0gdmFsdWUubWF0Y2gobnVtYmVyQW5kVW5pdClcblxuICAgICAgaWYgKHVuaXQpIHtcbiAgICAgICAgLy8gbWFrZSB2YWx1ZSBudW1lcmljXG4gICAgICAgIHRoaXMudmFsdWUgPSBwYXJzZUZsb2F0KHVuaXRbMV0pXG5cbiAgICAgICAgLy8gbm9ybWFsaXplXG4gICAgICAgIGlmICh1bml0WzVdID09PSAnJScpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlIC89IDEwMFxuICAgICAgICB9IGVsc2UgaWYgKHVuaXRbNV0gPT09ICdzJykge1xuICAgICAgICAgIHRoaXMudmFsdWUgKj0gMTAwMFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcmUgdW5pdFxuICAgICAgICB0aGlzLnVuaXQgPSB1bml0WzVdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNWR051bWJlcikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWUudmFsdWVPZigpXG4gICAgICAgIHRoaXMudW5pdCA9IHZhbHVlLnVuaXRcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gU3VidHJhY3QgbnVtYmVyXG4gIG1pbnVzKG51bWJlcikge1xuICAgIG51bWJlciA9IG5ldyBTVkdOdW1iZXIobnVtYmVyKVxuICAgIHJldHVybiBuZXcgU1ZHTnVtYmVyKHRoaXMgLSBudW1iZXIsIHRoaXMudW5pdCB8fCBudW1iZXIudW5pdClcbiAgfVxuXG4gIC8vIEFkZCBudW1iZXJcbiAgcGx1cyhudW1iZXIpIHtcbiAgICBudW1iZXIgPSBuZXcgU1ZHTnVtYmVyKG51bWJlcilcbiAgICByZXR1cm4gbmV3IFNWR051bWJlcih0aGlzICsgbnVtYmVyLCB0aGlzLnVuaXQgfHwgbnVtYmVyLnVuaXQpXG4gIH1cblxuICAvLyBNdWx0aXBseSBudW1iZXJcbiAgdGltZXMobnVtYmVyKSB7XG4gICAgbnVtYmVyID0gbmV3IFNWR051bWJlcihudW1iZXIpXG4gICAgcmV0dXJuIG5ldyBTVkdOdW1iZXIodGhpcyAqIG51bWJlciwgdGhpcy51bml0IHx8IG51bWJlci51bml0KVxuICB9XG5cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gW3RoaXMudmFsdWUsIHRoaXMudW5pdF1cbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpXG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKHRoaXMudW5pdCA9PT0gJyUnXG4gICAgICAgID8gfn4odGhpcy52YWx1ZSAqIDFlOCkgLyAxZTZcbiAgICAgICAgOiB0aGlzLnVuaXQgPT09ICdzJ1xuICAgICAgICAgID8gdGhpcy52YWx1ZSAvIDFlM1xuICAgICAgICAgIDogdGhpcy52YWx1ZSkgKyB0aGlzLnVuaXRcbiAgICApXG4gIH1cblxuICB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlXG4gIH1cbn1cbiIsImltcG9ydCB7IGF0dHJzIGFzIGRlZmF1bHRzIH0gZnJvbSAnLi9kZWZhdWx0cy5qcydcbmltcG9ydCB7IGlzTnVtYmVyIH0gZnJvbSAnLi9yZWdleC5qcydcbmltcG9ydCBDb2xvciBmcm9tICcuLi8uLi90eXBlcy9Db2xvci5qcydcbmltcG9ydCBTVkdBcnJheSBmcm9tICcuLi8uLi90eXBlcy9TVkdBcnJheS5qcydcbmltcG9ydCBTVkdOdW1iZXIgZnJvbSAnLi4vLi4vdHlwZXMvU1ZHTnVtYmVyLmpzJ1xuXG5jb25zdCBjb2xvckF0dHJpYnV0ZXMgPSBuZXcgU2V0KFtcbiAgJ2ZpbGwnLFxuICAnc3Ryb2tlJyxcbiAgJ2NvbG9yJyxcbiAgJ2JnY29sb3InLFxuICAnc3RvcC1jb2xvcicsXG4gICdmbG9vZC1jb2xvcicsXG4gICdsaWdodGluZy1jb2xvcidcbl0pXG5cbmNvbnN0IGhvb2tzID0gW11cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckF0dHJIb29rKGZuKSB7XG4gIGhvb2tzLnB1c2goZm4pXG59XG5cbi8vIFNldCBzdmcgZWxlbWVudCBhdHRyaWJ1dGVcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGF0dHIoYXR0ciwgdmFsLCBucykge1xuICAvLyBhY3QgYXMgZnVsbCBnZXR0ZXJcbiAgaWYgKGF0dHIgPT0gbnVsbCkge1xuICAgIC8vIGdldCBhbiBvYmplY3Qgb2YgYXR0cmlidXRlc1xuICAgIGF0dHIgPSB7fVxuICAgIHZhbCA9IHRoaXMubm9kZS5hdHRyaWJ1dGVzXG5cbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdmFsKSB7XG4gICAgICBhdHRyW25vZGUubm9kZU5hbWVdID0gaXNOdW1iZXIudGVzdChub2RlLm5vZGVWYWx1ZSlcbiAgICAgICAgPyBwYXJzZUZsb2F0KG5vZGUubm9kZVZhbHVlKVxuICAgICAgICA6IG5vZGUubm9kZVZhbHVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGF0dHJcbiAgfSBlbHNlIGlmIChhdHRyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAvLyBsb29wIHRocm91Z2ggYXJyYXkgYW5kIGdldCBhbGwgdmFsdWVzXG4gICAgcmV0dXJuIGF0dHIucmVkdWNlKChsYXN0LCBjdXJyKSA9PiB7XG4gICAgICBsYXN0W2N1cnJdID0gdGhpcy5hdHRyKGN1cnIpXG4gICAgICByZXR1cm4gbGFzdFxuICAgIH0sIHt9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBhdHRyID09PSAnb2JqZWN0JyAmJiBhdHRyLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAvLyBhcHBseSBldmVyeSBhdHRyaWJ1dGUgaW5kaXZpZHVhbGx5IGlmIGFuIG9iamVjdCBpcyBwYXNzZWRcbiAgICBmb3IgKHZhbCBpbiBhdHRyKSB0aGlzLmF0dHIodmFsLCBhdHRyW3ZhbF0pXG4gIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgLy8gcmVtb3ZlIHZhbHVlXG4gICAgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyKVxuICB9IGVsc2UgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgLy8gYWN0IGFzIGEgZ2V0dGVyIGlmIHRoZSBmaXJzdCBhbmQgb25seSBhcmd1bWVudCBpcyBub3QgYW4gb2JqZWN0XG4gICAgdmFsID0gdGhpcy5ub2RlLmdldEF0dHJpYnV0ZShhdHRyKVxuICAgIHJldHVybiB2YWwgPT0gbnVsbFxuICAgICAgPyBkZWZhdWx0c1thdHRyXVxuICAgICAgOiBpc051bWJlci50ZXN0KHZhbClcbiAgICAgICAgPyBwYXJzZUZsb2F0KHZhbClcbiAgICAgICAgOiB2YWxcbiAgfSBlbHNlIHtcbiAgICAvLyBMb29wIHRocm91Z2ggaG9va3MgYW5kIGV4ZWN1dGUgdGhlbSB0byBjb252ZXJ0IHZhbHVlXG4gICAgdmFsID0gaG9va3MucmVkdWNlKChfdmFsLCBob29rKSA9PiB7XG4gICAgICByZXR1cm4gaG9vayhhdHRyLCBfdmFsLCB0aGlzKVxuICAgIH0sIHZhbClcblxuICAgIC8vIGVuc3VyZSBjb3JyZWN0IG51bWVyaWMgdmFsdWVzIChhbHNvIGFjY2VwdHMgTmFOIGFuZCBJbmZpbml0eSlcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhbCA9IG5ldyBTVkdOdW1iZXIodmFsKVxuICAgIH0gZWxzZSBpZiAoY29sb3JBdHRyaWJ1dGVzLmhhcyhhdHRyKSAmJiBDb2xvci5pc0NvbG9yKHZhbCkpIHtcbiAgICAgIC8vIGVuc3VyZSBmdWxsIGhleCBjb2xvclxuICAgICAgdmFsID0gbmV3IENvbG9yKHZhbClcbiAgICB9IGVsc2UgaWYgKHZhbC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgIC8vIENoZWNrIGZvciBwbGFpbiBhcnJheXMgYW5kIHBhcnNlIGFycmF5IHZhbHVlc1xuICAgICAgdmFsID0gbmV3IFNWR0FycmF5KHZhbClcbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgcGFzc2VkIGF0dHJpYnV0ZSBpcyBsZWFkaW5nLi4uXG4gICAgaWYgKGF0dHIgPT09ICdsZWFkaW5nJykge1xuICAgICAgLy8gLi4uIGNhbGwgdGhlIGxlYWRpbmcgbWV0aG9kIGluc3RlYWRcbiAgICAgIGlmICh0aGlzLmxlYWRpbmcpIHtcbiAgICAgICAgdGhpcy5sZWFkaW5nKHZhbClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2V0IGdpdmVuIGF0dHJpYnV0ZSBvbiBub2RlXG4gICAgICB0eXBlb2YgbnMgPT09ICdzdHJpbmcnXG4gICAgICAgID8gdGhpcy5ub2RlLnNldEF0dHJpYnV0ZU5TKG5zLCBhdHRyLCB2YWwudG9TdHJpbmcoKSlcbiAgICAgICAgOiB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIHZhbC50b1N0cmluZygpKVxuICAgIH1cblxuICAgIC8vIHJlYnVpbGQgaWYgcmVxdWlyZWRcbiAgICBpZiAodGhpcy5yZWJ1aWxkICYmIChhdHRyID09PSAnZm9udC1zaXplJyB8fCBhdHRyID09PSAneCcpKSB7XG4gICAgICB0aGlzLnJlYnVpbGQoKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG4iLCJpbXBvcnQge1xuICBhZG9wdCxcbiAgYXNzaWduTmV3SWQsXG4gIGVpZCxcbiAgZXh0ZW5kLFxuICBtYWtlSW5zdGFuY2UsXG4gIGNyZWF0ZSxcbiAgcmVnaXN0ZXJcbn0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCB7IGZpbmQsIGZpbmRPbmUgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvc2VsZWN0b3IuanMnXG5pbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vdXRpbHMvd2luZG93LmpzJ1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMuanMnXG5pbXBvcnQgeyBzdmcsIGh0bWwgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvbmFtZXNwYWNlcy5qcydcbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuLi90eXBlcy9FdmVudFRhcmdldC5qcydcbmltcG9ydCBMaXN0IGZyb20gJy4uL3R5cGVzL0xpc3QuanMnXG5pbXBvcnQgYXR0ciBmcm9tICcuLi9tb2R1bGVzL2NvcmUvYXR0ci5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9tIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLm5vZGUgPSBub2RlXG4gICAgdGhpcy50eXBlID0gbm9kZS5ub2RlTmFtZVxuXG4gICAgaWYgKGF0dHJzICYmIG5vZGUgIT09IGF0dHJzKSB7XG4gICAgICB0aGlzLmF0dHIoYXR0cnMpXG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIGdpdmVuIGVsZW1lbnQgYXQgYSBwb3NpdGlvblxuICBhZGQoZWxlbWVudCwgaSkge1xuICAgIGVsZW1lbnQgPSBtYWtlSW5zdGFuY2UoZWxlbWVudClcblxuICAgIC8vIElmIG5vbi1yb290IHN2ZyBub2RlcyBhcmUgYWRkZWQgd2UgaGF2ZSB0byByZW1vdmUgdGhlaXIgbmFtZXNwYWNlc1xuICAgIGlmIChcbiAgICAgIGVsZW1lbnQucmVtb3ZlTmFtZXNwYWNlICYmXG4gICAgICB0aGlzLm5vZGUgaW5zdGFuY2VvZiBnbG9iYWxzLndpbmRvdy5TVkdFbGVtZW50XG4gICAgKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZU5hbWVzcGFjZSgpXG4gICAgfVxuXG4gICAgaWYgKGkgPT0gbnVsbCkge1xuICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGVsZW1lbnQubm9kZSlcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQubm9kZSAhPT0gdGhpcy5ub2RlLmNoaWxkTm9kZXNbaV0pIHtcbiAgICAgIHRoaXMubm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudC5ub2RlLCB0aGlzLm5vZGUuY2hpbGROb2Rlc1tpXSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gQWRkIGVsZW1lbnQgdG8gZ2l2ZW4gY29udGFpbmVyIGFuZCByZXR1cm4gc2VsZlxuICBhZGRUbyhwYXJlbnQsIGkpIHtcbiAgICByZXR1cm4gbWFrZUluc3RhbmNlKHBhcmVudCkucHV0KHRoaXMsIGkpXG4gIH1cblxuICAvLyBSZXR1cm5zIGFsbCBjaGlsZCBlbGVtZW50c1xuICBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gbmV3IExpc3QoXG4gICAgICBtYXAodGhpcy5ub2RlLmNoaWxkcmVuLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gYWRvcHQobm9kZSlcbiAgICAgIH0pXG4gICAgKVxuICB9XG5cbiAgLy8gUmVtb3ZlIGFsbCBlbGVtZW50cyBpbiB0aGlzIGNvbnRhaW5lclxuICBjbGVhcigpIHtcbiAgICAvLyByZW1vdmUgY2hpbGRyZW5cbiAgICB3aGlsZSAodGhpcy5ub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgdGhpcy5ub2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZS5sYXN0Q2hpbGQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIENsb25lIGVsZW1lbnRcbiAgY2xvbmUoZGVlcCA9IHRydWUsIGFzc2lnbk5ld0lkcyA9IHRydWUpIHtcbiAgICAvLyB3cml0ZSBkb20gZGF0YSB0byB0aGUgZG9tIHNvIHRoZSBjbG9uZSBjYW4gcGlja3VwIHRoZSBkYXRhXG4gICAgdGhpcy53cml0ZURhdGFUb0RvbSgpXG5cbiAgICAvLyBjbG9uZSBlbGVtZW50XG4gICAgbGV0IG5vZGVDbG9uZSA9IHRoaXMubm9kZS5jbG9uZU5vZGUoZGVlcClcbiAgICBpZiAoYXNzaWduTmV3SWRzKSB7XG4gICAgICAvLyBhc3NpZ24gbmV3IGlkXG4gICAgICBub2RlQ2xvbmUgPSBhc3NpZ25OZXdJZChub2RlQ2xvbmUpXG4gICAgfVxuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub2RlQ2xvbmUpXG4gIH1cblxuICAvLyBJdGVyYXRlcyBvdmVyIGFsbCBjaGlsZHJlbiBhbmQgaW52b2tlcyBhIGdpdmVuIGJsb2NrXG4gIGVhY2goYmxvY2ssIGRlZXApIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4oKVxuICAgIGxldCBpLCBpbFxuXG4gICAgZm9yIChpID0gMCwgaWwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBibG9jay5hcHBseShjaGlsZHJlbltpXSwgW2ksIGNoaWxkcmVuXSlcblxuICAgICAgaWYgKGRlZXApIHtcbiAgICAgICAgY2hpbGRyZW5baV0uZWFjaChibG9jaywgZGVlcClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZWxlbWVudChub2RlTmFtZSwgYXR0cnMpIHtcbiAgICByZXR1cm4gdGhpcy5wdXQobmV3IERvbShjcmVhdGUobm9kZU5hbWUpLCBhdHRycykpXG4gIH1cblxuICAvLyBHZXQgZmlyc3QgY2hpbGRcbiAgZmlyc3QoKSB7XG4gICAgcmV0dXJuIGFkb3B0KHRoaXMubm9kZS5maXJzdENoaWxkKVxuICB9XG5cbiAgLy8gR2V0IGEgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgZ2V0KGkpIHtcbiAgICByZXR1cm4gYWRvcHQodGhpcy5ub2RlLmNoaWxkTm9kZXNbaV0pXG4gIH1cblxuICBnZXRFdmVudEhvbGRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlXG4gIH1cblxuICBnZXRFdmVudFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlXG4gIH1cblxuICAvLyBDaGVja3MgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgYSBjaGlsZFxuICBoYXMoZWxlbWVudCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4KGVsZW1lbnQpID49IDBcbiAgfVxuXG4gIGh0bWwoaHRtbE9yRm4sIG91dGVySFRNTCkge1xuICAgIHJldHVybiB0aGlzLnhtbChodG1sT3JGbiwgb3V0ZXJIVE1MLCBodG1sKVxuICB9XG5cbiAgLy8gR2V0IC8gc2V0IGlkXG4gIGlkKGlkKSB7XG4gICAgLy8gZ2VuZXJhdGUgbmV3IGlkIGlmIG5vIGlkIHNldFxuICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnICYmICF0aGlzLm5vZGUuaWQpIHtcbiAgICAgIHRoaXMubm9kZS5pZCA9IGVpZCh0aGlzLnR5cGUpXG4gICAgfVxuXG4gICAgLy8gZG9uJ3Qgc2V0IGRpcmVjdGx5IHdpdGggdGhpcy5ub2RlLmlkIHRvIG1ha2UgYG51bGxgIHdvcmsgY29ycmVjdGx5XG4gICAgcmV0dXJuIHRoaXMuYXR0cignaWQnLCBpZClcbiAgfVxuXG4gIC8vIEdldHMgaW5kZXggb2YgZ2l2ZW4gZWxlbWVudFxuICBpbmRleChlbGVtZW50KSB7XG4gICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwodGhpcy5ub2RlLmNoaWxkTm9kZXMpLmluZGV4T2YoZWxlbWVudC5ub2RlKVxuICB9XG5cbiAgLy8gR2V0IHRoZSBsYXN0IGNoaWxkXG4gIGxhc3QoKSB7XG4gICAgcmV0dXJuIGFkb3B0KHRoaXMubm9kZS5sYXN0Q2hpbGQpXG4gIH1cblxuICAvLyBtYXRjaGVzIHRoZSBlbGVtZW50IHZzIGEgY3NzIHNlbGVjdG9yXG4gIG1hdGNoZXMoc2VsZWN0b3IpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMubm9kZVxuICAgIGNvbnN0IG1hdGNoZXIgPVxuICAgICAgZWwubWF0Y2hlcyB8fFxuICAgICAgZWwubWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICBlbC5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgZWwubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgIGVsLm9NYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgIG51bGxcbiAgICByZXR1cm4gbWF0Y2hlciAmJiBtYXRjaGVyLmNhbGwoZWwsIHNlbGVjdG9yKVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgcGFyZW50IGVsZW1lbnQgaW5zdGFuY2VcbiAgcGFyZW50KHR5cGUpIHtcbiAgICBsZXQgcGFyZW50ID0gdGhpc1xuXG4gICAgLy8gY2hlY2sgZm9yIHBhcmVudFxuICAgIGlmICghcGFyZW50Lm5vZGUucGFyZW50Tm9kZSkgcmV0dXJuIG51bGxcblxuICAgIC8vIGdldCBwYXJlbnQgZWxlbWVudFxuICAgIHBhcmVudCA9IGFkb3B0KHBhcmVudC5ub2RlLnBhcmVudE5vZGUpXG5cbiAgICBpZiAoIXR5cGUpIHJldHVybiBwYXJlbnRcblxuICAgIC8vIGxvb3AgdGhyb3VnaCBhbmNlc3RvcnMgaWYgdHlwZSBpcyBnaXZlblxuICAgIGRvIHtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50Lm1hdGNoZXModHlwZSkgOiBwYXJlbnQgaW5zdGFuY2VvZiB0eXBlXG4gICAgICApXG4gICAgICAgIHJldHVybiBwYXJlbnRcbiAgICB9IHdoaWxlICgocGFyZW50ID0gYWRvcHQocGFyZW50Lm5vZGUucGFyZW50Tm9kZSkpKVxuXG4gICAgcmV0dXJuIHBhcmVudFxuICB9XG5cbiAgLy8gQmFzaWNhbGx5IGRvZXMgdGhlIHNhbWUgYXMgYGFkZCgpYCBidXQgcmV0dXJucyB0aGUgYWRkZWQgZWxlbWVudCBpbnN0ZWFkXG4gIHB1dChlbGVtZW50LCBpKSB7XG4gICAgZWxlbWVudCA9IG1ha2VJbnN0YW5jZShlbGVtZW50KVxuICAgIHRoaXMuYWRkKGVsZW1lbnQsIGkpXG4gICAgcmV0dXJuIGVsZW1lbnRcbiAgfVxuXG4gIC8vIEFkZCBlbGVtZW50IHRvIGdpdmVuIGNvbnRhaW5lciBhbmQgcmV0dXJuIGNvbnRhaW5lclxuICBwdXRJbihwYXJlbnQsIGkpIHtcbiAgICByZXR1cm4gbWFrZUluc3RhbmNlKHBhcmVudCkuYWRkKHRoaXMsIGkpXG4gIH1cblxuICAvLyBSZW1vdmUgZWxlbWVudFxuICByZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KCkpIHtcbiAgICAgIHRoaXMucGFyZW50KCkucmVtb3ZlRWxlbWVudCh0aGlzKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBSZW1vdmUgYSBnaXZlbiBjaGlsZFxuICByZW1vdmVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICB0aGlzLm5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudC5ub2RlKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIFJlcGxhY2UgdGhpcyB3aXRoIGVsZW1lbnRcbiAgcmVwbGFjZShlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IG1ha2VJbnN0YW5jZShlbGVtZW50KVxuXG4gICAgaWYgKHRoaXMubm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLm5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZWxlbWVudC5ub2RlLCB0aGlzLm5vZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnRcbiAgfVxuXG4gIHJvdW5kKHByZWNpc2lvbiA9IDIsIG1hcCA9IG51bGwpIHtcbiAgICBjb25zdCBmYWN0b3IgPSAxMCAqKiBwcmVjaXNpb25cbiAgICBjb25zdCBhdHRycyA9IHRoaXMuYXR0cihtYXApXG5cbiAgICBmb3IgKGNvbnN0IGkgaW4gYXR0cnMpIHtcbiAgICAgIGlmICh0eXBlb2YgYXR0cnNbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGF0dHJzW2ldID0gTWF0aC5yb3VuZChhdHRyc1tpXSAqIGZhY3RvcikgLyBmYWN0b3JcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmF0dHIoYXR0cnMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEltcG9ydCAvIEV4cG9ydCByYXcgc3ZnXG4gIHN2ZyhzdmdPckZuLCBvdXRlclNWRykge1xuICAgIHJldHVybiB0aGlzLnhtbChzdmdPckZuLCBvdXRlclNWRywgc3ZnKVxuICB9XG5cbiAgLy8gUmV0dXJuIGlkIG9uIHN0cmluZyBjb252ZXJzaW9uXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmlkKClcbiAgfVxuXG4gIHdvcmRzKHRleHQpIHtcbiAgICAvLyBUaGlzIGlzIGZhc3RlciB0aGFuIHJlbW92aW5nIGFsbCBjaGlsZHJlbiBhbmQgYWRkaW5nIGEgbmV3IG9uZVxuICAgIHRoaXMubm9kZS50ZXh0Q29udGVudCA9IHRleHRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgd3JhcChub2RlKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQoKVxuXG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZFRvKG5vZGUpXG4gICAgfVxuXG4gICAgY29uc3QgcG9zaXRpb24gPSBwYXJlbnQuaW5kZXgodGhpcylcbiAgICByZXR1cm4gcGFyZW50LnB1dChub2RlLCBwb3NpdGlvbikucHV0KHRoaXMpXG4gIH1cblxuICAvLyB3cml0ZSBzdmdqcyBkYXRhIHRvIHRoZSBkb21cbiAgd3JpdGVEYXRhVG9Eb20oKSB7XG4gICAgLy8gZHVtcCB2YXJpYWJsZXMgcmVjdXJzaXZlbHlcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy53cml0ZURhdGFUb0RvbSgpXG4gICAgfSlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBJbXBvcnQgLyBFeHBvcnQgcmF3IHN2Z1xuICB4bWwoeG1sT3JGbiwgb3V0ZXJYTUwsIG5zKSB7XG4gICAgaWYgKHR5cGVvZiB4bWxPckZuID09PSAnYm9vbGVhbicpIHtcbiAgICAgIG5zID0gb3V0ZXJYTUxcbiAgICAgIG91dGVyWE1MID0geG1sT3JGblxuICAgICAgeG1sT3JGbiA9IG51bGxcbiAgICB9XG5cbiAgICAvLyBhY3QgYXMgZ2V0dGVyIGlmIG5vIHN2ZyBzdHJpbmcgaXMgZ2l2ZW5cbiAgICBpZiAoeG1sT3JGbiA9PSBudWxsIHx8IHR5cGVvZiB4bWxPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBUaGUgZGVmYXVsdCBmb3IgZXhwb3J0cyBpcywgdGhhdCB0aGUgb3V0ZXJOb2RlIGlzIGluY2x1ZGVkXG4gICAgICBvdXRlclhNTCA9IG91dGVyWE1MID09IG51bGwgPyB0cnVlIDogb3V0ZXJYTUxcblxuICAgICAgLy8gd3JpdGUgc3ZnanMgZGF0YSB0byB0aGUgZG9tXG4gICAgICB0aGlzLndyaXRlRGF0YVRvRG9tKClcbiAgICAgIGxldCBjdXJyZW50ID0gdGhpc1xuXG4gICAgICAvLyBBbiBleHBvcnQgbW9kaWZpZXIgd2FzIHBhc3NlZFxuICAgICAgaWYgKHhtbE9yRm4gIT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50ID0gYWRvcHQoY3VycmVudC5ub2RlLmNsb25lTm9kZSh0cnVlKSlcblxuICAgICAgICAvLyBJZiB0aGUgdXNlciB3YW50cyBvdXRlckhUTUwgd2UgbmVlZCB0byBwcm9jZXNzIHRoaXMgbm9kZSwgdG9vXG4gICAgICAgIGlmIChvdXRlclhNTCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHhtbE9yRm4oY3VycmVudClcbiAgICAgICAgICBjdXJyZW50ID0gcmVzdWx0IHx8IGN1cnJlbnRcblxuICAgICAgICAgIC8vIFRoZSB1c2VyIGRvZXMgbm90IHdhbnQgdGhpcyBub2RlPyBXZWxsLCB0aGVuIGhlIGdldHMgbm90aGluZ1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSByZXR1cm4gJydcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZXAgbG9vcCB0aHJvdWdoIGFsbCBjaGlsZHJlbiBhbmQgYXBwbHkgbW9kaWZpZXJcbiAgICAgICAgY3VycmVudC5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB4bWxPckZuKHRoaXMpXG4gICAgICAgICAgY29uc3QgX3RoaXMgPSByZXN1bHQgfHwgdGhpc1xuXG4gICAgICAgICAgLy8gSWYgbW9kaWZpZXIgcmV0dXJucyBmYWxzZSwgZGlzY2FyZCBub2RlXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKClcblxuICAgICAgICAgICAgLy8gSWYgbW9kaWZpZXIgcmV0dXJucyBuZXcgbm9kZSwgdXNlIGl0XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgJiYgdGhpcyAhPT0gX3RoaXMpIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZShfdGhpcylcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpXG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBvdXRlciBvciBpbm5lciBjb250ZW50XG4gICAgICByZXR1cm4gb3V0ZXJYTUwgPyBjdXJyZW50Lm5vZGUub3V0ZXJIVE1MIDogY3VycmVudC5ub2RlLmlubmVySFRNTFxuICAgIH1cblxuICAgIC8vIEFjdCBhcyBzZXR0ZXIgaWYgd2UgZ290IGEgc3RyaW5nXG5cbiAgICAvLyBUaGUgZGVmYXVsdCBmb3IgaW1wb3J0IGlzLCB0aGF0IHRoZSBjdXJyZW50IG5vZGUgaXMgbm90IHJlcGxhY2VkXG4gICAgb3V0ZXJYTUwgPSBvdXRlclhNTCA9PSBudWxsID8gZmFsc2UgOiBvdXRlclhNTFxuXG4gICAgLy8gQ3JlYXRlIHRlbXBvcmFyeSBob2xkZXJcbiAgICBjb25zdCB3ZWxsID0gY3JlYXRlKCd3cmFwcGVyJywgbnMpXG4gICAgY29uc3QgZnJhZ21lbnQgPSBnbG9iYWxzLmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXG4gICAgLy8gRHVtcCByYXcgc3ZnXG4gICAgd2VsbC5pbm5lckhUTUwgPSB4bWxPckZuXG5cbiAgICAvLyBUcmFuc3BsYW50IG5vZGVzIGludG8gdGhlIGZyYWdtZW50XG4gICAgZm9yIChsZXQgbGVuID0gd2VsbC5jaGlsZHJlbi5sZW5ndGg7IGxlbi0tOyApIHtcbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHdlbGwuZmlyc3RFbGVtZW50Q2hpbGQpXG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQoKVxuXG4gICAgLy8gQWRkIHRoZSB3aG9sZSBmcmFnbWVudCBhdCBvbmNlXG4gICAgcmV0dXJuIG91dGVyWE1MID8gdGhpcy5yZXBsYWNlKGZyYWdtZW50KSAmJiBwYXJlbnQgOiB0aGlzLmFkZChmcmFnbWVudClcbiAgfVxufVxuXG5leHRlbmQoRG9tLCB7IGF0dHIsIGZpbmQsIGZpbmRPbmUgfSlcbnJlZ2lzdGVyKERvbSwgJ0RvbScpXG4iLCJpbXBvcnQgeyBiYm94LCByYm94LCBpbnNpZGUgfSBmcm9tICcuLi90eXBlcy9Cb3guanMnXG5pbXBvcnQgeyBjdG0sIHNjcmVlbkNUTSB9IGZyb20gJy4uL3R5cGVzL01hdHJpeC5qcydcbmltcG9ydCB7XG4gIGV4dGVuZCxcbiAgZ2V0Q2xhc3MsXG4gIG1ha2VJbnN0YW5jZSxcbiAgcmVnaXN0ZXIsXG4gIHJvb3Rcbn0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi91dGlscy93aW5kb3cuanMnXG5pbXBvcnQgeyBwb2ludCB9IGZyb20gJy4uL3R5cGVzL1BvaW50LmpzJ1xuaW1wb3J0IHsgcHJvcG9ydGlvbmFsU2l6ZSwgd3JpdGVEYXRhVG9Eb20gfSBmcm9tICcuLi91dGlscy91dGlscy5qcydcbmltcG9ydCB7IHJlZmVyZW5jZSB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9yZWdleC5qcydcbmltcG9ydCBEb20gZnJvbSAnLi9Eb20uanMnXG5pbXBvcnQgTGlzdCBmcm9tICcuLi90eXBlcy9MaXN0LmpzJ1xuaW1wb3J0IFNWR051bWJlciBmcm9tICcuLi90eXBlcy9TVkdOdW1iZXIuanMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsZW1lbnQgZXh0ZW5kcyBEb20ge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycykge1xuICAgIHN1cGVyKG5vZGUsIGF0dHJzKVxuXG4gICAgLy8gaW5pdGlhbGl6ZSBkYXRhIG9iamVjdFxuICAgIHRoaXMuZG9tID0ge31cblxuICAgIC8vIGNyZWF0ZSBjaXJjdWxhciByZWZlcmVuY2VcbiAgICB0aGlzLm5vZGUuaW5zdGFuY2UgPSB0aGlzXG5cbiAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtc3ZnanMnKSB8fCBub2RlLmhhc0F0dHJpYnV0ZSgnc3ZnanM6ZGF0YScpKSB7XG4gICAgICAvLyBwdWxsIHN2Z2pzIGRhdGEgZnJvbSB0aGUgZG9tIChnZXRBdHRyaWJ1dGVOUyBkb2Vzbid0IHdvcmsgaW4gaHRtbDUpXG4gICAgICB0aGlzLnNldERhdGEoXG4gICAgICAgIEpTT04ucGFyc2Uobm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3ZnanMnKSkgPz9cbiAgICAgICAgICBKU09OLnBhcnNlKG5vZGUuZ2V0QXR0cmlidXRlKCdzdmdqczpkYXRhJykpID8/XG4gICAgICAgICAge31cbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAvLyBNb3ZlIGVsZW1lbnQgYnkgaXRzIGNlbnRlclxuICBjZW50ZXIoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmN4KHgpLmN5KHkpXG4gIH1cblxuICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHgtYXhpc1xuICBjeCh4KSB7XG4gICAgcmV0dXJuIHggPT0gbnVsbFxuICAgICAgPyB0aGlzLngoKSArIHRoaXMud2lkdGgoKSAvIDJcbiAgICAgIDogdGhpcy54KHggLSB0aGlzLndpZHRoKCkgLyAyKVxuICB9XG5cbiAgLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB5LWF4aXNcbiAgY3koeSkge1xuICAgIHJldHVybiB5ID09IG51bGxcbiAgICAgID8gdGhpcy55KCkgKyB0aGlzLmhlaWdodCgpIC8gMlxuICAgICAgOiB0aGlzLnkoeSAtIHRoaXMuaGVpZ2h0KCkgLyAyKVxuICB9XG5cbiAgLy8gR2V0IGRlZnNcbiAgZGVmcygpIHtcbiAgICBjb25zdCByb290ID0gdGhpcy5yb290KClcbiAgICByZXR1cm4gcm9vdCAmJiByb290LmRlZnMoKVxuICB9XG5cbiAgLy8gUmVsYXRpdmUgbW92ZSBvdmVyIHggYW5kIHkgYXhlc1xuICBkbW92ZSh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuZHgoeCkuZHkoeSlcbiAgfVxuXG4gIC8vIFJlbGF0aXZlIG1vdmUgb3ZlciB4IGF4aXNcbiAgZHgoeCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy54KG5ldyBTVkdOdW1iZXIoeCkucGx1cyh0aGlzLngoKSkpXG4gIH1cblxuICAvLyBSZWxhdGl2ZSBtb3ZlIG92ZXIgeSBheGlzXG4gIGR5KHkgPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMueShuZXcgU1ZHTnVtYmVyKHkpLnBsdXModGhpcy55KCkpKVxuICB9XG5cbiAgZ2V0RXZlbnRIb2xkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIFNldCBoZWlnaHQgb2YgZWxlbWVudFxuICBoZWlnaHQoaGVpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cignaGVpZ2h0JywgaGVpZ2h0KVxuICB9XG5cbiAgLy8gTW92ZSBlbGVtZW50IHRvIGdpdmVuIHggYW5kIHkgdmFsdWVzXG4gIG1vdmUoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLngoeCkueSh5KVxuICB9XG5cbiAgLy8gcmV0dXJuIGFycmF5IG9mIGFsbCBhbmNlc3RvcnMgb2YgZ2l2ZW4gdHlwZSB1cCB0byB0aGUgcm9vdCBzdmdcbiAgcGFyZW50cyh1bnRpbCA9IHRoaXMucm9vdCgpKSB7XG4gICAgY29uc3QgaXNTZWxlY3RvciA9IHR5cGVvZiB1bnRpbCA9PT0gJ3N0cmluZydcbiAgICBpZiAoIWlzU2VsZWN0b3IpIHtcbiAgICAgIHVudGlsID0gbWFrZUluc3RhbmNlKHVudGlsKVxuICAgIH1cbiAgICBjb25zdCBwYXJlbnRzID0gbmV3IExpc3QoKVxuICAgIGxldCBwYXJlbnQgPSB0aGlzXG5cbiAgICB3aGlsZSAoXG4gICAgICAocGFyZW50ID0gcGFyZW50LnBhcmVudCgpKSAmJlxuICAgICAgcGFyZW50Lm5vZGUgIT09IGdsb2JhbHMuZG9jdW1lbnQgJiZcbiAgICAgIHBhcmVudC5ub2RlTmFtZSAhPT0gJyNkb2N1bWVudC1mcmFnbWVudCdcbiAgICApIHtcbiAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpXG5cbiAgICAgIGlmICghaXNTZWxlY3RvciAmJiBwYXJlbnQubm9kZSA9PT0gdW50aWwubm9kZSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKGlzU2VsZWN0b3IgJiYgcGFyZW50Lm1hdGNoZXModW50aWwpKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Lm5vZGUgPT09IHRoaXMucm9vdCgpLm5vZGUpIHtcbiAgICAgICAgLy8gV2Ugd29ya2VkIG91ciB3YXkgdG8gdGhlIHJvb3QgYW5kIGRpZG4ndCBtYXRjaCBgdW50aWxgXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudHNcbiAgfVxuXG4gIC8vIEdldCByZWZlcmVuY2VkIGVsZW1lbnQgZm9ybSBhdHRyaWJ1dGUgdmFsdWVcbiAgcmVmZXJlbmNlKGF0dHIpIHtcbiAgICBhdHRyID0gdGhpcy5hdHRyKGF0dHIpXG4gICAgaWYgKCFhdHRyKSByZXR1cm4gbnVsbFxuXG4gICAgY29uc3QgbSA9IChhdHRyICsgJycpLm1hdGNoKHJlZmVyZW5jZSlcbiAgICByZXR1cm4gbSA/IG1ha2VJbnN0YW5jZShtWzFdKSA6IG51bGxcbiAgfVxuXG4gIC8vIEdldCBwYXJlbnQgZG9jdW1lbnRcbiAgcm9vdCgpIHtcbiAgICBjb25zdCBwID0gdGhpcy5wYXJlbnQoZ2V0Q2xhc3Mocm9vdCkpXG4gICAgcmV0dXJuIHAgJiYgcC5yb290KClcbiAgfVxuXG4gIC8vIHNldCBnaXZlbiBkYXRhIHRvIHRoZSBlbGVtZW50cyBkYXRhIHByb3BlcnR5XG4gIHNldERhdGEobykge1xuICAgIHRoaXMuZG9tID0gb1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBTZXQgZWxlbWVudCBzaXplIHRvIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcbiAgc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodClcblxuICAgIHJldHVybiB0aGlzLndpZHRoKG5ldyBTVkdOdW1iZXIocC53aWR0aCkpLmhlaWdodChuZXcgU1ZHTnVtYmVyKHAuaGVpZ2h0KSlcbiAgfVxuXG4gIC8vIFNldCB3aWR0aCBvZiBlbGVtZW50XG4gIHdpZHRoKHdpZHRoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cignd2lkdGgnLCB3aWR0aClcbiAgfVxuXG4gIC8vIHdyaXRlIHN2Z2pzIGRhdGEgdG8gdGhlIGRvbVxuICB3cml0ZURhdGFUb0RvbSgpIHtcbiAgICB3cml0ZURhdGFUb0RvbSh0aGlzLCB0aGlzLmRvbSlcbiAgICByZXR1cm4gc3VwZXIud3JpdGVEYXRhVG9Eb20oKVxuICB9XG5cbiAgLy8gTW92ZSBvdmVyIHgtYXhpc1xuICB4KHgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd4JywgeClcbiAgfVxuXG4gIC8vIE1vdmUgb3ZlciB5LWF4aXNcbiAgeSh5KSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cigneScsIHkpXG4gIH1cbn1cblxuZXh0ZW5kKEVsZW1lbnQsIHtcbiAgYmJveCxcbiAgcmJveCxcbiAgaW5zaWRlLFxuICBwb2ludCxcbiAgY3RtLFxuICBzY3JlZW5DVE1cbn0pXG5cbnJlZ2lzdGVyKEVsZW1lbnQsICdFbGVtZW50JylcbiIsImltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uLy4uL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgQ29sb3IgZnJvbSAnLi4vLi4vdHlwZXMvQ29sb3IuanMnXG5pbXBvcnQgRWxlbWVudCBmcm9tICcuLi8uLi9lbGVtZW50cy9FbGVtZW50LmpzJ1xuaW1wb3J0IE1hdHJpeCBmcm9tICcuLi8uLi90eXBlcy9NYXRyaXguanMnXG5pbXBvcnQgUG9pbnQgZnJvbSAnLi4vLi4vdHlwZXMvUG9pbnQuanMnXG5pbXBvcnQgU1ZHTnVtYmVyIGZyb20gJy4uLy4uL3R5cGVzL1NWR051bWJlci5qcydcblxuLy8gRGVmaW5lIGxpc3Qgb2YgYXZhaWxhYmxlIGF0dHJpYnV0ZXMgZm9yIHN0cm9rZSBhbmQgZmlsbFxuY29uc3Qgc3VnYXIgPSB7XG4gIHN0cm9rZTogW1xuICAgICdjb2xvcicsXG4gICAgJ3dpZHRoJyxcbiAgICAnb3BhY2l0eScsXG4gICAgJ2xpbmVjYXAnLFxuICAgICdsaW5lam9pbicsXG4gICAgJ21pdGVybGltaXQnLFxuICAgICdkYXNoYXJyYXknLFxuICAgICdkYXNob2Zmc2V0J1xuICBdLFxuICBmaWxsOiBbJ2NvbG9yJywgJ29wYWNpdHknLCAncnVsZSddLFxuICBwcmVmaXg6IGZ1bmN0aW9uICh0LCBhKSB7XG4gICAgcmV0dXJuIGEgPT09ICdjb2xvcicgPyB0IDogdCArICctJyArIGFcbiAgfVxufVxuXG4vLyBBZGQgc3VnYXIgZm9yIGZpbGwgYW5kIHN0cm9rZVxuO1snZmlsbCcsICdzdHJva2UnXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gIGNvbnN0IGV4dGVuc2lvbiA9IHt9XG4gIGxldCBpXG5cbiAgZXh0ZW5zaW9uW21dID0gZnVuY3Rpb24gKG8pIHtcbiAgICBpZiAodHlwZW9mIG8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKG0pXG4gICAgfVxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvID09PSAnc3RyaW5nJyB8fFxuICAgICAgbyBpbnN0YW5jZW9mIENvbG9yIHx8XG4gICAgICBDb2xvci5pc1JnYihvKSB8fFxuICAgICAgbyBpbnN0YW5jZW9mIEVsZW1lbnRcbiAgICApIHtcbiAgICAgIHRoaXMuYXR0cihtLCBvKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzZXQgYWxsIGF0dHJpYnV0ZXMgZnJvbSBzdWdhci5maWxsIGFuZCBzdWdhci5zdHJva2UgbGlzdFxuICAgICAgZm9yIChpID0gc3VnYXJbbV0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKG9bc3VnYXJbbV1baV1dICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmF0dHIoc3VnYXIucHJlZml4KG0sIHN1Z2FyW21dW2ldKSwgb1tzdWdhclttXVtpXV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmVnaXN0ZXJNZXRob2RzKFsnRWxlbWVudCcsICdSdW5uZXInXSwgZXh0ZW5zaW9uKVxufSlcblxucmVnaXN0ZXJNZXRob2RzKFsnRWxlbWVudCcsICdSdW5uZXInXSwge1xuICAvLyBMZXQgdGhlIHVzZXIgc2V0IHRoZSBtYXRyaXggZGlyZWN0bHlcbiAgbWF0cml4OiBmdW5jdGlvbiAobWF0LCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgLy8gQWN0IGFzIGEgZ2V0dGVyXG4gICAgaWYgKG1hdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IE1hdHJpeCh0aGlzKVxuICAgIH1cblxuICAgIC8vIEFjdCBhcyBhIHNldHRlciwgdGhlIHVzZXIgY2FuIHBhc3MgYSBtYXRyaXggb3IgYSBzZXQgb2YgbnVtYmVyc1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ3RyYW5zZm9ybScsIG5ldyBNYXRyaXgobWF0LCBiLCBjLCBkLCBlLCBmKSlcbiAgfSxcblxuICAvLyBNYXAgcm90YXRpb24gdG8gdHJhbnNmb3JtXG4gIHJvdGF0ZTogZnVuY3Rpb24gKGFuZ2xlLCBjeCwgY3kpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oeyByb3RhdGU6IGFuZ2xlLCBveDogY3gsIG95OiBjeSB9LCB0cnVlKVxuICB9LFxuXG4gIC8vIE1hcCBza2V3IHRvIHRyYW5zZm9ybVxuICBza2V3OiBmdW5jdGlvbiAoeCwgeSwgY3gsIGN5KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gM1xuICAgICAgPyB0aGlzLnRyYW5zZm9ybSh7IHNrZXc6IHgsIG94OiB5LCBveTogY3ggfSwgdHJ1ZSlcbiAgICAgIDogdGhpcy50cmFuc2Zvcm0oeyBza2V3OiBbeCwgeV0sIG94OiBjeCwgb3k6IGN5IH0sIHRydWUpXG4gIH0sXG5cbiAgc2hlYXI6IGZ1bmN0aW9uIChsYW0sIGN4LCBjeSkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh7IHNoZWFyOiBsYW0sIG94OiBjeCwgb3k6IGN5IH0sIHRydWUpXG4gIH0sXG5cbiAgLy8gTWFwIHNjYWxlIHRvIHRyYW5zZm9ybVxuICBzY2FsZTogZnVuY3Rpb24gKHgsIHksIGN4LCBjeSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDNcbiAgICAgID8gdGhpcy50cmFuc2Zvcm0oeyBzY2FsZTogeCwgb3g6IHksIG95OiBjeCB9LCB0cnVlKVxuICAgICAgOiB0aGlzLnRyYW5zZm9ybSh7IHNjYWxlOiBbeCwgeV0sIG94OiBjeCwgb3k6IGN5IH0sIHRydWUpXG4gIH0sXG5cbiAgLy8gTWFwIHRyYW5zbGF0ZSB0byB0cmFuc2Zvcm1cbiAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh7IHRyYW5zbGF0ZTogW3gsIHldIH0sIHRydWUpXG4gIH0sXG5cbiAgLy8gTWFwIHJlbGF0aXZlIHRyYW5zbGF0aW9ucyB0byB0cmFuc2Zvcm1cbiAgcmVsYXRpdmU6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHsgcmVsYXRpdmU6IFt4LCB5XSB9LCB0cnVlKVxuICB9LFxuXG4gIC8vIE1hcCBmbGlwIHRvIHRyYW5zZm9ybVxuICBmbGlwOiBmdW5jdGlvbiAoZGlyZWN0aW9uID0gJ2JvdGgnLCBvcmlnaW4gPSAnY2VudGVyJykge1xuICAgIGlmICgneHlib3RodHJ1ZScuaW5kZXhPZihkaXJlY3Rpb24pID09PSAtMSkge1xuICAgICAgb3JpZ2luID0gZGlyZWN0aW9uXG4gICAgICBkaXJlY3Rpb24gPSAnYm90aCdcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oeyBmbGlwOiBkaXJlY3Rpb24sIG9yaWdpbjogb3JpZ2luIH0sIHRydWUpXG4gIH0sXG5cbiAgLy8gT3BhY2l0eVxuICBvcGFjaXR5OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdvcGFjaXR5JywgdmFsdWUpXG4gIH1cbn0pXG5cbnJlZ2lzdGVyTWV0aG9kcygncmFkaXVzJywge1xuICAvLyBBZGQgeCBhbmQgeSByYWRpdXNcbiAgcmFkaXVzOiBmdW5jdGlvbiAoeCwgeSA9IHgpIHtcbiAgICBjb25zdCB0eXBlID0gKHRoaXMuX2VsZW1lbnQgfHwgdGhpcykudHlwZVxuICAgIHJldHVybiB0eXBlID09PSAncmFkaWFsR3JhZGllbnQnXG4gICAgICA/IHRoaXMuYXR0cigncicsIG5ldyBTVkdOdW1iZXIoeCkpXG4gICAgICA6IHRoaXMucngoeCkucnkoeSlcbiAgfVxufSlcblxucmVnaXN0ZXJNZXRob2RzKCdQYXRoJywge1xuICAvLyBHZXQgcGF0aCBsZW5ndGhcbiAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS5nZXRUb3RhbExlbmd0aCgpXG4gIH0sXG4gIC8vIEdldCBwb2ludCBhdCBsZW5ndGhcbiAgcG9pbnRBdDogZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5ub2RlLmdldFBvaW50QXRMZW5ndGgobGVuZ3RoKSlcbiAgfVxufSlcblxucmVnaXN0ZXJNZXRob2RzKFsnRWxlbWVudCcsICdSdW5uZXInXSwge1xuICAvLyBTZXQgZm9udFxuICBmb250OiBmdW5jdGlvbiAoYSwgdikge1xuICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodiBpbiBhKSB0aGlzLmZvbnQodiwgYVt2XSlcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgcmV0dXJuIGEgPT09ICdsZWFkaW5nJ1xuICAgICAgPyB0aGlzLmxlYWRpbmcodilcbiAgICAgIDogYSA9PT0gJ2FuY2hvcidcbiAgICAgICAgPyB0aGlzLmF0dHIoJ3RleHQtYW5jaG9yJywgdilcbiAgICAgICAgOiBhID09PSAnc2l6ZScgfHxcbiAgICAgICAgICAgIGEgPT09ICdmYW1pbHknIHx8XG4gICAgICAgICAgICBhID09PSAnd2VpZ2h0JyB8fFxuICAgICAgICAgICAgYSA9PT0gJ3N0cmV0Y2gnIHx8XG4gICAgICAgICAgICBhID09PSAndmFyaWFudCcgfHxcbiAgICAgICAgICAgIGEgPT09ICdzdHlsZSdcbiAgICAgICAgICA/IHRoaXMuYXR0cignZm9udC0nICsgYSwgdilcbiAgICAgICAgICA6IHRoaXMuYXR0cihhLCB2KVxuICB9XG59KVxuXG4vLyBBZGQgZXZlbnRzIHRvIGVsZW1lbnRzXG5jb25zdCBtZXRob2RzID0gW1xuICAnY2xpY2snLFxuICAnZGJsY2xpY2snLFxuICAnbW91c2Vkb3duJyxcbiAgJ21vdXNldXAnLFxuICAnbW91c2VvdmVyJyxcbiAgJ21vdXNlb3V0JyxcbiAgJ21vdXNlbW92ZScsXG4gICdtb3VzZWVudGVyJyxcbiAgJ21vdXNlbGVhdmUnLFxuICAndG91Y2hzdGFydCcsXG4gICd0b3VjaG1vdmUnLFxuICAndG91Y2hsZWF2ZScsXG4gICd0b3VjaGVuZCcsXG4gICd0b3VjaGNhbmNlbCcsXG4gICdjb250ZXh0bWVudScsXG4gICd3aGVlbCcsXG4gICdwb2ludGVyZG93bicsXG4gICdwb2ludGVybW92ZScsXG4gICdwb2ludGVydXAnLFxuICAncG9pbnRlcmxlYXZlJyxcbiAgJ3BvaW50ZXJjYW5jZWwnXG5dLnJlZHVjZShmdW5jdGlvbiAobGFzdCwgZXZlbnQpIHtcbiAgLy8gYWRkIGV2ZW50IHRvIEVsZW1lbnRcbiAgY29uc3QgZm4gPSBmdW5jdGlvbiAoZikge1xuICAgIGlmIChmID09PSBudWxsKSB7XG4gICAgICB0aGlzLm9mZihldmVudClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbihldmVudCwgZilcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGxhc3RbZXZlbnRdID0gZm5cbiAgcmV0dXJuIGxhc3Rcbn0sIHt9KVxuXG5yZWdpc3Rlck1ldGhvZHMoJ0VsZW1lbnQnLCBtZXRob2RzKVxuIiwiaW1wb3J0IHsgZ2V0T3JpZ2luLCBpc0Rlc2NyaXB0aXZlIH0gZnJvbSAnLi4vLi4vdXRpbHMvdXRpbHMuanMnXG5pbXBvcnQgeyBkZWxpbWl0ZXIsIHRyYW5zZm9ybXMgfSBmcm9tICcuLi9jb3JlL3JlZ2V4LmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vLi4vdXRpbHMvbWV0aG9kcy5qcydcbmltcG9ydCBNYXRyaXggZnJvbSAnLi4vLi4vdHlwZXMvTWF0cml4LmpzJ1xuXG4vLyBSZXNldCBhbGwgdHJhbnNmb3JtYXRpb25zXG5leHBvcnQgZnVuY3Rpb24gdW50cmFuc2Zvcm0oKSB7XG4gIHJldHVybiB0aGlzLmF0dHIoJ3RyYW5zZm9ybScsIG51bGwpXG59XG5cbi8vIG1lcmdlIHRoZSB3aG9sZSB0cmFuc2Zvcm1hdGlvbiBjaGFpbiBpbnRvIG9uZSBtYXRyaXggYW5kIHJldHVybnMgaXRcbmV4cG9ydCBmdW5jdGlvbiBtYXRyaXhpZnkoKSB7XG4gIGNvbnN0IG1hdHJpeCA9ICh0aGlzLmF0dHIoJ3RyYW5zZm9ybScpIHx8ICcnKVxuICAgIC8vIHNwbGl0IHRyYW5zZm9ybWF0aW9uc1xuICAgIC5zcGxpdCh0cmFuc2Zvcm1zKVxuICAgIC5zbGljZSgwLCAtMSlcbiAgICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIC8vIGdlbmVyYXRlIGtleSA9PiB2YWx1ZSBwYWlyc1xuICAgICAgY29uc3Qga3YgPSBzdHIudHJpbSgpLnNwbGl0KCcoJylcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGt2WzBdLFxuICAgICAgICBrdlsxXS5zcGxpdChkZWxpbWl0ZXIpLm1hcChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyKVxuICAgICAgICB9KVxuICAgICAgXVxuICAgIH0pXG4gICAgLnJldmVyc2UoKVxuICAgIC8vIG1lcmdlIGV2ZXJ5IHRyYW5zZm9ybWF0aW9uIGludG8gb25lIG1hdHJpeFxuICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG1hdHJpeCwgdHJhbnNmb3JtKSB7XG4gICAgICBpZiAodHJhbnNmb3JtWzBdID09PSAnbWF0cml4Jykge1xuICAgICAgICByZXR1cm4gbWF0cml4LmxtdWx0aXBseShNYXRyaXguZnJvbUFycmF5KHRyYW5zZm9ybVsxXSkpXG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0cml4W3RyYW5zZm9ybVswXV0uYXBwbHkobWF0cml4LCB0cmFuc2Zvcm1bMV0pXG4gICAgfSwgbmV3IE1hdHJpeCgpKVxuXG4gIHJldHVybiBtYXRyaXhcbn1cblxuLy8gYWRkIGFuIGVsZW1lbnQgdG8gYW5vdGhlciBwYXJlbnQgd2l0aG91dCBjaGFuZ2luZyB0aGUgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9uIHRoZSBzY3JlZW5cbmV4cG9ydCBmdW5jdGlvbiB0b1BhcmVudChwYXJlbnQsIGkpIHtcbiAgaWYgKHRoaXMgPT09IHBhcmVudCkgcmV0dXJuIHRoaXNcblxuICBpZiAoaXNEZXNjcmlwdGl2ZSh0aGlzLm5vZGUpKSByZXR1cm4gdGhpcy5hZGRUbyhwYXJlbnQsIGkpXG5cbiAgY29uc3QgY3RtID0gdGhpcy5zY3JlZW5DVE0oKVxuICBjb25zdCBwQ3RtID0gcGFyZW50LnNjcmVlbkNUTSgpLmludmVyc2UoKVxuXG4gIHRoaXMuYWRkVG8ocGFyZW50LCBpKS51bnRyYW5zZm9ybSgpLnRyYW5zZm9ybShwQ3RtLm11bHRpcGx5KGN0bSkpXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gc2FtZSBhcyBhYm92ZSB3aXRoIHBhcmVudCBlcXVhbHMgcm9vdC1zdmdcbmV4cG9ydCBmdW5jdGlvbiB0b1Jvb3QoaSkge1xuICByZXR1cm4gdGhpcy50b1BhcmVudCh0aGlzLnJvb3QoKSwgaSlcbn1cblxuLy8gQWRkIHRyYW5zZm9ybWF0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybShvLCByZWxhdGl2ZSkge1xuICAvLyBBY3QgYXMgYSBnZXR0ZXIgaWYgbm8gb2JqZWN0IHdhcyBwYXNzZWRcbiAgaWYgKG8gPT0gbnVsbCB8fCB0eXBlb2YgbyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBkZWNvbXBvc2VkID0gbmV3IE1hdHJpeCh0aGlzKS5kZWNvbXBvc2UoKVxuICAgIHJldHVybiBvID09IG51bGwgPyBkZWNvbXBvc2VkIDogZGVjb21wb3NlZFtvXVxuICB9XG5cbiAgaWYgKCFNYXRyaXguaXNNYXRyaXhMaWtlKG8pKSB7XG4gICAgLy8gU2V0IHRoZSBvcmlnaW4gYWNjb3JkaW5nIHRvIHRoZSBkZWZpbmVkIHRyYW5zZm9ybVxuICAgIG8gPSB7IC4uLm8sIG9yaWdpbjogZ2V0T3JpZ2luKG8sIHRoaXMpIH1cbiAgfVxuXG4gIC8vIFRoZSB1c2VyIGNhbiBwYXNzIGEgYm9vbGVhbiwgYW4gRWxlbWVudCBvciBhbiBNYXRyaXggb3Igbm90aGluZ1xuICBjb25zdCBjbGVhblJlbGF0aXZlID0gcmVsYXRpdmUgPT09IHRydWUgPyB0aGlzIDogcmVsYXRpdmUgfHwgZmFsc2VcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE1hdHJpeChjbGVhblJlbGF0aXZlKS50cmFuc2Zvcm0obylcbiAgcmV0dXJuIHRoaXMuYXR0cigndHJhbnNmb3JtJywgcmVzdWx0KVxufVxuXG5yZWdpc3Rlck1ldGhvZHMoJ0VsZW1lbnQnLCB7XG4gIHVudHJhbnNmb3JtLFxuICBtYXRyaXhpZnksXG4gIHRvUGFyZW50LFxuICB0b1Jvb3QsXG4gIHRyYW5zZm9ybVxufSlcbiIsImltcG9ydCB7IHJlZ2lzdGVyIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCBFbGVtZW50IGZyb20gJy4vRWxlbWVudC5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgRWxlbWVudCB7XG4gIGZsYXR0ZW4oKSB7XG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQ29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYXR0ZW4oKS51bmdyb3VwKClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHVuZ3JvdXAocGFyZW50ID0gdGhpcy5wYXJlbnQoKSwgaW5kZXggPSBwYXJlbnQuaW5kZXgodGhpcykpIHtcbiAgICAvLyB3aGVuIHBhcmVudCAhPSB0aGlzLCB3ZSB3YW50IGFwcGVuZCBhbGwgZWxlbWVudHMgdG8gdGhlIGVuZFxuICAgIGluZGV4ID0gaW5kZXggPT09IC0xID8gcGFyZW50LmNoaWxkcmVuKCkubGVuZ3RoIDogaW5kZXhcblxuICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoaSwgY2hpbGRyZW4pIHtcbiAgICAgIC8vIHJldmVyc2UgZWFjaFxuICAgICAgcmV0dXJuIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIGkgLSAxXS50b1BhcmVudChwYXJlbnQsIGluZGV4KVxuICAgIH0pXG5cbiAgICByZXR1cm4gdGhpcy5yZW1vdmUoKVxuICB9XG59XG5cbnJlZ2lzdGVyKENvbnRhaW5lciwgJ0NvbnRhaW5lcicpXG4iLCJpbXBvcnQgeyBub2RlT3JOZXcsIHJlZ2lzdGVyIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9Db250YWluZXIuanMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZnMgZXh0ZW5kcyBDb250YWluZXIge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ2RlZnMnLCBub2RlKSwgYXR0cnMpXG4gIH1cblxuICBmbGF0dGVuKCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB1bmdyb3VwKCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxucmVnaXN0ZXIoRGVmcywgJ0RlZnMnKVxuIiwiaW1wb3J0IHsgcmVnaXN0ZXIgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9FbGVtZW50LmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFwZSBleHRlbmRzIEVsZW1lbnQge31cblxucmVnaXN0ZXIoU2hhcGUsICdTaGFwZScpXG4iLCJpbXBvcnQgU1ZHTnVtYmVyIGZyb20gJy4uLy4uL3R5cGVzL1NWR051bWJlci5qcydcblxuLy8gUmFkaXVzIHggdmFsdWVcbmV4cG9ydCBmdW5jdGlvbiByeChyeCkge1xuICByZXR1cm4gdGhpcy5hdHRyKCdyeCcsIHJ4KVxufVxuXG4vLyBSYWRpdXMgeSB2YWx1ZVxuZXhwb3J0IGZ1bmN0aW9uIHJ5KHJ5KSB7XG4gIHJldHVybiB0aGlzLmF0dHIoJ3J5JywgcnkpXG59XG5cbi8vIE1vdmUgb3ZlciB4LWF4aXNcbmV4cG9ydCBmdW5jdGlvbiB4KHgpIHtcbiAgcmV0dXJuIHggPT0gbnVsbCA/IHRoaXMuY3goKSAtIHRoaXMucngoKSA6IHRoaXMuY3goeCArIHRoaXMucngoKSlcbn1cblxuLy8gTW92ZSBvdmVyIHktYXhpc1xuZXhwb3J0IGZ1bmN0aW9uIHkoeSkge1xuICByZXR1cm4geSA9PSBudWxsID8gdGhpcy5jeSgpIC0gdGhpcy5yeSgpIDogdGhpcy5jeSh5ICsgdGhpcy5yeSgpKVxufVxuXG4vLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHgtYXhpc1xuZXhwb3J0IGZ1bmN0aW9uIGN4KHgpIHtcbiAgcmV0dXJuIHRoaXMuYXR0cignY3gnLCB4KVxufVxuXG4vLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHktYXhpc1xuZXhwb3J0IGZ1bmN0aW9uIGN5KHkpIHtcbiAgcmV0dXJuIHRoaXMuYXR0cignY3knLCB5KVxufVxuXG4vLyBTZXQgd2lkdGggb2YgZWxlbWVudFxuZXhwb3J0IGZ1bmN0aW9uIHdpZHRoKHdpZHRoKSB7XG4gIHJldHVybiB3aWR0aCA9PSBudWxsID8gdGhpcy5yeCgpICogMiA6IHRoaXMucngobmV3IFNWR051bWJlcih3aWR0aCkuZGl2aWRlKDIpKVxufVxuXG4vLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcbmV4cG9ydCBmdW5jdGlvbiBoZWlnaHQoaGVpZ2h0KSB7XG4gIHJldHVybiBoZWlnaHQgPT0gbnVsbFxuICAgID8gdGhpcy5yeSgpICogMlxuICAgIDogdGhpcy5yeShuZXcgU1ZHTnVtYmVyKGhlaWdodCkuZGl2aWRlKDIpKVxufVxuIiwiaW1wb3J0IHtcbiAgZXh0ZW5kLFxuICBub2RlT3JOZXcsXG4gIHJlZ2lzdGVyLFxuICB3cmFwV2l0aEF0dHJDaGVja1xufSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgcHJvcG9ydGlvbmFsU2l6ZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcbmltcG9ydCBTVkdOdW1iZXIgZnJvbSAnLi4vdHlwZXMvU1ZHTnVtYmVyLmpzJ1xuaW1wb3J0IFNoYXBlIGZyb20gJy4vU2hhcGUuanMnXG5pbXBvcnQgKiBhcyBjaXJjbGVkIGZyb20gJy4uL21vZHVsZXMvY29yZS9jaXJjbGVkLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGxpcHNlIGV4dGVuZHMgU2hhcGUge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ2VsbGlwc2UnLCBub2RlKSwgYXR0cnMpXG4gIH1cblxuICBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0KVxuXG4gICAgcmV0dXJuIHRoaXMucngobmV3IFNWR051bWJlcihwLndpZHRoKS5kaXZpZGUoMikpLnJ5KFxuICAgICAgbmV3IFNWR051bWJlcihwLmhlaWdodCkuZGl2aWRlKDIpXG4gICAgKVxuICB9XG59XG5cbmV4dGVuZChFbGxpcHNlLCBjaXJjbGVkKVxuXG5yZWdpc3Rlck1ldGhvZHMoJ0NvbnRhaW5lcicsIHtcbiAgLy8gQ3JlYXRlIGFuIGVsbGlwc2VcbiAgZWxsaXBzZTogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHdpZHRoID0gMCwgaGVpZ2h0ID0gd2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5wdXQobmV3IEVsbGlwc2UoKSkuc2l6ZSh3aWR0aCwgaGVpZ2h0KS5tb3ZlKDAsIDApXG4gIH0pXG59KVxuXG5yZWdpc3RlcihFbGxpcHNlLCAnRWxsaXBzZScpXG4iLCJpbXBvcnQgRG9tIGZyb20gJy4vRG9tLmpzJ1xuaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4uL3V0aWxzL3dpbmRvdy5qcydcbmltcG9ydCB7IHJlZ2lzdGVyLCBjcmVhdGUgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuXG5jbGFzcyBGcmFnbWVudCBleHRlbmRzIERvbSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUgPSBnbG9iYWxzLmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSkge1xuICAgIHN1cGVyKG5vZGUpXG4gIH1cblxuICAvLyBJbXBvcnQgLyBFeHBvcnQgcmF3IHhtbFxuICB4bWwoeG1sT3JGbiwgb3V0ZXJYTUwsIG5zKSB7XG4gICAgaWYgKHR5cGVvZiB4bWxPckZuID09PSAnYm9vbGVhbicpIHtcbiAgICAgIG5zID0gb3V0ZXJYTUxcbiAgICAgIG91dGVyWE1MID0geG1sT3JGblxuICAgICAgeG1sT3JGbiA9IG51bGxcbiAgICB9XG5cbiAgICAvLyBiZWNhdXNlIHRoaXMgaXMgYSBmcmFnbWVudCB3ZSBoYXZlIHRvIHB1dCBhbGwgZWxlbWVudHMgaW50byBhIHdyYXBwZXIgZmlyc3RcbiAgICAvLyBiZWZvcmUgd2UgY2FuIGdldCB0aGUgaW5uZXJYTUwgZnJvbSBpdFxuICAgIGlmICh4bWxPckZuID09IG51bGwgfHwgdHlwZW9mIHhtbE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IHdyYXBwZXIgPSBuZXcgRG9tKGNyZWF0ZSgnd3JhcHBlcicsIG5zKSlcbiAgICAgIHdyYXBwZXIuYWRkKHRoaXMubm9kZS5jbG9uZU5vZGUodHJ1ZSkpXG5cbiAgICAgIHJldHVybiB3cmFwcGVyLnhtbChmYWxzZSwgbnMpXG4gICAgfVxuXG4gICAgLy8gQWN0IGFzIHNldHRlciBpZiB3ZSBnb3QgYSBzdHJpbmdcbiAgICByZXR1cm4gc3VwZXIueG1sKHhtbE9yRm4sIGZhbHNlLCBucylcbiAgfVxufVxuXG5yZWdpc3RlcihGcmFnbWVudCwgJ0ZyYWdtZW50JylcblxuZXhwb3J0IGRlZmF1bHQgRnJhZ21lbnRcbiIsImltcG9ydCBTVkdOdW1iZXIgZnJvbSAnLi4vLi4vdHlwZXMvU1ZHTnVtYmVyLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh4LCB5KSB7XG4gIHJldHVybiAodGhpcy5fZWxlbWVudCB8fCB0aGlzKS50eXBlID09PSAncmFkaWFsR3JhZGllbnQnXG4gICAgPyB0aGlzLmF0dHIoeyBmeDogbmV3IFNWR051bWJlcih4KSwgZnk6IG5ldyBTVkdOdW1iZXIoeSkgfSlcbiAgICA6IHRoaXMuYXR0cih7IHgxOiBuZXcgU1ZHTnVtYmVyKHgpLCB5MTogbmV3IFNWR051bWJlcih5KSB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG8oeCwgeSkge1xuICByZXR1cm4gKHRoaXMuX2VsZW1lbnQgfHwgdGhpcykudHlwZSA9PT0gJ3JhZGlhbEdyYWRpZW50J1xuICAgID8gdGhpcy5hdHRyKHsgY3g6IG5ldyBTVkdOdW1iZXIoeCksIGN5OiBuZXcgU1ZHTnVtYmVyKHkpIH0pXG4gICAgOiB0aGlzLmF0dHIoeyB4MjogbmV3IFNWR051bWJlcih4KSwgeTI6IG5ldyBTVkdOdW1iZXIoeSkgfSlcbn1cbiIsImltcG9ydCB7XG4gIGV4dGVuZCxcbiAgbm9kZU9yTmV3LFxuICByZWdpc3RlcixcbiAgd3JhcFdpdGhBdHRyQ2hlY2tcbn0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgQm94IGZyb20gJy4uL3R5cGVzL0JveC5qcydcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9Db250YWluZXIuanMnXG5pbXBvcnQgYmFzZUZpbmQgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3NlbGVjdG9yLmpzJ1xuaW1wb3J0ICogYXMgZ3JhZGllbnRlZCBmcm9tICcuLi9tb2R1bGVzL2NvcmUvZ3JhZGllbnRlZC5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JhZGllbnQgZXh0ZW5kcyBDb250YWluZXIge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBhdHRycykge1xuICAgIHN1cGVyKFxuICAgICAgbm9kZU9yTmV3KHR5cGUgKyAnR3JhZGllbnQnLCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyBudWxsIDogdHlwZSksXG4gICAgICBhdHRyc1xuICAgIClcbiAgfVxuXG4gIC8vIGN1c3RvbSBhdHRyIHRvIGhhbmRsZSB0cmFuc2Zvcm1cbiAgYXR0cihhLCBiLCBjKSB7XG4gICAgaWYgKGEgPT09ICd0cmFuc2Zvcm0nKSBhID0gJ2dyYWRpZW50VHJhbnNmb3JtJ1xuICAgIHJldHVybiBzdXBlci5hdHRyKGEsIGIsIGMpXG4gIH1cblxuICBiYm94KCkge1xuICAgIHJldHVybiBuZXcgQm94KClcbiAgfVxuXG4gIHRhcmdldHMoKSB7XG4gICAgcmV0dXJuIGJhc2VGaW5kKCdzdmcgW2ZpbGwqPScgKyB0aGlzLmlkKCkgKyAnXScpXG4gIH1cblxuICAvLyBBbGlhcyBzdHJpbmcgY29udmVyc2lvbiB0byBmaWxsXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnVybCgpXG4gIH1cblxuICAvLyBVcGRhdGUgZ3JhZGllbnRcbiAgdXBkYXRlKGJsb2NrKSB7XG4gICAgLy8gcmVtb3ZlIGFsbCBzdG9wc1xuICAgIHRoaXMuY2xlYXIoKVxuXG4gICAgLy8gaW52b2tlIHBhc3NlZCBibG9ja1xuICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJsb2NrLmNhbGwodGhpcywgdGhpcylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSBmaWxsIGlkXG4gIHVybCgpIHtcbiAgICByZXR1cm4gJ3VybCgjJyArIHRoaXMuaWQoKSArICcpJ1xuICB9XG59XG5cbmV4dGVuZChHcmFkaWVudCwgZ3JhZGllbnRlZClcblxucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgLy8gQ3JlYXRlIGdyYWRpZW50IGVsZW1lbnQgaW4gZGVmc1xuICAgIGdyYWRpZW50KC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5ncmFkaWVudCguLi5hcmdzKVxuICAgIH1cbiAgfSxcbiAgLy8gZGVmaW5lIGdyYWRpZW50XG4gIERlZnM6IHtcbiAgICBncmFkaWVudDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHR5cGUsIGJsb2NrKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IEdyYWRpZW50KHR5cGUpKS51cGRhdGUoYmxvY2spXG4gICAgfSlcbiAgfVxufSlcblxucmVnaXN0ZXIoR3JhZGllbnQsICdHcmFkaWVudCcpXG4iLCJpbXBvcnQgeyBub2RlT3JOZXcsIHJlZ2lzdGVyLCB3cmFwV2l0aEF0dHJDaGVjayB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xuaW1wb3J0IEJveCBmcm9tICcuLi90eXBlcy9Cb3guanMnXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQ29udGFpbmVyLmpzJ1xuaW1wb3J0IGJhc2VGaW5kIGZyb20gJy4uL21vZHVsZXMvY29yZS9zZWxlY3Rvci5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGF0dGVybiBleHRlbmRzIENvbnRhaW5lciB7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ3BhdHRlcm4nLCBub2RlKSwgYXR0cnMpXG4gIH1cblxuICAvLyBjdXN0b20gYXR0ciB0byBoYW5kbGUgdHJhbnNmb3JtXG4gIGF0dHIoYSwgYiwgYykge1xuICAgIGlmIChhID09PSAndHJhbnNmb3JtJykgYSA9ICdwYXR0ZXJuVHJhbnNmb3JtJ1xuICAgIHJldHVybiBzdXBlci5hdHRyKGEsIGIsIGMpXG4gIH1cblxuICBiYm94KCkge1xuICAgIHJldHVybiBuZXcgQm94KClcbiAgfVxuXG4gIHRhcmdldHMoKSB7XG4gICAgcmV0dXJuIGJhc2VGaW5kKCdzdmcgW2ZpbGwqPScgKyB0aGlzLmlkKCkgKyAnXScpXG4gIH1cblxuICAvLyBBbGlhcyBzdHJpbmcgY29udmVyc2lvbiB0byBmaWxsXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnVybCgpXG4gIH1cblxuICAvLyBVcGRhdGUgcGF0dGVybiBieSByZWJ1aWxkaW5nXG4gIHVwZGF0ZShibG9jaykge1xuICAgIC8vIHJlbW92ZSBjb250ZW50XG4gICAgdGhpcy5jbGVhcigpXG5cbiAgICAvLyBpbnZva2UgcGFzc2VkIGJsb2NrXG4gICAgaWYgKHR5cGVvZiBibG9jayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYmxvY2suY2FsbCh0aGlzLCB0aGlzKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIGZpbGwgaWRcbiAgdXJsKCkge1xuICAgIHJldHVybiAndXJsKCMnICsgdGhpcy5pZCgpICsgJyknXG4gIH1cbn1cblxucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgLy8gQ3JlYXRlIHBhdHRlcm4gZWxlbWVudCBpbiBkZWZzXG4gICAgcGF0dGVybiguLi5hcmdzKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZzKCkucGF0dGVybiguLi5hcmdzKVxuICAgIH1cbiAgfSxcbiAgRGVmczoge1xuICAgIHBhdHRlcm46IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCBibG9jaykge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBQYXR0ZXJuKCkpLnVwZGF0ZShibG9jaykuYXR0cih7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHBhdHRlcm5Vbml0czogJ3VzZXJTcGFjZU9uVXNlJ1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59KVxuXG5yZWdpc3RlcihQYXR0ZXJuLCAnUGF0dGVybicpXG4iLCJpbXBvcnQgeyBpc0ltYWdlIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3JlZ2V4LmpzJ1xuaW1wb3J0IHsgbm9kZU9yTmV3LCByZWdpc3Rlciwgd3JhcFdpdGhBdHRyQ2hlY2sgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgb2ZmLCBvbiB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9ldmVudC5qcydcbmltcG9ydCB7IHJlZ2lzdGVyQXR0ckhvb2sgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvYXR0ci5qcydcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgeyB4bGluayB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9uYW1lc3BhY2VzLmpzJ1xuaW1wb3J0IFBhdHRlcm4gZnJvbSAnLi9QYXR0ZXJuLmpzJ1xuaW1wb3J0IFNoYXBlIGZyb20gJy4vU2hhcGUuanMnXG5pbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vdXRpbHMvd2luZG93LmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbWFnZSBleHRlbmRzIFNoYXBlIHtcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdpbWFnZScsIG5vZGUpLCBhdHRycylcbiAgfVxuXG4gIC8vIChyZSlsb2FkIGltYWdlXG4gIGxvYWQodXJsLCBjYWxsYmFjaykge1xuICAgIGlmICghdXJsKSByZXR1cm4gdGhpc1xuXG4gICAgY29uc3QgaW1nID0gbmV3IGdsb2JhbHMud2luZG93LkltYWdlKClcblxuICAgIG9uKFxuICAgICAgaW1nLFxuICAgICAgJ2xvYWQnLFxuICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMucGFyZW50KFBhdHRlcm4pXG5cbiAgICAgICAgLy8gZW5zdXJlIGltYWdlIHNpemVcbiAgICAgICAgaWYgKHRoaXMud2lkdGgoKSA9PT0gMCAmJiB0aGlzLmhlaWdodCgpID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5zaXplKGltZy53aWR0aCwgaW1nLmhlaWdodClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgUGF0dGVybikge1xuICAgICAgICAgIC8vIGVuc3VyZSBwYXR0ZXJuIHNpemUgaWYgbm90IHNldFxuICAgICAgICAgIGlmIChwLndpZHRoKCkgPT09IDAgJiYgcC5oZWlnaHQoKSA9PT0gMCkge1xuICAgICAgICAgICAgcC5zaXplKHRoaXMud2lkdGgoKSwgdGhpcy5oZWlnaHQoKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBlKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdGhpc1xuICAgIClcblxuICAgIG9uKGltZywgJ2xvYWQgZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBkb250IGZvcmdldCB0byB1bmJpbmQgbWVtb3J5IGxlYWtpbmcgZXZlbnRzXG4gICAgICBvZmYoaW1nKVxuICAgIH0pXG5cbiAgICByZXR1cm4gdGhpcy5hdHRyKCdocmVmJywgKGltZy5zcmMgPSB1cmwpLCB4bGluaylcbiAgfVxufVxuXG5yZWdpc3RlckF0dHJIb29rKGZ1bmN0aW9uIChhdHRyLCB2YWwsIF90aGlzKSB7XG4gIC8vIGNvbnZlcnQgaW1hZ2UgZmlsbCBhbmQgc3Ryb2tlIHRvIHBhdHRlcm5zXG4gIGlmIChhdHRyID09PSAnZmlsbCcgfHwgYXR0ciA9PT0gJ3N0cm9rZScpIHtcbiAgICBpZiAoaXNJbWFnZS50ZXN0KHZhbCkpIHtcbiAgICAgIHZhbCA9IF90aGlzLnJvb3QoKS5kZWZzKCkuaW1hZ2UodmFsKVxuICAgIH1cbiAgfVxuXG4gIGlmICh2YWwgaW5zdGFuY2VvZiBJbWFnZSkge1xuICAgIHZhbCA9IF90aGlzXG4gICAgICAucm9vdCgpXG4gICAgICAuZGVmcygpXG4gICAgICAucGF0dGVybigwLCAwLCAocGF0dGVybikgPT4ge1xuICAgICAgICBwYXR0ZXJuLmFkZCh2YWwpXG4gICAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHZhbFxufSlcblxucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgLy8gY3JlYXRlIGltYWdlIGVsZW1lbnQsIGxvYWQgaW1hZ2UgYW5kIHNldCBpdHMgc2l6ZVxuICAgIGltYWdlOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBJbWFnZSgpKS5zaXplKDAsIDApLmxvYWQoc291cmNlLCBjYWxsYmFjaylcbiAgICB9KVxuICB9XG59KVxuXG5yZWdpc3RlcihJbWFnZSwgJ0ltYWdlJylcbiIsImltcG9ydCB7IGRlbGltaXRlciB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9yZWdleC5qcydcbmltcG9ydCBTVkdBcnJheSBmcm9tICcuL1NWR0FycmF5LmpzJ1xuaW1wb3J0IEJveCBmcm9tICcuL0JveC5qcydcbmltcG9ydCBNYXRyaXggZnJvbSAnLi9NYXRyaXguanMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50QXJyYXkgZXh0ZW5kcyBTVkdBcnJheSB7XG4gIC8vIEdldCBib3VuZGluZyBib3ggb2YgcG9pbnRzXG4gIGJib3goKSB7XG4gICAgbGV0IG1heFggPSAtSW5maW5pdHlcbiAgICBsZXQgbWF4WSA9IC1JbmZpbml0eVxuICAgIGxldCBtaW5YID0gSW5maW5pdHlcbiAgICBsZXQgbWluWSA9IEluZmluaXR5XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgbWF4WCA9IE1hdGgubWF4KGVsWzBdLCBtYXhYKVxuICAgICAgbWF4WSA9IE1hdGgubWF4KGVsWzFdLCBtYXhZKVxuICAgICAgbWluWCA9IE1hdGgubWluKGVsWzBdLCBtaW5YKVxuICAgICAgbWluWSA9IE1hdGgubWluKGVsWzFdLCBtaW5ZKVxuICAgIH0pXG4gICAgcmV0dXJuIG5ldyBCb3gobWluWCwgbWluWSwgbWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKVxuICB9XG5cbiAgLy8gTW92ZSBwb2ludCBzdHJpbmdcbiAgbW92ZSh4LCB5KSB7XG4gICAgY29uc3QgYm94ID0gdGhpcy5iYm94KClcblxuICAgIC8vIGdldCByZWxhdGl2ZSBvZmZzZXRcbiAgICB4IC09IGJveC54XG4gICAgeSAtPSBib3gueVxuXG4gICAgLy8gbW92ZSBldmVyeSBwb2ludFxuICAgIGlmICghaXNOYU4oeCkgJiYgIWlzTmFOKHkpKSB7XG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzW2ldID0gW3RoaXNbaV1bMF0gKyB4LCB0aGlzW2ldWzFdICsgeV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gUGFyc2UgcG9pbnQgc3RyaW5nIGFuZCBmbGF0IGFycmF5XG4gIHBhcnNlKGFycmF5ID0gWzAsIDBdKSB7XG4gICAgY29uc3QgcG9pbnRzID0gW11cblxuICAgIC8vIGlmIGl0IGlzIGFuIGFycmF5LCB3ZSBmbGF0dGVuIGl0IGFuZCB0aGVyZWZvcmUgY2xvbmUgaXQgdG8gMSBkZXB0aHNcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgYXJyYXkgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnJheSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRWxzZSwgaXQgaXMgY29uc2lkZXJlZCBhcyBhIHN0cmluZ1xuICAgICAgLy8gcGFyc2UgcG9pbnRzXG4gICAgICBhcnJheSA9IGFycmF5LnRyaW0oKS5zcGxpdChkZWxpbWl0ZXIpLm1hcChwYXJzZUZsb2F0KVxuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIHBvaW50cyAtIGh0dHBzOi8vc3Znd2cub3JnL3N2ZzItZHJhZnQvc2hhcGVzLmh0bWwjRGF0YVR5cGVQb2ludHNcbiAgICAvLyBPZGQgbnVtYmVyIG9mIGNvb3JkaW5hdGVzIGlzIGFuIGVycm9yLiBJbiBzdWNoIGNhc2VzLCBkcm9wIHRoZSBsYXN0IG9kZCBjb29yZGluYXRlLlxuICAgIGlmIChhcnJheS5sZW5ndGggJSAyICE9PSAwKSBhcnJheS5wb3AoKVxuXG4gICAgLy8gd3JhcCBwb2ludHMgaW4gdHdvLXR1cGxlc1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkgPSBpICsgMikge1xuICAgICAgcG9pbnRzLnB1c2goW2FycmF5W2ldLCBhcnJheVtpICsgMV1dKVxuICAgIH1cblxuICAgIHJldHVybiBwb2ludHNcbiAgfVxuXG4gIC8vIFJlc2l6ZSBwb2x5IHN0cmluZ1xuICBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBsZXQgaVxuICAgIGNvbnN0IGJveCA9IHRoaXMuYmJveCgpXG5cbiAgICAvLyByZWNhbGN1bGF0ZSBwb3NpdGlvbiBvZiBhbGwgcG9pbnRzIGFjY29yZGluZyB0byBuZXcgc2l6ZVxuICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChib3gud2lkdGgpXG4gICAgICAgIHRoaXNbaV1bMF0gPSAoKHRoaXNbaV1bMF0gLSBib3gueCkgKiB3aWR0aCkgLyBib3gud2lkdGggKyBib3gueFxuICAgICAgaWYgKGJveC5oZWlnaHQpXG4gICAgICAgIHRoaXNbaV1bMV0gPSAoKHRoaXNbaV1bMV0gLSBib3gueSkgKiBoZWlnaHQpIC8gYm94LmhlaWdodCArIGJveC55XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIENvbnZlcnQgYXJyYXkgdG8gbGluZSBvYmplY3RcbiAgdG9MaW5lKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4MTogdGhpc1swXVswXSxcbiAgICAgIHkxOiB0aGlzWzBdWzFdLFxuICAgICAgeDI6IHRoaXNbMV1bMF0sXG4gICAgICB5MjogdGhpc1sxXVsxXVxuICAgIH1cbiAgfVxuXG4gIC8vIENvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IGFycmF5ID0gW11cbiAgICAvLyBjb252ZXJ0IHRvIGEgcG9seSBwb2ludCBzdHJpbmdcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSB0aGlzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGFycmF5LnB1c2godGhpc1tpXS5qb2luKCcsJykpXG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5LmpvaW4oJyAnKVxuICB9XG5cbiAgdHJhbnNmb3JtKG0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnRyYW5zZm9ybU8obSlcbiAgfVxuXG4gIC8vIHRyYW5zZm9ybSBwb2ludHMgd2l0aCBtYXRyaXggKHNpbWlsYXIgdG8gUG9pbnQudHJhbnNmb3JtKVxuICB0cmFuc2Zvcm1PKG0pIHtcbiAgICBpZiAoIU1hdHJpeC5pc01hdHJpeExpa2UobSkpIHtcbiAgICAgIG0gPSBuZXcgTWF0cml4KG0pXG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IHRoaXMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgLy8gUGVyZm9ybSB0aGUgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgICBjb25zdCBbeCwgeV0gPSB0aGlzW2ldXG4gICAgICB0aGlzW2ldWzBdID0gbS5hICogeCArIG0uYyAqIHkgKyBtLmVcbiAgICAgIHRoaXNbaV1bMV0gPSBtLmIgKiB4ICsgbS5kICogeSArIG0uZlxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cbiIsImltcG9ydCBQb2ludEFycmF5IGZyb20gJy4uLy4uL3R5cGVzL1BvaW50QXJyYXkuanMnXG5cbmV4cG9ydCBjb25zdCBNb3JwaEFycmF5ID0gUG9pbnRBcnJheVxuXG4vLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lciBvdmVyIHgtYXhpc1xuZXhwb3J0IGZ1bmN0aW9uIHgoeCkge1xuICByZXR1cm4geCA9PSBudWxsID8gdGhpcy5iYm94KCkueCA6IHRoaXMubW92ZSh4LCB0aGlzLmJib3goKS55KVxufVxuXG4vLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lciBvdmVyIHktYXhpc1xuZXhwb3J0IGZ1bmN0aW9uIHkoeSkge1xuICByZXR1cm4geSA9PSBudWxsID8gdGhpcy5iYm94KCkueSA6IHRoaXMubW92ZSh0aGlzLmJib3goKS54LCB5KVxufVxuXG4vLyBTZXQgd2lkdGggb2YgZWxlbWVudFxuZXhwb3J0IGZ1bmN0aW9uIHdpZHRoKHdpZHRoKSB7XG4gIGNvbnN0IGIgPSB0aGlzLmJib3goKVxuICByZXR1cm4gd2lkdGggPT0gbnVsbCA/IGIud2lkdGggOiB0aGlzLnNpemUod2lkdGgsIGIuaGVpZ2h0KVxufVxuXG4vLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcbmV4cG9ydCBmdW5jdGlvbiBoZWlnaHQoaGVpZ2h0KSB7XG4gIGNvbnN0IGIgPSB0aGlzLmJib3goKVxuICByZXR1cm4gaGVpZ2h0ID09IG51bGwgPyBiLmhlaWdodCA6IHRoaXMuc2l6ZShiLndpZHRoLCBoZWlnaHQpXG59XG4iLCJpbXBvcnQge1xuICBleHRlbmQsXG4gIG5vZGVPck5ldyxcbiAgcmVnaXN0ZXIsXG4gIHdyYXBXaXRoQXR0ckNoZWNrXG59IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5pbXBvcnQgeyBwcm9wb3J0aW9uYWxTaXplIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMuanMnXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xuaW1wb3J0IFBvaW50QXJyYXkgZnJvbSAnLi4vdHlwZXMvUG9pbnRBcnJheS5qcydcbmltcG9ydCBTaGFwZSBmcm9tICcuL1NoYXBlLmpzJ1xuaW1wb3J0ICogYXMgcG9pbnRlZCBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcG9pbnRlZC5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZSBleHRlbmRzIFNoYXBlIHtcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygnbGluZScsIG5vZGUpLCBhdHRycylcbiAgfVxuXG4gIC8vIEdldCBhcnJheVxuICBhcnJheSgpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50QXJyYXkoW1xuICAgICAgW3RoaXMuYXR0cigneDEnKSwgdGhpcy5hdHRyKCd5MScpXSxcbiAgICAgIFt0aGlzLmF0dHIoJ3gyJyksIHRoaXMuYXR0cigneTInKV1cbiAgICBdKVxuICB9XG5cbiAgLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXJcbiAgbW92ZSh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cih0aGlzLmFycmF5KCkubW92ZSh4LCB5KS50b0xpbmUoKSlcbiAgfVxuXG4gIC8vIE92ZXJ3cml0ZSBuYXRpdmUgcGxvdCgpIG1ldGhvZFxuICBwbG90KHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgaWYgKHgxID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5KClcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB5MSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHgxID0geyB4MSwgeTEsIHgyLCB5MiB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHgxID0gbmV3IFBvaW50QXJyYXkoeDEpLnRvTGluZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYXR0cih4MSlcbiAgfVxuXG4gIC8vIFNldCBlbGVtZW50IHNpemUgdG8gZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuICBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0KVxuICAgIHJldHVybiB0aGlzLmF0dHIodGhpcy5hcnJheSgpLnNpemUocC53aWR0aCwgcC5oZWlnaHQpLnRvTGluZSgpKVxuICB9XG59XG5cbmV4dGVuZChMaW5lLCBwb2ludGVkKVxuXG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgYSBsaW5lIGVsZW1lbnRcbiAgICBsaW5lOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgLy8gbWFrZSBzdXJlIHBsb3QgaXMgY2FsbGVkIGFzIGEgc2V0dGVyXG4gICAgICAvLyB4MSBpcyBub3QgbmVjZXNzYXJpbHkgYSBudW1iZXIsIGl0IGNhbiBhbHNvIGJlIGFuIGFycmF5LCBhIHN0cmluZyBhbmQgYSBQb2ludEFycmF5XG4gICAgICByZXR1cm4gTGluZS5wcm90b3R5cGUucGxvdC5hcHBseShcbiAgICAgICAgdGhpcy5wdXQobmV3IExpbmUoKSksXG4gICAgICAgIGFyZ3NbMF0gIT0gbnVsbCA/IGFyZ3MgOiBbMCwgMCwgMCwgMF1cbiAgICAgIClcbiAgICB9KVxuICB9XG59KVxuXG5yZWdpc3RlcihMaW5lLCAnTGluZScpXG4iLCJpbXBvcnQgeyBub2RlT3JOZXcsIHJlZ2lzdGVyLCB3cmFwV2l0aEF0dHJDaGVjayB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL0NvbnRhaW5lci5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFya2VyIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygnbWFya2VyJywgbm9kZSksIGF0dHJzKVxuICB9XG5cbiAgLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XG4gIGhlaWdodChoZWlnaHQpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdtYXJrZXJIZWlnaHQnLCBoZWlnaHQpXG4gIH1cblxuICBvcmllbnQob3JpZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cignb3JpZW50Jywgb3JpZW50KVxuICB9XG5cbiAgLy8gU2V0IG1hcmtlciByZWZYIGFuZCByZWZZXG4gIHJlZih4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cigncmVmWCcsIHgpLmF0dHIoJ3JlZlknLCB5KVxuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSBmaWxsIGlkXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAndXJsKCMnICsgdGhpcy5pZCgpICsgJyknXG4gIH1cblxuICAvLyBVcGRhdGUgbWFya2VyXG4gIHVwZGF0ZShibG9jaykge1xuICAgIC8vIHJlbW92ZSBhbGwgY29udGVudFxuICAgIHRoaXMuY2xlYXIoKVxuXG4gICAgLy8gaW52b2tlIHBhc3NlZCBibG9ja1xuICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJsb2NrLmNhbGwodGhpcywgdGhpcylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcbiAgd2lkdGgod2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdtYXJrZXJXaWR0aCcsIHdpZHRoKVxuICB9XG59XG5cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIG1hcmtlciguLi5hcmdzKSB7XG4gICAgICAvLyBDcmVhdGUgbWFya2VyIGVsZW1lbnQgaW4gZGVmc1xuICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLm1hcmtlciguLi5hcmdzKVxuICAgIH1cbiAgfSxcbiAgRGVmczoge1xuICAgIC8vIENyZWF0ZSBtYXJrZXJcbiAgICBtYXJrZXI6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCBibG9jaykge1xuICAgICAgLy8gU2V0IGRlZmF1bHQgdmlld2JveCB0byBtYXRjaCB0aGUgd2lkdGggYW5kIGhlaWdodCwgc2V0IHJlZiB0byBjeCBhbmQgY3kgYW5kIHNldCBvcmllbnQgdG8gYXV0b1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBNYXJrZXIoKSlcbiAgICAgICAgLnNpemUod2lkdGgsIGhlaWdodClcbiAgICAgICAgLnJlZih3aWR0aCAvIDIsIGhlaWdodCAvIDIpXG4gICAgICAgIC52aWV3Ym94KDAsIDAsIHdpZHRoLCBoZWlnaHQpXG4gICAgICAgIC5hdHRyKCdvcmllbnQnLCAnYXV0bycpXG4gICAgICAgIC51cGRhdGUoYmxvY2spXG4gICAgfSlcbiAgfSxcbiAgbWFya2VyOiB7XG4gICAgLy8gQ3JlYXRlIGFuZCBhdHRhY2ggbWFya2Vyc1xuICAgIG1hcmtlcihtYXJrZXIsIHdpZHRoLCBoZWlnaHQsIGJsb2NrKSB7XG4gICAgICBsZXQgYXR0ciA9IFsnbWFya2VyJ11cblxuICAgICAgLy8gQnVpbGQgYXR0cmlidXRlIG5hbWVcbiAgICAgIGlmIChtYXJrZXIgIT09ICdhbGwnKSBhdHRyLnB1c2gobWFya2VyKVxuICAgICAgYXR0ciA9IGF0dHIuam9pbignLScpXG5cbiAgICAgIC8vIFNldCBtYXJrZXIgYXR0cmlidXRlXG4gICAgICBtYXJrZXIgPVxuICAgICAgICBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBNYXJrZXJcbiAgICAgICAgICA/IGFyZ3VtZW50c1sxXVxuICAgICAgICAgIDogdGhpcy5kZWZzKCkubWFya2VyKHdpZHRoLCBoZWlnaHQsIGJsb2NrKVxuXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKGF0dHIsIG1hcmtlcilcbiAgICB9XG4gIH1cbn0pXG5cbnJlZ2lzdGVyKE1hcmtlciwgJ01hcmtlcicpXG4iLCJpbXBvcnQgeyB0aW1lbGluZSB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9kZWZhdWx0cy5qcydcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5cbi8qKipcbkJhc2UgQ2xhc3Ncbj09PT09PT09PT1cblRoZSBiYXNlIHN0ZXBwZXIgY2xhc3MgdGhhdCB3aWxsIGJlXG4qKiovXG5cbmZ1bmN0aW9uIG1ha2VTZXR0ZXJHZXR0ZXIoaywgZikge1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAodiA9PSBudWxsKSByZXR1cm4gdGhpc1trXVxuICAgIHRoaXNba10gPSB2XG4gICAgaWYgKGYpIGYuY2FsbCh0aGlzKVxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGVhc2luZyA9IHtcbiAgJy0nOiBmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHBvc1xuICB9LFxuICAnPD4nOiBmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIC1NYXRoLmNvcyhwb3MgKiBNYXRoLlBJKSAvIDIgKyAwLjVcbiAgfSxcbiAgJz4nOiBmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIE1hdGguc2luKChwb3MgKiBNYXRoLlBJKSAvIDIpXG4gIH0sXG4gICc8JzogZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiAtTWF0aC5jb3MoKHBvcyAqIE1hdGguUEkpIC8gMikgKyAxXG4gIH0sXG4gIGJlemllcjogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgLy8gc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtZWFzaW5nLTEvI2N1YmljLWJlemllci1hbGdvXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAodCA8IDApIHtcbiAgICAgICAgaWYgKHgxID4gMCkge1xuICAgICAgICAgIHJldHVybiAoeTEgLyB4MSkgKiB0XG4gICAgICAgIH0gZWxzZSBpZiAoeDIgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuICh5MiAvIHgyKSAqIHRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHQgPiAxKSB7XG4gICAgICAgIGlmICh4MiA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gKCgxIC0geTIpIC8gKDEgLSB4MikpICogdCArICh5MiAtIHgyKSAvICgxIC0geDIpXG4gICAgICAgIH0gZWxzZSBpZiAoeDEgPCAxKSB7XG4gICAgICAgICAgcmV0dXJuICgoMSAtIHkxKSAvICgxIC0geDEpKSAqIHQgKyAoeTEgLSB4MSkgLyAoMSAtIHgxKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAxXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAzICogdCAqICgxIC0gdCkgKiogMiAqIHkxICsgMyAqIHQgKiogMiAqICgxIC0gdCkgKiB5MiArIHQgKiogM1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtZWFzaW5nLTEvI3N0ZXAtdGltaW5nLWZ1bmN0aW9uLWFsZ29cbiAgc3RlcHM6IGZ1bmN0aW9uIChzdGVwcywgc3RlcFBvc2l0aW9uID0gJ2VuZCcpIHtcbiAgICAvLyBkZWFsIHdpdGggXCJqdW1wLVwiIHByZWZpeFxuICAgIHN0ZXBQb3NpdGlvbiA9IHN0ZXBQb3NpdGlvbi5zcGxpdCgnLScpLnJldmVyc2UoKVswXVxuXG4gICAgbGV0IGp1bXBzID0gc3RlcHNcbiAgICBpZiAoc3RlcFBvc2l0aW9uID09PSAnbm9uZScpIHtcbiAgICAgIC0tanVtcHNcbiAgICB9IGVsc2UgaWYgKHN0ZXBQb3NpdGlvbiA9PT0gJ2JvdGgnKSB7XG4gICAgICArK2p1bXBzXG4gICAgfVxuXG4gICAgLy8gVGhlIGJlZm9yZUZsYWcgaXMgZXNzZW50aWFsbHkgdXNlbGVzc1xuICAgIHJldHVybiAodCwgYmVmb3JlRmxhZyA9IGZhbHNlKSA9PiB7XG4gICAgICAvLyBTdGVwIGlzIGNhbGxlZCBjdXJyZW50U3RlcCBpbiByZWZlcmVuY2VkIHVybFxuICAgICAgbGV0IHN0ZXAgPSBNYXRoLmZsb29yKHQgKiBzdGVwcylcbiAgICAgIGNvbnN0IGp1bXBpbmcgPSAodCAqIHN0ZXApICUgMSA9PT0gMFxuXG4gICAgICBpZiAoc3RlcFBvc2l0aW9uID09PSAnc3RhcnQnIHx8IHN0ZXBQb3NpdGlvbiA9PT0gJ2JvdGgnKSB7XG4gICAgICAgICsrc3RlcFxuICAgICAgfVxuXG4gICAgICBpZiAoYmVmb3JlRmxhZyAmJiBqdW1waW5nKSB7XG4gICAgICAgIC0tc3RlcFxuICAgICAgfVxuXG4gICAgICBpZiAodCA+PSAwICYmIHN0ZXAgPCAwKSB7XG4gICAgICAgIHN0ZXAgPSAwXG4gICAgICB9XG5cbiAgICAgIGlmICh0IDw9IDEgJiYgc3RlcCA+IGp1bXBzKSB7XG4gICAgICAgIHN0ZXAgPSBqdW1wc1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RlcCAvIGp1bXBzXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTdGVwcGVyIHtcbiAgZG9uZSgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKioqXG5FYXNpbmcgRnVuY3Rpb25zXG49PT09PT09PT09PT09PT09XG4qKiovXG5cbmV4cG9ydCBjbGFzcyBFYXNlIGV4dGVuZHMgU3RlcHBlciB7XG4gIGNvbnN0cnVjdG9yKGZuID0gdGltZWxpbmUuZWFzZSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmVhc2UgPSBlYXNpbmdbZm5dIHx8IGZuXG4gIH1cblxuICBzdGVwKGZyb20sIHRvLCBwb3MpIHtcbiAgICBpZiAodHlwZW9mIGZyb20gIT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcG9zIDwgMSA/IGZyb20gOiB0b1xuICAgIH1cbiAgICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICogdGhpcy5lYXNlKHBvcylcbiAgfVxufVxuXG4vKioqXG5Db250cm9sbGVyIFR5cGVzXG49PT09PT09PT09PT09PT09XG4qKiovXG5cbmV4cG9ydCBjbGFzcyBDb250cm9sbGVyIGV4dGVuZHMgU3RlcHBlciB7XG4gIGNvbnN0cnVjdG9yKGZuKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuc3RlcHBlciA9IGZuXG4gIH1cblxuICBkb25lKGMpIHtcbiAgICByZXR1cm4gYy5kb25lXG4gIH1cblxuICBzdGVwKGN1cnJlbnQsIHRhcmdldCwgZHQsIGMpIHtcbiAgICByZXR1cm4gdGhpcy5zdGVwcGVyKGN1cnJlbnQsIHRhcmdldCwgZHQsIGMpXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjYWxjdWxhdGUoKSB7XG4gIC8vIEFwcGx5IHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcbiAgY29uc3QgZHVyYXRpb24gPSAodGhpcy5fZHVyYXRpb24gfHwgNTAwKSAvIDEwMDBcbiAgY29uc3Qgb3ZlcnNob290ID0gdGhpcy5fb3ZlcnNob290IHx8IDBcblxuICAvLyBDYWxjdWxhdGUgdGhlIFBJRCBuYXR1cmFsIHJlc3BvbnNlXG4gIGNvbnN0IGVwcyA9IDFlLTEwXG4gIGNvbnN0IHBpID0gTWF0aC5QSVxuICBjb25zdCBvcyA9IE1hdGgubG9nKG92ZXJzaG9vdCAvIDEwMCArIGVwcylcbiAgY29uc3QgemV0YSA9IC1vcyAvIE1hdGguc3FydChwaSAqIHBpICsgb3MgKiBvcylcbiAgY29uc3Qgd24gPSAzLjkgLyAoemV0YSAqIGR1cmF0aW9uKVxuXG4gIC8vIENhbGN1bGF0ZSB0aGUgU3ByaW5nIHZhbHVlc1xuICB0aGlzLmQgPSAyICogemV0YSAqIHduXG4gIHRoaXMuayA9IHduICogd25cbn1cblxuZXhwb3J0IGNsYXNzIFNwcmluZyBleHRlbmRzIENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihkdXJhdGlvbiA9IDUwMCwgb3ZlcnNob290ID0gMCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmR1cmF0aW9uKGR1cmF0aW9uKS5vdmVyc2hvb3Qob3ZlcnNob290KVxuICB9XG5cbiAgc3RlcChjdXJyZW50LCB0YXJnZXQsIGR0LCBjKSB7XG4gICAgaWYgKHR5cGVvZiBjdXJyZW50ID09PSAnc3RyaW5nJykgcmV0dXJuIGN1cnJlbnRcbiAgICBjLmRvbmUgPSBkdCA9PT0gSW5maW5pdHlcbiAgICBpZiAoZHQgPT09IEluZmluaXR5KSByZXR1cm4gdGFyZ2V0XG4gICAgaWYgKGR0ID09PSAwKSByZXR1cm4gY3VycmVudFxuXG4gICAgaWYgKGR0ID4gMTAwKSBkdCA9IDE2XG5cbiAgICBkdCAvPSAxMDAwXG5cbiAgICAvLyBHZXQgdGhlIHByZXZpb3VzIHZlbG9jaXR5XG4gICAgY29uc3QgdmVsb2NpdHkgPSBjLnZlbG9jaXR5IHx8IDBcblxuICAgIC8vIEFwcGx5IHRoZSBjb250cm9sIHRvIGdldCB0aGUgbmV3IHBvc2l0aW9uIGFuZCBzdG9yZSBpdFxuICAgIGNvbnN0IGFjY2VsZXJhdGlvbiA9IC10aGlzLmQgKiB2ZWxvY2l0eSAtIHRoaXMuayAqIChjdXJyZW50IC0gdGFyZ2V0KVxuICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gY3VycmVudCArIHZlbG9jaXR5ICogZHQgKyAoYWNjZWxlcmF0aW9uICogZHQgKiBkdCkgLyAyXG5cbiAgICAvLyBTdG9yZSB0aGUgdmVsb2NpdHlcbiAgICBjLnZlbG9jaXR5ID0gdmVsb2NpdHkgKyBhY2NlbGVyYXRpb24gKiBkdFxuXG4gICAgLy8gRmlndXJlIG91dCBpZiB3ZSBoYXZlIGNvbnZlcmdlZCwgYW5kIGlmIHNvLCBwYXNzIHRoZSB2YWx1ZVxuICAgIGMuZG9uZSA9IE1hdGguYWJzKHRhcmdldCAtIG5ld1Bvc2l0aW9uKSArIE1hdGguYWJzKHZlbG9jaXR5KSA8IDAuMDAyXG4gICAgcmV0dXJuIGMuZG9uZSA/IHRhcmdldCA6IG5ld1Bvc2l0aW9uXG4gIH1cbn1cblxuZXh0ZW5kKFNwcmluZywge1xuICBkdXJhdGlvbjogbWFrZVNldHRlckdldHRlcignX2R1cmF0aW9uJywgcmVjYWxjdWxhdGUpLFxuICBvdmVyc2hvb3Q6IG1ha2VTZXR0ZXJHZXR0ZXIoJ19vdmVyc2hvb3QnLCByZWNhbGN1bGF0ZSlcbn0pXG5cbmV4cG9ydCBjbGFzcyBQSUQgZXh0ZW5kcyBDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IocCA9IDAuMSwgaSA9IDAuMDEsIGQgPSAwLCB3aW5kdXAgPSAxMDAwKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMucChwKS5pKGkpLmQoZCkud2luZHVwKHdpbmR1cClcbiAgfVxuXG4gIHN0ZXAoY3VycmVudCwgdGFyZ2V0LCBkdCwgYykge1xuICAgIGlmICh0eXBlb2YgY3VycmVudCA9PT0gJ3N0cmluZycpIHJldHVybiBjdXJyZW50XG4gICAgYy5kb25lID0gZHQgPT09IEluZmluaXR5XG5cbiAgICBpZiAoZHQgPT09IEluZmluaXR5KSByZXR1cm4gdGFyZ2V0XG4gICAgaWYgKGR0ID09PSAwKSByZXR1cm4gY3VycmVudFxuXG4gICAgY29uc3QgcCA9IHRhcmdldCAtIGN1cnJlbnRcbiAgICBsZXQgaSA9IChjLmludGVncmFsIHx8IDApICsgcCAqIGR0XG4gICAgY29uc3QgZCA9IChwIC0gKGMuZXJyb3IgfHwgMCkpIC8gZHRcbiAgICBjb25zdCB3aW5kdXAgPSB0aGlzLl93aW5kdXBcblxuICAgIC8vIGFudGl3aW5kdXBcbiAgICBpZiAod2luZHVwICE9PSBmYWxzZSkge1xuICAgICAgaSA9IE1hdGgubWF4KC13aW5kdXAsIE1hdGgubWluKGksIHdpbmR1cCkpXG4gICAgfVxuXG4gICAgYy5lcnJvciA9IHBcbiAgICBjLmludGVncmFsID0gaVxuXG4gICAgYy5kb25lID0gTWF0aC5hYnMocCkgPCAwLjAwMVxuXG4gICAgcmV0dXJuIGMuZG9uZSA/IHRhcmdldCA6IGN1cnJlbnQgKyAodGhpcy5QICogcCArIHRoaXMuSSAqIGkgKyB0aGlzLkQgKiBkKVxuICB9XG59XG5cbmV4dGVuZChQSUQsIHtcbiAgd2luZHVwOiBtYWtlU2V0dGVyR2V0dGVyKCdfd2luZHVwJyksXG4gIHA6IG1ha2VTZXR0ZXJHZXR0ZXIoJ1AnKSxcbiAgaTogbWFrZVNldHRlckdldHRlcignSScpLFxuICBkOiBtYWtlU2V0dGVyR2V0dGVyKCdEJylcbn0pXG4iLCJpbXBvcnQgeyBpc1BhdGhMZXR0ZXIgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcmVnZXguanMnXG5pbXBvcnQgUG9pbnQgZnJvbSAnLi4vdHlwZXMvUG9pbnQuanMnXG5cbmNvbnN0IHNlZ21lbnRQYXJhbWV0ZXJzID0ge1xuICBNOiAyLFxuICBMOiAyLFxuICBIOiAxLFxuICBWOiAxLFxuICBDOiA2LFxuICBTOiA0LFxuICBROiA0LFxuICBUOiAyLFxuICBBOiA3LFxuICBaOiAwXG59XG5cbmNvbnN0IHBhdGhIYW5kbGVycyA9IHtcbiAgTTogZnVuY3Rpb24gKGMsIHAsIHAwKSB7XG4gICAgcC54ID0gcDAueCA9IGNbMF1cbiAgICBwLnkgPSBwMC55ID0gY1sxXVxuXG4gICAgcmV0dXJuIFsnTScsIHAueCwgcC55XVxuICB9LFxuICBMOiBmdW5jdGlvbiAoYywgcCkge1xuICAgIHAueCA9IGNbMF1cbiAgICBwLnkgPSBjWzFdXG4gICAgcmV0dXJuIFsnTCcsIGNbMF0sIGNbMV1dXG4gIH0sXG4gIEg6IGZ1bmN0aW9uIChjLCBwKSB7XG4gICAgcC54ID0gY1swXVxuICAgIHJldHVybiBbJ0gnLCBjWzBdXVxuICB9LFxuICBWOiBmdW5jdGlvbiAoYywgcCkge1xuICAgIHAueSA9IGNbMF1cbiAgICByZXR1cm4gWydWJywgY1swXV1cbiAgfSxcbiAgQzogZnVuY3Rpb24gKGMsIHApIHtcbiAgICBwLnggPSBjWzRdXG4gICAgcC55ID0gY1s1XVxuICAgIHJldHVybiBbJ0MnLCBjWzBdLCBjWzFdLCBjWzJdLCBjWzNdLCBjWzRdLCBjWzVdXVxuICB9LFxuICBTOiBmdW5jdGlvbiAoYywgcCkge1xuICAgIHAueCA9IGNbMl1cbiAgICBwLnkgPSBjWzNdXG4gICAgcmV0dXJuIFsnUycsIGNbMF0sIGNbMV0sIGNbMl0sIGNbM11dXG4gIH0sXG4gIFE6IGZ1bmN0aW9uIChjLCBwKSB7XG4gICAgcC54ID0gY1syXVxuICAgIHAueSA9IGNbM11cbiAgICByZXR1cm4gWydRJywgY1swXSwgY1sxXSwgY1syXSwgY1szXV1cbiAgfSxcbiAgVDogZnVuY3Rpb24gKGMsIHApIHtcbiAgICBwLnggPSBjWzBdXG4gICAgcC55ID0gY1sxXVxuICAgIHJldHVybiBbJ1QnLCBjWzBdLCBjWzFdXVxuICB9LFxuICBaOiBmdW5jdGlvbiAoYywgcCwgcDApIHtcbiAgICBwLnggPSBwMC54XG4gICAgcC55ID0gcDAueVxuICAgIHJldHVybiBbJ1onXVxuICB9LFxuICBBOiBmdW5jdGlvbiAoYywgcCkge1xuICAgIHAueCA9IGNbNV1cbiAgICBwLnkgPSBjWzZdXG4gICAgcmV0dXJuIFsnQScsIGNbMF0sIGNbMV0sIGNbMl0sIGNbM10sIGNbNF0sIGNbNV0sIGNbNl1dXG4gIH1cbn1cblxuY29uc3QgbWxodnF0Y3NheiA9ICdtbGh2cXRjc2F6Jy5zcGxpdCgnJylcblxuZm9yIChsZXQgaSA9IDAsIGlsID0gbWxodnF0Y3Nhei5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gIHBhdGhIYW5kbGVyc1ttbGh2cXRjc2F6W2ldXSA9IChmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYywgcCwgcDApIHtcbiAgICAgIGlmIChpID09PSAnSCcpIGNbMF0gPSBjWzBdICsgcC54XG4gICAgICBlbHNlIGlmIChpID09PSAnVicpIGNbMF0gPSBjWzBdICsgcC55XG4gICAgICBlbHNlIGlmIChpID09PSAnQScpIHtcbiAgICAgICAgY1s1XSA9IGNbNV0gKyBwLnhcbiAgICAgICAgY1s2XSA9IGNbNl0gKyBwLnlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IGMubGVuZ3RoOyBqIDwgamw7ICsraikge1xuICAgICAgICAgIGNbal0gPSBjW2pdICsgKGogJSAyID8gcC55IDogcC54KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoSGFuZGxlcnNbaV0oYywgcCwgcDApXG4gICAgfVxuICB9KShtbGh2cXRjc2F6W2ldLnRvVXBwZXJDYXNlKCkpXG59XG5cbmZ1bmN0aW9uIG1ha2VBYnNvbHV0KHBhcnNlcikge1xuICBjb25zdCBjb21tYW5kID0gcGFyc2VyLnNlZ21lbnRbMF1cbiAgcmV0dXJuIHBhdGhIYW5kbGVyc1tjb21tYW5kXShwYXJzZXIuc2VnbWVudC5zbGljZSgxKSwgcGFyc2VyLnAsIHBhcnNlci5wMClcbn1cblxuZnVuY3Rpb24gc2VnbWVudENvbXBsZXRlKHBhcnNlcikge1xuICByZXR1cm4gKFxuICAgIHBhcnNlci5zZWdtZW50Lmxlbmd0aCAmJlxuICAgIHBhcnNlci5zZWdtZW50Lmxlbmd0aCAtIDEgPT09XG4gICAgICBzZWdtZW50UGFyYW1ldGVyc1twYXJzZXIuc2VnbWVudFswXS50b1VwcGVyQ2FzZSgpXVxuICApXG59XG5cbmZ1bmN0aW9uIHN0YXJ0TmV3U2VnbWVudChwYXJzZXIsIHRva2VuKSB7XG4gIHBhcnNlci5pbk51bWJlciAmJiBmaW5hbGl6ZU51bWJlcihwYXJzZXIsIGZhbHNlKVxuICBjb25zdCBwYXRoTGV0dGVyID0gaXNQYXRoTGV0dGVyLnRlc3QodG9rZW4pXG5cbiAgaWYgKHBhdGhMZXR0ZXIpIHtcbiAgICBwYXJzZXIuc2VnbWVudCA9IFt0b2tlbl1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsYXN0Q29tbWFuZCA9IHBhcnNlci5sYXN0Q29tbWFuZFxuICAgIGNvbnN0IHNtYWxsID0gbGFzdENvbW1hbmQudG9Mb3dlckNhc2UoKVxuICAgIGNvbnN0IGlzU21hbGwgPSBsYXN0Q29tbWFuZCA9PT0gc21hbGxcbiAgICBwYXJzZXIuc2VnbWVudCA9IFtzbWFsbCA9PT0gJ20nID8gKGlzU21hbGwgPyAnbCcgOiAnTCcpIDogbGFzdENvbW1hbmRdXG4gIH1cblxuICBwYXJzZXIuaW5TZWdtZW50ID0gdHJ1ZVxuICBwYXJzZXIubGFzdENvbW1hbmQgPSBwYXJzZXIuc2VnbWVudFswXVxuXG4gIHJldHVybiBwYXRoTGV0dGVyXG59XG5cbmZ1bmN0aW9uIGZpbmFsaXplTnVtYmVyKHBhcnNlciwgaW5OdW1iZXIpIHtcbiAgaWYgKCFwYXJzZXIuaW5OdW1iZXIpIHRocm93IG5ldyBFcnJvcignUGFyc2VyIEVycm9yJylcbiAgcGFyc2VyLm51bWJlciAmJiBwYXJzZXIuc2VnbWVudC5wdXNoKHBhcnNlRmxvYXQocGFyc2VyLm51bWJlcikpXG4gIHBhcnNlci5pbk51bWJlciA9IGluTnVtYmVyXG4gIHBhcnNlci5udW1iZXIgPSAnJ1xuICBwYXJzZXIucG9pbnRTZWVuID0gZmFsc2VcbiAgcGFyc2VyLmhhc0V4cG9uZW50ID0gZmFsc2VcblxuICBpZiAoc2VnbWVudENvbXBsZXRlKHBhcnNlcikpIHtcbiAgICBmaW5hbGl6ZVNlZ21lbnQocGFyc2VyKVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmFsaXplU2VnbWVudChwYXJzZXIpIHtcbiAgcGFyc2VyLmluU2VnbWVudCA9IGZhbHNlXG4gIGlmIChwYXJzZXIuYWJzb2x1dGUpIHtcbiAgICBwYXJzZXIuc2VnbWVudCA9IG1ha2VBYnNvbHV0KHBhcnNlcilcbiAgfVxuICBwYXJzZXIuc2VnbWVudHMucHVzaChwYXJzZXIuc2VnbWVudClcbn1cblxuZnVuY3Rpb24gaXNBcmNGbGFnKHBhcnNlcikge1xuICBpZiAoIXBhcnNlci5zZWdtZW50Lmxlbmd0aCkgcmV0dXJuIGZhbHNlXG4gIGNvbnN0IGlzQXJjID0gcGFyc2VyLnNlZ21lbnRbMF0udG9VcHBlckNhc2UoKSA9PT0gJ0EnXG4gIGNvbnN0IGxlbmd0aCA9IHBhcnNlci5zZWdtZW50Lmxlbmd0aFxuXG4gIHJldHVybiBpc0FyYyAmJiAobGVuZ3RoID09PSA0IHx8IGxlbmd0aCA9PT0gNSlcbn1cblxuZnVuY3Rpb24gaXNFeHBvbmVudGlhbChwYXJzZXIpIHtcbiAgcmV0dXJuIHBhcnNlci5sYXN0VG9rZW4udG9VcHBlckNhc2UoKSA9PT0gJ0UnXG59XG5cbmNvbnN0IHBhdGhEZWxpbWl0ZXJzID0gbmV3IFNldChbJyAnLCAnLCcsICdcXHQnLCAnXFxuJywgJ1xccicsICdcXGYnXSlcbmV4cG9ydCBmdW5jdGlvbiBwYXRoUGFyc2VyKGQsIHRvQWJzb2x1dGUgPSB0cnVlKSB7XG4gIGxldCBpbmRleCA9IDBcbiAgbGV0IHRva2VuID0gJydcbiAgY29uc3QgcGFyc2VyID0ge1xuICAgIHNlZ21lbnQ6IFtdLFxuICAgIGluTnVtYmVyOiBmYWxzZSxcbiAgICBudW1iZXI6ICcnLFxuICAgIGxhc3RUb2tlbjogJycsXG4gICAgaW5TZWdtZW50OiBmYWxzZSxcbiAgICBzZWdtZW50czogW10sXG4gICAgcG9pbnRTZWVuOiBmYWxzZSxcbiAgICBoYXNFeHBvbmVudDogZmFsc2UsXG4gICAgYWJzb2x1dGU6IHRvQWJzb2x1dGUsXG4gICAgcDA6IG5ldyBQb2ludCgpLFxuICAgIHA6IG5ldyBQb2ludCgpXG4gIH1cblxuICB3aGlsZSAoKChwYXJzZXIubGFzdFRva2VuID0gdG9rZW4pLCAodG9rZW4gPSBkLmNoYXJBdChpbmRleCsrKSkpKSB7XG4gICAgaWYgKCFwYXJzZXIuaW5TZWdtZW50KSB7XG4gICAgICBpZiAoc3RhcnROZXdTZWdtZW50KHBhcnNlciwgdG9rZW4pKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRva2VuID09PSAnLicpIHtcbiAgICAgIGlmIChwYXJzZXIucG9pbnRTZWVuIHx8IHBhcnNlci5oYXNFeHBvbmVudCkge1xuICAgICAgICBmaW5hbGl6ZU51bWJlcihwYXJzZXIsIGZhbHNlKVxuICAgICAgICAtLWluZGV4XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBwYXJzZXIuaW5OdW1iZXIgPSB0cnVlXG4gICAgICBwYXJzZXIucG9pbnRTZWVuID0gdHJ1ZVxuICAgICAgcGFyc2VyLm51bWJlciArPSB0b2tlblxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoIWlzTmFOKHBhcnNlSW50KHRva2VuKSkpIHtcbiAgICAgIGlmIChwYXJzZXIubnVtYmVyID09PSAnMCcgfHwgaXNBcmNGbGFnKHBhcnNlcikpIHtcbiAgICAgICAgcGFyc2VyLmluTnVtYmVyID0gdHJ1ZVxuICAgICAgICBwYXJzZXIubnVtYmVyID0gdG9rZW5cbiAgICAgICAgZmluYWxpemVOdW1iZXIocGFyc2VyLCB0cnVlKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBwYXJzZXIuaW5OdW1iZXIgPSB0cnVlXG4gICAgICBwYXJzZXIubnVtYmVyICs9IHRva2VuXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChwYXRoRGVsaW1pdGVycy5oYXModG9rZW4pKSB7XG4gICAgICBpZiAocGFyc2VyLmluTnVtYmVyKSB7XG4gICAgICAgIGZpbmFsaXplTnVtYmVyKHBhcnNlciwgZmFsc2UpXG4gICAgICB9XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmICh0b2tlbiA9PT0gJy0nIHx8IHRva2VuID09PSAnKycpIHtcbiAgICAgIGlmIChwYXJzZXIuaW5OdW1iZXIgJiYgIWlzRXhwb25lbnRpYWwocGFyc2VyKSkge1xuICAgICAgICBmaW5hbGl6ZU51bWJlcihwYXJzZXIsIGZhbHNlKVxuICAgICAgICAtLWluZGV4XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBwYXJzZXIubnVtYmVyICs9IHRva2VuXG4gICAgICBwYXJzZXIuaW5OdW1iZXIgPSB0cnVlXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmICh0b2tlbi50b1VwcGVyQ2FzZSgpID09PSAnRScpIHtcbiAgICAgIHBhcnNlci5udW1iZXIgKz0gdG9rZW5cbiAgICAgIHBhcnNlci5oYXNFeHBvbmVudCA9IHRydWVcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKGlzUGF0aExldHRlci50ZXN0KHRva2VuKSkge1xuICAgICAgaWYgKHBhcnNlci5pbk51bWJlcikge1xuICAgICAgICBmaW5hbGl6ZU51bWJlcihwYXJzZXIsIGZhbHNlKVxuICAgICAgfSBlbHNlIGlmICghc2VnbWVudENvbXBsZXRlKHBhcnNlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJzZXIgRXJyb3InKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluYWxpemVTZWdtZW50KHBhcnNlcilcbiAgICAgIH1cbiAgICAgIC0taW5kZXhcbiAgICB9XG4gIH1cblxuICBpZiAocGFyc2VyLmluTnVtYmVyKSB7XG4gICAgZmluYWxpemVOdW1iZXIocGFyc2VyLCBmYWxzZSlcbiAgfVxuXG4gIGlmIChwYXJzZXIuaW5TZWdtZW50ICYmIHNlZ21lbnRDb21wbGV0ZShwYXJzZXIpKSB7XG4gICAgZmluYWxpemVTZWdtZW50KHBhcnNlcilcbiAgfVxuXG4gIHJldHVybiBwYXJzZXIuc2VnbWVudHNcbn1cbiIsImltcG9ydCBTVkdBcnJheSBmcm9tICcuL1NWR0FycmF5LmpzJ1xuaW1wb3J0IHBhcnNlciBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcGFyc2VyLmpzJ1xuaW1wb3J0IEJveCBmcm9tICcuL0JveC5qcydcbmltcG9ydCB7IHBhdGhQYXJzZXIgfSBmcm9tICcuLi91dGlscy9wYXRoUGFyc2VyLmpzJ1xuXG5mdW5jdGlvbiBhcnJheVRvU3RyaW5nKGEpIHtcbiAgbGV0IHMgPSAnJ1xuICBmb3IgKGxldCBpID0gMCwgaWwgPSBhLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICBzICs9IGFbaV1bMF1cblxuICAgIGlmIChhW2ldWzFdICE9IG51bGwpIHtcbiAgICAgIHMgKz0gYVtpXVsxXVxuXG4gICAgICBpZiAoYVtpXVsyXSAhPSBudWxsKSB7XG4gICAgICAgIHMgKz0gJyAnXG4gICAgICAgIHMgKz0gYVtpXVsyXVxuXG4gICAgICAgIGlmIChhW2ldWzNdICE9IG51bGwpIHtcbiAgICAgICAgICBzICs9ICcgJ1xuICAgICAgICAgIHMgKz0gYVtpXVszXVxuICAgICAgICAgIHMgKz0gJyAnXG4gICAgICAgICAgcyArPSBhW2ldWzRdXG5cbiAgICAgICAgICBpZiAoYVtpXVs1XSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzICs9ICcgJ1xuICAgICAgICAgICAgcyArPSBhW2ldWzVdXG4gICAgICAgICAgICBzICs9ICcgJ1xuICAgICAgICAgICAgcyArPSBhW2ldWzZdXG5cbiAgICAgICAgICAgIGlmIChhW2ldWzddICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcyArPSAnICdcbiAgICAgICAgICAgICAgcyArPSBhW2ldWzddXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHMgKyAnICdcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGF0aEFycmF5IGV4dGVuZHMgU1ZHQXJyYXkge1xuICAvLyBHZXQgYm91bmRpbmcgYm94IG9mIHBhdGhcbiAgYmJveCgpIHtcbiAgICBwYXJzZXIoKS5wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHRoaXMudG9TdHJpbmcoKSlcbiAgICByZXR1cm4gbmV3IEJveChwYXJzZXIubm9kZXMucGF0aC5nZXRCQm94KCkpXG4gIH1cblxuICAvLyBNb3ZlIHBhdGggc3RyaW5nXG4gIG1vdmUoeCwgeSkge1xuICAgIC8vIGdldCBib3VuZGluZyBib3ggb2YgY3VycmVudCBzaXR1YXRpb25cbiAgICBjb25zdCBib3ggPSB0aGlzLmJib3goKVxuXG4gICAgLy8gZ2V0IHJlbGF0aXZlIG9mZnNldFxuICAgIHggLT0gYm94LnhcbiAgICB5IC09IGJveC55XG5cbiAgICBpZiAoIWlzTmFOKHgpICYmICFpc05hTih5KSkge1xuICAgICAgLy8gbW92ZSBldmVyeSBwb2ludFxuICAgICAgZm9yIChsZXQgbCwgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbCA9IHRoaXNbaV1bMF1cblxuICAgICAgICBpZiAobCA9PT0gJ00nIHx8IGwgPT09ICdMJyB8fCBsID09PSAnVCcpIHtcbiAgICAgICAgICB0aGlzW2ldWzFdICs9IHhcbiAgICAgICAgICB0aGlzW2ldWzJdICs9IHlcbiAgICAgICAgfSBlbHNlIGlmIChsID09PSAnSCcpIHtcbiAgICAgICAgICB0aGlzW2ldWzFdICs9IHhcbiAgICAgICAgfSBlbHNlIGlmIChsID09PSAnVicpIHtcbiAgICAgICAgICB0aGlzW2ldWzFdICs9IHlcbiAgICAgICAgfSBlbHNlIGlmIChsID09PSAnQycgfHwgbCA9PT0gJ1MnIHx8IGwgPT09ICdRJykge1xuICAgICAgICAgIHRoaXNbaV1bMV0gKz0geFxuICAgICAgICAgIHRoaXNbaV1bMl0gKz0geVxuICAgICAgICAgIHRoaXNbaV1bM10gKz0geFxuICAgICAgICAgIHRoaXNbaV1bNF0gKz0geVxuXG4gICAgICAgICAgaWYgKGwgPT09ICdDJykge1xuICAgICAgICAgICAgdGhpc1tpXVs1XSArPSB4XG4gICAgICAgICAgICB0aGlzW2ldWzZdICs9IHlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobCA9PT0gJ0EnKSB7XG4gICAgICAgICAgdGhpc1tpXVs2XSArPSB4XG4gICAgICAgICAgdGhpc1tpXVs3XSArPSB5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gQWJzb2x1dGl6ZSBhbmQgcGFyc2UgcGF0aCB0byBhcnJheVxuICBwYXJzZShkID0gJ00wIDAnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZCkpIHtcbiAgICAgIGQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBkKS50b1N0cmluZygpXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhQYXJzZXIoZClcbiAgfVxuXG4gIC8vIFJlc2l6ZSBwYXRoIHN0cmluZ1xuICBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAvLyBnZXQgYm91bmRpbmcgYm94IG9mIGN1cnJlbnQgc2l0dWF0aW9uXG4gICAgY29uc3QgYm94ID0gdGhpcy5iYm94KClcbiAgICBsZXQgaSwgbFxuXG4gICAgLy8gSWYgdGhlIGJveCB3aWR0aCBvciBoZWlnaHQgaXMgMCB0aGVuIHdlIGlnbm9yZVxuICAgIC8vIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgcmVzcGVjdGl2ZSBheGlzXG4gICAgYm94LndpZHRoID0gYm94LndpZHRoID09PSAwID8gMSA6IGJveC53aWR0aFxuICAgIGJveC5oZWlnaHQgPSBib3guaGVpZ2h0ID09PSAwID8gMSA6IGJveC5oZWlnaHRcblxuICAgIC8vIHJlY2FsY3VsYXRlIHBvc2l0aW9uIG9mIGFsbCBwb2ludHMgYWNjb3JkaW5nIHRvIG5ldyBzaXplXG4gICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgbCA9IHRoaXNbaV1bMF1cblxuICAgICAgaWYgKGwgPT09ICdNJyB8fCBsID09PSAnTCcgfHwgbCA9PT0gJ1QnKSB7XG4gICAgICAgIHRoaXNbaV1bMV0gPSAoKHRoaXNbaV1bMV0gLSBib3gueCkgKiB3aWR0aCkgLyBib3gud2lkdGggKyBib3gueFxuICAgICAgICB0aGlzW2ldWzJdID0gKCh0aGlzW2ldWzJdIC0gYm94LnkpICogaGVpZ2h0KSAvIGJveC5oZWlnaHQgKyBib3gueVxuICAgICAgfSBlbHNlIGlmIChsID09PSAnSCcpIHtcbiAgICAgICAgdGhpc1tpXVsxXSA9ICgodGhpc1tpXVsxXSAtIGJveC54KSAqIHdpZHRoKSAvIGJveC53aWR0aCArIGJveC54XG4gICAgICB9IGVsc2UgaWYgKGwgPT09ICdWJykge1xuICAgICAgICB0aGlzW2ldWzFdID0gKCh0aGlzW2ldWzFdIC0gYm94LnkpICogaGVpZ2h0KSAvIGJveC5oZWlnaHQgKyBib3gueVxuICAgICAgfSBlbHNlIGlmIChsID09PSAnQycgfHwgbCA9PT0gJ1MnIHx8IGwgPT09ICdRJykge1xuICAgICAgICB0aGlzW2ldWzFdID0gKCh0aGlzW2ldWzFdIC0gYm94LngpICogd2lkdGgpIC8gYm94LndpZHRoICsgYm94LnhcbiAgICAgICAgdGhpc1tpXVsyXSA9ICgodGhpc1tpXVsyXSAtIGJveC55KSAqIGhlaWdodCkgLyBib3guaGVpZ2h0ICsgYm94LnlcbiAgICAgICAgdGhpc1tpXVszXSA9ICgodGhpc1tpXVszXSAtIGJveC54KSAqIHdpZHRoKSAvIGJveC53aWR0aCArIGJveC54XG4gICAgICAgIHRoaXNbaV1bNF0gPSAoKHRoaXNbaV1bNF0gLSBib3gueSkgKiBoZWlnaHQpIC8gYm94LmhlaWdodCArIGJveC55XG5cbiAgICAgICAgaWYgKGwgPT09ICdDJykge1xuICAgICAgICAgIHRoaXNbaV1bNV0gPSAoKHRoaXNbaV1bNV0gLSBib3gueCkgKiB3aWR0aCkgLyBib3gud2lkdGggKyBib3gueFxuICAgICAgICAgIHRoaXNbaV1bNl0gPSAoKHRoaXNbaV1bNl0gLSBib3gueSkgKiBoZWlnaHQpIC8gYm94LmhlaWdodCArIGJveC55XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobCA9PT0gJ0EnKSB7XG4gICAgICAgIC8vIHJlc2l6ZSByYWRpaVxuICAgICAgICB0aGlzW2ldWzFdID0gKHRoaXNbaV1bMV0gKiB3aWR0aCkgLyBib3gud2lkdGhcbiAgICAgICAgdGhpc1tpXVsyXSA9ICh0aGlzW2ldWzJdICogaGVpZ2h0KSAvIGJveC5oZWlnaHRcblxuICAgICAgICAvLyBtb3ZlIHBvc2l0aW9uIHZhbHVlc1xuICAgICAgICB0aGlzW2ldWzZdID0gKCh0aGlzW2ldWzZdIC0gYm94LngpICogd2lkdGgpIC8gYm94LndpZHRoICsgYm94LnhcbiAgICAgICAgdGhpc1tpXVs3XSA9ICgodGhpc1tpXVs3XSAtIGJveC55KSAqIGhlaWdodCkgLyBib3guaGVpZ2h0ICsgYm94LnlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gQ29udmVydCBhcnJheSB0byBzdHJpbmdcbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGFycmF5VG9TdHJpbmcodGhpcylcbiAgfVxufVxuIiwiaW1wb3J0IHsgRWFzZSB9IGZyb20gJy4vQ29udHJvbGxlci5qcydcbmltcG9ydCB7XG4gIGRlbGltaXRlcixcbiAgbnVtYmVyQW5kVW5pdCxcbiAgaXNQYXRoTGV0dGVyXG59IGZyb20gJy4uL21vZHVsZXMvY29yZS9yZWdleC5qcydcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5pbXBvcnQgQ29sb3IgZnJvbSAnLi4vdHlwZXMvQ29sb3IuanMnXG5pbXBvcnQgUGF0aEFycmF5IGZyb20gJy4uL3R5cGVzL1BhdGhBcnJheS5qcydcbmltcG9ydCBTVkdBcnJheSBmcm9tICcuLi90eXBlcy9TVkdBcnJheS5qcydcbmltcG9ydCBTVkdOdW1iZXIgZnJvbSAnLi4vdHlwZXMvU1ZHTnVtYmVyLmpzJ1xuXG5jb25zdCBnZXRDbGFzc0ZvclR5cGUgPSAodmFsdWUpID0+IHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZVxuXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBTVkdOdW1iZXJcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChDb2xvci5pc0NvbG9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIENvbG9yXG4gICAgfSBlbHNlIGlmIChkZWxpbWl0ZXIudGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBpc1BhdGhMZXR0ZXIudGVzdCh2YWx1ZSkgPyBQYXRoQXJyYXkgOiBTVkdBcnJheVxuICAgIH0gZWxzZSBpZiAobnVtYmVyQW5kVW5pdC50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIFNWR051bWJlclxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTm9uTW9ycGhhYmxlXG4gICAgfVxuICB9IGVsc2UgaWYgKG1vcnBoYWJsZVR5cGVzLmluZGV4T2YodmFsdWUuY29uc3RydWN0b3IpID4gLTEpIHtcbiAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3JcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBTVkdBcnJheVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIE9iamVjdEJhZ1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBOb25Nb3JwaGFibGVcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb3JwaGFibGUge1xuICBjb25zdHJ1Y3RvcihzdGVwcGVyKSB7XG4gICAgdGhpcy5fc3RlcHBlciA9IHN0ZXBwZXIgfHwgbmV3IEVhc2UoJy0nKVxuXG4gICAgdGhpcy5fZnJvbSA9IG51bGxcbiAgICB0aGlzLl90byA9IG51bGxcbiAgICB0aGlzLl90eXBlID0gbnVsbFxuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsXG4gICAgdGhpcy5fbW9ycGhPYmogPSBudWxsXG4gIH1cblxuICBhdChwb3MpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9ycGhPYmoubW9ycGgoXG4gICAgICB0aGlzLl9mcm9tLFxuICAgICAgdGhpcy5fdG8sXG4gICAgICBwb3MsXG4gICAgICB0aGlzLl9zdGVwcGVyLFxuICAgICAgdGhpcy5fY29udGV4dFxuICAgIClcbiAgfVxuXG4gIGRvbmUoKSB7XG4gICAgY29uc3QgY29tcGxldGUgPSB0aGlzLl9jb250ZXh0Lm1hcCh0aGlzLl9zdGVwcGVyLmRvbmUpLnJlZHVjZShmdW5jdGlvbiAoXG4gICAgICBsYXN0LFxuICAgICAgY3VyclxuICAgICkge1xuICAgICAgcmV0dXJuIGxhc3QgJiYgY3VyclxuICAgIH0sIHRydWUpXG4gICAgcmV0dXJuIGNvbXBsZXRlXG4gIH1cblxuICBmcm9tKHZhbCkge1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Zyb21cbiAgICB9XG5cbiAgICB0aGlzLl9mcm9tID0gdGhpcy5fc2V0KHZhbClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RlcHBlcihzdGVwcGVyKSB7XG4gICAgaWYgKHN0ZXBwZXIgPT0gbnVsbCkgcmV0dXJuIHRoaXMuX3N0ZXBwZXJcbiAgICB0aGlzLl9zdGVwcGVyID0gc3RlcHBlclxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB0byh2YWwpIHtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b1xuICAgIH1cblxuICAgIHRoaXMuX3RvID0gdGhpcy5fc2V0KHZhbClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdHlwZSh0eXBlKSB7XG4gICAgLy8gZ2V0dGVyXG4gICAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3R5cGVcbiAgICB9XG5cbiAgICAvLyBzZXR0ZXJcbiAgICB0aGlzLl90eXBlID0gdHlwZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBfc2V0KHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLl90eXBlKSB7XG4gICAgICB0aGlzLnR5cGUoZ2V0Q2xhc3NGb3JUeXBlKHZhbHVlKSlcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0ID0gbmV3IHRoaXMuX3R5cGUodmFsdWUpXG4gICAgaWYgKHRoaXMuX3R5cGUgPT09IENvbG9yKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLl90b1xuICAgICAgICA/IHJlc3VsdFt0aGlzLl90b1s0XV0oKVxuICAgICAgICA6IHRoaXMuX2Zyb21cbiAgICAgICAgICA/IHJlc3VsdFt0aGlzLl9mcm9tWzRdXSgpXG4gICAgICAgICAgOiByZXN1bHRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdHlwZSA9PT0gT2JqZWN0QmFnKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLl90b1xuICAgICAgICA/IHJlc3VsdC5hbGlnbih0aGlzLl90bylcbiAgICAgICAgOiB0aGlzLl9mcm9tXG4gICAgICAgICAgPyByZXN1bHQuYWxpZ24odGhpcy5fZnJvbSlcbiAgICAgICAgICA6IHJlc3VsdFxuICAgIH1cblxuICAgIHJlc3VsdCA9IHJlc3VsdC50b0NvbnN1bWFibGUoKVxuXG4gICAgdGhpcy5fbW9ycGhPYmogPSB0aGlzLl9tb3JwaE9iaiB8fCBuZXcgdGhpcy5fdHlwZSgpXG4gICAgdGhpcy5fY29udGV4dCA9XG4gICAgICB0aGlzLl9jb250ZXh0IHx8XG4gICAgICBBcnJheS5hcHBseShudWxsLCBBcnJheShyZXN1bHQubGVuZ3RoKSlcbiAgICAgICAgLm1hcChPYmplY3QpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICBvLmRvbmUgPSB0cnVlXG4gICAgICAgICAgcmV0dXJuIG9cbiAgICAgICAgfSlcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE5vbk1vcnBoYWJsZSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmluaXQoLi4uYXJncylcbiAgfVxuXG4gIGluaXQodmFsKSB7XG4gICAgdmFsID0gQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsWzBdIDogdmFsXG4gICAgdGhpcy52YWx1ZSA9IHZhbFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiBbdGhpcy52YWx1ZV1cbiAgfVxuXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtQmFnIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHRoaXMuaW5pdCguLi5hcmdzKVxuICB9XG5cbiAgaW5pdChvYmopIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICBvYmogPSB7XG4gICAgICAgIHNjYWxlWDogb2JqWzBdLFxuICAgICAgICBzY2FsZVk6IG9ialsxXSxcbiAgICAgICAgc2hlYXI6IG9ialsyXSxcbiAgICAgICAgcm90YXRlOiBvYmpbM10sXG4gICAgICAgIHRyYW5zbGF0ZVg6IG9ials0XSxcbiAgICAgICAgdHJhbnNsYXRlWTogb2JqWzVdLFxuICAgICAgICBvcmlnaW5YOiBvYmpbNl0sXG4gICAgICAgIG9yaWdpblk6IG9ials3XVxuICAgICAgfVxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgVHJhbnNmb3JtQmFnLmRlZmF1bHRzLCBvYmopXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgY29uc3QgdiA9IHRoaXNcblxuICAgIHJldHVybiBbXG4gICAgICB2LnNjYWxlWCxcbiAgICAgIHYuc2NhbGVZLFxuICAgICAgdi5zaGVhcixcbiAgICAgIHYucm90YXRlLFxuICAgICAgdi50cmFuc2xhdGVYLFxuICAgICAgdi50cmFuc2xhdGVZLFxuICAgICAgdi5vcmlnaW5YLFxuICAgICAgdi5vcmlnaW5ZXG4gICAgXVxuICB9XG59XG5cblRyYW5zZm9ybUJhZy5kZWZhdWx0cyA9IHtcbiAgc2NhbGVYOiAxLFxuICBzY2FsZVk6IDEsXG4gIHNoZWFyOiAwLFxuICByb3RhdGU6IDAsXG4gIHRyYW5zbGF0ZVg6IDAsXG4gIHRyYW5zbGF0ZVk6IDAsXG4gIG9yaWdpblg6IDAsXG4gIG9yaWdpblk6IDBcbn1cblxuY29uc3Qgc29ydEJ5S2V5ID0gKGEsIGIpID0+IHtcbiAgcmV0dXJuIGFbMF0gPCBiWzBdID8gLTEgOiBhWzBdID4gYlswXSA/IDEgOiAwXG59XG5cbmV4cG9ydCBjbGFzcyBPYmplY3RCYWcge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgdGhpcy5pbml0KC4uLmFyZ3MpXG4gIH1cblxuICBhbGlnbihvdGhlcikge1xuICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMudmFsdWVzXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gdmFsdWVzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgIC8vIElmIHRoZSB0eXBlIGlzIHRoZSBzYW1lIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpZiB0aGUgY29sb3IgaXMgaW4gdGhlIGNvcnJlY3QgZm9ybWF0XG4gICAgICBpZiAodmFsdWVzW2kgKyAxXSA9PT0gb3RoZXJbaSArIDFdKSB7XG4gICAgICAgIGlmICh2YWx1ZXNbaSArIDFdID09PSBDb2xvciAmJiBvdGhlcltpICsgN10gIT09IHZhbHVlc1tpICsgN10pIHtcbiAgICAgICAgICBjb25zdCBzcGFjZSA9IG90aGVyW2kgKyA3XVxuICAgICAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKHRoaXMudmFsdWVzLnNwbGljZShpICsgMywgNSkpXG4gICAgICAgICAgICBbc3BhY2VdKClcbiAgICAgICAgICAgIC50b0FycmF5KClcbiAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2UoaSArIDMsIDAsIC4uLmNvbG9yKVxuICAgICAgICB9XG5cbiAgICAgICAgaSArPSB2YWx1ZXNbaSArIDJdICsgMlxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoIW90aGVyW2kgKyAxXSkge1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgdHlwZXMgZGlmZmVyLCBzbyB3ZSBvdmVyd3JpdGUgdGhlIG5ldyB0eXBlIHdpdGggdGhlIG9sZCBvbmVcbiAgICAgIC8vIEFuZCBpbml0aWFsaXplIGl0IHdpdGggdGhlIHR5cGVzIGRlZmF1bHQgKGUuZy4gYmxhY2sgZm9yIGNvbG9yIG9yIDAgZm9yIG51bWJlcilcbiAgICAgIGNvbnN0IGRlZmF1bHRPYmplY3QgPSBuZXcgb3RoZXJbaSArIDFdKCkudG9BcnJheSgpXG5cbiAgICAgIC8vIFRoYW4gd2UgZml4IHRoZSB2YWx1ZXMgYXJyYXlcbiAgICAgIGNvbnN0IHRvRGVsZXRlID0gdmFsdWVzW2kgKyAyXSArIDNcblxuICAgICAgdmFsdWVzLnNwbGljZShcbiAgICAgICAgaSxcbiAgICAgICAgdG9EZWxldGUsXG4gICAgICAgIG90aGVyW2ldLFxuICAgICAgICBvdGhlcltpICsgMV0sXG4gICAgICAgIG90aGVyW2kgKyAyXSxcbiAgICAgICAgLi4uZGVmYXVsdE9iamVjdFxuICAgICAgKVxuXG4gICAgICBpICs9IHZhbHVlc1tpICsgMl0gKyAyXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBpbml0KG9iak9yQXJyKSB7XG4gICAgdGhpcy52YWx1ZXMgPSBbXVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqT3JBcnIpKSB7XG4gICAgICB0aGlzLnZhbHVlcyA9IG9iak9yQXJyLnNsaWNlKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIG9iak9yQXJyID0gb2JqT3JBcnIgfHwge31cbiAgICBjb25zdCBlbnRyaWVzID0gW11cblxuICAgIGZvciAoY29uc3QgaSBpbiBvYmpPckFycikge1xuICAgICAgY29uc3QgVHlwZSA9IGdldENsYXNzRm9yVHlwZShvYmpPckFycltpXSlcbiAgICAgIGNvbnN0IHZhbCA9IG5ldyBUeXBlKG9iak9yQXJyW2ldKS50b0FycmF5KClcbiAgICAgIGVudHJpZXMucHVzaChbaSwgVHlwZSwgdmFsLmxlbmd0aCwgLi4udmFsXSlcbiAgICB9XG5cbiAgICBlbnRyaWVzLnNvcnQoc29ydEJ5S2V5KVxuXG4gICAgdGhpcy52YWx1ZXMgPSBlbnRyaWVzLnJlZHVjZSgobGFzdCwgY3VycikgPT4gbGFzdC5jb25jYXQoY3VyciksIFtdKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1xuICB9XG5cbiAgdmFsdWVPZigpIHtcbiAgICBjb25zdCBvYmogPSB7fVxuICAgIGNvbnN0IGFyciA9IHRoaXMudmFsdWVzXG5cbiAgICAvLyBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgd2hpbGUgKGFyci5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGtleSA9IGFyci5zaGlmdCgpXG4gICAgICBjb25zdCBUeXBlID0gYXJyLnNoaWZ0KClcbiAgICAgIGNvbnN0IG51bSA9IGFyci5zaGlmdCgpXG4gICAgICBjb25zdCB2YWx1ZXMgPSBhcnIuc3BsaWNlKDAsIG51bSlcbiAgICAgIG9ialtrZXldID0gbmV3IFR5cGUodmFsdWVzKSAvLyAudmFsdWVPZigpXG4gICAgfVxuXG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbmNvbnN0IG1vcnBoYWJsZVR5cGVzID0gW05vbk1vcnBoYWJsZSwgVHJhbnNmb3JtQmFnLCBPYmplY3RCYWddXG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3Rlck1vcnBoYWJsZVR5cGUodHlwZSA9IFtdKSB7XG4gIG1vcnBoYWJsZVR5cGVzLnB1c2goLi4uW10uY29uY2F0KHR5cGUpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZU1vcnBoYWJsZSgpIHtcbiAgZXh0ZW5kKG1vcnBoYWJsZVR5cGVzLCB7XG4gICAgdG8odmFsKSB7XG4gICAgICByZXR1cm4gbmV3IE1vcnBoYWJsZSgpXG4gICAgICAgIC50eXBlKHRoaXMuY29uc3RydWN0b3IpXG4gICAgICAgIC5mcm9tKHRoaXMudG9BcnJheSgpKSAvLyB0aGlzLnZhbHVlT2YoKSlcbiAgICAgICAgLnRvKHZhbClcbiAgICB9LFxuICAgIGZyb21BcnJheShhcnIpIHtcbiAgICAgIHRoaXMuaW5pdChhcnIpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgdG9Db25zdW1hYmxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgpXG4gICAgfSxcbiAgICBtb3JwaChmcm9tLCB0bywgcG9zLCBzdGVwcGVyLCBjb250ZXh0KSB7XG4gICAgICBjb25zdCBtYXBwZXIgPSBmdW5jdGlvbiAoaSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHN0ZXBwZXIuc3RlcChpLCB0b1tpbmRleF0sIHBvcywgY29udGV4dFtpbmRleF0sIGNvbnRleHQpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmZyb21BcnJheShmcm9tLm1hcChtYXBwZXIpKVxuICAgIH1cbiAgfSlcbn1cbiIsImltcG9ydCB7IG5vZGVPck5ldywgcmVnaXN0ZXIsIHdyYXBXaXRoQXR0ckNoZWNrIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCB7IHByb3BvcnRpb25hbFNpemUgfSBmcm9tICcuLi91dGlscy91dGlscy5qcydcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgUGF0aEFycmF5IGZyb20gJy4uL3R5cGVzL1BhdGhBcnJheS5qcydcbmltcG9ydCBTaGFwZSBmcm9tICcuL1NoYXBlLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXRoIGV4dGVuZHMgU2hhcGUge1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdwYXRoJywgbm9kZSksIGF0dHJzKVxuICB9XG5cbiAgLy8gR2V0IGFycmF5XG4gIGFycmF5KCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheSB8fCAodGhpcy5fYXJyYXkgPSBuZXcgUGF0aEFycmF5KHRoaXMuYXR0cignZCcpKSlcbiAgfVxuXG4gIC8vIENsZWFyIGFycmF5IGNhY2hlXG4gIGNsZWFyKCkge1xuICAgIGRlbGV0ZSB0aGlzLl9hcnJheVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcbiAgaGVpZ2h0KGhlaWdodCkge1xuICAgIHJldHVybiBoZWlnaHQgPT0gbnVsbFxuICAgICAgPyB0aGlzLmJib3goKS5oZWlnaHRcbiAgICAgIDogdGhpcy5zaXplKHRoaXMuYmJveCgpLndpZHRoLCBoZWlnaHQpXG4gIH1cblxuICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lclxuICBtb3ZlKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdkJywgdGhpcy5hcnJheSgpLm1vdmUoeCwgeSkpXG4gIH1cblxuICAvLyBQbG90IG5ldyBwYXRoXG4gIHBsb3QoZCkge1xuICAgIHJldHVybiBkID09IG51bGxcbiAgICAgID8gdGhpcy5hcnJheSgpXG4gICAgICA6IHRoaXMuY2xlYXIoKS5hdHRyKFxuICAgICAgICAgICdkJyxcbiAgICAgICAgICB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyBkIDogKHRoaXMuX2FycmF5ID0gbmV3IFBhdGhBcnJheShkKSlcbiAgICAgICAgKVxuICB9XG5cbiAgLy8gU2V0IGVsZW1lbnQgc2l6ZSB0byBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XG4gIHNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHAgPSBwcm9wb3J0aW9uYWxTaXplKHRoaXMsIHdpZHRoLCBoZWlnaHQpXG4gICAgcmV0dXJuIHRoaXMuYXR0cignZCcsIHRoaXMuYXJyYXkoKS5zaXplKHAud2lkdGgsIHAuaGVpZ2h0KSlcbiAgfVxuXG4gIC8vIFNldCB3aWR0aCBvZiBlbGVtZW50XG4gIHdpZHRoKHdpZHRoKSB7XG4gICAgcmV0dXJuIHdpZHRoID09IG51bGxcbiAgICAgID8gdGhpcy5iYm94KCkud2lkdGhcbiAgICAgIDogdGhpcy5zaXplKHdpZHRoLCB0aGlzLmJib3goKS5oZWlnaHQpXG4gIH1cblxuICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lciBvdmVyIHgtYXhpc1xuICB4KHgpIHtcbiAgICByZXR1cm4geCA9PSBudWxsID8gdGhpcy5iYm94KCkueCA6IHRoaXMubW92ZSh4LCB0aGlzLmJib3goKS55KVxuICB9XG5cbiAgLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXIgb3ZlciB5LWF4aXNcbiAgeSh5KSB7XG4gICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMuYmJveCgpLnkgOiB0aGlzLm1vdmUodGhpcy5iYm94KCkueCwgeSlcbiAgfVxufVxuXG4vLyBEZWZpbmUgbW9ycGhhYmxlIGFycmF5XG5QYXRoLnByb3RvdHlwZS5Nb3JwaEFycmF5ID0gUGF0aEFycmF5XG5cbi8vIEFkZCBwYXJlbnQgbWV0aG9kXG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgYSB3cmFwcGVkIHBhdGggZWxlbWVudFxuICAgIHBhdGg6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uIChkKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgcGxvdCBpcyBjYWxsZWQgYXMgYSBzZXR0ZXJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgUGF0aCgpKS5wbG90KGQgfHwgbmV3IFBhdGhBcnJheSgpKVxuICAgIH0pXG4gIH1cbn0pXG5cbnJlZ2lzdGVyKFBhdGgsICdQYXRoJylcbiIsImltcG9ydCB7IHByb3BvcnRpb25hbFNpemUgfSBmcm9tICcuLi8uLi91dGlscy91dGlscy5qcydcbmltcG9ydCBQb2ludEFycmF5IGZyb20gJy4uLy4uL3R5cGVzL1BvaW50QXJyYXkuanMnXG5cbi8vIEdldCBhcnJheVxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5KCkge1xuICByZXR1cm4gdGhpcy5fYXJyYXkgfHwgKHRoaXMuX2FycmF5ID0gbmV3IFBvaW50QXJyYXkodGhpcy5hdHRyKCdwb2ludHMnKSkpXG59XG5cbi8vIENsZWFyIGFycmF5IGNhY2hlXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIoKSB7XG4gIGRlbGV0ZSB0aGlzLl9hcnJheVxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lclxuZXhwb3J0IGZ1bmN0aW9uIG1vdmUoeCwgeSkge1xuICByZXR1cm4gdGhpcy5hdHRyKCdwb2ludHMnLCB0aGlzLmFycmF5KCkubW92ZSh4LCB5KSlcbn1cblxuLy8gUGxvdCBuZXcgcGF0aFxuZXhwb3J0IGZ1bmN0aW9uIHBsb3QocCkge1xuICByZXR1cm4gcCA9PSBudWxsXG4gICAgPyB0aGlzLmFycmF5KClcbiAgICA6IHRoaXMuY2xlYXIoKS5hdHRyKFxuICAgICAgICAncG9pbnRzJyxcbiAgICAgICAgdHlwZW9mIHAgPT09ICdzdHJpbmcnID8gcCA6ICh0aGlzLl9hcnJheSA9IG5ldyBQb2ludEFycmF5KHApKVxuICAgICAgKVxufVxuXG4vLyBTZXQgZWxlbWVudCBzaXplIHRvIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcbmV4cG9ydCBmdW5jdGlvbiBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgY29uc3QgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodClcbiAgcmV0dXJuIHRoaXMuYXR0cigncG9pbnRzJywgdGhpcy5hcnJheSgpLnNpemUocC53aWR0aCwgcC5oZWlnaHQpKVxufVxuIiwiaW1wb3J0IHtcbiAgZXh0ZW5kLFxuICBub2RlT3JOZXcsXG4gIHJlZ2lzdGVyLFxuICB3cmFwV2l0aEF0dHJDaGVja1xufSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcbmltcG9ydCBQb2ludEFycmF5IGZyb20gJy4uL3R5cGVzL1BvaW50QXJyYXkuanMnXG5pbXBvcnQgU2hhcGUgZnJvbSAnLi9TaGFwZS5qcydcbmltcG9ydCAqIGFzIHBvaW50ZWQgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3BvaW50ZWQuanMnXG5pbXBvcnQgKiBhcyBwb2x5IGZyb20gJy4uL21vZHVsZXMvY29yZS9wb2x5LmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5Z29uIGV4dGVuZHMgU2hhcGUge1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdwb2x5Z29uJywgbm9kZSksIGF0dHJzKVxuICB9XG59XG5cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIC8vIENyZWF0ZSBhIHdyYXBwZWQgcG9seWdvbiBlbGVtZW50XG4gICAgcG9seWdvbjogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHApIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBwbG90IGlzIGNhbGxlZCBhcyBhIHNldHRlclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBQb2x5Z29uKCkpLnBsb3QocCB8fCBuZXcgUG9pbnRBcnJheSgpKVxuICAgIH0pXG4gIH1cbn0pXG5cbmV4dGVuZChQb2x5Z29uLCBwb2ludGVkKVxuZXh0ZW5kKFBvbHlnb24sIHBvbHkpXG5yZWdpc3RlcihQb2x5Z29uLCAnUG9seWdvbicpXG4iLCJpbXBvcnQge1xuICBleHRlbmQsXG4gIG5vZGVPck5ldyxcbiAgcmVnaXN0ZXIsXG4gIHdyYXBXaXRoQXR0ckNoZWNrXG59IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xuaW1wb3J0IFBvaW50QXJyYXkgZnJvbSAnLi4vdHlwZXMvUG9pbnRBcnJheS5qcydcbmltcG9ydCBTaGFwZSBmcm9tICcuL1NoYXBlLmpzJ1xuaW1wb3J0ICogYXMgcG9pbnRlZCBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcG9pbnRlZC5qcydcbmltcG9ydCAqIGFzIHBvbHkgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3BvbHkuanMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbHlsaW5lIGV4dGVuZHMgU2hhcGUge1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdwb2x5bGluZScsIG5vZGUpLCBhdHRycylcbiAgfVxufVxuXG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgYSB3cmFwcGVkIHBvbHlnb24gZWxlbWVudFxuICAgIHBvbHlsaW5lOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAocCkge1xuICAgICAgLy8gbWFrZSBzdXJlIHBsb3QgaXMgY2FsbGVkIGFzIGEgc2V0dGVyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFBvbHlsaW5lKCkpLnBsb3QocCB8fCBuZXcgUG9pbnRBcnJheSgpKVxuICAgIH0pXG4gIH1cbn0pXG5cbmV4dGVuZChQb2x5bGluZSwgcG9pbnRlZClcbmV4dGVuZChQb2x5bGluZSwgcG9seSlcbnJlZ2lzdGVyKFBvbHlsaW5lLCAnUG9seWxpbmUnKVxuIiwiaW1wb3J0IHtcbiAgZXh0ZW5kLFxuICBub2RlT3JOZXcsXG4gIHJlZ2lzdGVyLFxuICB3cmFwV2l0aEF0dHJDaGVja1xufSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcbmltcG9ydCB7IHJ4LCByeSB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9jaXJjbGVkLmpzJ1xuaW1wb3J0IFNoYXBlIGZyb20gJy4vU2hhcGUuanMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlY3QgZXh0ZW5kcyBTaGFwZSB7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ3JlY3QnLCBub2RlKSwgYXR0cnMpXG4gIH1cbn1cblxuZXh0ZW5kKFJlY3QsIHsgcngsIHJ5IH0pXG5cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIC8vIENyZWF0ZSBhIHJlY3QgZWxlbWVudFxuICAgIHJlY3Q6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFJlY3QoKSkuc2l6ZSh3aWR0aCwgaGVpZ2h0KVxuICAgIH0pXG4gIH1cbn0pXG5cbnJlZ2lzdGVyKFJlY3QsICdSZWN0JylcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1ZXVlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZmlyc3QgPSBudWxsXG4gICAgdGhpcy5fbGFzdCA9IG51bGxcbiAgfVxuXG4gIC8vIFNob3dzIHVzIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0XG4gIGZpcnN0KCkge1xuICAgIHJldHVybiB0aGlzLl9maXJzdCAmJiB0aGlzLl9maXJzdC52YWx1ZVxuICB9XG5cbiAgLy8gU2hvd3MgdXMgdGhlIGxhc3QgaXRlbSBpbiB0aGUgbGlzdFxuICBsYXN0KCkge1xuICAgIHJldHVybiB0aGlzLl9sYXN0ICYmIHRoaXMuX2xhc3QudmFsdWVcbiAgfVxuXG4gIHB1c2godmFsdWUpIHtcbiAgICAvLyBBbiBpdGVtIHN0b3JlcyBhbiBpZCBhbmQgdGhlIHByb3ZpZGVkIHZhbHVlXG4gICAgY29uc3QgaXRlbSA9XG4gICAgICB0eXBlb2YgdmFsdWUubmV4dCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHsgdmFsdWU6IHZhbHVlLCBuZXh0OiBudWxsLCBwcmV2OiBudWxsIH1cblxuICAgIC8vIERlYWwgd2l0aCB0aGUgcXVldWUgYmVpbmcgZW1wdHkgb3IgcG9wdWxhdGVkXG4gICAgaWYgKHRoaXMuX2xhc3QpIHtcbiAgICAgIGl0ZW0ucHJldiA9IHRoaXMuX2xhc3RcbiAgICAgIHRoaXMuX2xhc3QubmV4dCA9IGl0ZW1cbiAgICAgIHRoaXMuX2xhc3QgPSBpdGVtXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xhc3QgPSBpdGVtXG4gICAgICB0aGlzLl9maXJzdCA9IGl0ZW1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdGhlIGN1cnJlbnQgaXRlbVxuICAgIHJldHVybiBpdGVtXG4gIH1cblxuICAvLyBSZW1vdmVzIHRoZSBpdGVtIHRoYXQgd2FzIHJldHVybmVkIGZyb20gdGhlIHB1c2hcbiAgcmVtb3ZlKGl0ZW0pIHtcbiAgICAvLyBSZWxpbmsgdGhlIHByZXZpb3VzIGl0ZW1cbiAgICBpZiAoaXRlbS5wcmV2KSBpdGVtLnByZXYubmV4dCA9IGl0ZW0ubmV4dFxuICAgIGlmIChpdGVtLm5leHQpIGl0ZW0ubmV4dC5wcmV2ID0gaXRlbS5wcmV2XG4gICAgaWYgKGl0ZW0gPT09IHRoaXMuX2xhc3QpIHRoaXMuX2xhc3QgPSBpdGVtLnByZXZcbiAgICBpZiAoaXRlbSA9PT0gdGhpcy5fZmlyc3QpIHRoaXMuX2ZpcnN0ID0gaXRlbS5uZXh0XG5cbiAgICAvLyBJbnZhbGlkYXRlIGl0ZW1cbiAgICBpdGVtLnByZXYgPSBudWxsXG4gICAgaXRlbS5uZXh0ID0gbnVsbFxuICB9XG5cbiAgc2hpZnQoKSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhIHZhbHVlXG4gICAgY29uc3QgcmVtb3ZlID0gdGhpcy5fZmlyc3RcbiAgICBpZiAoIXJlbW92ZSkgcmV0dXJuIG51bGxcblxuICAgIC8vIElmIHdlIGRvLCByZW1vdmUgaXQgYW5kIHJlbGluayB0aGluZ3NcbiAgICB0aGlzLl9maXJzdCA9IHJlbW92ZS5uZXh0XG4gICAgaWYgKHRoaXMuX2ZpcnN0KSB0aGlzLl9maXJzdC5wcmV2ID0gbnVsbFxuICAgIHRoaXMuX2xhc3QgPSB0aGlzLl9maXJzdCA/IHRoaXMuX2xhc3QgOiBudWxsXG4gICAgcmV0dXJuIHJlbW92ZS52YWx1ZVxuICB9XG59XG4iLCJpbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vdXRpbHMvd2luZG93LmpzJ1xuaW1wb3J0IFF1ZXVlIGZyb20gJy4vUXVldWUuanMnXG5cbmNvbnN0IEFuaW1hdG9yID0ge1xuICBuZXh0RHJhdzogbnVsbCxcbiAgZnJhbWVzOiBuZXcgUXVldWUoKSxcbiAgdGltZW91dHM6IG5ldyBRdWV1ZSgpLFxuICBpbW1lZGlhdGVzOiBuZXcgUXVldWUoKSxcbiAgdGltZXI6ICgpID0+IGdsb2JhbHMud2luZG93LnBlcmZvcm1hbmNlIHx8IGdsb2JhbHMud2luZG93LkRhdGUsXG4gIHRyYW5zZm9ybXM6IFtdLFxuXG4gIGZyYW1lKGZuKSB7XG4gICAgLy8gU3RvcmUgdGhlIG5vZGVcbiAgICBjb25zdCBub2RlID0gQW5pbWF0b3IuZnJhbWVzLnB1c2goeyBydW46IGZuIH0pXG5cbiAgICAvLyBSZXF1ZXN0IGFuIGFuaW1hdGlvbiBmcmFtZSBpZiB3ZSBkb24ndCBoYXZlIG9uZVxuICAgIGlmIChBbmltYXRvci5uZXh0RHJhdyA9PT0gbnVsbCkge1xuICAgICAgQW5pbWF0b3IubmV4dERyYXcgPSBnbG9iYWxzLndpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoQW5pbWF0b3IuX2RyYXcpXG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRoZSBub2RlIHNvIHdlIGNhbiByZW1vdmUgaXQgZWFzaWx5XG4gICAgcmV0dXJuIG5vZGVcbiAgfSxcblxuICB0aW1lb3V0KGZuLCBkZWxheSkge1xuICAgIGRlbGF5ID0gZGVsYXkgfHwgMFxuXG4gICAgLy8gV29yayBvdXQgd2hlbiB0aGUgZXZlbnQgc2hvdWxkIGZpcmVcbiAgICBjb25zdCB0aW1lID0gQW5pbWF0b3IudGltZXIoKS5ub3coKSArIGRlbGF5XG5cbiAgICAvLyBBZGQgdGhlIHRpbWVvdXQgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcbiAgICBjb25zdCBub2RlID0gQW5pbWF0b3IudGltZW91dHMucHVzaCh7IHJ1bjogZm4sIHRpbWU6IHRpbWUgfSlcblxuICAgIC8vIFJlcXVlc3QgYW5vdGhlciBhbmltYXRpb24gZnJhbWUgaWYgd2UgbmVlZCBvbmVcbiAgICBpZiAoQW5pbWF0b3IubmV4dERyYXcgPT09IG51bGwpIHtcbiAgICAgIEFuaW1hdG9yLm5leHREcmF3ID0gZ2xvYmFscy53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKEFuaW1hdG9yLl9kcmF3KVxuICAgIH1cblxuICAgIHJldHVybiBub2RlXG4gIH0sXG5cbiAgaW1tZWRpYXRlKGZuKSB7XG4gICAgLy8gQWRkIHRoZSBpbW1lZGlhdGUgZm4gdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcbiAgICBjb25zdCBub2RlID0gQW5pbWF0b3IuaW1tZWRpYXRlcy5wdXNoKGZuKVxuICAgIC8vIFJlcXVlc3QgYW5vdGhlciBhbmltYXRpb24gZnJhbWUgaWYgd2UgbmVlZCBvbmVcbiAgICBpZiAoQW5pbWF0b3IubmV4dERyYXcgPT09IG51bGwpIHtcbiAgICAgIEFuaW1hdG9yLm5leHREcmF3ID0gZ2xvYmFscy53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKEFuaW1hdG9yLl9kcmF3KVxuICAgIH1cblxuICAgIHJldHVybiBub2RlXG4gIH0sXG5cbiAgY2FuY2VsRnJhbWUobm9kZSkge1xuICAgIG5vZGUgIT0gbnVsbCAmJiBBbmltYXRvci5mcmFtZXMucmVtb3ZlKG5vZGUpXG4gIH0sXG5cbiAgY2xlYXJUaW1lb3V0KG5vZGUpIHtcbiAgICBub2RlICE9IG51bGwgJiYgQW5pbWF0b3IudGltZW91dHMucmVtb3ZlKG5vZGUpXG4gIH0sXG5cbiAgY2FuY2VsSW1tZWRpYXRlKG5vZGUpIHtcbiAgICBub2RlICE9IG51bGwgJiYgQW5pbWF0b3IuaW1tZWRpYXRlcy5yZW1vdmUobm9kZSlcbiAgfSxcblxuICBfZHJhdyhub3cpIHtcbiAgICAvLyBSdW4gYWxsIHRoZSB0aW1lb3V0cyB3ZSBjYW4gcnVuLCBpZiB0aGV5IGFyZSBub3QgcmVhZHkgeWV0LCBhZGQgdGhlbVxuICAgIC8vIHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlIGltbWVkaWF0ZWx5ISAoYmFkIHRpbWVvdXRzISEhIFtzYXJjYXNtXSlcbiAgICBsZXQgbmV4dFRpbWVvdXQgPSBudWxsXG4gICAgY29uc3QgbGFzdFRpbWVvdXQgPSBBbmltYXRvci50aW1lb3V0cy5sYXN0KClcbiAgICB3aGlsZSAoKG5leHRUaW1lb3V0ID0gQW5pbWF0b3IudGltZW91dHMuc2hpZnQoKSkpIHtcbiAgICAgIC8vIFJ1biB0aGUgdGltZW91dCBpZiBpdHMgdGltZSwgb3IgcHVzaCBpdCB0byB0aGUgZW5kXG4gICAgICBpZiAobm93ID49IG5leHRUaW1lb3V0LnRpbWUpIHtcbiAgICAgICAgbmV4dFRpbWVvdXQucnVuKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEFuaW1hdG9yLnRpbWVvdXRzLnB1c2gobmV4dFRpbWVvdXQpXG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGhpdCB0aGUgbGFzdCBpdGVtLCB3ZSBzaG91bGQgc3RvcCBzaGlmdGluZyBvdXQgbW9yZSBpdGVtc1xuICAgICAgaWYgKG5leHRUaW1lb3V0ID09PSBsYXN0VGltZW91dCkgYnJlYWtcbiAgICB9XG5cbiAgICAvLyBSdW4gYWxsIG9mIHRoZSBhbmltYXRpb24gZnJhbWVzXG4gICAgbGV0IG5leHRGcmFtZSA9IG51bGxcbiAgICBjb25zdCBsYXN0RnJhbWUgPSBBbmltYXRvci5mcmFtZXMubGFzdCgpXG4gICAgd2hpbGUgKG5leHRGcmFtZSAhPT0gbGFzdEZyYW1lICYmIChuZXh0RnJhbWUgPSBBbmltYXRvci5mcmFtZXMuc2hpZnQoKSkpIHtcbiAgICAgIG5leHRGcmFtZS5ydW4obm93KVxuICAgIH1cblxuICAgIGxldCBuZXh0SW1tZWRpYXRlID0gbnVsbFxuICAgIHdoaWxlICgobmV4dEltbWVkaWF0ZSA9IEFuaW1hdG9yLmltbWVkaWF0ZXMuc2hpZnQoKSkpIHtcbiAgICAgIG5leHRJbW1lZGlhdGUoKVxuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgcmVtYWluaW5nIHRpbWVvdXRzIG9yIGZyYW1lcywgZHJhdyB1bnRpbCB3ZSBkb24ndCBhbnltb3JlXG4gICAgQW5pbWF0b3IubmV4dERyYXcgPVxuICAgICAgQW5pbWF0b3IudGltZW91dHMuZmlyc3QoKSB8fCBBbmltYXRvci5mcmFtZXMuZmlyc3QoKVxuICAgICAgICA/IGdsb2JhbHMud2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShBbmltYXRvci5fZHJhdylcbiAgICAgICAgOiBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQW5pbWF0b3JcbiIsImltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi91dGlscy93aW5kb3cuanMnXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xuaW1wb3J0IEFuaW1hdG9yIGZyb20gJy4vQW5pbWF0b3IuanMnXG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnLi4vdHlwZXMvRXZlbnRUYXJnZXQuanMnXG5cbmNvbnN0IG1ha2VTY2hlZHVsZSA9IGZ1bmN0aW9uIChydW5uZXJJbmZvKSB7XG4gIGNvbnN0IHN0YXJ0ID0gcnVubmVySW5mby5zdGFydFxuICBjb25zdCBkdXJhdGlvbiA9IHJ1bm5lckluZm8ucnVubmVyLmR1cmF0aW9uKClcbiAgY29uc3QgZW5kID0gc3RhcnQgKyBkdXJhdGlvblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgZW5kOiBlbmQsXG4gICAgcnVubmVyOiBydW5uZXJJbmZvLnJ1bm5lclxuICB9XG59XG5cbmNvbnN0IGRlZmF1bHRTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHcgPSBnbG9iYWxzLndpbmRvd1xuICByZXR1cm4gKHcucGVyZm9ybWFuY2UgfHwgdy5EYXRlKS5ub3coKVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lbGluZSBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgLy8gQ29uc3RydWN0IGEgbmV3IHRpbWVsaW5lIG9uIHRoZSBnaXZlbiBlbGVtZW50XG4gIGNvbnN0cnVjdG9yKHRpbWVTb3VyY2UgPSBkZWZhdWx0U291cmNlKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5fdGltZVNvdXJjZSA9IHRpbWVTb3VyY2VcblxuICAgIC8vIHRlcm1pbmF0ZSByZXNldHMgYWxsIHZhcmlhYmxlcyB0byB0aGVpciBpbml0aWFsIHN0YXRlXG4gICAgdGhpcy50ZXJtaW5hdGUoKVxuICB9XG5cbiAgYWN0aXZlKCkge1xuICAgIHJldHVybiAhIXRoaXMuX25leHRGcmFtZVxuICB9XG5cbiAgZmluaXNoKCkge1xuICAgIC8vIEdvIHRvIGVuZCBhbmQgcGF1c2VcbiAgICB0aGlzLnRpbWUodGhpcy5nZXRFbmRUaW1lT2ZUaW1lbGluZSgpICsgMSlcbiAgICByZXR1cm4gdGhpcy5wYXVzZSgpXG4gIH1cblxuICAvLyBDYWxjdWxhdGVzIHRoZSBlbmQgb2YgdGhlIHRpbWVsaW5lXG4gIGdldEVuZFRpbWUoKSB7XG4gICAgY29uc3QgbGFzdFJ1bm5lckluZm8gPSB0aGlzLmdldExhc3RSdW5uZXJJbmZvKClcbiAgICBjb25zdCBsYXN0RHVyYXRpb24gPSBsYXN0UnVubmVySW5mbyA/IGxhc3RSdW5uZXJJbmZvLnJ1bm5lci5kdXJhdGlvbigpIDogMFxuICAgIGNvbnN0IGxhc3RTdGFydFRpbWUgPSBsYXN0UnVubmVySW5mbyA/IGxhc3RSdW5uZXJJbmZvLnN0YXJ0IDogdGhpcy5fdGltZVxuICAgIHJldHVybiBsYXN0U3RhcnRUaW1lICsgbGFzdER1cmF0aW9uXG4gIH1cblxuICBnZXRFbmRUaW1lT2ZUaW1lbGluZSgpIHtcbiAgICBjb25zdCBlbmRUaW1lcyA9IHRoaXMuX3J1bm5lcnMubWFwKChpKSA9PiBpLnN0YXJ0ICsgaS5ydW5uZXIuZHVyYXRpb24oKSlcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgLi4uZW5kVGltZXMpXG4gIH1cblxuICBnZXRMYXN0UnVubmVySW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSdW5uZXJJbmZvQnlJZCh0aGlzLl9sYXN0UnVubmVySWQpXG4gIH1cblxuICBnZXRSdW5uZXJJbmZvQnlJZChpZCkge1xuICAgIHJldHVybiB0aGlzLl9ydW5uZXJzW3RoaXMuX3J1bm5lcklkcy5pbmRleE9mKGlkKV0gfHwgbnVsbFxuICB9XG5cbiAgcGF1c2UoKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZVxuICAgIHJldHVybiB0aGlzLl9jb250aW51ZSgpXG4gIH1cblxuICBwZXJzaXN0KGR0T3JGb3JldmVyKSB7XG4gICAgaWYgKGR0T3JGb3JldmVyID09IG51bGwpIHJldHVybiB0aGlzLl9wZXJzaXN0XG4gICAgdGhpcy5fcGVyc2lzdCA9IGR0T3JGb3JldmVyXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHBsYXkoKSB7XG4gICAgLy8gTm93IG1ha2Ugc3VyZSB3ZSBhcmUgbm90IHBhdXNlZCBhbmQgY29udGludWUgdGhlIGFuaW1hdGlvblxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlXG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVGltZSgpLl9jb250aW51ZSgpXG4gIH1cblxuICByZXZlcnNlKHllcykge1xuICAgIGNvbnN0IGN1cnJlbnRTcGVlZCA9IHRoaXMuc3BlZWQoKVxuICAgIGlmICh5ZXMgPT0gbnVsbCkgcmV0dXJuIHRoaXMuc3BlZWQoLWN1cnJlbnRTcGVlZClcblxuICAgIGNvbnN0IHBvc2l0aXZlID0gTWF0aC5hYnMoY3VycmVudFNwZWVkKVxuICAgIHJldHVybiB0aGlzLnNwZWVkKHllcyA/IC1wb3NpdGl2ZSA6IHBvc2l0aXZlKVxuICB9XG5cbiAgLy8gc2NoZWR1bGVzIGEgcnVubmVyIG9uIHRoZSB0aW1lbGluZVxuICBzY2hlZHVsZShydW5uZXIsIGRlbGF5LCB3aGVuKSB7XG4gICAgaWYgKHJ1bm5lciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVubmVycy5tYXAobWFrZVNjaGVkdWxlKVxuICAgIH1cblxuICAgIC8vIFRoZSBzdGFydCB0aW1lIGZvciB0aGUgbmV4dCBhbmltYXRpb24gY2FuIGVpdGhlciBiZSBnaXZlbiBleHBsaWNpdGx5LFxuICAgIC8vIGRlcml2ZWQgZnJvbSB0aGUgY3VycmVudCB0aW1lbGluZSB0aW1lIG9yIGl0IGNhbiBiZSByZWxhdGl2ZSB0byB0aGVcbiAgICAvLyBsYXN0IHN0YXJ0IHRpbWUgdG8gY2hhaW4gYW5pbWF0aW9ucyBkaXJlY3RseVxuXG4gICAgbGV0IGFic29sdXRlU3RhcnRUaW1lID0gMFxuICAgIGNvbnN0IGVuZFRpbWUgPSB0aGlzLmdldEVuZFRpbWUoKVxuICAgIGRlbGF5ID0gZGVsYXkgfHwgMFxuXG4gICAgLy8gV29yayBvdXQgd2hlbiB0byBzdGFydCB0aGUgYW5pbWF0aW9uXG4gICAgaWYgKHdoZW4gPT0gbnVsbCB8fCB3aGVuID09PSAnbGFzdCcgfHwgd2hlbiA9PT0gJ2FmdGVyJykge1xuICAgICAgLy8gVGFrZSB0aGUgbGFzdCB0aW1lIGFuZCBpbmNyZW1lbnRcbiAgICAgIGFic29sdXRlU3RhcnRUaW1lID0gZW5kVGltZVxuICAgIH0gZWxzZSBpZiAod2hlbiA9PT0gJ2Fic29sdXRlJyB8fCB3aGVuID09PSAnc3RhcnQnKSB7XG4gICAgICBhYnNvbHV0ZVN0YXJ0VGltZSA9IGRlbGF5XG4gICAgICBkZWxheSA9IDBcbiAgICB9IGVsc2UgaWYgKHdoZW4gPT09ICdub3cnKSB7XG4gICAgICBhYnNvbHV0ZVN0YXJ0VGltZSA9IHRoaXMuX3RpbWVcbiAgICB9IGVsc2UgaWYgKHdoZW4gPT09ICdyZWxhdGl2ZScpIHtcbiAgICAgIGNvbnN0IHJ1bm5lckluZm8gPSB0aGlzLmdldFJ1bm5lckluZm9CeUlkKHJ1bm5lci5pZClcbiAgICAgIGlmIChydW5uZXJJbmZvKSB7XG4gICAgICAgIGFic29sdXRlU3RhcnRUaW1lID0gcnVubmVySW5mby5zdGFydCArIGRlbGF5XG4gICAgICAgIGRlbGF5ID0gMFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAod2hlbiA9PT0gJ3dpdGgtbGFzdCcpIHtcbiAgICAgIGNvbnN0IGxhc3RSdW5uZXJJbmZvID0gdGhpcy5nZXRMYXN0UnVubmVySW5mbygpXG4gICAgICBjb25zdCBsYXN0U3RhcnRUaW1lID0gbGFzdFJ1bm5lckluZm8gPyBsYXN0UnVubmVySW5mby5zdGFydCA6IHRoaXMuX3RpbWVcbiAgICAgIGFic29sdXRlU3RhcnRUaW1lID0gbGFzdFN0YXJ0VGltZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHRoZSBcIndoZW5cIiBwYXJhbWV0ZXInKVxuICAgIH1cblxuICAgIC8vIE1hbmFnZSBydW5uZXJcbiAgICBydW5uZXIudW5zY2hlZHVsZSgpXG4gICAgcnVubmVyLnRpbWVsaW5lKHRoaXMpXG5cbiAgICBjb25zdCBwZXJzaXN0ID0gcnVubmVyLnBlcnNpc3QoKVxuICAgIGNvbnN0IHJ1bm5lckluZm8gPSB7XG4gICAgICBwZXJzaXN0OiBwZXJzaXN0ID09PSBudWxsID8gdGhpcy5fcGVyc2lzdCA6IHBlcnNpc3QsXG4gICAgICBzdGFydDogYWJzb2x1dGVTdGFydFRpbWUgKyBkZWxheSxcbiAgICAgIHJ1bm5lclxuICAgIH1cblxuICAgIHRoaXMuX2xhc3RSdW5uZXJJZCA9IHJ1bm5lci5pZFxuXG4gICAgdGhpcy5fcnVubmVycy5wdXNoKHJ1bm5lckluZm8pXG4gICAgdGhpcy5fcnVubmVycy5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0IC0gYi5zdGFydClcbiAgICB0aGlzLl9ydW5uZXJJZHMgPSB0aGlzLl9ydW5uZXJzLm1hcCgoaW5mbykgPT4gaW5mby5ydW5uZXIuaWQpXG5cbiAgICB0aGlzLnVwZGF0ZVRpbWUoKS5fY29udGludWUoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzZWVrKGR0KSB7XG4gICAgcmV0dXJuIHRoaXMudGltZSh0aGlzLl90aW1lICsgZHQpXG4gIH1cblxuICBzb3VyY2UoZm4pIHtcbiAgICBpZiAoZm4gPT0gbnVsbCkgcmV0dXJuIHRoaXMuX3RpbWVTb3VyY2VcbiAgICB0aGlzLl90aW1lU291cmNlID0gZm5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3BlZWQoc3BlZWQpIHtcbiAgICBpZiAoc3BlZWQgPT0gbnVsbCkgcmV0dXJuIHRoaXMuX3NwZWVkXG4gICAgdGhpcy5fc3BlZWQgPSBzcGVlZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdG9wKCkge1xuICAgIC8vIEdvIHRvIHN0YXJ0IGFuZCBwYXVzZVxuICAgIHRoaXMudGltZSgwKVxuICAgIHJldHVybiB0aGlzLnBhdXNlKClcbiAgfVxuXG4gIHRpbWUodGltZSkge1xuICAgIGlmICh0aW1lID09IG51bGwpIHJldHVybiB0aGlzLl90aW1lXG4gICAgdGhpcy5fdGltZSA9IHRpbWVcbiAgICByZXR1cm4gdGhpcy5fY29udGludWUodHJ1ZSlcbiAgfVxuXG4gIC8vIFJlbW92ZSB0aGUgcnVubmVyIGZyb20gdGhpcyB0aW1lbGluZVxuICB1bnNjaGVkdWxlKHJ1bm5lcikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fcnVubmVySWRzLmluZGV4T2YocnVubmVyLmlkKVxuICAgIGlmIChpbmRleCA8IDApIHJldHVybiB0aGlzXG5cbiAgICB0aGlzLl9ydW5uZXJzLnNwbGljZShpbmRleCwgMSlcbiAgICB0aGlzLl9ydW5uZXJJZHMuc3BsaWNlKGluZGV4LCAxKVxuXG4gICAgcnVubmVyLnRpbWVsaW5lKG51bGwpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIE1ha2VzIHN1cmUsIHRoYXQgYWZ0ZXIgcGF1c2luZyB0aGUgdGltZSBkb2Vzbid0IGp1bXBcbiAgdXBkYXRlVGltZSgpIHtcbiAgICBpZiAoIXRoaXMuYWN0aXZlKCkpIHtcbiAgICAgIHRoaXMuX2xhc3RTb3VyY2VUaW1lID0gdGhpcy5fdGltZVNvdXJjZSgpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBDaGVja3MgaWYgd2UgYXJlIHJ1bm5pbmcgYW5kIGNvbnRpbnVlcyB0aGUgYW5pbWF0aW9uXG4gIF9jb250aW51ZShpbW1lZGlhdGVTdGVwID0gZmFsc2UpIHtcbiAgICBBbmltYXRvci5jYW5jZWxGcmFtZSh0aGlzLl9uZXh0RnJhbWUpXG4gICAgdGhpcy5fbmV4dEZyYW1lID0gbnVsbFxuXG4gICAgaWYgKGltbWVkaWF0ZVN0ZXApIHJldHVybiB0aGlzLl9zdGVwSW1tZWRpYXRlKClcbiAgICBpZiAodGhpcy5fcGF1c2VkKSByZXR1cm4gdGhpc1xuXG4gICAgdGhpcy5fbmV4dEZyYW1lID0gQW5pbWF0b3IuZnJhbWUodGhpcy5fc3RlcClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgX3N0ZXBGbihpbW1lZGlhdGVTdGVwID0gZmFsc2UpIHtcbiAgICAvLyBHZXQgdGhlIHRpbWUgZGVsdGEgZnJvbSB0aGUgbGFzdCB0aW1lIGFuZCB1cGRhdGUgdGhlIHRpbWVcbiAgICBjb25zdCB0aW1lID0gdGhpcy5fdGltZVNvdXJjZSgpXG4gICAgbGV0IGR0U291cmNlID0gdGltZSAtIHRoaXMuX2xhc3RTb3VyY2VUaW1lXG5cbiAgICBpZiAoaW1tZWRpYXRlU3RlcCkgZHRTb3VyY2UgPSAwXG5cbiAgICBjb25zdCBkdFRpbWUgPSB0aGlzLl9zcGVlZCAqIGR0U291cmNlICsgKHRoaXMuX3RpbWUgLSB0aGlzLl9sYXN0U3RlcFRpbWUpXG4gICAgdGhpcy5fbGFzdFNvdXJjZVRpbWUgPSB0aW1lXG5cbiAgICAvLyBPbmx5IHVwZGF0ZSB0aGUgdGltZSBpZiB3ZSB1c2UgdGhlIHRpbWVTb3VyY2UuXG4gICAgLy8gT3RoZXJ3aXNlIHVzZSB0aGUgY3VycmVudCB0aW1lXG4gICAgaWYgKCFpbW1lZGlhdGVTdGVwKSB7XG4gICAgICAvLyBVcGRhdGUgdGhlIHRpbWVcbiAgICAgIHRoaXMuX3RpbWUgKz0gZHRUaW1lXG4gICAgICB0aGlzLl90aW1lID0gdGhpcy5fdGltZSA8IDAgPyAwIDogdGhpcy5fdGltZVxuICAgIH1cbiAgICB0aGlzLl9sYXN0U3RlcFRpbWUgPSB0aGlzLl90aW1lXG4gICAgdGhpcy5maXJlKCd0aW1lJywgdGhpcy5fdGltZSlcblxuICAgIC8vIFRoaXMgaXMgZm9yIHRoZSBjYXNlIHRoYXQgdGhlIHRpbWVsaW5lIHdhcyBzZWVrZWQgc28gdGhhdCB0aGUgdGltZVxuICAgIC8vIGlzIG5vdyBiZWZvcmUgdGhlIHN0YXJ0VGltZSBvZiB0aGUgcnVubmVyLiBUaGF0IGlzIHdoeSB3ZSBuZWVkIHRvIHNldFxuICAgIC8vIHRoZSBydW5uZXIgdG8gcG9zaXRpb24gMFxuXG4gICAgLy8gRklYTUU6XG4gICAgLy8gSG93ZXZlciwgcmVzZXR0aW5nIGluIGluc2VydGlvbiBvcmRlciBsZWFkcyB0byBidWdzLiBDb25zaWRlcmluZyB0aGUgY2FzZSxcbiAgICAvLyB3aGVyZSAyIHJ1bm5lcnMgY2hhbmdlIHRoZSBzYW1lIGF0dHJpYnV0ZSBidXQgaW4gZGlmZmVyZW50IHRpbWVzLFxuICAgIC8vIHJlc2V0dGluZyBib3RoIG9mIHRoZW0gd2lsbCBsZWFkIHRvIHRoZSBjYXNlIHdoZXJlIHRoZSBsYXRlciBkZWZpbmVkXG4gICAgLy8gcnVubmVyIGFsd2F5cyB3aW5zIHRoZSByZXNldCBldmVuIGlmIHRoZSBvdGhlciBydW5uZXIgc3RhcnRlZCBlYXJsaWVyXG4gICAgLy8gYW5kIHRoZXJlZm9yZSBzaG91bGQgd2luIHRoZSBhdHRyaWJ1dGUgYmF0dGxlXG4gICAgLy8gdGhpcyBjYW4gYmUgc29sdmVkIGJ5IHJlc2V0dGluZyB0aGVtIGJhY2t3YXJkc1xuICAgIGZvciAobGV0IGsgPSB0aGlzLl9ydW5uZXJzLmxlbmd0aDsgay0tOyApIHtcbiAgICAgIC8vIEdldCBhbmQgcnVuIHRoZSBjdXJyZW50IHJ1bm5lciBhbmQgaWdub3JlIGl0IGlmIGl0cyBpbmFjdGl2ZVxuICAgICAgY29uc3QgcnVubmVySW5mbyA9IHRoaXMuX3J1bm5lcnNba11cbiAgICAgIGNvbnN0IHJ1bm5lciA9IHJ1bm5lckluZm8ucnVubmVyXG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGdpdmUgdGhlIGFjdHVhbCBkaWZmZXJlbmNlXG4gICAgICAvLyBiZXR3ZWVuIHJ1bm5lciBzdGFydCB0aW1lIGFuZCBub3dcbiAgICAgIGNvbnN0IGR0VG9TdGFydCA9IHRoaXMuX3RpbWUgLSBydW5uZXJJbmZvLnN0YXJ0XG5cbiAgICAgIC8vIERvbnQgcnVuIHJ1bm5lciBpZiBub3Qgc3RhcnRlZCB5ZXRcbiAgICAgIC8vIGFuZCB0cnkgdG8gcmVzZXQgaXRcbiAgICAgIGlmIChkdFRvU3RhcnQgPD0gMCkge1xuICAgICAgICBydW5uZXIucmVzZXQoKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJ1biBhbGwgb2YgdGhlIHJ1bm5lcnMgZGlyZWN0bHlcbiAgICBsZXQgcnVubmVyc0xlZnQgPSBmYWxzZVxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9ydW5uZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvLyBHZXQgYW5kIHJ1biB0aGUgY3VycmVudCBydW5uZXIgYW5kIGlnbm9yZSBpdCBpZiBpdHMgaW5hY3RpdmVcbiAgICAgIGNvbnN0IHJ1bm5lckluZm8gPSB0aGlzLl9ydW5uZXJzW2ldXG4gICAgICBjb25zdCBydW5uZXIgPSBydW5uZXJJbmZvLnJ1bm5lclxuICAgICAgbGV0IGR0ID0gZHRUaW1lXG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGdpdmUgdGhlIGFjdHVhbCBkaWZmZXJlbmNlXG4gICAgICAvLyBiZXR3ZWVuIHJ1bm5lciBzdGFydCB0aW1lIGFuZCBub3dcbiAgICAgIGNvbnN0IGR0VG9TdGFydCA9IHRoaXMuX3RpbWUgLSBydW5uZXJJbmZvLnN0YXJ0XG5cbiAgICAgIC8vIERvbnQgcnVuIHJ1bm5lciBpZiBub3Qgc3RhcnRlZCB5ZXRcbiAgICAgIGlmIChkdFRvU3RhcnQgPD0gMCkge1xuICAgICAgICBydW5uZXJzTGVmdCA9IHRydWVcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSBpZiAoZHRUb1N0YXJ0IDwgZHQpIHtcbiAgICAgICAgLy8gQWRqdXN0IGR0IHRvIG1ha2Ugc3VyZSB0aGF0IGFuaW1hdGlvbiBpcyBvbiBwb2ludFxuICAgICAgICBkdCA9IGR0VG9TdGFydFxuICAgICAgfVxuXG4gICAgICBpZiAoIXJ1bm5lci5hY3RpdmUoKSkgY29udGludWVcblxuICAgICAgLy8gSWYgdGhpcyBydW5uZXIgaXMgc3RpbGwgZ29pbmcsIHNpZ25hbCB0aGF0IHdlIG5lZWQgYW5vdGhlciBhbmltYXRpb25cbiAgICAgIC8vIGZyYW1lLCBvdGhlcndpc2UsIHJlbW92ZSB0aGUgY29tcGxldGVkIHJ1bm5lclxuICAgICAgY29uc3QgZmluaXNoZWQgPSBydW5uZXIuc3RlcChkdCkuZG9uZVxuICAgICAgaWYgKCFmaW5pc2hlZCkge1xuICAgICAgICBydW5uZXJzTGVmdCA9IHRydWVcbiAgICAgICAgLy8gY29udGludWVcbiAgICAgIH0gZWxzZSBpZiAocnVubmVySW5mby5wZXJzaXN0ICE9PSB0cnVlKSB7XG4gICAgICAgIC8vIHJ1bm5lciBpcyBmaW5pc2hlZC4gQW5kIHJ1bm5lciBtaWdodCBnZXQgcmVtb3ZlZFxuICAgICAgICBjb25zdCBlbmRUaW1lID0gcnVubmVyLmR1cmF0aW9uKCkgLSBydW5uZXIudGltZSgpICsgdGhpcy5fdGltZVxuXG4gICAgICAgIGlmIChlbmRUaW1lICsgcnVubmVySW5mby5wZXJzaXN0IDwgdGhpcy5fdGltZSkge1xuICAgICAgICAgIC8vIERlbGV0ZSBydW5uZXIgYW5kIGNvcnJlY3QgaW5kZXhcbiAgICAgICAgICBydW5uZXIudW5zY2hlZHVsZSgpXG4gICAgICAgICAgLS1pXG4gICAgICAgICAgLS1sZW5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJhc2ljYWxseTogd2UgY29udGludWUgd2hlbiB0aGVyZSBhcmUgcnVubmVycyByaWdodCBmcm9tIHVzIGluIHRpbWVcbiAgICAvLyB3aGVuIC0tPiwgYW5kIHdoZW4gcnVubmVycyBhcmUgbGVmdCBmcm9tIHVzIHdoZW4gPC0tXG4gICAgaWYgKFxuICAgICAgKHJ1bm5lcnNMZWZ0ICYmICEodGhpcy5fc3BlZWQgPCAwICYmIHRoaXMuX3RpbWUgPT09IDApKSB8fFxuICAgICAgKHRoaXMuX3J1bm5lcklkcy5sZW5ndGggJiYgdGhpcy5fc3BlZWQgPCAwICYmIHRoaXMuX3RpbWUgPiAwKVxuICAgICkge1xuICAgICAgdGhpcy5fY29udGludWUoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhdXNlKClcbiAgICAgIHRoaXMuZmlyZSgnZmluaXNoZWQnKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB0ZXJtaW5hdGUoKSB7XG4gICAgLy8gY2xlYW51cCBtZW1vcnlcblxuICAgIC8vIFN0b3JlIHRoZSB0aW1pbmcgdmFyaWFibGVzXG4gICAgdGhpcy5fc3RhcnRUaW1lID0gMFxuICAgIHRoaXMuX3NwZWVkID0gMS4wXG5cbiAgICAvLyBEZXRlcm1pbmVzIGhvdyBsb25nIGEgcnVubmVyIGlzIGhvbGQgaW4gbWVtb3J5LiBDYW4gYmUgYSBkdCBvciB0cnVlL2ZhbHNlXG4gICAgdGhpcy5fcGVyc2lzdCA9IDBcblxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIHJ1bm5pbmcgYW5pbWF0aW9ucyBhbmQgdGhlaXIgc3RhcnRpbmcgcGFyYW1ldGVyc1xuICAgIHRoaXMuX25leHRGcmFtZSA9IG51bGxcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlXG4gICAgdGhpcy5fcnVubmVycyA9IFtdXG4gICAgdGhpcy5fcnVubmVySWRzID0gW11cbiAgICB0aGlzLl9sYXN0UnVubmVySWQgPSAtMVxuICAgIHRoaXMuX3RpbWUgPSAwXG4gICAgdGhpcy5fbGFzdFNvdXJjZVRpbWUgPSAwXG4gICAgdGhpcy5fbGFzdFN0ZXBUaW1lID0gMFxuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgc3RlcCBpcyBhbHdheXMgY2FsbGVkIGluIGNsYXNzIGNvbnRleHRcbiAgICB0aGlzLl9zdGVwID0gdGhpcy5fc3RlcEZuLmJpbmQodGhpcywgZmFsc2UpXG4gICAgdGhpcy5fc3RlcEltbWVkaWF0ZSA9IHRoaXMuX3N0ZXBGbi5iaW5kKHRoaXMsIHRydWUpXG4gIH1cbn1cblxucmVnaXN0ZXJNZXRob2RzKHtcbiAgRWxlbWVudDoge1xuICAgIHRpbWVsaW5lOiBmdW5jdGlvbiAodGltZWxpbmUpIHtcbiAgICAgIGlmICh0aW1lbGluZSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3RpbWVsaW5lID0gdGhpcy5fdGltZWxpbmUgfHwgbmV3IFRpbWVsaW5lKClcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVsaW5lXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl90aW1lbGluZSA9IHRpbWVsaW5lXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgfVxuICB9XG59KVxuIiwiaW1wb3J0IHsgQ29udHJvbGxlciwgRWFzZSwgU3RlcHBlciB9IGZyb20gJy4vQ29udHJvbGxlci5qcydcbmltcG9ydCB7IGV4dGVuZCwgcmVnaXN0ZXIgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgZnJvbSwgdG8gfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvZ3JhZGllbnRlZC5qcydcbmltcG9ydCB7IGdldE9yaWdpbiB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLmpzJ1xuaW1wb3J0IHsgbm9vcCwgdGltZWxpbmUgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvZGVmYXVsdHMuanMnXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xuaW1wb3J0IHsgcngsIHJ5IH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL2NpcmNsZWQuanMnXG5pbXBvcnQgQW5pbWF0b3IgZnJvbSAnLi9BbmltYXRvci5qcydcbmltcG9ydCBCb3ggZnJvbSAnLi4vdHlwZXMvQm94LmpzJ1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4uL3R5cGVzL0V2ZW50VGFyZ2V0LmpzJ1xuaW1wb3J0IE1hdHJpeCBmcm9tICcuLi90eXBlcy9NYXRyaXguanMnXG5pbXBvcnQgTW9ycGhhYmxlLCB7IFRyYW5zZm9ybUJhZywgT2JqZWN0QmFnIH0gZnJvbSAnLi9Nb3JwaGFibGUuanMnXG5pbXBvcnQgUG9pbnQgZnJvbSAnLi4vdHlwZXMvUG9pbnQuanMnXG5pbXBvcnQgU1ZHTnVtYmVyIGZyb20gJy4uL3R5cGVzL1NWR051bWJlci5qcydcbmltcG9ydCBUaW1lbGluZSBmcm9tICcuL1RpbWVsaW5lLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdW5uZXIgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpXG5cbiAgICAvLyBTdG9yZSBhIHVuaXF1ZSBpZCBvbiB0aGUgcnVubmVyLCBzbyB0aGF0IHdlIGNhbiBpZGVudGlmeSBpdCBsYXRlclxuICAgIHRoaXMuaWQgPSBSdW5uZXIuaWQrK1xuXG4gICAgLy8gRW5zdXJlIGEgZGVmYXVsdCB2YWx1ZVxuICAgIG9wdGlvbnMgPSBvcHRpb25zID09IG51bGwgPyB0aW1lbGluZS5kdXJhdGlvbiA6IG9wdGlvbnNcblxuICAgIC8vIEVuc3VyZSB0aGF0IHdlIGdldCBhIGNvbnRyb2xsZXJcbiAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyBuZXcgQ29udHJvbGxlcihvcHRpb25zKSA6IG9wdGlvbnNcblxuICAgIC8vIERlY2xhcmUgYWxsIG9mIHRoZSB2YXJpYWJsZXNcbiAgICB0aGlzLl9lbGVtZW50ID0gbnVsbFxuICAgIHRoaXMuX3RpbWVsaW5lID0gbnVsbFxuICAgIHRoaXMuZG9uZSA9IGZhbHNlXG4gICAgdGhpcy5fcXVldWUgPSBbXVxuXG4gICAgLy8gV29yayBvdXQgdGhlIHN0ZXBwZXIgYW5kIHRoZSBkdXJhdGlvblxuICAgIHRoaXMuX2R1cmF0aW9uID0gdHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInICYmIG9wdGlvbnNcbiAgICB0aGlzLl9pc0RlY2xhcmF0aXZlID0gb3B0aW9ucyBpbnN0YW5jZW9mIENvbnRyb2xsZXJcbiAgICB0aGlzLl9zdGVwcGVyID0gdGhpcy5faXNEZWNsYXJhdGl2ZSA/IG9wdGlvbnMgOiBuZXcgRWFzZSgpXG5cbiAgICAvLyBXZSBjb3B5IHRoZSBjdXJyZW50IHZhbHVlcyBmcm9tIHRoZSB0aW1lbGluZSBiZWNhdXNlIHRoZXkgY2FuIGNoYW5nZVxuICAgIHRoaXMuX2hpc3RvcnkgPSB7fVxuXG4gICAgLy8gU3RvcmUgdGhlIHN0YXRlIG9mIHRoZSBydW5uZXJcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlXG4gICAgdGhpcy5fdGltZSA9IDBcbiAgICB0aGlzLl9sYXN0VGltZSA9IDBcblxuICAgIC8vIEF0IGNyZWF0aW9uLCB0aGUgcnVubmVyIGlzIGluIHJlc2V0IHN0YXRlXG4gICAgdGhpcy5fcmVzZXRlZCA9IHRydWVcblxuICAgIC8vIFNhdmUgdHJhbnNmb3JtcyBhcHBsaWVkIHRvIHRoaXMgcnVubmVyXG4gICAgdGhpcy50cmFuc2Zvcm1zID0gbmV3IE1hdHJpeCgpXG4gICAgdGhpcy50cmFuc2Zvcm1JZCA9IDFcblxuICAgIC8vIExvb3BpbmcgdmFyaWFibGVzXG4gICAgdGhpcy5faGF2ZVJldmVyc2VkID0gZmFsc2VcbiAgICB0aGlzLl9yZXZlcnNlID0gZmFsc2VcbiAgICB0aGlzLl9sb29wc0RvbmUgPSAwXG4gICAgdGhpcy5fc3dpbmcgPSBmYWxzZVxuICAgIHRoaXMuX3dhaXQgPSAwXG4gICAgdGhpcy5fdGltZXMgPSAxXG5cbiAgICB0aGlzLl9mcmFtZUlkID0gbnVsbFxuXG4gICAgLy8gU3RvcmVzIGhvdyBsb25nIGEgcnVubmVyIGlzIHN0b3JlZCBhZnRlciBiZWluZyBkb25lXG4gICAgdGhpcy5fcGVyc2lzdCA9IHRoaXMuX2lzRGVjbGFyYXRpdmUgPyB0cnVlIDogbnVsbFxuICB9XG5cbiAgc3RhdGljIHNhbml0aXNlKGR1cmF0aW9uLCBkZWxheSwgd2hlbikge1xuICAgIC8vIEluaXRpYWxpc2UgdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuICAgIGxldCB0aW1lcyA9IDFcbiAgICBsZXQgc3dpbmcgPSBmYWxzZVxuICAgIGxldCB3YWl0ID0gMFxuICAgIGR1cmF0aW9uID0gZHVyYXRpb24gPz8gdGltZWxpbmUuZHVyYXRpb25cbiAgICBkZWxheSA9IGRlbGF5ID8/IHRpbWVsaW5lLmRlbGF5XG4gICAgd2hlbiA9IHdoZW4gfHwgJ2xhc3QnXG5cbiAgICAvLyBJZiB3ZSBoYXZlIGFuIG9iamVjdCwgdW5wYWNrIHRoZSB2YWx1ZXNcbiAgICBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJiAhKGR1cmF0aW9uIGluc3RhbmNlb2YgU3RlcHBlcikpIHtcbiAgICAgIGRlbGF5ID0gZHVyYXRpb24uZGVsYXkgPz8gZGVsYXlcbiAgICAgIHdoZW4gPSBkdXJhdGlvbi53aGVuID8/IHdoZW5cbiAgICAgIHN3aW5nID0gZHVyYXRpb24uc3dpbmcgfHwgc3dpbmdcbiAgICAgIHRpbWVzID0gZHVyYXRpb24udGltZXMgPz8gdGltZXNcbiAgICAgIHdhaXQgPSBkdXJhdGlvbi53YWl0ID8/IHdhaXRcbiAgICAgIGR1cmF0aW9uID0gZHVyYXRpb24uZHVyYXRpb24gPz8gdGltZWxpbmUuZHVyYXRpb25cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgZGVsYXk6IGRlbGF5LFxuICAgICAgc3dpbmc6IHN3aW5nLFxuICAgICAgdGltZXM6IHRpbWVzLFxuICAgICAgd2FpdDogd2FpdCxcbiAgICAgIHdoZW46IHdoZW5cbiAgICB9XG4gIH1cblxuICBhY3RpdmUoZW5hYmxlZCkge1xuICAgIGlmIChlbmFibGVkID09IG51bGwpIHJldHVybiB0aGlzLmVuYWJsZWRcbiAgICB0aGlzLmVuYWJsZWQgPSBlbmFibGVkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qXG4gIFByaXZhdGUgTWV0aG9kc1xuICA9PT09PT09PT09PT09PT1cbiAgTWV0aG9kcyB0aGF0IHNob3VsZG4ndCBiZSB1c2VkIGV4dGVybmFsbHlcbiAgKi9cbiAgYWRkVHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgIHRoaXMudHJhbnNmb3Jtcy5sbXVsdGlwbHlPKHRyYW5zZm9ybSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgYWZ0ZXIoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5vbignZmluaXNoZWQnLCBmbilcbiAgfVxuXG4gIGFuaW1hdGUoZHVyYXRpb24sIGRlbGF5LCB3aGVuKSB7XG4gICAgY29uc3QgbyA9IFJ1bm5lci5zYW5pdGlzZShkdXJhdGlvbiwgZGVsYXksIHdoZW4pXG4gICAgY29uc3QgcnVubmVyID0gbmV3IFJ1bm5lcihvLmR1cmF0aW9uKVxuICAgIGlmICh0aGlzLl90aW1lbGluZSkgcnVubmVyLnRpbWVsaW5lKHRoaXMuX3RpbWVsaW5lKVxuICAgIGlmICh0aGlzLl9lbGVtZW50KSBydW5uZXIuZWxlbWVudCh0aGlzLl9lbGVtZW50KVxuICAgIHJldHVybiBydW5uZXIubG9vcChvKS5zY2hlZHVsZShvLmRlbGF5LCBvLndoZW4pXG4gIH1cblxuICBjbGVhclRyYW5zZm9ybSgpIHtcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBuZXcgTWF0cml4KClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gVE9ETzogS2VlcCB0cmFjayBvZiBhbGwgdHJhbnNmb3JtYXRpb25zIHNvIHRoYXQgZGVsZXRpb24gaXMgZmFzdGVyXG4gIGNsZWFyVHJhbnNmb3Jtc0Zyb21RdWV1ZSgpIHtcbiAgICBpZiAoXG4gICAgICAhdGhpcy5kb25lIHx8XG4gICAgICAhdGhpcy5fdGltZWxpbmUgfHxcbiAgICAgICF0aGlzLl90aW1lbGluZS5fcnVubmVySWRzLmluY2x1ZGVzKHRoaXMuaWQpXG4gICAgKSB7XG4gICAgICB0aGlzLl9xdWV1ZSA9IHRoaXMuX3F1ZXVlLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICByZXR1cm4gIWl0ZW0uaXNUcmFuc2Zvcm1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZGVsYXkoZGVsYXkpIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRlKDAsIGRlbGF5KVxuICB9XG5cbiAgZHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWVzICogKHRoaXMuX3dhaXQgKyB0aGlzLl9kdXJhdGlvbikgLSB0aGlzLl93YWl0XG4gIH1cblxuICBkdXJpbmcoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZShudWxsLCBmbilcbiAgfVxuXG4gIGVhc2UoZm4pIHtcbiAgICB0aGlzLl9zdGVwcGVyID0gbmV3IEVhc2UoZm4pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICAvKlxuICBSdW5uZXIgRGVmaW5pdGlvbnNcbiAgPT09PT09PT09PT09PT09PT09XG4gIFRoZXNlIG1ldGhvZHMgaGVscCB1cyBkZWZpbmUgdGhlIHJ1bnRpbWUgYmVoYXZpb3VyIG9mIHRoZSBSdW5uZXIgb3IgdGhleVxuICBoZWxwIHVzIG1ha2UgbmV3IHJ1bm5lcnMgZnJvbSB0aGUgY3VycmVudCBydW5uZXJcbiAgKi9cblxuICBlbGVtZW50KGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSByZXR1cm4gdGhpcy5fZWxlbWVudFxuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50XG4gICAgZWxlbWVudC5fcHJlcGFyZVJ1bm5lcigpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGZpbmlzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGVwKEluZmluaXR5KVxuICB9XG5cbiAgbG9vcCh0aW1lcywgc3dpbmcsIHdhaXQpIHtcbiAgICAvLyBEZWFsIHdpdGggdGhlIHVzZXIgcGFzc2luZyBpbiBhbiBvYmplY3RcbiAgICBpZiAodHlwZW9mIHRpbWVzID09PSAnb2JqZWN0Jykge1xuICAgICAgc3dpbmcgPSB0aW1lcy5zd2luZ1xuICAgICAgd2FpdCA9IHRpbWVzLndhaXRcbiAgICAgIHRpbWVzID0gdGltZXMudGltZXNcbiAgICB9XG5cbiAgICAvLyBTYW5pdGlzZSB0aGUgdmFsdWVzIGFuZCBzdG9yZSB0aGVtXG4gICAgdGhpcy5fdGltZXMgPSB0aW1lcyB8fCBJbmZpbml0eVxuICAgIHRoaXMuX3N3aW5nID0gc3dpbmcgfHwgZmFsc2VcbiAgICB0aGlzLl93YWl0ID0gd2FpdCB8fCAwXG5cbiAgICAvLyBBbGxvdyB0cnVlIHRvIGJlIHBhc3NlZFxuICAgIGlmICh0aGlzLl90aW1lcyA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fdGltZXMgPSBJbmZpbml0eVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBsb29wcyhwKSB7XG4gICAgY29uc3QgbG9vcER1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKyB0aGlzLl93YWl0XG4gICAgaWYgKHAgPT0gbnVsbCkge1xuICAgICAgY29uc3QgbG9vcHNEb25lID0gTWF0aC5mbG9vcih0aGlzLl90aW1lIC8gbG9vcER1cmF0aW9uKVxuICAgICAgY29uc3QgcmVsYXRpdmVUaW1lID0gdGhpcy5fdGltZSAtIGxvb3BzRG9uZSAqIGxvb3BEdXJhdGlvblxuICAgICAgY29uc3QgcG9zaXRpb24gPSByZWxhdGl2ZVRpbWUgLyB0aGlzLl9kdXJhdGlvblxuICAgICAgcmV0dXJuIE1hdGgubWluKGxvb3BzRG9uZSArIHBvc2l0aW9uLCB0aGlzLl90aW1lcylcbiAgICB9XG4gICAgY29uc3Qgd2hvbGUgPSBNYXRoLmZsb29yKHApXG4gICAgY29uc3QgcGFydGlhbCA9IHAgJSAxXG4gICAgY29uc3QgdGltZSA9IGxvb3BEdXJhdGlvbiAqIHdob2xlICsgdGhpcy5fZHVyYXRpb24gKiBwYXJ0aWFsXG4gICAgcmV0dXJuIHRoaXMudGltZSh0aW1lKVxuICB9XG5cbiAgcGVyc2lzdChkdE9yRm9yZXZlcikge1xuICAgIGlmIChkdE9yRm9yZXZlciA9PSBudWxsKSByZXR1cm4gdGhpcy5fcGVyc2lzdFxuICAgIHRoaXMuX3BlcnNpc3QgPSBkdE9yRm9yZXZlclxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwb3NpdGlvbihwKSB7XG4gICAgLy8gR2V0IGFsbCBvZiB0aGUgdmFyaWFibGVzIHdlIG5lZWRcbiAgICBjb25zdCB4ID0gdGhpcy5fdGltZVxuICAgIGNvbnN0IGQgPSB0aGlzLl9kdXJhdGlvblxuICAgIGNvbnN0IHcgPSB0aGlzLl93YWl0XG4gICAgY29uc3QgdCA9IHRoaXMuX3RpbWVzXG4gICAgY29uc3QgcyA9IHRoaXMuX3N3aW5nXG4gICAgY29uc3QgciA9IHRoaXMuX3JldmVyc2VcbiAgICBsZXQgcG9zaXRpb25cblxuICAgIGlmIChwID09IG51bGwpIHtcbiAgICAgIC8qXG4gICAgICBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIGEgdGltZSB0byBhIHBvc2l0aW9uIGluIHRoZSByYW5nZSBbMCwgMV1cbiAgICAgIFRoZSBmdWxsIGV4cGxhbmF0aW9uIGNhbiBiZSBmb3VuZCBpbiB0aGlzIGRlc21vcyBkZW1vbnN0cmF0aW9uXG4gICAgICAgIGh0dHBzOi8vd3d3LmRlc21vcy5jb20vY2FsY3VsYXRvci91NGZiYXZnY2hlXG4gICAgICBUaGUgbG9naWMgaXMgc2xpZ2h0bHkgc2ltcGxpZmllZCBoZXJlIGJlY2F1c2Ugd2UgY2FuIHVzZSBib29sZWFuc1xuICAgICAgKi9cblxuICAgICAgLy8gRmlndXJlIG91dCB0aGUgdmFsdWUgd2l0aG91dCB0aGlua2luZyBhYm91dCB0aGUgc3RhcnQgb3IgZW5kIHRpbWVcbiAgICAgIGNvbnN0IGYgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICBjb25zdCBzd2luZ2luZyA9IHMgKiBNYXRoLmZsb29yKCh4ICUgKDIgKiAodyArIGQpKSkgLyAodyArIGQpKVxuICAgICAgICBjb25zdCBiYWNrd2FyZHMgPSAoc3dpbmdpbmcgJiYgIXIpIHx8ICghc3dpbmdpbmcgJiYgcilcbiAgICAgICAgY29uc3QgdW5jbGlwZWQgPVxuICAgICAgICAgIChNYXRoLnBvdygtMSwgYmFja3dhcmRzKSAqICh4ICUgKHcgKyBkKSkpIC8gZCArIGJhY2t3YXJkc1xuICAgICAgICBjb25zdCBjbGlwcGVkID0gTWF0aC5tYXgoTWF0aC5taW4odW5jbGlwZWQsIDEpLCAwKVxuICAgICAgICByZXR1cm4gY2xpcHBlZFxuICAgICAgfVxuXG4gICAgICAvLyBGaWd1cmUgb3V0IHRoZSB2YWx1ZSBieSBpbmNvcnBvcmF0aW5nIHRoZSBzdGFydCB0aW1lXG4gICAgICBjb25zdCBlbmRUaW1lID0gdCAqICh3ICsgZCkgLSB3XG4gICAgICBwb3NpdGlvbiA9XG4gICAgICAgIHggPD0gMFxuICAgICAgICAgID8gTWF0aC5yb3VuZChmKDFlLTUpKVxuICAgICAgICAgIDogeCA8IGVuZFRpbWVcbiAgICAgICAgICAgID8gZih4KVxuICAgICAgICAgICAgOiBNYXRoLnJvdW5kKGYoZW5kVGltZSAtIDFlLTUpKVxuICAgICAgcmV0dXJuIHBvc2l0aW9uXG4gICAgfVxuXG4gICAgLy8gV29yayBvdXQgdGhlIGxvb3BzIGRvbmUgYW5kIGFkZCB0aGUgcG9zaXRpb24gdG8gdGhlIGxvb3BzIGRvbmVcbiAgICBjb25zdCBsb29wc0RvbmUgPSBNYXRoLmZsb29yKHRoaXMubG9vcHMoKSlcbiAgICBjb25zdCBzd2luZ0ZvcndhcmQgPSBzICYmIGxvb3BzRG9uZSAlIDIgPT09IDBcbiAgICBjb25zdCBmb3J3YXJkcyA9IChzd2luZ0ZvcndhcmQgJiYgIXIpIHx8IChyICYmIHN3aW5nRm9yd2FyZClcbiAgICBwb3NpdGlvbiA9IGxvb3BzRG9uZSArIChmb3J3YXJkcyA/IHAgOiAxIC0gcClcbiAgICByZXR1cm4gdGhpcy5sb29wcyhwb3NpdGlvbilcbiAgfVxuXG4gIHByb2dyZXNzKHApIHtcbiAgICBpZiAocCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4oMSwgdGhpcy5fdGltZSAvIHRoaXMuZHVyYXRpb24oKSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGltZShwICogdGhpcy5kdXJhdGlvbigpKVxuICB9XG5cbiAgLypcbiAgQmFzaWMgRnVuY3Rpb25hbGl0eVxuICA9PT09PT09PT09PT09PT09PT09XG4gIFRoZXNlIG1ldGhvZHMgYWxsb3cgdXMgdG8gYXR0YWNoIGJhc2ljIGZ1bmN0aW9ucyB0byB0aGUgcnVubmVyIGRpcmVjdGx5XG4gICovXG4gIHF1ZXVlKGluaXRGbiwgcnVuRm4sIHJldGFyZ2V0Rm4sIGlzVHJhbnNmb3JtKSB7XG4gICAgdGhpcy5fcXVldWUucHVzaCh7XG4gICAgICBpbml0aWFsaXNlcjogaW5pdEZuIHx8IG5vb3AsXG4gICAgICBydW5uZXI6IHJ1bkZuIHx8IG5vb3AsXG4gICAgICByZXRhcmdldDogcmV0YXJnZXRGbixcbiAgICAgIGlzVHJhbnNmb3JtOiBpc1RyYW5zZm9ybSxcbiAgICAgIGluaXRpYWxpc2VkOiBmYWxzZSxcbiAgICAgIGZpbmlzaGVkOiBmYWxzZVxuICAgIH0pXG4gICAgY29uc3QgdGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lKClcbiAgICB0aW1lbGluZSAmJiB0aGlzLnRpbWVsaW5lKCkuX2NvbnRpbnVlKClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgaWYgKHRoaXMuX3Jlc2V0ZWQpIHJldHVybiB0aGlzXG4gICAgdGhpcy50aW1lKDApXG4gICAgdGhpcy5fcmVzZXRlZCA9IHRydWVcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmV2ZXJzZShyZXZlcnNlKSB7XG4gICAgdGhpcy5fcmV2ZXJzZSA9IHJldmVyc2UgPT0gbnVsbCA/ICF0aGlzLl9yZXZlcnNlIDogcmV2ZXJzZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzY2hlZHVsZSh0aW1lbGluZSwgZGVsYXksIHdoZW4pIHtcbiAgICAvLyBUaGUgdXNlciBkb2Vzbid0IG5lZWQgdG8gcGFzcyBhIHRpbWVsaW5lIGlmIHdlIGFscmVhZHkgaGF2ZSBvbmVcbiAgICBpZiAoISh0aW1lbGluZSBpbnN0YW5jZW9mIFRpbWVsaW5lKSkge1xuICAgICAgd2hlbiA9IGRlbGF5XG4gICAgICBkZWxheSA9IHRpbWVsaW5lXG4gICAgICB0aW1lbGluZSA9IHRoaXMudGltZWxpbmUoKVxuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIG5vIHRpbWVsaW5lLCB5ZWxsIGF0IHRoZSB1c2VyLi4uXG4gICAgaWYgKCF0aW1lbGluZSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ1J1bm5lciBjYW5ub3QgYmUgc2NoZWR1bGVkIHdpdGhvdXQgdGltZWxpbmUnKVxuICAgIH1cblxuICAgIC8vIFNjaGVkdWxlIHRoZSBydW5uZXIgb24gdGhlIHRpbWVsaW5lIHByb3ZpZGVkXG4gICAgdGltZWxpbmUuc2NoZWR1bGUodGhpcywgZGVsYXksIHdoZW4pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0ZXAoZHQpIHtcbiAgICAvLyBJZiB3ZSBhcmUgaW5hY3RpdmUsIHRoaXMgc3RlcHBlciBqdXN0IGdldHMgc2tpcHBlZFxuICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm4gdGhpc1xuXG4gICAgLy8gVXBkYXRlIHRoZSB0aW1lIGFuZCBnZXQgdGhlIG5ldyBwb3NpdGlvblxuICAgIGR0ID0gZHQgPT0gbnVsbCA/IDE2IDogZHRcbiAgICB0aGlzLl90aW1lICs9IGR0XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uKClcblxuICAgIC8vIEZpZ3VyZSBvdXQgaWYgd2UgbmVlZCB0byBydW4gdGhlIHN0ZXBwZXIgaW4gdGhpcyBmcmFtZVxuICAgIGNvbnN0IHJ1bm5pbmcgPSB0aGlzLl9sYXN0UG9zaXRpb24gIT09IHBvc2l0aW9uICYmIHRoaXMuX3RpbWUgPj0gMFxuICAgIHRoaXMuX2xhc3RQb3NpdGlvbiA9IHBvc2l0aW9uXG5cbiAgICAvLyBGaWd1cmUgb3V0IGlmIHdlIGp1c3Qgc3RhcnRlZFxuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbigpXG4gICAgY29uc3QganVzdFN0YXJ0ZWQgPSB0aGlzLl9sYXN0VGltZSA8PSAwICYmIHRoaXMuX3RpbWUgPiAwXG4gICAgY29uc3QganVzdEZpbmlzaGVkID0gdGhpcy5fbGFzdFRpbWUgPCBkdXJhdGlvbiAmJiB0aGlzLl90aW1lID49IGR1cmF0aW9uXG5cbiAgICB0aGlzLl9sYXN0VGltZSA9IHRoaXMuX3RpbWVcbiAgICBpZiAoanVzdFN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuZmlyZSgnc3RhcnQnLCB0aGlzKVxuICAgIH1cblxuICAgIC8vIFdvcmsgb3V0IGlmIHRoZSBydW5uZXIgaXMgZmluaXNoZWQgc2V0IHRoZSBkb25lIGZsYWcgaGVyZSBzbyBhbmltYXRpb25zXG4gICAgLy8ga25vdywgdGhhdCB0aGV5IGFyZSBydW5uaW5nIGluIHRoZSBsYXN0IHN0ZXAgKHRoaXMgaXMgZ29vZCBmb3JcbiAgICAvLyB0cmFuc2Zvcm1hdGlvbnMgd2hpY2ggY2FuIGJlIG1lcmdlZClcbiAgICBjb25zdCBkZWNsYXJhdGl2ZSA9IHRoaXMuX2lzRGVjbGFyYXRpdmVcbiAgICB0aGlzLmRvbmUgPSAhZGVjbGFyYXRpdmUgJiYgIWp1c3RGaW5pc2hlZCAmJiB0aGlzLl90aW1lID49IGR1cmF0aW9uXG5cbiAgICAvLyBSdW5uZXIgaXMgcnVubmluZy4gU28gaXRzIG5vdCBpbiByZXNldCBzdGF0ZSBhbnltb3JlXG4gICAgdGhpcy5fcmVzZXRlZCA9IGZhbHNlXG5cbiAgICBsZXQgY29udmVyZ2VkID0gZmFsc2VcbiAgICAvLyBDYWxsIGluaXRpYWxpc2UgYW5kIHRoZSBydW4gZnVuY3Rpb25cbiAgICBpZiAocnVubmluZyB8fCBkZWNsYXJhdGl2ZSkge1xuICAgICAgdGhpcy5faW5pdGlhbGlzZShydW5uaW5nKVxuXG4gICAgICAvLyBjbGVhciB0aGUgdHJhbnNmb3JtcyBvbiB0aGlzIHJ1bm5lciBzbyB0aGV5IGRvbnQgZ2V0IGFkZGVkIGFnYWluIGFuZCBhZ2FpblxuICAgICAgdGhpcy50cmFuc2Zvcm1zID0gbmV3IE1hdHJpeCgpXG4gICAgICBjb252ZXJnZWQgPSB0aGlzLl9ydW4oZGVjbGFyYXRpdmUgPyBkdCA6IHBvc2l0aW9uKVxuXG4gICAgICB0aGlzLmZpcmUoJ3N0ZXAnLCB0aGlzKVxuICAgIH1cbiAgICAvLyBjb3JyZWN0IHRoZSBkb25lIGZsYWcgaGVyZVxuICAgIC8vIGRlY2xhcmF0aXZlIGFuaW1hdGlvbnMgaXRzZWxmIGtub3cgd2hlbiB0aGV5IGNvbnZlcmdlZFxuICAgIHRoaXMuZG9uZSA9IHRoaXMuZG9uZSB8fCAoY29udmVyZ2VkICYmIGRlY2xhcmF0aXZlKVxuICAgIGlmIChqdXN0RmluaXNoZWQpIHtcbiAgICAgIHRoaXMuZmlyZSgnZmluaXNoZWQnLCB0aGlzKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLypcbiAgUnVubmVyIGFuaW1hdGlvbiBtZXRob2RzXG4gID09PT09PT09PT09PT09PT09PT09PT09PVxuICBDb250cm9sIGhvdyB0aGUgYW5pbWF0aW9uIHBsYXlzXG4gICovXG4gIHRpbWUodGltZSkge1xuICAgIGlmICh0aW1lID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl90aW1lXG4gICAgfVxuICAgIGNvbnN0IGR0ID0gdGltZSAtIHRoaXMuX3RpbWVcbiAgICB0aGlzLnN0ZXAoZHQpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRpbWVsaW5lKHRpbWVsaW5lKSB7XG4gICAgLy8gY2hlY2sgZXhwbGljaXRseSBmb3IgdW5kZWZpbmVkIHNvIHdlIGNhbiBzZXQgdGhlIHRpbWVsaW5lIHRvIG51bGxcbiAgICBpZiAodHlwZW9mIHRpbWVsaW5lID09PSAndW5kZWZpbmVkJykgcmV0dXJuIHRoaXMuX3RpbWVsaW5lXG4gICAgdGhpcy5fdGltZWxpbmUgPSB0aW1lbGluZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB1bnNjaGVkdWxlKCkge1xuICAgIGNvbnN0IHRpbWVsaW5lID0gdGhpcy50aW1lbGluZSgpXG4gICAgdGltZWxpbmUgJiYgdGltZWxpbmUudW5zY2hlZHVsZSh0aGlzKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBSdW4gZWFjaCBpbml0aWFsaXNlIGZ1bmN0aW9uIGluIHRoZSBydW5uZXIgaWYgcmVxdWlyZWRcbiAgX2luaXRpYWxpc2UocnVubmluZykge1xuICAgIC8vIElmIHdlIGFyZW4ndCBydW5uaW5nLCB3ZSBzaG91bGRuJ3QgaW5pdGlhbGlzZSB3aGVuIG5vdCBkZWNsYXJhdGl2ZVxuICAgIGlmICghcnVubmluZyAmJiAhdGhpcy5faXNEZWNsYXJhdGl2ZSkgcmV0dXJuXG5cbiAgICAvLyBMb29wIHRocm91Z2ggYWxsIG9mIHRoZSBpbml0aWFsaXNlcnNcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5fcXVldWUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIC8vIEdldCB0aGUgY3VycmVudCBpbml0aWFsaXNlclxuICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuX3F1ZXVlW2ldXG5cbiAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIHdlIG5lZWQgdG8gaW5pdGlhbGlzZVxuICAgICAgY29uc3QgbmVlZHNJdCA9IHRoaXMuX2lzRGVjbGFyYXRpdmUgfHwgKCFjdXJyZW50LmluaXRpYWxpc2VkICYmIHJ1bm5pbmcpXG4gICAgICBydW5uaW5nID0gIWN1cnJlbnQuZmluaXNoZWRcblxuICAgICAgLy8gQ2FsbCB0aGUgaW5pdGlhbGlzZXIgaWYgd2UgbmVlZCB0b1xuICAgICAgaWYgKG5lZWRzSXQgJiYgcnVubmluZykge1xuICAgICAgICBjdXJyZW50LmluaXRpYWxpc2VyLmNhbGwodGhpcylcbiAgICAgICAgY3VycmVudC5pbml0aWFsaXNlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTYXZlIGEgbW9ycGhlciB0byB0aGUgbW9ycGhlciBsaXN0IHNvIHRoYXQgd2UgY2FuIHJldGFyZ2V0IGl0IGxhdGVyXG4gIF9yZW1lbWJlck1vcnBoZXIobWV0aG9kLCBtb3JwaGVyKSB7XG4gICAgdGhpcy5faGlzdG9yeVttZXRob2RdID0ge1xuICAgICAgbW9ycGhlcjogbW9ycGhlcixcbiAgICAgIGNhbGxlcjogdGhpcy5fcXVldWVbdGhpcy5fcXVldWUubGVuZ3RoIC0gMV1cbiAgICB9XG5cbiAgICAvLyBXZSBoYXZlIHRvIHJlc3VtZSB0aGUgdGltZWxpbmUgaW4gY2FzZSBhIGNvbnRyb2xsZXJcbiAgICAvLyBpcyBhbHJlYWR5IGRvbmUgd2l0aG91dCBiZWluZyBldmVyIHJ1blxuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGUuZy4gdGhpcyBpcyBkb25lOlxuICAgIC8vICAgIGFuaW0gPSBlbC5hbmltYXRlKG5ldyBTVkcuU3ByaW5nKVxuICAgIC8vIGFuZCBsYXRlclxuICAgIC8vICAgIGFuaW0ubW92ZSguLi4pXG4gICAgaWYgKHRoaXMuX2lzRGVjbGFyYXRpdmUpIHtcbiAgICAgIGNvbnN0IHRpbWVsaW5lID0gdGhpcy50aW1lbGluZSgpXG4gICAgICB0aW1lbGluZSAmJiB0aW1lbGluZS5wbGF5KClcbiAgICB9XG4gIH1cblxuICAvLyBUcnkgdG8gc2V0IHRoZSB0YXJnZXQgZm9yIGEgbW9ycGhlciBpZiB0aGUgbW9ycGhlciBleGlzdHMsIG90aGVyd2lzZVxuICAvLyBSdW4gZWFjaCBydW4gZnVuY3Rpb24gZm9yIHRoZSBwb3NpdGlvbiBvciBkdCBnaXZlblxuICBfcnVuKHBvc2l0aW9uT3JEdCkge1xuICAgIC8vIFJ1biBhbGwgb2YgdGhlIF9xdWV1ZSBkaXJlY3RseVxuICAgIGxldCBhbGxmaW5pc2hlZCA9IHRydWVcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5fcXVldWUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIC8vIEdldCB0aGUgY3VycmVudCBmdW5jdGlvbiB0byBydW5cbiAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLl9xdWV1ZVtpXVxuXG4gICAgICAvLyBSdW4gdGhlIGZ1bmN0aW9uIGlmIGl0cyBub3QgZmluaXNoZWQsIHdlIGtlZXAgdHJhY2sgb2YgdGhlIGZpbmlzaGVkXG4gICAgICAvLyBmbGFnIGZvciB0aGUgc2FrZSBvZiBkZWNsYXJhdGl2ZSBfcXVldWVcbiAgICAgIGNvbnN0IGNvbnZlcmdlZCA9IGN1cnJlbnQucnVubmVyLmNhbGwodGhpcywgcG9zaXRpb25PckR0KVxuICAgICAgY3VycmVudC5maW5pc2hlZCA9IGN1cnJlbnQuZmluaXNoZWQgfHwgY29udmVyZ2VkID09PSB0cnVlXG4gICAgICBhbGxmaW5pc2hlZCA9IGFsbGZpbmlzaGVkICYmIGN1cnJlbnQuZmluaXNoZWRcbiAgICB9XG5cbiAgICAvLyBXZSByZXBvcnQgd2hlbiBhbGwgb2YgdGhlIGNvbnN0cnVjdG9ycyBhcmUgZmluaXNoZWRcbiAgICByZXR1cm4gYWxsZmluaXNoZWRcbiAgfVxuXG4gIC8vIGRvIG5vdGhpbmcgYW5kIHJldHVybiBmYWxzZVxuICBfdHJ5UmV0YXJnZXQobWV0aG9kLCB0YXJnZXQsIGV4dHJhKSB7XG4gICAgaWYgKHRoaXMuX2hpc3RvcnlbbWV0aG9kXSkge1xuICAgICAgLy8gaWYgdGhlIGxhc3QgbWV0aG9kIHdhc24ndCBldmVuIGluaXRpYWxpc2VkLCB0aHJvdyBpdCBhd2F5XG4gICAgICBpZiAoIXRoaXMuX2hpc3RvcnlbbWV0aG9kXS5jYWxsZXIuaW5pdGlhbGlzZWQpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9xdWV1ZS5pbmRleE9mKHRoaXMuX2hpc3RvcnlbbWV0aG9kXS5jYWxsZXIpXG4gICAgICAgIHRoaXMuX3F1ZXVlLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIC8vIGZvciB0aGUgY2FzZSBvZiB0cmFuc2Zvcm1hdGlvbnMsIHdlIHVzZSB0aGUgc3BlY2lhbCByZXRhcmdldCBmdW5jdGlvblxuICAgICAgLy8gd2hpY2ggaGFzIGFjY2VzcyB0byB0aGUgb3V0ZXIgc2NvcGVcbiAgICAgIGlmICh0aGlzLl9oaXN0b3J5W21ldGhvZF0uY2FsbGVyLnJldGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX2hpc3RvcnlbbWV0aG9kXS5jYWxsZXIucmV0YXJnZXQuY2FsbCh0aGlzLCB0YXJnZXQsIGV4dHJhKVxuICAgICAgICAvLyBmb3IgZXZlcnl0aGluZyBlbHNlIGEgc2ltcGxlIG1vcnBoZXIgY2hhbmdlIGlzIHN1ZmZpY2llbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2hpc3RvcnlbbWV0aG9kXS5tb3JwaGVyLnRvKHRhcmdldClcbiAgICAgIH1cblxuICAgICAgdGhpcy5faGlzdG9yeVttZXRob2RdLmNhbGxlci5maW5pc2hlZCA9IGZhbHNlXG4gICAgICBjb25zdCB0aW1lbGluZSA9IHRoaXMudGltZWxpbmUoKVxuICAgICAgdGltZWxpbmUgJiYgdGltZWxpbmUucGxheSgpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5SdW5uZXIuaWQgPSAwXG5cbmV4cG9ydCBjbGFzcyBGYWtlUnVubmVyIHtcbiAgY29uc3RydWN0b3IodHJhbnNmb3JtcyA9IG5ldyBNYXRyaXgoKSwgaWQgPSAtMSwgZG9uZSA9IHRydWUpIHtcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSB0cmFuc2Zvcm1zXG4gICAgdGhpcy5pZCA9IGlkXG4gICAgdGhpcy5kb25lID0gZG9uZVxuICB9XG5cbiAgY2xlYXJUcmFuc2Zvcm1zRnJvbVF1ZXVlKCkge31cbn1cblxuZXh0ZW5kKFtSdW5uZXIsIEZha2VSdW5uZXJdLCB7XG4gIG1lcmdlV2l0aChydW5uZXIpIHtcbiAgICByZXR1cm4gbmV3IEZha2VSdW5uZXIoXG4gICAgICBydW5uZXIudHJhbnNmb3Jtcy5sbXVsdGlwbHkodGhpcy50cmFuc2Zvcm1zKSxcbiAgICAgIHJ1bm5lci5pZFxuICAgIClcbiAgfVxufSlcblxuLy8gRmFrZVJ1bm5lci5lbXB0eVJ1bm5lciA9IG5ldyBGYWtlUnVubmVyKClcblxuY29uc3QgbG11bHRpcGx5ID0gKGxhc3QsIGN1cnIpID0+IGxhc3QubG11bHRpcGx5TyhjdXJyKVxuY29uc3QgZ2V0UnVubmVyVHJhbnNmb3JtID0gKHJ1bm5lcikgPT4gcnVubmVyLnRyYW5zZm9ybXNcblxuZnVuY3Rpb24gbWVyZ2VUcmFuc2Zvcm1zKCkge1xuICAvLyBGaW5kIHRoZSBtYXRyaXggdG8gYXBwbHkgdG8gdGhlIGVsZW1lbnQgYW5kIGFwcGx5IGl0XG4gIGNvbnN0IHJ1bm5lcnMgPSB0aGlzLl90cmFuc2Zvcm1hdGlvblJ1bm5lcnMucnVubmVyc1xuICBjb25zdCBuZXRUcmFuc2Zvcm0gPSBydW5uZXJzXG4gICAgLm1hcChnZXRSdW5uZXJUcmFuc2Zvcm0pXG4gICAgLnJlZHVjZShsbXVsdGlwbHksIG5ldyBNYXRyaXgoKSlcblxuICB0aGlzLnRyYW5zZm9ybShuZXRUcmFuc2Zvcm0pXG5cbiAgdGhpcy5fdHJhbnNmb3JtYXRpb25SdW5uZXJzLm1lcmdlKClcblxuICBpZiAodGhpcy5fdHJhbnNmb3JtYXRpb25SdW5uZXJzLmxlbmd0aCgpID09PSAxKSB7XG4gICAgdGhpcy5fZnJhbWVJZCA9IG51bGxcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUnVubmVyQXJyYXkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJ1bm5lcnMgPSBbXVxuICAgIHRoaXMuaWRzID0gW11cbiAgfVxuXG4gIGFkZChydW5uZXIpIHtcbiAgICBpZiAodGhpcy5ydW5uZXJzLmluY2x1ZGVzKHJ1bm5lcikpIHJldHVyblxuICAgIGNvbnN0IGlkID0gcnVubmVyLmlkICsgMVxuXG4gICAgdGhpcy5ydW5uZXJzLnB1c2gocnVubmVyKVxuICAgIHRoaXMuaWRzLnB1c2goaWQpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgY2xlYXJCZWZvcmUoaWQpIHtcbiAgICBjb25zdCBkZWxldGVDbnQgPSB0aGlzLmlkcy5pbmRleE9mKGlkICsgMSkgfHwgMVxuICAgIHRoaXMuaWRzLnNwbGljZSgwLCBkZWxldGVDbnQsIDApXG4gICAgdGhpcy5ydW5uZXJzXG4gICAgICAuc3BsaWNlKDAsIGRlbGV0ZUNudCwgbmV3IEZha2VSdW5uZXIoKSlcbiAgICAgIC5mb3JFYWNoKChyKSA9PiByLmNsZWFyVHJhbnNmb3Jtc0Zyb21RdWV1ZSgpKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBlZGl0KGlkLCBuZXdSdW5uZXIpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuaWRzLmluZGV4T2YoaWQgKyAxKVxuICAgIHRoaXMuaWRzLnNwbGljZShpbmRleCwgMSwgaWQgKyAxKVxuICAgIHRoaXMucnVubmVycy5zcGxpY2UoaW5kZXgsIDEsIG5ld1J1bm5lcilcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0QnlJRChpZCkge1xuICAgIHJldHVybiB0aGlzLnJ1bm5lcnNbdGhpcy5pZHMuaW5kZXhPZihpZCArIDEpXVxuICB9XG5cbiAgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmlkcy5sZW5ndGhcbiAgfVxuXG4gIG1lcmdlKCkge1xuICAgIGxldCBsYXN0UnVubmVyID0gbnVsbFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ydW5uZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBydW5uZXIgPSB0aGlzLnJ1bm5lcnNbaV1cblxuICAgICAgY29uc3QgY29uZGl0aW9uID1cbiAgICAgICAgbGFzdFJ1bm5lciAmJlxuICAgICAgICBydW5uZXIuZG9uZSAmJlxuICAgICAgICBsYXN0UnVubmVyLmRvbmUgJiZcbiAgICAgICAgLy8gZG9uJ3QgbWVyZ2UgcnVubmVyIHdoZW4gcGVyc2lzdGVkIG9uIHRpbWVsaW5lXG4gICAgICAgICghcnVubmVyLl90aW1lbGluZSB8fFxuICAgICAgICAgICFydW5uZXIuX3RpbWVsaW5lLl9ydW5uZXJJZHMuaW5jbHVkZXMocnVubmVyLmlkKSkgJiZcbiAgICAgICAgKCFsYXN0UnVubmVyLl90aW1lbGluZSB8fFxuICAgICAgICAgICFsYXN0UnVubmVyLl90aW1lbGluZS5fcnVubmVySWRzLmluY2x1ZGVzKGxhc3RSdW5uZXIuaWQpKVxuXG4gICAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgIC8vIHRoZSArMSBoYXBwZW5zIGluIHRoZSBmdW5jdGlvblxuICAgICAgICB0aGlzLnJlbW92ZShydW5uZXIuaWQpXG4gICAgICAgIGNvbnN0IG5ld1J1bm5lciA9IHJ1bm5lci5tZXJnZVdpdGgobGFzdFJ1bm5lcilcbiAgICAgICAgdGhpcy5lZGl0KGxhc3RSdW5uZXIuaWQsIG5ld1J1bm5lcilcbiAgICAgICAgbGFzdFJ1bm5lciA9IG5ld1J1bm5lclxuICAgICAgICAtLWlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RSdW5uZXIgPSBydW5uZXJcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmVtb3ZlKGlkKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmlkcy5pbmRleE9mKGlkICsgMSlcbiAgICB0aGlzLmlkcy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgdGhpcy5ydW5uZXJzLnNwbGljZShpbmRleCwgMSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIEVsZW1lbnQ6IHtcbiAgICBhbmltYXRlKGR1cmF0aW9uLCBkZWxheSwgd2hlbikge1xuICAgICAgY29uc3QgbyA9IFJ1bm5lci5zYW5pdGlzZShkdXJhdGlvbiwgZGVsYXksIHdoZW4pXG4gICAgICBjb25zdCB0aW1lbGluZSA9IHRoaXMudGltZWxpbmUoKVxuICAgICAgcmV0dXJuIG5ldyBSdW5uZXIoby5kdXJhdGlvbilcbiAgICAgICAgLmxvb3AobylcbiAgICAgICAgLmVsZW1lbnQodGhpcylcbiAgICAgICAgLnRpbWVsaW5lKHRpbWVsaW5lLnBsYXkoKSlcbiAgICAgICAgLnNjaGVkdWxlKG8uZGVsYXksIG8ud2hlbilcbiAgICB9LFxuXG4gICAgZGVsYXkoYnksIHdoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoMCwgYnksIHdoZW4pXG4gICAgfSxcblxuICAgIC8vIHRoaXMgZnVuY3Rpb24gc2VhcmNoZXMgZm9yIGFsbCBydW5uZXJzIG9uIHRoZSBlbGVtZW50IGFuZCBkZWxldGVzIHRoZSBvbmVzXG4gICAgLy8gd2hpY2ggcnVuIGJlZm9yZSB0aGUgY3VycmVudCBvbmUuIFRoaXMgaXMgYmVjYXVzZSBhYnNvbHV0ZSB0cmFuc2Zvcm1hdGlvbnNcbiAgICAvLyBvdmVyd3JpdGUgYW55dGhpbmcgYW55d2F5IHNvIHRoZXJlIGlzIG5vIG5lZWQgdG8gd2FzdGUgdGltZSBjb21wdXRpbmdcbiAgICAvLyBvdGhlciBydW5uZXJzXG4gICAgX2NsZWFyVHJhbnNmb3JtUnVubmVyc0JlZm9yZShjdXJyZW50UnVubmVyKSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1hdGlvblJ1bm5lcnMuY2xlYXJCZWZvcmUoY3VycmVudFJ1bm5lci5pZClcbiAgICB9LFxuXG4gICAgX2N1cnJlbnRUcmFuc2Zvcm0oY3VycmVudCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtYXRpb25SdW5uZXJzLnJ1bm5lcnNcbiAgICAgICAgICAvLyB3ZSBuZWVkIHRoZSBlcXVhbCBzaWduIGhlcmUgdG8gbWFrZSBzdXJlLCB0aGF0IGFsc28gdHJhbnNmb3JtYXRpb25zXG4gICAgICAgICAgLy8gb24gdGhlIHNhbWUgcnVubmVyIHdoaWNoIGV4ZWN1dGUgYmVmb3JlIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIGFyZVxuICAgICAgICAgIC8vIHRha2VuIGludG8gYWNjb3VudFxuICAgICAgICAgIC5maWx0ZXIoKHJ1bm5lcikgPT4gcnVubmVyLmlkIDw9IGN1cnJlbnQuaWQpXG4gICAgICAgICAgLm1hcChnZXRSdW5uZXJUcmFuc2Zvcm0pXG4gICAgICAgICAgLnJlZHVjZShsbXVsdGlwbHksIG5ldyBNYXRyaXgoKSlcbiAgICAgIClcbiAgICB9LFxuXG4gICAgX2FkZFJ1bm5lcihydW5uZXIpIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybWF0aW9uUnVubmVycy5hZGQocnVubmVyKVxuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcnVubmVyIG1lcmdlIGlzIGV4ZWN1dGVkIGF0IHRoZSB2ZXJ5IGVuZCBvZlxuICAgICAgLy8gYWxsIEFuaW1hdG9yIGZ1bmN0aW9ucy4gVGhhdCBpcyB3aHkgd2UgdXNlIGltbWVkaWF0ZSBoZXJlIHRvIGV4ZWN1dGVcbiAgICAgIC8vIHRoZSBtZXJnZSByaWdodCBhZnRlciBhbGwgZnJhbWVzIGFyZSBydW5cbiAgICAgIEFuaW1hdG9yLmNhbmNlbEltbWVkaWF0ZSh0aGlzLl9mcmFtZUlkKVxuICAgICAgdGhpcy5fZnJhbWVJZCA9IEFuaW1hdG9yLmltbWVkaWF0ZShtZXJnZVRyYW5zZm9ybXMuYmluZCh0aGlzKSlcbiAgICB9LFxuXG4gICAgX3ByZXBhcmVSdW5uZXIoKSB7XG4gICAgICBpZiAodGhpcy5fZnJhbWVJZCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWF0aW9uUnVubmVycyA9IG5ldyBSdW5uZXJBcnJheSgpLmFkZChcbiAgICAgICAgICBuZXcgRmFrZVJ1bm5lcihuZXcgTWF0cml4KHRoaXMpKVxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG59KVxuXG4vLyBXaWxsIG91dHB1dCB0aGUgZWxlbWVudHMgZnJvbSBhcnJheSBBIHRoYXQgYXJlIG5vdCBpbiB0aGUgYXJyYXkgQlxuY29uc3QgZGlmZmVyZW5jZSA9IChhLCBiKSA9PiBhLmZpbHRlcigoeCkgPT4gIWIuaW5jbHVkZXMoeCkpXG5cbmV4dGVuZChSdW5uZXIsIHtcbiAgYXR0cihhLCB2KSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVBdHRyKCdhdHRyJywgYSwgdilcbiAgfSxcblxuICAvLyBBZGQgYW5pbWF0YWJsZSBzdHlsZXNcbiAgY3NzKHMsIHYpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZUF0dHIoJ2NzcycsIHMsIHYpXG4gIH0sXG5cbiAgc3R5bGVBdHRyKHR5cGUsIG5hbWVPckF0dHJzLCB2YWwpIHtcbiAgICBpZiAodHlwZW9mIG5hbWVPckF0dHJzID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMuc3R5bGVBdHRyKHR5cGUsIHsgW25hbWVPckF0dHJzXTogdmFsIH0pXG4gICAgfVxuXG4gICAgbGV0IGF0dHJzID0gbmFtZU9yQXR0cnNcbiAgICBpZiAodGhpcy5fdHJ5UmV0YXJnZXQodHlwZSwgYXR0cnMpKSByZXR1cm4gdGhpc1xuXG4gICAgbGV0IG1vcnBoZXIgPSBuZXcgTW9ycGhhYmxlKHRoaXMuX3N0ZXBwZXIpLnRvKGF0dHJzKVxuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMoYXR0cnMpXG5cbiAgICB0aGlzLnF1ZXVlKFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBtb3JwaGVyID0gbW9ycGhlci5mcm9tKHRoaXMuZWxlbWVudCgpW3R5cGVdKGtleXMpKVxuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50KClbdHlwZV0obW9ycGhlci5hdChwb3MpLnZhbHVlT2YoKSlcbiAgICAgICAgcmV0dXJuIG1vcnBoZXIuZG9uZSgpXG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKG5ld1RvQXR0cnMpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55IG5ldyBrZXlzIHdlcmUgYWRkZWRcbiAgICAgICAgY29uc3QgbmV3S2V5cyA9IE9iamVjdC5rZXlzKG5ld1RvQXR0cnMpXG4gICAgICAgIGNvbnN0IGRpZmZlcmVuY2VzID0gZGlmZmVyZW5jZShuZXdLZXlzLCBrZXlzKVxuXG4gICAgICAgIC8vIElmIHRoZWlyIGFyZSBuZXcga2V5cywgaW5pdGlhbGl6ZSB0aGVtIGFuZCBhZGQgdGhlbSB0byBtb3JwaGVyXG4gICAgICAgIGlmIChkaWZmZXJlbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBHZXQgdGhlIHZhbHVlc1xuICAgICAgICAgIGNvbnN0IGFkZGVkRnJvbUF0dHJzID0gdGhpcy5lbGVtZW50KClbdHlwZV0oZGlmZmVyZW5jZXMpXG5cbiAgICAgICAgICAvLyBHZXQgdGhlIGFscmVhZHkgaW5pdGlhbGl6ZWQgdmFsdWVzXG4gICAgICAgICAgY29uc3Qgb2xkRnJvbUF0dHJzID0gbmV3IE9iamVjdEJhZyhtb3JwaGVyLmZyb20oKSkudmFsdWVPZigpXG5cbiAgICAgICAgICAvLyBNZXJnZSBvbGQgYW5kIG5ld1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24ob2xkRnJvbUF0dHJzLCBhZGRlZEZyb21BdHRycylcbiAgICAgICAgICBtb3JwaGVyLmZyb20ob2xkRnJvbUF0dHJzKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IHRoZSBvYmplY3QgZnJvbSB0aGUgbW9ycGhlclxuICAgICAgICBjb25zdCBvbGRUb0F0dHJzID0gbmV3IE9iamVjdEJhZyhtb3JwaGVyLnRvKCkpLnZhbHVlT2YoKVxuXG4gICAgICAgIC8vIE1lcmdlIGluIG5ldyBhdHRyaWJ1dGVzXG4gICAgICAgIE9iamVjdC5hc3NpZ24ob2xkVG9BdHRycywgbmV3VG9BdHRycylcblxuICAgICAgICAvLyBDaGFuZ2UgbW9ycGhlciB0YXJnZXRcbiAgICAgICAgbW9ycGhlci50byhvbGRUb0F0dHJzKVxuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIHNhdmUgdGhlIHdvcmsgd2UgZGlkIHNvIHdlIGRvbid0IG5lZWQgaXQgdG8gZG8gYWdhaW5cbiAgICAgICAga2V5cyA9IG5ld0tleXNcbiAgICAgICAgYXR0cnMgPSBuZXdUb0F0dHJzXG4gICAgICB9XG4gICAgKVxuXG4gICAgdGhpcy5fcmVtZW1iZXJNb3JwaGVyKHR5cGUsIG1vcnBoZXIpXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcblxuICB6b29tKGxldmVsLCBwb2ludCkge1xuICAgIGlmICh0aGlzLl90cnlSZXRhcmdldCgnem9vbScsIGxldmVsLCBwb2ludCkpIHJldHVybiB0aGlzXG5cbiAgICBsZXQgbW9ycGhlciA9IG5ldyBNb3JwaGFibGUodGhpcy5fc3RlcHBlcikudG8obmV3IFNWR051bWJlcihsZXZlbCkpXG5cbiAgICB0aGlzLnF1ZXVlKFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBtb3JwaGVyID0gbW9ycGhlci5mcm9tKHRoaXMuZWxlbWVudCgpLnpvb20oKSlcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCgpLnpvb20obW9ycGhlci5hdChwb3MpLCBwb2ludClcbiAgICAgICAgcmV0dXJuIG1vcnBoZXIuZG9uZSgpXG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKG5ld0xldmVsLCBuZXdQb2ludCkge1xuICAgICAgICBwb2ludCA9IG5ld1BvaW50XG4gICAgICAgIG1vcnBoZXIudG8obmV3TGV2ZWwpXG4gICAgICB9XG4gICAgKVxuXG4gICAgdGhpcy5fcmVtZW1iZXJNb3JwaGVyKCd6b29tJywgbW9ycGhlcilcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuXG4gIC8qKlxuICAgKiogYWJzb2x1dGUgdHJhbnNmb3JtYXRpb25zXG4gICAqKi9cblxuICAvL1xuICAvLyBNIHYgLS0tLS18LS0tLS0oRCBNIHYgPSBGIHYpLS0tLS0tfC0tLS0tPiAgVCB2XG4gIC8vXG4gIC8vIDEuIGRlZmluZSB0aGUgZmluYWwgc3RhdGUgKFQpIGFuZCBkZWNvbXBvc2UgaXQgKG9uY2UpXG4gIC8vICAgIHQgPSBbdHgsIHR5LCB0aGUsIGxhbSwgc3ksIHN4XVxuICAvLyAyLiBvbiBldmVyeSBmcmFtZTogcHVsbCB0aGUgY3VycmVudCBzdGF0ZSBvZiBhbGwgcHJldmlvdXMgdHJhbnNmb3Jtc1xuICAvLyAgICAoTSAtIG0gY2FuIGNoYW5nZSlcbiAgLy8gICBhbmQgdGhlbiB3cml0ZSB0aGlzIGFzIG0gPSBbdHgwLCB0eTAsIHRoZTAsIGxhbTAsIHN5MCwgc3gwXVxuICAvLyAzLiBGaW5kIHRoZSBpbnRlcnBvbGF0ZWQgbWF0cml4IEYocG9zKSA9IG0gKyBwb3MgKiAodCAtIG0pXG4gIC8vICAgLSBOb3RlIEYoMCkgPSBNXG4gIC8vICAgLSBOb3RlIEYoMSkgPSBUXG4gIC8vIDQuIE5vdyB5b3UgZ2V0IHRoZSBkZWx0YSBtYXRyaXggYXMgYSByZXN1bHQ6IEQgPSBGICogaW52KE0pXG5cbiAgdHJhbnNmb3JtKHRyYW5zZm9ybXMsIHJlbGF0aXZlLCBhZmZpbmUpIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGEgZGVjbGFyYXRpdmUgZnVuY3Rpb24sIHdlIHNob3VsZCByZXRhcmdldCBpdCBpZiBwb3NzaWJsZVxuICAgIHJlbGF0aXZlID0gdHJhbnNmb3Jtcy5yZWxhdGl2ZSB8fCByZWxhdGl2ZVxuICAgIGlmIChcbiAgICAgIHRoaXMuX2lzRGVjbGFyYXRpdmUgJiZcbiAgICAgICFyZWxhdGl2ZSAmJlxuICAgICAgdGhpcy5fdHJ5UmV0YXJnZXQoJ3RyYW5zZm9ybScsIHRyYW5zZm9ybXMpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8vIFBhcnNlIHRoZSBwYXJhbWV0ZXJzXG4gICAgY29uc3QgaXNNYXRyaXggPSBNYXRyaXguaXNNYXRyaXhMaWtlKHRyYW5zZm9ybXMpXG4gICAgYWZmaW5lID1cbiAgICAgIHRyYW5zZm9ybXMuYWZmaW5lICE9IG51bGxcbiAgICAgICAgPyB0cmFuc2Zvcm1zLmFmZmluZVxuICAgICAgICA6IGFmZmluZSAhPSBudWxsXG4gICAgICAgICAgPyBhZmZpbmVcbiAgICAgICAgICA6ICFpc01hdHJpeFxuXG4gICAgLy8gQ3JlYXRlIGEgbW9ycGhlciBhbmQgc2V0IGl0cyB0eXBlXG4gICAgY29uc3QgbW9ycGhlciA9IG5ldyBNb3JwaGFibGUodGhpcy5fc3RlcHBlcikudHlwZShcbiAgICAgIGFmZmluZSA/IFRyYW5zZm9ybUJhZyA6IE1hdHJpeFxuICAgIClcblxuICAgIGxldCBvcmlnaW5cbiAgICBsZXQgZWxlbWVudFxuICAgIGxldCBjdXJyZW50XG4gICAgbGV0IGN1cnJlbnRBbmdsZVxuICAgIGxldCBzdGFydFRyYW5zZm9ybVxuXG4gICAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgZWxlbWVudCBhbmQgb3JpZ2luIGlzIGRlZmluZWRcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50IHx8IHRoaXMuZWxlbWVudCgpXG4gICAgICBvcmlnaW4gPSBvcmlnaW4gfHwgZ2V0T3JpZ2luKHRyYW5zZm9ybXMsIGVsZW1lbnQpXG5cbiAgICAgIHN0YXJ0VHJhbnNmb3JtID0gbmV3IE1hdHJpeChyZWxhdGl2ZSA/IHVuZGVmaW5lZCA6IGVsZW1lbnQpXG5cbiAgICAgIC8vIGFkZCB0aGUgcnVubmVyIHRvIHRoZSBlbGVtZW50IHNvIGl0IGNhbiBtZXJnZSB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgIGVsZW1lbnQuX2FkZFJ1bm5lcih0aGlzKVxuXG4gICAgICAvLyBEZWFjdGl2YXRlIGFsbCB0cmFuc2Zvcm1zIHRoYXQgaGF2ZSBydW4gc28gZmFyIGlmIHdlIGFyZSBhYnNvbHV0ZVxuICAgICAgaWYgKCFyZWxhdGl2ZSkge1xuICAgICAgICBlbGVtZW50Ll9jbGVhclRyYW5zZm9ybVJ1bm5lcnNCZWZvcmUodGhpcylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4ocG9zKSB7XG4gICAgICAvLyBjbGVhciBhbGwgb3RoZXIgdHJhbnNmb3JtcyBiZWZvcmUgdGhpcyBpbiBjYXNlIHNvbWV0aGluZyBpcyBzYXZlZFxuICAgICAgLy8gb24gdGhpcyBydW5uZXIuIFdlIGFyZSBhYnNvbHV0ZS4gV2UgZG9udCBuZWVkIHRoZXNlIVxuICAgICAgaWYgKCFyZWxhdGl2ZSkgdGhpcy5jbGVhclRyYW5zZm9ybSgpXG5cbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gbmV3IFBvaW50KG9yaWdpbikudHJhbnNmb3JtKFxuICAgICAgICBlbGVtZW50Ll9jdXJyZW50VHJhbnNmb3JtKHRoaXMpXG4gICAgICApXG5cbiAgICAgIGxldCB0YXJnZXQgPSBuZXcgTWF0cml4KHsgLi4udHJhbnNmb3Jtcywgb3JpZ2luOiBbeCwgeV0gfSlcbiAgICAgIGxldCBzdGFydCA9IHRoaXMuX2lzRGVjbGFyYXRpdmUgJiYgY3VycmVudCA/IGN1cnJlbnQgOiBzdGFydFRyYW5zZm9ybVxuXG4gICAgICBpZiAoYWZmaW5lKSB7XG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5kZWNvbXBvc2UoeCwgeSlcbiAgICAgICAgc3RhcnQgPSBzdGFydC5kZWNvbXBvc2UoeCwgeSlcblxuICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgYW5kIHRhcmdldCBhbmdsZSBhcyBpdCB3YXMgc2V0XG4gICAgICAgIGNvbnN0IHJUYXJnZXQgPSB0YXJnZXQucm90YXRlXG4gICAgICAgIGNvbnN0IHJDdXJyZW50ID0gc3RhcnQucm90YXRlXG5cbiAgICAgICAgLy8gRmlndXJlIG91dCB0aGUgc2hvcnRlc3QgcGF0aCB0byByb3RhdGUgZGlyZWN0bHlcbiAgICAgICAgY29uc3QgcG9zc2liaWxpdGllcyA9IFtyVGFyZ2V0IC0gMzYwLCByVGFyZ2V0LCByVGFyZ2V0ICsgMzYwXVxuICAgICAgICBjb25zdCBkaXN0YW5jZXMgPSBwb3NzaWJpbGl0aWVzLm1hcCgoYSkgPT4gTWF0aC5hYnMoYSAtIHJDdXJyZW50KSlcbiAgICAgICAgY29uc3Qgc2hvcnRlc3QgPSBNYXRoLm1pbiguLi5kaXN0YW5jZXMpXG4gICAgICAgIGNvbnN0IGluZGV4ID0gZGlzdGFuY2VzLmluZGV4T2Yoc2hvcnRlc3QpXG4gICAgICAgIHRhcmdldC5yb3RhdGUgPSBwb3NzaWJpbGl0aWVzW2luZGV4XVxuICAgICAgfVxuXG4gICAgICBpZiAocmVsYXRpdmUpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSB0byBiZSBjYXJlZnVsIGhlcmUgbm90IHRvIG92ZXJ3cml0ZSB0aGUgcm90YXRpb25cbiAgICAgICAgLy8gd2l0aCB0aGUgcm90YXRlIG1ldGhvZCBvZiBNYXRyaXhcbiAgICAgICAgaWYgKCFpc01hdHJpeCkge1xuICAgICAgICAgIHRhcmdldC5yb3RhdGUgPSB0cmFuc2Zvcm1zLnJvdGF0ZSB8fCAwXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lzRGVjbGFyYXRpdmUgJiYgY3VycmVudEFuZ2xlKSB7XG4gICAgICAgICAgc3RhcnQucm90YXRlID0gY3VycmVudEFuZ2xlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbW9ycGhlci5mcm9tKHN0YXJ0KVxuICAgICAgbW9ycGhlci50byh0YXJnZXQpXG5cbiAgICAgIGNvbnN0IGFmZmluZVBhcmFtZXRlcnMgPSBtb3JwaGVyLmF0KHBvcylcbiAgICAgIGN1cnJlbnRBbmdsZSA9IGFmZmluZVBhcmFtZXRlcnMucm90YXRlXG4gICAgICBjdXJyZW50ID0gbmV3IE1hdHJpeChhZmZpbmVQYXJhbWV0ZXJzKVxuXG4gICAgICB0aGlzLmFkZFRyYW5zZm9ybShjdXJyZW50KVxuICAgICAgZWxlbWVudC5fYWRkUnVubmVyKHRoaXMpXG4gICAgICByZXR1cm4gbW9ycGhlci5kb25lKClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXRhcmdldChuZXdUcmFuc2Zvcm1zKSB7XG4gICAgICAvLyBvbmx5IGdldCBhIG5ldyBvcmlnaW4gaWYgaXQgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBjYWxsXG4gICAgICBpZiAoXG4gICAgICAgIChuZXdUcmFuc2Zvcm1zLm9yaWdpbiB8fCAnY2VudGVyJykudG9TdHJpbmcoKSAhPT1cbiAgICAgICAgKHRyYW5zZm9ybXMub3JpZ2luIHx8ICdjZW50ZXInKS50b1N0cmluZygpXG4gICAgICApIHtcbiAgICAgICAgb3JpZ2luID0gZ2V0T3JpZ2luKG5ld1RyYW5zZm9ybXMsIGVsZW1lbnQpXG4gICAgICB9XG5cbiAgICAgIC8vIG92ZXJ3cml0ZSB0aGUgb2xkIHRyYW5zZm9ybWF0aW9ucyB3aXRoIHRoZSBuZXcgb25lc1xuICAgICAgdHJhbnNmb3JtcyA9IHsgLi4ubmV3VHJhbnNmb3Jtcywgb3JpZ2luIH1cbiAgICB9XG5cbiAgICB0aGlzLnF1ZXVlKHNldHVwLCBydW4sIHJldGFyZ2V0LCB0cnVlKVxuICAgIHRoaXMuX2lzRGVjbGFyYXRpdmUgJiYgdGhpcy5fcmVtZW1iZXJNb3JwaGVyKCd0cmFuc2Zvcm0nLCBtb3JwaGVyKVxuICAgIHJldHVybiB0aGlzXG4gIH0sXG5cbiAgLy8gQW5pbWF0YWJsZSB4LWF4aXNcbiAgeCh4KSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlTnVtYmVyKCd4JywgeClcbiAgfSxcblxuICAvLyBBbmltYXRhYmxlIHktYXhpc1xuICB5KHkpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVldWVOdW1iZXIoJ3knLCB5KVxuICB9LFxuXG4gIGF4KHgpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVldWVOdW1iZXIoJ2F4JywgeClcbiAgfSxcblxuICBheSh5KSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlTnVtYmVyKCdheScsIHkpXG4gIH0sXG5cbiAgZHgoeCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5fcXVldWVOdW1iZXJEZWx0YSgneCcsIHgpXG4gIH0sXG5cbiAgZHkoeSA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5fcXVldWVOdW1iZXJEZWx0YSgneScsIHkpXG4gIH0sXG5cbiAgZG1vdmUoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmR4KHgpLmR5KHkpXG4gIH0sXG5cbiAgX3F1ZXVlTnVtYmVyRGVsdGEobWV0aG9kLCB0bykge1xuICAgIHRvID0gbmV3IFNWR051bWJlcih0bylcblxuICAgIC8vIFRyeSB0byBjaGFuZ2UgdGhlIHRhcmdldCBpZiB3ZSBoYXZlIHRoaXMgbWV0aG9kIGFscmVhZHkgcmVnaXN0ZXJlZFxuICAgIGlmICh0aGlzLl90cnlSZXRhcmdldChtZXRob2QsIHRvKSkgcmV0dXJuIHRoaXNcblxuICAgIC8vIE1ha2UgYSBtb3JwaGVyIGFuZCBxdWV1ZSB0aGUgYW5pbWF0aW9uXG4gICAgY29uc3QgbW9ycGhlciA9IG5ldyBNb3JwaGFibGUodGhpcy5fc3RlcHBlcikudG8odG8pXG4gICAgbGV0IGZyb20gPSBudWxsXG4gICAgdGhpcy5xdWV1ZShcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnJvbSA9IHRoaXMuZWxlbWVudCgpW21ldGhvZF0oKVxuICAgICAgICBtb3JwaGVyLmZyb20oZnJvbSlcbiAgICAgICAgbW9ycGhlci50byhmcm9tICsgdG8pXG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB0aGlzLmVsZW1lbnQoKVttZXRob2RdKG1vcnBoZXIuYXQocG9zKSlcbiAgICAgICAgcmV0dXJuIG1vcnBoZXIuZG9uZSgpXG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKG5ld1RvKSB7XG4gICAgICAgIG1vcnBoZXIudG8oZnJvbSArIG5ldyBTVkdOdW1iZXIobmV3VG8pKVxuICAgICAgfVxuICAgIClcblxuICAgIC8vIFJlZ2lzdGVyIHRoZSBtb3JwaGVyIHNvIHRoYXQgaWYgaXQgaXMgY2hhbmdlZCBhZ2Fpbiwgd2UgY2FuIHJldGFyZ2V0IGl0XG4gICAgdGhpcy5fcmVtZW1iZXJNb3JwaGVyKG1ldGhvZCwgbW9ycGhlcilcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuXG4gIF9xdWV1ZU9iamVjdChtZXRob2QsIHRvKSB7XG4gICAgLy8gVHJ5IHRvIGNoYW5nZSB0aGUgdGFyZ2V0IGlmIHdlIGhhdmUgdGhpcyBtZXRob2QgYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgaWYgKHRoaXMuX3RyeVJldGFyZ2V0KG1ldGhvZCwgdG8pKSByZXR1cm4gdGhpc1xuXG4gICAgLy8gTWFrZSBhIG1vcnBoZXIgYW5kIHF1ZXVlIHRoZSBhbmltYXRpb25cbiAgICBjb25zdCBtb3JwaGVyID0gbmV3IE1vcnBoYWJsZSh0aGlzLl9zdGVwcGVyKS50byh0bylcbiAgICB0aGlzLnF1ZXVlKFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBtb3JwaGVyLmZyb20odGhpcy5lbGVtZW50KClbbWV0aG9kXSgpKVxuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50KClbbWV0aG9kXShtb3JwaGVyLmF0KHBvcykpXG4gICAgICAgIHJldHVybiBtb3JwaGVyLmRvbmUoKVxuICAgICAgfVxuICAgIClcblxuICAgIC8vIFJlZ2lzdGVyIHRoZSBtb3JwaGVyIHNvIHRoYXQgaWYgaXQgaXMgY2hhbmdlZCBhZ2Fpbiwgd2UgY2FuIHJldGFyZ2V0IGl0XG4gICAgdGhpcy5fcmVtZW1iZXJNb3JwaGVyKG1ldGhvZCwgbW9ycGhlcilcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuXG4gIF9xdWV1ZU51bWJlcihtZXRob2QsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlT2JqZWN0KG1ldGhvZCwgbmV3IFNWR051bWJlcih2YWx1ZSkpXG4gIH0sXG5cbiAgLy8gQW5pbWF0YWJsZSBjZW50ZXIgeC1heGlzXG4gIGN4KHgpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVldWVOdW1iZXIoJ2N4JywgeClcbiAgfSxcblxuICAvLyBBbmltYXRhYmxlIGNlbnRlciB5LWF4aXNcbiAgY3koeSkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlcignY3knLCB5KVxuICB9LFxuXG4gIC8vIEFkZCBhbmltYXRhYmxlIG1vdmVcbiAgbW92ZSh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMueCh4KS55KHkpXG4gIH0sXG5cbiAgYW1vdmUoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmF4KHgpLmF5KHkpXG4gIH0sXG5cbiAgLy8gQWRkIGFuaW1hdGFibGUgY2VudGVyXG4gIGNlbnRlcih4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuY3goeCkuY3koeSlcbiAgfSxcblxuICAvLyBBZGQgYW5pbWF0YWJsZSBzaXplXG4gIHNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIC8vIGFuaW1hdGUgYmJveCBiYXNlZCBzaXplIGZvciBhbGwgb3RoZXIgZWxlbWVudHNcbiAgICBsZXQgYm94XG5cbiAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgIGJveCA9IHRoaXMuX2VsZW1lbnQuYmJveCgpXG4gICAgfVxuXG4gICAgaWYgKCF3aWR0aCkge1xuICAgICAgd2lkdGggPSAoYm94LndpZHRoIC8gYm94LmhlaWdodCkgKiBoZWlnaHRcbiAgICB9XG5cbiAgICBpZiAoIWhlaWdodCkge1xuICAgICAgaGVpZ2h0ID0gKGJveC5oZWlnaHQgLyBib3gud2lkdGgpICogd2lkdGhcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy53aWR0aCh3aWR0aCkuaGVpZ2h0KGhlaWdodClcbiAgfSxcblxuICAvLyBBZGQgYW5pbWF0YWJsZSB3aWR0aFxuICB3aWR0aCh3aWR0aCkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlcignd2lkdGgnLCB3aWR0aClcbiAgfSxcblxuICAvLyBBZGQgYW5pbWF0YWJsZSBoZWlnaHRcbiAgaGVpZ2h0KGhlaWdodCkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlcignaGVpZ2h0JywgaGVpZ2h0KVxuICB9LFxuXG4gIC8vIEFkZCBhbmltYXRhYmxlIHBsb3RcbiAgcGxvdChhLCBiLCBjLCBkKSB7XG4gICAgLy8gTGluZXMgY2FuIGJlIHBsb3R0ZWQgd2l0aCA0IGFyZ3VtZW50c1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgICByZXR1cm4gdGhpcy5wbG90KFthLCBiLCBjLCBkXSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdHJ5UmV0YXJnZXQoJ3Bsb3QnLCBhKSkgcmV0dXJuIHRoaXNcblxuICAgIGNvbnN0IG1vcnBoZXIgPSBuZXcgTW9ycGhhYmxlKHRoaXMuX3N0ZXBwZXIpXG4gICAgICAudHlwZSh0aGlzLl9lbGVtZW50Lk1vcnBoQXJyYXkpXG4gICAgICAudG8oYSlcblxuICAgIHRoaXMucXVldWUoXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1vcnBoZXIuZnJvbSh0aGlzLl9lbGVtZW50LmFycmF5KCkpXG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnBsb3QobW9ycGhlci5hdChwb3MpKVxuICAgICAgICByZXR1cm4gbW9ycGhlci5kb25lKClcbiAgICAgIH1cbiAgICApXG5cbiAgICB0aGlzLl9yZW1lbWJlck1vcnBoZXIoJ3Bsb3QnLCBtb3JwaGVyKVxuICAgIHJldHVybiB0aGlzXG4gIH0sXG5cbiAgLy8gQWRkIGxlYWRpbmcgbWV0aG9kXG4gIGxlYWRpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVldWVOdW1iZXIoJ2xlYWRpbmcnLCB2YWx1ZSlcbiAgfSxcblxuICAvLyBBZGQgYW5pbWF0YWJsZSB2aWV3Ym94XG4gIHZpZXdib3goeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU9iamVjdCgndmlld2JveCcsIG5ldyBCb3goeCwgeSwgd2lkdGgsIGhlaWdodCkpXG4gIH0sXG5cbiAgdXBkYXRlKG8pIHtcbiAgICBpZiAodHlwZW9mIG8gIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGUoe1xuICAgICAgICBvZmZzZXQ6IGFyZ3VtZW50c1swXSxcbiAgICAgICAgY29sb3I6IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgb3BhY2l0eTogYXJndW1lbnRzWzJdXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChvLm9wYWNpdHkgIT0gbnVsbCkgdGhpcy5hdHRyKCdzdG9wLW9wYWNpdHknLCBvLm9wYWNpdHkpXG4gICAgaWYgKG8uY29sb3IgIT0gbnVsbCkgdGhpcy5hdHRyKCdzdG9wLWNvbG9yJywgby5jb2xvcilcbiAgICBpZiAoby5vZmZzZXQgIT0gbnVsbCkgdGhpcy5hdHRyKCdvZmZzZXQnLCBvLm9mZnNldClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cbn0pXG5cbmV4dGVuZChSdW5uZXIsIHsgcngsIHJ5LCBmcm9tLCB0byB9KVxucmVnaXN0ZXIoUnVubmVyLCAnUnVubmVyJylcbiIsImltcG9ydCB7XG4gIGFkb3B0LFxuICBub2RlT3JOZXcsXG4gIHJlZ2lzdGVyLFxuICB3cmFwV2l0aEF0dHJDaGVja1xufSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgc3ZnLCB4bGluaywgeG1sbnMgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvbmFtZXNwYWNlcy5qcydcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQ29udGFpbmVyLmpzJ1xuaW1wb3J0IERlZnMgZnJvbSAnLi9EZWZzLmpzJ1xuaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4uL3V0aWxzL3dpbmRvdy5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ZnIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdzdmcnLCBub2RlKSwgYXR0cnMpXG4gICAgdGhpcy5uYW1lc3BhY2UoKVxuICB9XG5cbiAgLy8gQ3JlYXRlcyBhbmQgcmV0dXJucyBkZWZzIGVsZW1lbnRcbiAgZGVmcygpIHtcbiAgICBpZiAoIXRoaXMuaXNSb290KCkpIHJldHVybiB0aGlzLnJvb3QoKS5kZWZzKClcblxuICAgIHJldHVybiBhZG9wdCh0aGlzLm5vZGUucXVlcnlTZWxlY3RvcignZGVmcycpKSB8fCB0aGlzLnB1dChuZXcgRGVmcygpKVxuICB9XG5cbiAgaXNSb290KCkge1xuICAgIHJldHVybiAoXG4gICAgICAhdGhpcy5ub2RlLnBhcmVudE5vZGUgfHxcbiAgICAgICghKHRoaXMubm9kZS5wYXJlbnROb2RlIGluc3RhbmNlb2YgZ2xvYmFscy53aW5kb3cuU1ZHRWxlbWVudCkgJiZcbiAgICAgICAgdGhpcy5ub2RlLnBhcmVudE5vZGUubm9kZU5hbWUgIT09ICcjZG9jdW1lbnQtZnJhZ21lbnQnKVxuICAgIClcbiAgfVxuXG4gIC8vIEFkZCBuYW1lc3BhY2VzXG4gIG5hbWVzcGFjZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNSb290KCkpIHJldHVybiB0aGlzLnJvb3QoKS5uYW1lc3BhY2UoKVxuICAgIHJldHVybiB0aGlzLmF0dHIoeyB4bWxuczogc3ZnLCB2ZXJzaW9uOiAnMS4xJyB9KS5hdHRyKFxuICAgICAgJ3htbG5zOnhsaW5rJyxcbiAgICAgIHhsaW5rLFxuICAgICAgeG1sbnNcbiAgICApXG4gIH1cblxuICByZW1vdmVOYW1lc3BhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cih7IHhtbG5zOiBudWxsLCB2ZXJzaW9uOiBudWxsIH0pXG4gICAgICAuYXR0cigneG1sbnM6eGxpbmsnLCBudWxsLCB4bWxucylcbiAgICAgIC5hdHRyKCd4bWxuczpzdmdqcycsIG51bGwsIHhtbG5zKVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHJvb3Qgc3ZnXG4gIC8vIElmIG5vdCwgY2FsbCByb290KCkgZnJvbSB0aGlzIGVsZW1lbnRcbiAgcm9vdCgpIHtcbiAgICBpZiAodGhpcy5pc1Jvb3QoKSkgcmV0dXJuIHRoaXNcbiAgICByZXR1cm4gc3VwZXIucm9vdCgpXG4gIH1cbn1cblxucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgLy8gQ3JlYXRlIG5lc3RlZCBzdmcgZG9jdW1lbnRcbiAgICBuZXN0ZWQ6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU3ZnKCkpXG4gICAgfSlcbiAgfVxufSlcblxucmVnaXN0ZXIoU3ZnLCAnU3ZnJywgdHJ1ZSlcbiIsImltcG9ydCB7IG5vZGVPck5ldywgcmVnaXN0ZXIsIHdyYXBXaXRoQXR0ckNoZWNrIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQ29udGFpbmVyLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTeW1ib2wgZXh0ZW5kcyBDb250YWluZXIge1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdzeW1ib2wnLCBub2RlKSwgYXR0cnMpXG4gIH1cbn1cblxucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgc3ltYm9sOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFN5bWJvbCgpKVxuICAgIH0pXG4gIH1cbn0pXG5cbnJlZ2lzdGVyKFN5bWJvbCwgJ1N5bWJvbCcpXG4iLCJpbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vLi4vdXRpbHMvd2luZG93LmpzJ1xuXG4vLyBDcmVhdGUgcGxhaW4gdGV4dCBub2RlXG5leHBvcnQgZnVuY3Rpb24gcGxhaW4odGV4dCkge1xuICAvLyBjbGVhciBpZiBidWlsZCBtb2RlIGlzIGRpc2FibGVkXG4gIGlmICh0aGlzLl9idWlsZCA9PT0gZmFsc2UpIHtcbiAgICB0aGlzLmNsZWFyKClcbiAgfVxuXG4gIC8vIGNyZWF0ZSB0ZXh0IG5vZGVcbiAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGdsb2JhbHMuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gR2V0IGxlbmd0aCBvZiB0ZXh0IGVsZW1lbnRcbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gIHJldHVybiB0aGlzLm5vZGUuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKClcbn1cblxuLy8gTW92ZSBvdmVyIHgtYXhpc1xuLy8gVGV4dCBpcyBtb3ZlZCBieSBpdHMgYm91bmRpbmcgYm94XG4vLyB0ZXh0LWFuY2hvciBkb2VzIE5PVCBtYXR0ZXJcbmV4cG9ydCBmdW5jdGlvbiB4KHgsIGJveCA9IHRoaXMuYmJveCgpKSB7XG4gIGlmICh4ID09IG51bGwpIHtcbiAgICByZXR1cm4gYm94LnhcbiAgfVxuXG4gIHJldHVybiB0aGlzLmF0dHIoJ3gnLCB0aGlzLmF0dHIoJ3gnKSArIHggLSBib3gueClcbn1cblxuLy8gTW92ZSBvdmVyIHktYXhpc1xuZXhwb3J0IGZ1bmN0aW9uIHkoeSwgYm94ID0gdGhpcy5iYm94KCkpIHtcbiAgaWYgKHkgPT0gbnVsbCkge1xuICAgIHJldHVybiBib3gueVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXR0cigneScsIHRoaXMuYXR0cigneScpICsgeSAtIGJveC55KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbW92ZSh4LCB5LCBib3ggPSB0aGlzLmJib3goKSkge1xuICByZXR1cm4gdGhpcy54KHgsIGJveCkueSh5LCBib3gpXG59XG5cbi8vIE1vdmUgY2VudGVyIG92ZXIgeC1heGlzXG5leHBvcnQgZnVuY3Rpb24gY3goeCwgYm94ID0gdGhpcy5iYm94KCkpIHtcbiAgaWYgKHggPT0gbnVsbCkge1xuICAgIHJldHVybiBib3guY3hcbiAgfVxuXG4gIHJldHVybiB0aGlzLmF0dHIoJ3gnLCB0aGlzLmF0dHIoJ3gnKSArIHggLSBib3guY3gpXG59XG5cbi8vIE1vdmUgY2VudGVyIG92ZXIgeS1heGlzXG5leHBvcnQgZnVuY3Rpb24gY3koeSwgYm94ID0gdGhpcy5iYm94KCkpIHtcbiAgaWYgKHkgPT0gbnVsbCkge1xuICAgIHJldHVybiBib3guY3lcbiAgfVxuXG4gIHJldHVybiB0aGlzLmF0dHIoJ3knLCB0aGlzLmF0dHIoJ3knKSArIHkgLSBib3guY3kpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjZW50ZXIoeCwgeSwgYm94ID0gdGhpcy5iYm94KCkpIHtcbiAgcmV0dXJuIHRoaXMuY3goeCwgYm94KS5jeSh5LCBib3gpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBheCh4KSB7XG4gIHJldHVybiB0aGlzLmF0dHIoJ3gnLCB4KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXkoeSkge1xuICByZXR1cm4gdGhpcy5hdHRyKCd5JywgeSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFtb3ZlKHgsIHkpIHtcbiAgcmV0dXJuIHRoaXMuYXgoeCkuYXkoeSlcbn1cblxuLy8gRW5hYmxlIC8gZGlzYWJsZSBidWlsZCBtb2RlXG5leHBvcnQgZnVuY3Rpb24gYnVpbGQoYnVpbGQpIHtcbiAgdGhpcy5fYnVpbGQgPSAhIWJ1aWxkXG4gIHJldHVybiB0aGlzXG59XG4iLCJpbXBvcnQge1xuICBhZG9wdCxcbiAgZXh0ZW5kLFxuICBub2RlT3JOZXcsXG4gIHJlZ2lzdGVyLFxuICB3cmFwV2l0aEF0dHJDaGVja1xufSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcbmltcG9ydCBTVkdOdW1iZXIgZnJvbSAnLi4vdHlwZXMvU1ZHTnVtYmVyLmpzJ1xuaW1wb3J0IFNoYXBlIGZyb20gJy4vU2hhcGUuanMnXG5pbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vdXRpbHMvd2luZG93LmpzJ1xuaW1wb3J0ICogYXMgdGV4dGFibGUgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3RleHRhYmxlLmpzJ1xuaW1wb3J0IHsgaXNEZXNjcmlwdGl2ZSwgd3JpdGVEYXRhVG9Eb20gfSBmcm9tICcuLi91dGlscy91dGlscy5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dCBleHRlbmRzIFNoYXBlIHtcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygndGV4dCcsIG5vZGUpLCBhdHRycylcblxuICAgIHRoaXMuZG9tLmxlYWRpbmcgPSB0aGlzLmRvbS5sZWFkaW5nID8/IG5ldyBTVkdOdW1iZXIoMS4zKSAvLyBzdG9yZSBsZWFkaW5nIHZhbHVlIGZvciByZWJ1aWxkaW5nXG4gICAgdGhpcy5fcmVidWlsZCA9IHRydWUgLy8gZW5hYmxlIGF1dG9tYXRpYyB1cGRhdGluZyBvZiBkeSB2YWx1ZXNcbiAgICB0aGlzLl9idWlsZCA9IGZhbHNlIC8vIGRpc2FibGUgYnVpbGQgbW9kZSBmb3IgYWRkaW5nIG11bHRpcGxlIGxpbmVzXG4gIH1cblxuICAvLyBTZXQgLyBnZXQgbGVhZGluZ1xuICBsZWFkaW5nKHZhbHVlKSB7XG4gICAgLy8gYWN0IGFzIGdldHRlclxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb20ubGVhZGluZ1xuICAgIH1cblxuICAgIC8vIGFjdCBhcyBzZXR0ZXJcbiAgICB0aGlzLmRvbS5sZWFkaW5nID0gbmV3IFNWR051bWJlcih2YWx1ZSlcblxuICAgIHJldHVybiB0aGlzLnJlYnVpbGQoKVxuICB9XG5cbiAgLy8gUmVidWlsZCBhcHBlYXJhbmNlIHR5cGVcbiAgcmVidWlsZChyZWJ1aWxkKSB7XG4gICAgLy8gc3RvcmUgbmV3IHJlYnVpbGQgZmxhZyBpZiBnaXZlblxuICAgIGlmICh0eXBlb2YgcmVidWlsZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aGlzLl9yZWJ1aWxkID0gcmVidWlsZFxuICAgIH1cblxuICAgIC8vIGRlZmluZSBwb3NpdGlvbiBvZiBhbGwgbGluZXNcbiAgICBpZiAodGhpcy5fcmVidWlsZCkge1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICAgIGxldCBibGFua0xpbmVPZmZzZXQgPSAwXG4gICAgICBjb25zdCBsZWFkaW5nID0gdGhpcy5kb20ubGVhZGluZ1xuXG4gICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgaWYgKGlzRGVzY3JpcHRpdmUodGhpcy5ub2RlKSkgcmV0dXJuXG5cbiAgICAgICAgY29uc3QgZm9udFNpemUgPSBnbG9iYWxzLndpbmRvd1xuICAgICAgICAgIC5nZXRDb21wdXRlZFN0eWxlKHRoaXMubm9kZSlcbiAgICAgICAgICAuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udC1zaXplJylcblxuICAgICAgICBjb25zdCBkeSA9IGxlYWRpbmcgKiBuZXcgU1ZHTnVtYmVyKGZvbnRTaXplKVxuXG4gICAgICAgIGlmICh0aGlzLmRvbS5uZXdMaW5lZCkge1xuICAgICAgICAgIHRoaXMuYXR0cigneCcsIHNlbGYuYXR0cigneCcpKVxuXG4gICAgICAgICAgaWYgKHRoaXMudGV4dCgpID09PSAnXFxuJykge1xuICAgICAgICAgICAgYmxhbmtMaW5lT2Zmc2V0ICs9IGR5XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cignZHknLCBpID8gZHkgKyBibGFua0xpbmVPZmZzZXQgOiAwKVxuICAgICAgICAgICAgYmxhbmtMaW5lT2Zmc2V0ID0gMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgdGhpcy5maXJlKCdyZWJ1aWxkJylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gb3ZlcndyaXRlIG1ldGhvZCBmcm9tIHBhcmVudCB0byBzZXQgZGF0YSBwcm9wZXJseVxuICBzZXREYXRhKG8pIHtcbiAgICB0aGlzLmRvbSA9IG9cbiAgICB0aGlzLmRvbS5sZWFkaW5nID0gbmV3IFNWR051bWJlcihvLmxlYWRpbmcgfHwgMS4zKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB3cml0ZURhdGFUb0RvbSgpIHtcbiAgICB3cml0ZURhdGFUb0RvbSh0aGlzLCB0aGlzLmRvbSwgeyBsZWFkaW5nOiAxLjMgfSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gU2V0IHRoZSB0ZXh0IGNvbnRlbnRcbiAgdGV4dCh0ZXh0KSB7XG4gICAgLy8gYWN0IGFzIGdldHRlclxuICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5ub2RlLmNoaWxkTm9kZXNcbiAgICAgIGxldCBmaXJzdExpbmUgPSAwXG4gICAgICB0ZXh0ID0gJydcblxuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIC8vIHNraXAgdGV4dFBhdGhzIC0gdGhleSBhcmUgbm8gbGluZXNcbiAgICAgICAgaWYgKGNoaWxkcmVuW2ldLm5vZGVOYW1lID09PSAndGV4dFBhdGgnIHx8IGlzRGVzY3JpcHRpdmUoY2hpbGRyZW5baV0pKSB7XG4gICAgICAgICAgaWYgKGkgPT09IDApIGZpcnN0TGluZSA9IGkgKyAxXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBuZXdsaW5lIGlmIGl0cyBub3QgdGhlIGZpcnN0IGNoaWxkIGFuZCBuZXdMaW5lZCBpcyBzZXQgdG8gdHJ1ZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgaSAhPT0gZmlyc3RMaW5lICYmXG4gICAgICAgICAgY2hpbGRyZW5baV0ubm9kZVR5cGUgIT09IDMgJiZcbiAgICAgICAgICBhZG9wdChjaGlsZHJlbltpXSkuZG9tLm5ld0xpbmVkID09PSB0cnVlXG4gICAgICAgICkge1xuICAgICAgICAgIHRleHQgKz0gJ1xcbidcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBjb250ZW50IG9mIHRoaXMgbm9kZVxuICAgICAgICB0ZXh0ICs9IGNoaWxkcmVuW2ldLnRleHRDb250ZW50XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ZXh0XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGV4aXN0aW5nIGNvbnRlbnRcbiAgICB0aGlzLmNsZWFyKCkuYnVpbGQodHJ1ZSlcblxuICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gY2FsbCBibG9ja1xuICAgICAgdGV4dC5jYWxsKHRoaXMsIHRoaXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN0b3JlIHRleHQgYW5kIG1ha2Ugc3VyZSB0ZXh0IGlzIG5vdCBibGFua1xuICAgICAgdGV4dCA9ICh0ZXh0ICsgJycpLnNwbGl0KCdcXG4nKVxuXG4gICAgICAvLyBidWlsZCBuZXcgbGluZXNcbiAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IHRleHQubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICB0aGlzLm5ld0xpbmUodGV4dFtqXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkaXNhYmxlIGJ1aWxkIG1vZGUgYW5kIHJlYnVpbGQgbGluZXNcbiAgICByZXR1cm4gdGhpcy5idWlsZChmYWxzZSkucmVidWlsZCgpXG4gIH1cbn1cblxuZXh0ZW5kKFRleHQsIHRleHRhYmxlKVxuXG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgdGV4dCBlbGVtZW50XG4gICAgdGV4dDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHRleHQgPSAnJykge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBUZXh0KCkpLnRleHQodGV4dClcbiAgICB9KSxcblxuICAgIC8vIENyZWF0ZSBwbGFpbiB0ZXh0IGVsZW1lbnRcbiAgICBwbGFpbjogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHRleHQgPSAnJykge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBUZXh0KCkpLnBsYWluKHRleHQpXG4gICAgfSlcbiAgfVxufSlcblxucmVnaXN0ZXIoVGV4dCwgJ1RleHQnKVxuIiwiaW1wb3J0IHtcbiAgZXh0ZW5kLFxuICBub2RlT3JOZXcsXG4gIHJlZ2lzdGVyLFxuICB3cmFwV2l0aEF0dHJDaGVja1xufSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4uL3V0aWxzL3dpbmRvdy5qcydcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgU1ZHTnVtYmVyIGZyb20gJy4uL3R5cGVzL1NWR051bWJlci5qcydcbmltcG9ydCBTaGFwZSBmcm9tICcuL1NoYXBlLmpzJ1xuaW1wb3J0IFRleHQgZnJvbSAnLi9UZXh0LmpzJ1xuaW1wb3J0ICogYXMgdGV4dGFibGUgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3RleHRhYmxlLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUc3BhbiBleHRlbmRzIFNoYXBlIHtcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygndHNwYW4nLCBub2RlKSwgYXR0cnMpXG4gICAgdGhpcy5fYnVpbGQgPSBmYWxzZSAvLyBkaXNhYmxlIGJ1aWxkIG1vZGUgZm9yIGFkZGluZyBtdWx0aXBsZSBsaW5lc1xuICB9XG5cbiAgLy8gU2hvcnRjdXQgZHhcbiAgZHgoZHgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdkeCcsIGR4KVxuICB9XG5cbiAgLy8gU2hvcnRjdXQgZHlcbiAgZHkoZHkpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdkeScsIGR5KVxuICB9XG5cbiAgLy8gQ3JlYXRlIG5ldyBsaW5lXG4gIG5ld0xpbmUoKSB7XG4gICAgLy8gbWFyayBuZXcgbGluZVxuICAgIHRoaXMuZG9tLm5ld0xpbmVkID0gdHJ1ZVxuXG4gICAgLy8gZmV0Y2ggcGFyZW50XG4gICAgY29uc3QgdGV4dCA9IHRoaXMucGFyZW50KClcblxuICAgIC8vIGVhcmx5IHJldHVybiBpbiBjYXNlIHdlIGFyZSBub3QgaW4gYSB0ZXh0IGVsZW1lbnRcbiAgICBpZiAoISh0ZXh0IGluc3RhbmNlb2YgVGV4dCkpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgY29uc3QgaSA9IHRleHQuaW5kZXgodGhpcylcblxuICAgIGNvbnN0IGZvbnRTaXplID0gZ2xvYmFscy53aW5kb3dcbiAgICAgIC5nZXRDb21wdXRlZFN0eWxlKHRoaXMubm9kZSlcbiAgICAgIC5nZXRQcm9wZXJ0eVZhbHVlKCdmb250LXNpemUnKVxuICAgIGNvbnN0IGR5ID0gdGV4dC5kb20ubGVhZGluZyAqIG5ldyBTVkdOdW1iZXIoZm9udFNpemUpXG5cbiAgICAvLyBhcHBseSBuZXcgcG9zaXRpb25cbiAgICByZXR1cm4gdGhpcy5keShpID8gZHkgOiAwKS5hdHRyKCd4JywgdGV4dC54KCkpXG4gIH1cblxuICAvLyBTZXQgdGV4dCBjb250ZW50XG4gIHRleHQodGV4dCkge1xuICAgIGlmICh0ZXh0ID09IG51bGwpXG4gICAgICByZXR1cm4gdGhpcy5ub2RlLnRleHRDb250ZW50ICsgKHRoaXMuZG9tLm5ld0xpbmVkID8gJ1xcbicgOiAnJylcblxuICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5jbGVhcigpLmJ1aWxkKHRydWUpXG4gICAgICB0ZXh0LmNhbGwodGhpcywgdGhpcylcbiAgICAgIHRoaXMuYnVpbGQoZmFsc2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxhaW4odGV4dClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbmV4dGVuZChUc3BhbiwgdGV4dGFibGUpXG5cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIFRzcGFuOiB7XG4gICAgdHNwYW46IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh0ZXh0ID0gJycpIHtcbiAgICAgIGNvbnN0IHRzcGFuID0gbmV3IFRzcGFuKClcblxuICAgICAgLy8gY2xlYXIgaWYgYnVpbGQgbW9kZSBpcyBkaXNhYmxlZFxuICAgICAgaWYgKCF0aGlzLl9idWlsZCkge1xuICAgICAgICB0aGlzLmNsZWFyKClcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIG5ldyB0c3BhblxuICAgICAgcmV0dXJuIHRoaXMucHV0KHRzcGFuKS50ZXh0KHRleHQpXG4gICAgfSlcbiAgfSxcbiAgVGV4dDoge1xuICAgIG5ld0xpbmU6IGZ1bmN0aW9uICh0ZXh0ID0gJycpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzcGFuKHRleHQpLm5ld0xpbmUoKVxuICAgIH1cbiAgfVxufSlcblxucmVnaXN0ZXIoVHNwYW4sICdUc3BhbicpXG4iLCJpbXBvcnQgeyBjeCwgY3ksIGhlaWdodCwgd2lkdGgsIHgsIHkgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvY2lyY2xlZC5qcydcbmltcG9ydCB7XG4gIGV4dGVuZCxcbiAgbm9kZU9yTmV3LFxuICByZWdpc3RlcixcbiAgd3JhcFdpdGhBdHRyQ2hlY2tcbn0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgU1ZHTnVtYmVyIGZyb20gJy4uL3R5cGVzL1NWR051bWJlci5qcydcbmltcG9ydCBTaGFwZSBmcm9tICcuL1NoYXBlLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaXJjbGUgZXh0ZW5kcyBTaGFwZSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygnY2lyY2xlJywgbm9kZSksIGF0dHJzKVxuICB9XG5cbiAgcmFkaXVzKHIpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdyJywgcilcbiAgfVxuXG4gIC8vIFJhZGl1cyB4IHZhbHVlXG4gIHJ4KHJ4KSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cigncicsIHJ4KVxuICB9XG5cbiAgLy8gQWxpYXMgcmFkaXVzIHggdmFsdWVcbiAgcnkocnkpIHtcbiAgICByZXR1cm4gdGhpcy5yeChyeSlcbiAgfVxuXG4gIHNpemUoc2l6ZSkge1xuICAgIHJldHVybiB0aGlzLnJhZGl1cyhuZXcgU1ZHTnVtYmVyKHNpemUpLmRpdmlkZSgyKSlcbiAgfVxufVxuXG5leHRlbmQoQ2lyY2xlLCB7IHgsIHksIGN4LCBjeSwgd2lkdGgsIGhlaWdodCB9KVxuXG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgY2lyY2xlIGVsZW1lbnRcbiAgICBjaXJjbGU6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uIChzaXplID0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBDaXJjbGUoKSkuc2l6ZShzaXplKS5tb3ZlKDAsIDApXG4gICAgfSlcbiAgfVxufSlcblxucmVnaXN0ZXIoQ2lyY2xlLCAnQ2lyY2xlJylcbiIsImltcG9ydCB7IG5vZGVPck5ldywgcmVnaXN0ZXIsIHdyYXBXaXRoQXR0ckNoZWNrIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQ29udGFpbmVyLmpzJ1xuaW1wb3J0IGJhc2VGaW5kIGZyb20gJy4uL21vZHVsZXMvY29yZS9zZWxlY3Rvci5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2xpcFBhdGggZXh0ZW5kcyBDb250YWluZXIge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ2NsaXBQYXRoJywgbm9kZSksIGF0dHJzKVxuICB9XG5cbiAgLy8gVW5jbGlwIGFsbCBjbGlwcGVkIGVsZW1lbnRzIGFuZCByZW1vdmUgaXRzZWxmXG4gIHJlbW92ZSgpIHtcbiAgICAvLyB1bmNsaXAgYWxsIHRhcmdldHNcbiAgICB0aGlzLnRhcmdldHMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgZWwudW5jbGlwKClcbiAgICB9KVxuXG4gICAgLy8gcmVtb3ZlIGNsaXBQYXRoIGZyb20gcGFyZW50XG4gICAgcmV0dXJuIHN1cGVyLnJlbW92ZSgpXG4gIH1cblxuICB0YXJnZXRzKCkge1xuICAgIHJldHVybiBiYXNlRmluZCgnc3ZnIFtjbGlwLXBhdGgqPScgKyB0aGlzLmlkKCkgKyAnXScpXG4gIH1cbn1cblxucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgLy8gQ3JlYXRlIGNsaXBwaW5nIGVsZW1lbnRcbiAgICBjbGlwOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZzKCkucHV0KG5ldyBDbGlwUGF0aCgpKVxuICAgIH0pXG4gIH0sXG4gIEVsZW1lbnQ6IHtcbiAgICAvLyBEaXN0cmlidXRlIGNsaXBQYXRoIHRvIHN2ZyBlbGVtZW50XG4gICAgY2xpcHBlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZSgnY2xpcC1wYXRoJylcbiAgICB9LFxuXG4gICAgY2xpcFdpdGgoZWxlbWVudCkge1xuICAgICAgLy8gdXNlIGdpdmVuIGNsaXAgb3IgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgY29uc3QgY2xpcHBlciA9XG4gICAgICAgIGVsZW1lbnQgaW5zdGFuY2VvZiBDbGlwUGF0aFxuICAgICAgICAgID8gZWxlbWVudFxuICAgICAgICAgIDogdGhpcy5wYXJlbnQoKS5jbGlwKCkuYWRkKGVsZW1lbnQpXG5cbiAgICAgIC8vIGFwcGx5IG1hc2tcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2NsaXAtcGF0aCcsICd1cmwoIycgKyBjbGlwcGVyLmlkKCkgKyAnKScpXG4gICAgfSxcblxuICAgIC8vIFVuY2xpcCBlbGVtZW50XG4gICAgdW5jbGlwKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cignY2xpcC1wYXRoJywgbnVsbClcbiAgICB9XG4gIH1cbn0pXG5cbnJlZ2lzdGVyKENsaXBQYXRoLCAnQ2xpcFBhdGgnKVxuIiwiaW1wb3J0IHsgbm9kZU9yTmV3LCByZWdpc3Rlciwgd3JhcFdpdGhBdHRyQ2hlY2sgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcbmltcG9ydCBFbGVtZW50IGZyb20gJy4vRWxlbWVudC5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9yZWlnbk9iamVjdCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ2ZvcmVpZ25PYmplY3QnLCBub2RlKSwgYXR0cnMpXG4gIH1cbn1cblxucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgZm9yZWlnbk9iamVjdDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgRm9yZWlnbk9iamVjdCgpKS5zaXplKHdpZHRoLCBoZWlnaHQpXG4gICAgfSlcbiAgfVxufSlcblxucmVnaXN0ZXIoRm9yZWlnbk9iamVjdCwgJ0ZvcmVpZ25PYmplY3QnKVxuIiwiaW1wb3J0IE1hdHJpeCBmcm9tICcuLi8uLi90eXBlcy9NYXRyaXguanMnXG5pbXBvcnQgUG9pbnQgZnJvbSAnLi4vLi4vdHlwZXMvUG9pbnQuanMnXG5pbXBvcnQgQm94IGZyb20gJy4uLy4uL3R5cGVzL0JveC5qcydcbmltcG9ydCB7IHByb3BvcnRpb25hbFNpemUgfSBmcm9tICcuLi8uLi91dGlscy91dGlscy5qcydcbmltcG9ydCB7IGdldFdpbmRvdyB9IGZyb20gJy4uLy4uL3V0aWxzL3dpbmRvdy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGRtb3ZlKGR4LCBkeSkge1xuICB0aGlzLmNoaWxkcmVuKCkuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICBsZXQgYmJveFxuXG4gICAgLy8gV2UgaGF2ZSB0byB3cmFwIHRoaXMgZm9yIGVsZW1lbnRzIHRoYXQgZG9udCBoYXZlIGEgYmJveFxuICAgIC8vIGUuZy4gdGl0bGUgYW5kIG90aGVyIGRlc2NyaXB0aXZlIGVsZW1lbnRzXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCB0aGUgY2hpbGRzIGJib3hcbiAgICAgIC8vIEJ1ZzogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTkwNTAzOVxuICAgICAgLy8gQmVjYXVzZSBiYm94IGZvciBuZXN0ZWQgc3ZncyByZXR1cm5zIHRoZSBjb250ZW50cyBiYm94IGluIHRoZSBjb29yZGluYXRlIHNwYWNlIG9mIHRoZSBzdmcgaXRzZWxmICh3ZWlyZCEpLCB3ZSBjYW50IHVzZSBiYm94IGZvciBzdmdzXG4gICAgICAvLyBUaGVyZWZvcmUgd2UgaGF2ZSB0byB1c2UgZ2V0Qm91bmRpbmdDbGllbnRSZWN0LiBCdXQgVEhBVCBpcyBicm9rZW4gKGFzIGV4cGxhaW5lZCBpbiB0aGUgYnVnKS5cbiAgICAgIC8vIEZ1bm5pbHkgZW5vdWdoIHRoZSBicm9rZW4gYmVoYXZpb3Igd291bGQgd29yayBmb3IgdXMgYnV0IHRoYXQgYnJlYWtzIGl0IGluIGNocm9tZVxuICAgICAgLy8gU28gd2UgaGF2ZSB0byByZXBsaWNhdGUgdGhlIGJyb2tlbiBiZWhhdmlvciBvZiBGRiBieSBqdXN0IHJlYWRpbmcgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIHN2ZyBpdHNlbGZcbiAgICAgIGJib3ggPVxuICAgICAgICBjaGlsZC5ub2RlIGluc3RhbmNlb2YgZ2V0V2luZG93KCkuU1ZHU1ZHRWxlbWVudFxuICAgICAgICAgID8gbmV3IEJveChjaGlsZC5hdHRyKFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCddKSlcbiAgICAgICAgICA6IGNoaWxkLmJib3goKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIEdldCBjaGlsZHMgbWF0cml4XG4gICAgY29uc3QgbSA9IG5ldyBNYXRyaXgoY2hpbGQpXG4gICAgLy8gVHJhbnNsYXRlIGNoaWxkcyBtYXRyaXggYnkgYW1vdW50IGFuZFxuICAgIC8vIHRyYW5zZm9ybSBpdCBiYWNrIGludG8gcGFyZW50cyBzcGFjZVxuICAgIGNvbnN0IG1hdHJpeCA9IG0udHJhbnNsYXRlKGR4LCBkeSkudHJhbnNmb3JtKG0uaW52ZXJzZSgpKVxuICAgIC8vIENhbGN1bGF0ZSBuZXcgeCBhbmQgeSBmcm9tIG9sZCBib3hcbiAgICBjb25zdCBwID0gbmV3IFBvaW50KGJib3gueCwgYmJveC55KS50cmFuc2Zvcm0obWF0cml4KVxuICAgIC8vIE1vdmUgZWxlbWVudFxuICAgIGNoaWxkLm1vdmUocC54LCBwLnkpXG4gIH0pXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGR4KGR4KSB7XG4gIHJldHVybiB0aGlzLmRtb3ZlKGR4LCAwKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZHkoZHkpIHtcbiAgcmV0dXJuIHRoaXMuZG1vdmUoMCwgZHkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoZWlnaHQoaGVpZ2h0LCBib3ggPSB0aGlzLmJib3goKSkge1xuICBpZiAoaGVpZ2h0ID09IG51bGwpIHJldHVybiBib3guaGVpZ2h0XG4gIHJldHVybiB0aGlzLnNpemUoYm94LndpZHRoLCBoZWlnaHQsIGJveClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vdmUoeCA9IDAsIHkgPSAwLCBib3ggPSB0aGlzLmJib3goKSkge1xuICBjb25zdCBkeCA9IHggLSBib3gueFxuICBjb25zdCBkeSA9IHkgLSBib3gueVxuXG4gIHJldHVybiB0aGlzLmRtb3ZlKGR4LCBkeSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNpemUod2lkdGgsIGhlaWdodCwgYm94ID0gdGhpcy5iYm94KCkpIHtcbiAgY29uc3QgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodCwgYm94KVxuICBjb25zdCBzY2FsZVggPSBwLndpZHRoIC8gYm94LndpZHRoXG4gIGNvbnN0IHNjYWxlWSA9IHAuaGVpZ2h0IC8gYm94LmhlaWdodFxuXG4gIHRoaXMuY2hpbGRyZW4oKS5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgIGNvbnN0IG8gPSBuZXcgUG9pbnQoYm94KS50cmFuc2Zvcm0obmV3IE1hdHJpeChjaGlsZCkuaW52ZXJzZSgpKVxuICAgIGNoaWxkLnNjYWxlKHNjYWxlWCwgc2NhbGVZLCBvLngsIG8ueSlcbiAgfSlcblxuICByZXR1cm4gdGhpc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2lkdGgod2lkdGgsIGJveCA9IHRoaXMuYmJveCgpKSB7XG4gIGlmICh3aWR0aCA9PSBudWxsKSByZXR1cm4gYm94LndpZHRoXG4gIHJldHVybiB0aGlzLnNpemUod2lkdGgsIGJveC5oZWlnaHQsIGJveClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHgoeCwgYm94ID0gdGhpcy5iYm94KCkpIHtcbiAgaWYgKHggPT0gbnVsbCkgcmV0dXJuIGJveC54XG4gIHJldHVybiB0aGlzLm1vdmUoeCwgYm94LnksIGJveClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHkoeSwgYm94ID0gdGhpcy5iYm94KCkpIHtcbiAgaWYgKHkgPT0gbnVsbCkgcmV0dXJuIGJveC55XG4gIHJldHVybiB0aGlzLm1vdmUoYm94LngsIHksIGJveClcbn1cbiIsImltcG9ydCB7XG4gIG5vZGVPck5ldyxcbiAgcmVnaXN0ZXIsXG4gIHdyYXBXaXRoQXR0ckNoZWNrLFxuICBleHRlbmRcbn0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQ29udGFpbmVyLmpzJ1xuaW1wb3J0ICogYXMgY29udGFpbmVyR2VvbWV0cnkgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL2NvbnRhaW5lckdlb21ldHJ5LmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdnJywgbm9kZSksIGF0dHJzKVxuICB9XG59XG5cbmV4dGVuZChHLCBjb250YWluZXJHZW9tZXRyeSlcblxucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgLy8gQ3JlYXRlIGEgZ3JvdXAgZWxlbWVudFxuICAgIGdyb3VwOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IEcoKSlcbiAgICB9KVxuICB9XG59KVxuXG5yZWdpc3RlcihHLCAnRycpXG4iLCJpbXBvcnQge1xuICBub2RlT3JOZXcsXG4gIHJlZ2lzdGVyLFxuICB3cmFwV2l0aEF0dHJDaGVjayxcbiAgZXh0ZW5kXG59IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xuaW1wb3J0IHsgeGxpbmsgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvbmFtZXNwYWNlcy5qcydcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9Db250YWluZXIuanMnXG5pbXBvcnQgKiBhcyBjb250YWluZXJHZW9tZXRyeSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvY29udGFpbmVyR2VvbWV0cnkuanMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEEgZXh0ZW5kcyBDb250YWluZXIge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ2EnLCBub2RlKSwgYXR0cnMpXG4gIH1cblxuICAvLyBMaW5rIHRhcmdldCBhdHRyaWJ1dGVcbiAgdGFyZ2V0KHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ3RhcmdldCcsIHRhcmdldClcbiAgfVxuXG4gIC8vIExpbmsgdXJsXG4gIHRvKHVybCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ2hyZWYnLCB1cmwsIHhsaW5rKVxuICB9XG59XG5cbmV4dGVuZChBLCBjb250YWluZXJHZW9tZXRyeSlcblxucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgLy8gQ3JlYXRlIGEgaHlwZXJsaW5rIGVsZW1lbnRcbiAgICBsaW5rOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAodXJsKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IEEoKSkudG8odXJsKVxuICAgIH0pXG4gIH0sXG4gIEVsZW1lbnQ6IHtcbiAgICB1bmxpbmsoKSB7XG4gICAgICBjb25zdCBsaW5rID0gdGhpcy5saW5rZXIoKVxuXG4gICAgICBpZiAoIWxpbmspIHJldHVybiB0aGlzXG5cbiAgICAgIGNvbnN0IHBhcmVudCA9IGxpbmsucGFyZW50KClcblxuICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKClcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kZXggPSBwYXJlbnQuaW5kZXgobGluaylcbiAgICAgIHBhcmVudC5hZGQodGhpcywgaW5kZXgpXG5cbiAgICAgIGxpbmsucmVtb3ZlKClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgICBsaW5rVG8odXJsKSB7XG4gICAgICAvLyByZXVzZSBvbGQgbGluayBpZiBwb3NzaWJsZVxuICAgICAgbGV0IGxpbmsgPSB0aGlzLmxpbmtlcigpXG5cbiAgICAgIGlmICghbGluaykge1xuICAgICAgICBsaW5rID0gbmV3IEEoKVxuICAgICAgICB0aGlzLndyYXAobGluaylcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB1cmwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdXJsLmNhbGwobGluaywgbGluaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmsudG8odXJsKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgbGlua2VyKCkge1xuICAgICAgY29uc3QgbGluayA9IHRoaXMucGFyZW50KClcbiAgICAgIGlmIChsaW5rICYmIGxpbmsubm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcbiAgICAgICAgcmV0dXJuIGxpbmtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbn0pXG5cbnJlZ2lzdGVyKEEsICdBJylcbiIsImltcG9ydCB7IG5vZGVPck5ldywgcmVnaXN0ZXIsIHdyYXBXaXRoQXR0ckNoZWNrIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQ29udGFpbmVyLmpzJ1xuaW1wb3J0IGJhc2VGaW5kIGZyb20gJy4uL21vZHVsZXMvY29yZS9zZWxlY3Rvci5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFzayBleHRlbmRzIENvbnRhaW5lciB7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ21hc2snLCBub2RlKSwgYXR0cnMpXG4gIH1cblxuICAvLyBVbm1hc2sgYWxsIG1hc2tlZCBlbGVtZW50cyBhbmQgcmVtb3ZlIGl0c2VsZlxuICByZW1vdmUoKSB7XG4gICAgLy8gdW5tYXNrIGFsbCB0YXJnZXRzXG4gICAgdGhpcy50YXJnZXRzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGVsLnVubWFzaygpXG4gICAgfSlcblxuICAgIC8vIHJlbW92ZSBtYXNrIGZyb20gcGFyZW50XG4gICAgcmV0dXJuIHN1cGVyLnJlbW92ZSgpXG4gIH1cblxuICB0YXJnZXRzKCkge1xuICAgIHJldHVybiBiYXNlRmluZCgnc3ZnIFttYXNrKj0nICsgdGhpcy5pZCgpICsgJ10nKVxuICB9XG59XG5cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIG1hc2s6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5wdXQobmV3IE1hc2soKSlcbiAgICB9KVxuICB9LFxuICBFbGVtZW50OiB7XG4gICAgLy8gRGlzdHJpYnV0ZSBtYXNrIHRvIHN2ZyBlbGVtZW50XG4gICAgbWFza2VyKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlKCdtYXNrJylcbiAgICB9LFxuXG4gICAgbWFza1dpdGgoZWxlbWVudCkge1xuICAgICAgLy8gdXNlIGdpdmVuIG1hc2sgb3IgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgY29uc3QgbWFza2VyID1cbiAgICAgICAgZWxlbWVudCBpbnN0YW5jZW9mIE1hc2sgPyBlbGVtZW50IDogdGhpcy5wYXJlbnQoKS5tYXNrKCkuYWRkKGVsZW1lbnQpXG5cbiAgICAgIC8vIGFwcGx5IG1hc2tcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ21hc2snLCAndXJsKCMnICsgbWFza2VyLmlkKCkgKyAnKScpXG4gICAgfSxcblxuICAgIC8vIFVubWFzayBlbGVtZW50XG4gICAgdW5tYXNrKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cignbWFzaycsIG51bGwpXG4gICAgfVxuICB9XG59KVxuXG5yZWdpc3RlcihNYXNrLCAnTWFzaycpXG4iLCJpbXBvcnQgeyBub2RlT3JOZXcsIHJlZ2lzdGVyIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCBFbGVtZW50IGZyb20gJy4vRWxlbWVudC5qcydcbmltcG9ydCBTVkdOdW1iZXIgZnJvbSAnLi4vdHlwZXMvU1ZHTnVtYmVyLmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RvcCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ3N0b3AnLCBub2RlKSwgYXR0cnMpXG4gIH1cblxuICAvLyBhZGQgY29sb3Igc3RvcHNcbiAgdXBkYXRlKG8pIHtcbiAgICBpZiAodHlwZW9mIG8gPT09ICdudW1iZXInIHx8IG8gaW5zdGFuY2VvZiBTVkdOdW1iZXIpIHtcbiAgICAgIG8gPSB7XG4gICAgICAgIG9mZnNldDogYXJndW1lbnRzWzBdLFxuICAgICAgICBjb2xvcjogYXJndW1lbnRzWzFdLFxuICAgICAgICBvcGFjaXR5OiBhcmd1bWVudHNbMl1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzZXQgYXR0cmlidXRlc1xuICAgIGlmIChvLm9wYWNpdHkgIT0gbnVsbCkgdGhpcy5hdHRyKCdzdG9wLW9wYWNpdHknLCBvLm9wYWNpdHkpXG4gICAgaWYgKG8uY29sb3IgIT0gbnVsbCkgdGhpcy5hdHRyKCdzdG9wLWNvbG9yJywgby5jb2xvcilcbiAgICBpZiAoby5vZmZzZXQgIT0gbnVsbCkgdGhpcy5hdHRyKCdvZmZzZXQnLCBuZXcgU1ZHTnVtYmVyKG8ub2Zmc2V0KSlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxucmVnaXN0ZXJNZXRob2RzKHtcbiAgR3JhZGllbnQ6IHtcbiAgICAvLyBBZGQgYSBjb2xvciBzdG9wXG4gICAgc3RvcDogZnVuY3Rpb24gKG9mZnNldCwgY29sb3IsIG9wYWNpdHkpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU3RvcCgpKS51cGRhdGUob2Zmc2V0LCBjb2xvciwgb3BhY2l0eSlcbiAgICB9XG4gIH1cbn0pXG5cbnJlZ2lzdGVyKFN0b3AsICdTdG9wJylcbiIsImltcG9ydCB7IG5vZGVPck5ldywgcmVnaXN0ZXIgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcbmltcG9ydCB7IHVuQ2FtZWxDYXNlIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMuanMnXG5pbXBvcnQgRWxlbWVudCBmcm9tICcuL0VsZW1lbnQuanMnXG5cbmZ1bmN0aW9uIGNzc1J1bGUoc2VsZWN0b3IsIHJ1bGUpIHtcbiAgaWYgKCFzZWxlY3RvcikgcmV0dXJuICcnXG4gIGlmICghcnVsZSkgcmV0dXJuIHNlbGVjdG9yXG5cbiAgbGV0IHJldCA9IHNlbGVjdG9yICsgJ3snXG5cbiAgZm9yIChjb25zdCBpIGluIHJ1bGUpIHtcbiAgICByZXQgKz0gdW5DYW1lbENhc2UoaSkgKyAnOicgKyBydWxlW2ldICsgJzsnXG4gIH1cblxuICByZXQgKz0gJ30nXG5cbiAgcmV0dXJuIHJldFxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHlsZSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ3N0eWxlJywgbm9kZSksIGF0dHJzKVxuICB9XG5cbiAgYWRkVGV4dCh3ID0gJycpIHtcbiAgICB0aGlzLm5vZGUudGV4dENvbnRlbnQgKz0gd1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBmb250KG5hbWUsIHNyYywgcGFyYW1zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlKCdAZm9udC1mYWNlJywge1xuICAgICAgZm9udEZhbWlseTogbmFtZSxcbiAgICAgIHNyYzogc3JjLFxuICAgICAgLi4ucGFyYW1zXG4gICAgfSlcbiAgfVxuXG4gIHJ1bGUoc2VsZWN0b3IsIG9iaikge1xuICAgIHJldHVybiB0aGlzLmFkZFRleHQoY3NzUnVsZShzZWxlY3Rvciwgb2JqKSlcbiAgfVxufVxuXG5yZWdpc3Rlck1ldGhvZHMoJ0RvbScsIHtcbiAgc3R5bGUoc2VsZWN0b3IsIG9iaikge1xuICAgIHJldHVybiB0aGlzLnB1dChuZXcgU3R5bGUoKSkucnVsZShzZWxlY3Rvciwgb2JqKVxuICB9LFxuICBmb250ZmFjZShuYW1lLCBzcmMsIHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnB1dChuZXcgU3R5bGUoKSkuZm9udChuYW1lLCBzcmMsIHBhcmFtcylcbiAgfVxufSlcblxucmVnaXN0ZXIoU3R5bGUsICdTdHlsZScpXG4iLCJpbXBvcnQgeyBub2RlT3JOZXcsIHJlZ2lzdGVyLCB3cmFwV2l0aEF0dHJDaGVjayB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xuaW1wb3J0IHsgeGxpbmsgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvbmFtZXNwYWNlcy5qcydcbmltcG9ydCBQYXRoIGZyb20gJy4vUGF0aC5qcydcbmltcG9ydCBQYXRoQXJyYXkgZnJvbSAnLi4vdHlwZXMvUGF0aEFycmF5LmpzJ1xuaW1wb3J0IFRleHQgZnJvbSAnLi9UZXh0LmpzJ1xuaW1wb3J0IGJhc2VGaW5kIGZyb20gJy4uL21vZHVsZXMvY29yZS9zZWxlY3Rvci5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dFBhdGggZXh0ZW5kcyBUZXh0IHtcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygndGV4dFBhdGgnLCBub2RlKSwgYXR0cnMpXG4gIH1cblxuICAvLyByZXR1cm4gdGhlIGFycmF5IG9mIHRoZSBwYXRoIHRyYWNrIGVsZW1lbnRcbiAgYXJyYXkoKSB7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrKClcblxuICAgIHJldHVybiB0cmFjayA/IHRyYWNrLmFycmF5KCkgOiBudWxsXG4gIH1cblxuICAvLyBQbG90IHBhdGggaWYgYW55XG4gIHBsb3QoZCkge1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFjaygpXG4gICAgbGV0IHBhdGhBcnJheSA9IG51bGxcblxuICAgIGlmICh0cmFjaykge1xuICAgICAgcGF0aEFycmF5ID0gdHJhY2sucGxvdChkKVxuICAgIH1cblxuICAgIHJldHVybiBkID09IG51bGwgPyBwYXRoQXJyYXkgOiB0aGlzXG4gIH1cblxuICAvLyBHZXQgdGhlIHBhdGggZWxlbWVudFxuICB0cmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2UoJ2hyZWYnKVxuICB9XG59XG5cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIHRleHRQYXRoOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAodGV4dCwgcGF0aCkge1xuICAgICAgLy8gQ29udmVydCB0ZXh0IHRvIGluc3RhbmNlIGlmIG5lZWRlZFxuICAgICAgaWYgKCEodGV4dCBpbnN0YW5jZW9mIFRleHQpKSB7XG4gICAgICAgIHRleHQgPSB0aGlzLnRleHQodGV4dClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRleHQucGF0aChwYXRoKVxuICAgIH0pXG4gIH0sXG4gIFRleHQ6IHtcbiAgICAvLyBDcmVhdGUgcGF0aCBmb3IgdGV4dCB0byBydW4gb25cbiAgICBwYXRoOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAodHJhY2ssIGltcG9ydE5vZGVzID0gdHJ1ZSkge1xuICAgICAgY29uc3QgdGV4dFBhdGggPSBuZXcgVGV4dFBhdGgoKVxuXG4gICAgICAvLyBpZiB0cmFjayBpcyBhIHBhdGgsIHJldXNlIGl0XG4gICAgICBpZiAoISh0cmFjayBpbnN0YW5jZW9mIFBhdGgpKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBwYXRoIGVsZW1lbnRcbiAgICAgICAgdHJhY2sgPSB0aGlzLmRlZnMoKS5wYXRoKHRyYWNrKVxuICAgICAgfVxuXG4gICAgICAvLyBsaW5rIHRleHRQYXRoIHRvIHBhdGggYW5kIGFkZCBjb250ZW50XG4gICAgICB0ZXh0UGF0aC5hdHRyKCdocmVmJywgJyMnICsgdHJhY2ssIHhsaW5rKVxuXG4gICAgICAvLyBUcmFuc3BsYW50IGFsbCBub2RlcyBmcm9tIHRleHQgdG8gdGV4dFBhdGhcbiAgICAgIGxldCBub2RlXG4gICAgICBpZiAoaW1wb3J0Tm9kZXMpIHtcbiAgICAgICAgd2hpbGUgKChub2RlID0gdGhpcy5ub2RlLmZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgdGV4dFBhdGgubm9kZS5hcHBlbmRDaGlsZChub2RlKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCB0ZXh0UGF0aCBlbGVtZW50IGFzIGNoaWxkIG5vZGUgYW5kIHJldHVybiB0ZXh0UGF0aFxuICAgICAgcmV0dXJuIHRoaXMucHV0KHRleHRQYXRoKVxuICAgIH0pLFxuXG4gICAgLy8gR2V0IHRoZSB0ZXh0UGF0aCBjaGlsZHJlblxuICAgIHRleHRQYXRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZE9uZSgndGV4dFBhdGgnKVxuICAgIH1cbiAgfSxcbiAgUGF0aDoge1xuICAgIC8vIGNyZWF0ZXMgYSB0ZXh0UGF0aCBmcm9tIHRoaXMgcGF0aFxuICAgIHRleHQ6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAvLyBDb252ZXJ0IHRleHQgdG8gaW5zdGFuY2UgaWYgbmVlZGVkXG4gICAgICBpZiAoISh0ZXh0IGluc3RhbmNlb2YgVGV4dCkpIHtcbiAgICAgICAgdGV4dCA9IG5ldyBUZXh0KCkuYWRkVG8odGhpcy5wYXJlbnQoKSkudGV4dCh0ZXh0KVxuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgdGV4dFBhdGggZnJvbSB0ZXh0IGFuZCBwYXRoIGFuZCByZXR1cm5cbiAgICAgIHJldHVybiB0ZXh0LnBhdGgodGhpcylcbiAgICB9KSxcblxuICAgIHRhcmdldHMoKSB7XG4gICAgICByZXR1cm4gYmFzZUZpbmQoJ3N2ZyB0ZXh0UGF0aCcpLmZpbHRlcigobm9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG5vZGUuYXR0cignaHJlZicpIHx8ICcnKS5pbmNsdWRlcyh0aGlzLmlkKCkpXG4gICAgICB9KVxuXG4gICAgICAvLyBEb2VzIG5vdCB3b3JrIGluIElFMTEuIFVzZSB3aGVuIElFIHN1cHBvcnQgaXMgZHJvcHBlZFxuICAgICAgLy8gcmV0dXJuIGJhc2VGaW5kKCdzdmcgdGV4dFBhdGhbKnxocmVmKj0nICsgdGhpcy5pZCgpICsgJ10nKVxuICAgIH1cbiAgfVxufSlcblxuVGV4dFBhdGgucHJvdG90eXBlLk1vcnBoQXJyYXkgPSBQYXRoQXJyYXlcbnJlZ2lzdGVyKFRleHRQYXRoLCAnVGV4dFBhdGgnKVxuIiwiaW1wb3J0IHsgbm9kZU9yTmV3LCByZWdpc3Rlciwgd3JhcFdpdGhBdHRyQ2hlY2sgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcbmltcG9ydCB7IHhsaW5rIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL25hbWVzcGFjZXMuanMnXG5pbXBvcnQgU2hhcGUgZnJvbSAnLi9TaGFwZS5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXNlIGV4dGVuZHMgU2hhcGUge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ3VzZScsIG5vZGUpLCBhdHRycylcbiAgfVxuXG4gIC8vIFVzZSBlbGVtZW50IGFzIGEgcmVmZXJlbmNlXG4gIHVzZShlbGVtZW50LCBmaWxlKSB7XG4gICAgLy8gU2V0IGxpbmVkIGVsZW1lbnRcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdocmVmJywgKGZpbGUgfHwgJycpICsgJyMnICsgZWxlbWVudCwgeGxpbmspXG4gIH1cbn1cblxucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgLy8gQ3JlYXRlIGEgdXNlIGVsZW1lbnRcbiAgICB1c2U6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uIChlbGVtZW50LCBmaWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFVzZSgpKS51c2UoZWxlbWVudCwgZmlsZSlcbiAgICB9KVxuICB9XG59KVxuXG5yZWdpc3RlcihVc2UsICdVc2UnKVxuIiwiLyogT3B0aW9uYWwgTW9kdWxlcyAqL1xuaW1wb3J0ICcuL21vZHVsZXMvb3B0aW9uYWwvYXJyYW5nZS5qcydcbmltcG9ydCAnLi9tb2R1bGVzL29wdGlvbmFsL2NsYXNzLmpzJ1xuaW1wb3J0ICcuL21vZHVsZXMvb3B0aW9uYWwvY3NzLmpzJ1xuaW1wb3J0ICcuL21vZHVsZXMvb3B0aW9uYWwvZGF0YS5qcydcbmltcG9ydCAnLi9tb2R1bGVzL29wdGlvbmFsL21lbW9yeS5qcydcbmltcG9ydCAnLi9tb2R1bGVzL29wdGlvbmFsL3N1Z2FyLmpzJ1xuaW1wb3J0ICcuL21vZHVsZXMvb3B0aW9uYWwvdHJhbnNmb3JtLmpzJ1xuXG5pbXBvcnQgeyBleHRlbmQsIG1ha2VJbnN0YW5jZSB9IGZyb20gJy4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCB7IGdldE1ldGhvZE5hbWVzLCBnZXRNZXRob2RzRm9yIH0gZnJvbSAnLi91dGlscy9tZXRob2RzLmpzJ1xuaW1wb3J0IEJveCBmcm9tICcuL3R5cGVzL0JveC5qcydcbmltcG9ydCBDb2xvciBmcm9tICcuL3R5cGVzL0NvbG9yLmpzJ1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL2VsZW1lbnRzL0NvbnRhaW5lci5qcydcbmltcG9ydCBEZWZzIGZyb20gJy4vZWxlbWVudHMvRGVmcy5qcydcbmltcG9ydCBEb20gZnJvbSAnLi9lbGVtZW50cy9Eb20uanMnXG5pbXBvcnQgRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL0VsZW1lbnQuanMnXG5pbXBvcnQgRWxsaXBzZSBmcm9tICcuL2VsZW1lbnRzL0VsbGlwc2UuanMnXG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnLi90eXBlcy9FdmVudFRhcmdldC5qcydcbmltcG9ydCBGcmFnbWVudCBmcm9tICcuL2VsZW1lbnRzL0ZyYWdtZW50LmpzJ1xuaW1wb3J0IEdyYWRpZW50IGZyb20gJy4vZWxlbWVudHMvR3JhZGllbnQuanMnXG5pbXBvcnQgSW1hZ2UgZnJvbSAnLi9lbGVtZW50cy9JbWFnZS5qcydcbmltcG9ydCBMaW5lIGZyb20gJy4vZWxlbWVudHMvTGluZS5qcydcbmltcG9ydCBMaXN0IGZyb20gJy4vdHlwZXMvTGlzdC5qcydcbmltcG9ydCBNYXJrZXIgZnJvbSAnLi9lbGVtZW50cy9NYXJrZXIuanMnXG5pbXBvcnQgTWF0cml4IGZyb20gJy4vdHlwZXMvTWF0cml4LmpzJ1xuaW1wb3J0IE1vcnBoYWJsZSwge1xuICBOb25Nb3JwaGFibGUsXG4gIE9iamVjdEJhZyxcbiAgVHJhbnNmb3JtQmFnLFxuICBtYWtlTW9ycGhhYmxlLFxuICByZWdpc3Rlck1vcnBoYWJsZVR5cGVcbn0gZnJvbSAnLi9hbmltYXRpb24vTW9ycGhhYmxlLmpzJ1xuaW1wb3J0IFBhdGggZnJvbSAnLi9lbGVtZW50cy9QYXRoLmpzJ1xuaW1wb3J0IFBhdGhBcnJheSBmcm9tICcuL3R5cGVzL1BhdGhBcnJheS5qcydcbmltcG9ydCBQYXR0ZXJuIGZyb20gJy4vZWxlbWVudHMvUGF0dGVybi5qcydcbmltcG9ydCBQb2ludEFycmF5IGZyb20gJy4vdHlwZXMvUG9pbnRBcnJheS5qcydcbmltcG9ydCBQb2ludCBmcm9tICcuL3R5cGVzL1BvaW50LmpzJ1xuaW1wb3J0IFBvbHlnb24gZnJvbSAnLi9lbGVtZW50cy9Qb2x5Z29uLmpzJ1xuaW1wb3J0IFBvbHlsaW5lIGZyb20gJy4vZWxlbWVudHMvUG9seWxpbmUuanMnXG5pbXBvcnQgUmVjdCBmcm9tICcuL2VsZW1lbnRzL1JlY3QuanMnXG5pbXBvcnQgUnVubmVyIGZyb20gJy4vYW5pbWF0aW9uL1J1bm5lci5qcydcbmltcG9ydCBTVkdBcnJheSBmcm9tICcuL3R5cGVzL1NWR0FycmF5LmpzJ1xuaW1wb3J0IFNWR051bWJlciBmcm9tICcuL3R5cGVzL1NWR051bWJlci5qcydcbmltcG9ydCBTaGFwZSBmcm9tICcuL2VsZW1lbnRzL1NoYXBlLmpzJ1xuaW1wb3J0IFN2ZyBmcm9tICcuL2VsZW1lbnRzL1N2Zy5qcydcbmltcG9ydCBTeW1ib2wgZnJvbSAnLi9lbGVtZW50cy9TeW1ib2wuanMnXG5pbXBvcnQgVGV4dCBmcm9tICcuL2VsZW1lbnRzL1RleHQuanMnXG5pbXBvcnQgVHNwYW4gZnJvbSAnLi9lbGVtZW50cy9Uc3Bhbi5qcydcbmltcG9ydCAqIGFzIGRlZmF1bHRzIGZyb20gJy4vbW9kdWxlcy9jb3JlL2RlZmF1bHRzLmpzJ1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi91dGlscy91dGlscy5qcydcbmltcG9ydCAqIGFzIG5hbWVzcGFjZXMgZnJvbSAnLi9tb2R1bGVzL2NvcmUvbmFtZXNwYWNlcy5qcydcbmltcG9ydCAqIGFzIHJlZ2V4IGZyb20gJy4vbW9kdWxlcy9jb3JlL3JlZ2V4LmpzJ1xuXG5leHBvcnQge1xuICBNb3JwaGFibGUsXG4gIHJlZ2lzdGVyTW9ycGhhYmxlVHlwZSxcbiAgbWFrZU1vcnBoYWJsZSxcbiAgVHJhbnNmb3JtQmFnLFxuICBPYmplY3RCYWcsXG4gIE5vbk1vcnBoYWJsZVxufVxuXG5leHBvcnQgeyBkZWZhdWx0cywgdXRpbHMsIG5hbWVzcGFjZXMsIHJlZ2V4IH1cbmV4cG9ydCBjb25zdCBTVkcgPSBtYWtlSW5zdGFuY2VcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFyc2VyIH0gZnJvbSAnLi9tb2R1bGVzL2NvcmUvcGFyc2VyLmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmaW5kIH0gZnJvbSAnLi9tb2R1bGVzL2NvcmUvc2VsZWN0b3IuanMnXG5leHBvcnQgKiBmcm9tICcuL21vZHVsZXMvY29yZS9ldmVudC5qcydcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvYWRvcHRlci5qcydcbmV4cG9ydCB7XG4gIGdldFdpbmRvdyxcbiAgcmVnaXN0ZXJXaW5kb3csXG4gIHJlc3RvcmVXaW5kb3csXG4gIHNhdmVXaW5kb3csXG4gIHdpdGhXaW5kb3dcbn0gZnJvbSAnLi91dGlscy93aW5kb3cuanMnXG5cbi8qIEFuaW1hdGlvbiBNb2R1bGVzICovXG5leHBvcnQgeyBkZWZhdWx0IGFzIEFuaW1hdG9yIH0gZnJvbSAnLi9hbmltYXRpb24vQW5pbWF0b3IuanMnXG5leHBvcnQge1xuICBDb250cm9sbGVyLFxuICBFYXNlLFxuICBQSUQsXG4gIFNwcmluZyxcbiAgZWFzaW5nXG59IGZyb20gJy4vYW5pbWF0aW9uL0NvbnRyb2xsZXIuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIFF1ZXVlIH0gZnJvbSAnLi9hbmltYXRpb24vUXVldWUuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIFJ1bm5lciB9IGZyb20gJy4vYW5pbWF0aW9uL1J1bm5lci5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGltZWxpbmUgfSBmcm9tICcuL2FuaW1hdGlvbi9UaW1lbGluZS5qcydcblxuLyogVHlwZXMgKi9cbmV4cG9ydCB7IGRlZmF1bHQgYXMgQXJyYXkgfSBmcm9tICcuL3R5cGVzL1NWR0FycmF5LmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCb3ggfSBmcm9tICcuL3R5cGVzL0JveC5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29sb3IgfSBmcm9tICcuL3R5cGVzL0NvbG9yLmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFdmVudFRhcmdldCB9IGZyb20gJy4vdHlwZXMvRXZlbnRUYXJnZXQuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIE1hdHJpeCB9IGZyb20gJy4vdHlwZXMvTWF0cml4LmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBOdW1iZXIgfSBmcm9tICcuL3R5cGVzL1NWR051bWJlci5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUGF0aEFycmF5IH0gZnJvbSAnLi90eXBlcy9QYXRoQXJyYXkuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIFBvaW50IH0gZnJvbSAnLi90eXBlcy9Qb2ludC5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUG9pbnRBcnJheSB9IGZyb20gJy4vdHlwZXMvUG9pbnRBcnJheS5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGlzdCB9IGZyb20gJy4vdHlwZXMvTGlzdC5qcydcblxuLyogRWxlbWVudHMgKi9cbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2lyY2xlIH0gZnJvbSAnLi9lbGVtZW50cy9DaXJjbGUuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIENsaXBQYXRoIH0gZnJvbSAnLi9lbGVtZW50cy9DbGlwUGF0aC5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29udGFpbmVyIH0gZnJvbSAnLi9lbGVtZW50cy9Db250YWluZXIuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIERlZnMgfSBmcm9tICcuL2VsZW1lbnRzL0RlZnMuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIERvbSB9IGZyb20gJy4vZWxlbWVudHMvRG9tLmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFbGVtZW50IH0gZnJvbSAnLi9lbGVtZW50cy9FbGVtZW50LmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFbGxpcHNlIH0gZnJvbSAnLi9lbGVtZW50cy9FbGxpcHNlLmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGb3JlaWduT2JqZWN0IH0gZnJvbSAnLi9lbGVtZW50cy9Gb3JlaWduT2JqZWN0LmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGcmFnbWVudCB9IGZyb20gJy4vZWxlbWVudHMvRnJhZ21lbnQuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIEdyYWRpZW50IH0gZnJvbSAnLi9lbGVtZW50cy9HcmFkaWVudC5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRyB9IGZyb20gJy4vZWxlbWVudHMvRy5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQSB9IGZyb20gJy4vZWxlbWVudHMvQS5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSW1hZ2UgfSBmcm9tICcuL2VsZW1lbnRzL0ltYWdlLmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaW5lIH0gZnJvbSAnLi9lbGVtZW50cy9MaW5lLmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXJrZXIgfSBmcm9tICcuL2VsZW1lbnRzL01hcmtlci5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWFzayB9IGZyb20gJy4vZWxlbWVudHMvTWFzay5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUGF0aCB9IGZyb20gJy4vZWxlbWVudHMvUGF0aC5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUGF0dGVybiB9IGZyb20gJy4vZWxlbWVudHMvUGF0dGVybi5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUG9seWdvbiB9IGZyb20gJy4vZWxlbWVudHMvUG9seWdvbi5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUG9seWxpbmUgfSBmcm9tICcuL2VsZW1lbnRzL1BvbHlsaW5lLmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSZWN0IH0gZnJvbSAnLi9lbGVtZW50cy9SZWN0LmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTaGFwZSB9IGZyb20gJy4vZWxlbWVudHMvU2hhcGUuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIFN0b3AgfSBmcm9tICcuL2VsZW1lbnRzL1N0b3AuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIFN0eWxlIH0gZnJvbSAnLi9lbGVtZW50cy9TdHlsZS5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3ZnIH0gZnJvbSAnLi9lbGVtZW50cy9TdmcuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIFN5bWJvbCB9IGZyb20gJy4vZWxlbWVudHMvU3ltYm9sLmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUZXh0IH0gZnJvbSAnLi9lbGVtZW50cy9UZXh0LmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUZXh0UGF0aCB9IGZyb20gJy4vZWxlbWVudHMvVGV4dFBhdGguanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIFRzcGFuIH0gZnJvbSAnLi9lbGVtZW50cy9Uc3Bhbi5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVXNlIH0gZnJvbSAnLi9lbGVtZW50cy9Vc2UuanMnXG5cbmV4dGVuZChbU3ZnLCBTeW1ib2wsIEltYWdlLCBQYXR0ZXJuLCBNYXJrZXJdLCBnZXRNZXRob2RzRm9yKCd2aWV3Ym94JykpXG5cbmV4dGVuZChbTGluZSwgUG9seWxpbmUsIFBvbHlnb24sIFBhdGhdLCBnZXRNZXRob2RzRm9yKCdtYXJrZXInKSlcblxuZXh0ZW5kKFRleHQsIGdldE1ldGhvZHNGb3IoJ1RleHQnKSlcbmV4dGVuZChQYXRoLCBnZXRNZXRob2RzRm9yKCdQYXRoJykpXG5cbmV4dGVuZChEZWZzLCBnZXRNZXRob2RzRm9yKCdEZWZzJykpXG5cbmV4dGVuZChbVGV4dCwgVHNwYW5dLCBnZXRNZXRob2RzRm9yKCdUc3BhbicpKVxuXG5leHRlbmQoW1JlY3QsIEVsbGlwc2UsIEdyYWRpZW50LCBSdW5uZXJdLCBnZXRNZXRob2RzRm9yKCdyYWRpdXMnKSlcblxuZXh0ZW5kKEV2ZW50VGFyZ2V0LCBnZXRNZXRob2RzRm9yKCdFdmVudFRhcmdldCcpKVxuZXh0ZW5kKERvbSwgZ2V0TWV0aG9kc0ZvcignRG9tJykpXG5leHRlbmQoRWxlbWVudCwgZ2V0TWV0aG9kc0ZvcignRWxlbWVudCcpKVxuZXh0ZW5kKFNoYXBlLCBnZXRNZXRob2RzRm9yKCdTaGFwZScpKVxuZXh0ZW5kKFtDb250YWluZXIsIEZyYWdtZW50XSwgZ2V0TWV0aG9kc0ZvcignQ29udGFpbmVyJykpXG5leHRlbmQoR3JhZGllbnQsIGdldE1ldGhvZHNGb3IoJ0dyYWRpZW50JykpXG5cbmV4dGVuZChSdW5uZXIsIGdldE1ldGhvZHNGb3IoJ1J1bm5lcicpKVxuXG5MaXN0LmV4dGVuZChnZXRNZXRob2ROYW1lcygpKVxuXG5yZWdpc3Rlck1vcnBoYWJsZVR5cGUoW1xuICBTVkdOdW1iZXIsXG4gIENvbG9yLFxuICBCb3gsXG4gIE1hdHJpeCxcbiAgU1ZHQXJyYXksXG4gIFBvaW50QXJyYXksXG4gIFBhdGhBcnJheSxcbiAgUG9pbnRcbl0pXG5cbm1ha2VNb3JwaGFibGUoKVxuIiwiaW1wb3J0IHsgQ2lyY2xlLCBHLCBUZXh0IH0gZnJvbSBcIkBzdmdkb3Rqcy9zdmcuanNcIjtcclxuaW1wb3J0IHsgTkJTUCB9IGZyb20gXCIuLi8uLi9zcmMvZW5naW5lXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVGV4dENpcmNsZSBleHRlbmRzIEcge1xyXG4gICRjaXJjbGU6IENpcmNsZSB8IG51bGwgPSBudWxsO1xyXG4gICR0ZXh0OiBUZXh0IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIGluaXQoXHJcbiAgICB0ZXh0OiBzdHJpbmcsXHJcbiAgICB4OiBudW1iZXIsXHJcbiAgICB5OiBudW1iZXIsXHJcbiAgICBzaXplOiBudW1iZXIsXHJcbiAgICBzdHJva2VXaWR0aDogbnVtYmVyXHJcbiAgKTogdGhpcyB7XHJcbiAgICB0aGlzLiRjaXJjbGUgPSB0aGlzLmNpcmNsZShzaXplKVxyXG4gICAgICAuc3Ryb2tlKHsgd2lkdGg6IHN0cm9rZVdpZHRoIH0pXHJcbiAgICAgIC5jZW50ZXIoMCwgMCk7XHJcbiAgICB0aGlzLiR0ZXh0ID0gdGhpcy50ZXh0KHRleHQpLmNlbnRlcigwLCAwKTtcclxuICAgIGlmICh4ICYmIHkpIHRoaXMuY2VudGVyKHgsIHkpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBnZXRUZXh0KCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy4kdGV4dD8udGV4dCgpIHx8IFwiXCI7XHJcbiAgfVxyXG5cclxuICBzZXRUZXh0KHRleHQ6IHN0cmluZyk6IHRoaXMge1xyXG4gICAgaWYgKHRleHQgPT0gbnVsbCkgdGV4dCA9IFwiXCI7XHJcbiAgICB0ZXh0ID0gYCR7dGV4dH1gO1xyXG4gICAgLy8gTm9uLWJyZWFraW5nIHNwYWNlOiBXZSBuZWVkIHRvIGhhdmUgc29tZSB0ZXh0LCBvdGhlcndpc2UgdGhlIGNvb3JkaW5hdGVzIGFyZSByZXNldCB0byAoMCwgMClcclxuICAgIGlmICh0ZXh0ID09PSBcIlwiKSB0ZXh0ID0gTkJTUDtcclxuICAgIHRoaXMuJHRleHQ/LnRleHQodGV4dCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGdldFNpemUoKTogbnVtYmVyIHtcclxuICAgIGNvbnN0IHIgPSB0aGlzLmF0dHIoXCJyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiByID09PSBcIm51bWJlclwiKSByZXR1cm4gciAqIDI7XHJcbiAgICBpZiAodHlwZW9mIHIgPT09IFwic3RyaW5nXCIgJiYgIWlzTmFOKE51bWJlcihyKSkpIHJldHVybiBOdW1iZXIocikgKiAyO1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICBzZXRTaXplKGRpYW1ldGVyOiBudW1iZXIsIGFuaW1hdGlvbkR1cmF0aW9uOiBudW1iZXIgPSAwKTogdGhpcyB7XHJcbiAgICB0aGlzLmFuaW1hdGUoYW5pbWF0aW9uRHVyYXRpb24pLmF0dHIoXCJyXCIsIFN0cmluZyhkaWFtZXRlciAvIDIpKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRleHQoKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgZmluZCwgUGF0aCB9IGZyb20gXCJAc3ZnZG90anMvc3ZnLmpzXCI7XHJcbmltcG9ydCB7IENvbm5lY3Rpb24gfSBmcm9tIFwiLi9jb25uZWN0aW9uXCI7XHJcbmltcG9ydCB7IFRleHRDaXJjbGUgfSBmcm9tIFwiLi90ZXh0LWNpcmNsZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEdyYXBoTm9kZSBleHRlbmRzIFRleHRDaXJjbGUge1xyXG4gICRpbmNvbWluZzogUmVjb3JkPHN0cmluZywgQ29ubmVjdGlvbjxHcmFwaE5vZGU+IHwgbnVsbD4gPSB7fTtcclxuICAkb3V0Z29pbmc6IFJlY29yZDxzdHJpbmcsIENvbm5lY3Rpb248R3JhcGhOb2RlPiB8IG51bGw+ID0ge307XHJcbiAgJG51bGxhcnk6IFJlY29yZDxzdHJpbmcsIFBhdGggfCBudWxsPiA9IHt9O1xyXG5cclxuICBpbml0KFxyXG4gICAgdGV4dDogc3RyaW5nLFxyXG4gICAgeDogbnVtYmVyLFxyXG4gICAgeTogbnVtYmVyLFxyXG4gICAgc2l6ZTogbnVtYmVyLFxyXG4gICAgc3Ryb2tlV2lkdGg6IG51bWJlclxyXG4gICk6IHRoaXMge1xyXG4gICAgY29uc3QgYmdTaXplID0gMyAqIHNpemU7XHJcbiAgICB0aGlzLnJlY3QoYmdTaXplLCBiZ1NpemUpLmNlbnRlcigwLCAwKS5hZGRDbGFzcyhcImludmlzaWJsZVwiKTtcclxuICAgIHJldHVybiBzdXBlci5pbml0KHRleHQsIHgsIHksIHNpemUsIHN0cm9rZVdpZHRoKTtcclxuICB9XHJcblxyXG4gIGdldEJlbmQoa2V5OiB1bmtub3duKTogbnVtYmVyIHtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgZ2V0RGlyZWN0ZWQoa2V5OiB1bmtub3duKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGdldEluY29taW5nKGluS2V5OiBzdHJpbmcpOiBDb25uZWN0aW9uPEdyYXBoTm9kZT4gfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLiRpbmNvbWluZ1tpbktleV07XHJcbiAgfVxyXG5cclxuICBnZXRPdXRnb2luZyhvdXRLZXk6IHN0cmluZyk6IENvbm5lY3Rpb248R3JhcGhOb2RlPiB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuJG91dGdvaW5nW291dEtleV07XHJcbiAgfVxyXG5cclxuICBnZXRJbmNvbWluZ0VkZ2VzKCk6IENvbm5lY3Rpb248R3JhcGhOb2RlPltdIHtcclxuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuJGluY29taW5nKS5maWx0ZXIoKGUpID0+IGUgIT09IG51bGwpO1xyXG4gIH1cclxuXHJcbiAgZ2V0T3V0Z29pbmdFZGdlcygpOiBDb25uZWN0aW9uPEdyYXBoTm9kZT5bXSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLiRvdXRnb2luZykuZmlsdGVyKChlKSA9PiBlICE9PSBudWxsKTtcclxuICB9XHJcblxyXG4gIGdldFByZWRlY2Vzc29ycygpOiBHcmFwaE5vZGVbXSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLiRpbmNvbWluZylcclxuICAgICAgLm1hcCgoZSkgPT4gZT8uZ2V0U3RhcnQoKSlcclxuICAgICAgLmZpbHRlcigoZSkgPT4gZSAhPT0gdW5kZWZpbmVkICYmIGUgIT09IG51bGwpO1xyXG4gIH1cclxuXHJcbiAgZ2V0U3VjY2Vzc29ycygpOiBHcmFwaE5vZGVbXSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLiRvdXRnb2luZylcclxuICAgICAgLm1hcCgoZSkgPT4gZT8uZ2V0RW5kKCkpXHJcbiAgICAgIC5maWx0ZXIoKGUpID0+IGUgIT09IHVuZGVmaW5lZCAmJiBlICE9PSBudWxsKTtcclxuICB9XHJcblxyXG4gIGdldFByZWRlY2Vzc29yKGluS2V5OiBzdHJpbmcpOiBHcmFwaE5vZGUgfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLiRpbmNvbWluZ1tpbktleV0/LmdldFN0YXJ0KCkgfHwgbnVsbDtcclxuICB9XHJcblxyXG4gIGdldFN1Y2Nlc3NvcihvdXRLZXk6IHN0cmluZyk6IEdyYXBoTm9kZSB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuJG91dGdvaW5nW291dEtleV0/LmdldEVuZCgpIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICBzZXRQcmVkZWNlc3NvcihcclxuICAgIGluS2V5OiBzdHJpbmcsXHJcbiAgICBvdXRLZXk6IHN0cmluZyxcclxuICAgIHByZWRlY2Vzc29yOiBHcmFwaE5vZGUsXHJcbiAgICBzdHJva2VXaWR0aDogbnVtYmVyXHJcbiAgKTogdGhpcyB7XHJcbiAgICBwcmVkZWNlc3Nvci5zZXRTdWNjZXNzb3Iob3V0S2V5LCBpbktleSwgdGhpcywgc3Ryb2tlV2lkdGgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBzZXRTdWNjZXNzb3IoXHJcbiAgICBvdXRLZXk6IHN0cmluZyxcclxuICAgIGluS2V5OiBzdHJpbmcsXHJcbiAgICBzdWNjZXNzb3I6IEdyYXBoTm9kZSxcclxuICAgIHN0cm9rZVdpZHRoOiBudW1iZXJcclxuICApOiB0aGlzIHtcclxuICAgIGNvbnN0IG91dEVkZ2UgPSB0aGlzLiRvdXRnb2luZ1tvdXRLZXldO1xyXG4gICAgaWYgKG91dEVkZ2UpIHtcclxuICAgICAgY29uc3Qgb2xkU3VjY2Vzc29yID0gb3V0RWRnZS5nZXRFbmQoKTtcclxuICAgICAgY29uc3Qgb2xkSW5jb21pbmcgPSBvbGRTdWNjZXNzb3I/LiRpbmNvbWluZztcclxuICAgICAgZm9yIChjb25zdCBrIGluIG9sZEluY29taW5nKSB7XHJcbiAgICAgICAgaWYgKG9sZEluY29taW5nW2tdID09PSBvdXRFZGdlKSBkZWxldGUgb2xkSW5jb21pbmdba107XHJcbiAgICAgIH1cclxuICAgICAgb3V0RWRnZS5yZW1vdmUoKTtcclxuICAgIH1cclxuICAgIGlmIChzdWNjZXNzb3IpIHtcclxuICAgICAgY29uc3QgaW5FZGdlID0gc3VjY2Vzc29yLiRpbmNvbWluZ1tpbktleV07XHJcbiAgICAgIGlmIChpbkVkZ2UpIHtcclxuICAgICAgICBjb25zdCBvbGRQcmVkZWNlc3NvciA9IGluRWRnZS5nZXRTdGFydCgpO1xyXG4gICAgICAgIGNvbnN0IG9sZE91dGdvaW5nID0gb2xkUHJlZGVjZXNzb3I/LiRvdXRnb2luZztcclxuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gb2xkT3V0Z29pbmcpIHtcclxuICAgICAgICAgIGlmIChvbGRPdXRnb2luZ1trXSA9PT0gaW5FZGdlKSBkZWxldGUgb2xkT3V0Z29pbmdba107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluRWRnZS5yZW1vdmUoKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBlZGdlID0gdGhpcy5yb290KCkuY29ubmVjdGlvbihcclxuICAgICAgICB0aGlzLFxyXG4gICAgICAgIHN1Y2Nlc3NvcixcclxuICAgICAgICBzdHJva2VXaWR0aCxcclxuICAgICAgICB0aGlzLmdldEJlbmQob3V0S2V5KSxcclxuICAgICAgICB0aGlzLmdldERpcmVjdGVkKG91dEtleSlcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHRoaXMuJG91dGdvaW5nW291dEtleV0gPSBlZGdlO1xyXG4gICAgICBzdWNjZXNzb3IuJGluY29taW5nW2luS2V5XSA9IGVkZ2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkZWxldGUgdGhpcy4kb3V0Z29pbmdbb3V0S2V5XTtcclxuICAgIH1cclxuICAgIHRoaXMuX3VwZGF0ZU51bGxhcnkoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZU51bGxhcnkoKTogdm9pZCB7XHJcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgZmluZChcImdcIikpIHtcclxuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBHcmFwaE5vZGUpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGMgaW4gbm9kZS4kbnVsbGFyeSkge1xyXG4gICAgICAgICAgY29uc3Qgc2hvdyA9ICFub2RlLiRvdXRnb2luZ1tjXTtcclxuICAgICAgICAgIGlmIChzaG93KSBub2RlLiRudWxsYXJ5W2NdPy5yZW1vdmVDbGFzcyhcImludmlzaWJsZVwiKTtcclxuICAgICAgICAgIGVsc2Ugbm9kZS4kbnVsbGFyeVtjXT8uYWRkQ2xhc3MoXCJpbnZpc2libGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXRJbmNvbWluZ0hpZ2hsaWdodChpbktleTogc3RyaW5nLCBoaWdoOiBib29sZWFuIHwgbnVsbCk6IHRoaXMge1xyXG4gICAgdGhpcy5zZXRIaWdobGlnaHQoaGlnaCk7XHJcbiAgICB0aGlzLmdldEluY29taW5nKGluS2V5KT8uc2V0SGlnaGxpZ2h0KGhpZ2gpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBnZXRIaWdobGlnaHQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5oYXNDbGFzcyhcImhpZ2hsaWdodFwiKTtcclxuICB9XHJcbiAgc2V0T3V0Z29pbmdIaWdobGlnaHQob3V0S2V5OiBzdHJpbmcsIGhpZ2g6IGJvb2xlYW4gfCBudWxsKTogdGhpcyB7XHJcbiAgICB0aGlzLnNldEhpZ2hsaWdodChoaWdoKTtcclxuICAgIHRoaXMuZ2V0T3V0Z29pbmcob3V0S2V5KT8uc2V0SGlnaGxpZ2h0KGhpZ2gpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPOiBCZXR0ZXIgbmFtaW5nOiBSZW1vdmUgd2hhdD8gSXRzZWxmXHJcbiAgLy8gVE9ETzogUmVmYWN0b3IgdG8gdXNlIGZvcmVhY2ggbG9vcD9cclxuICByZW1vdmUoKTogdGhpcyB7XHJcbiAgICBmb3IgKGNvbnN0IG91dEtleSBpbiB0aGlzLiRvdXRnb2luZykge1xyXG4gICAgICBjb25zdCBvdXRFZGdlID0gdGhpcy4kb3V0Z29pbmdbb3V0S2V5XTtcclxuICAgICAgaWYgKCFvdXRFZGdlKSBjb250aW51ZTtcclxuICAgICAgY29uc3QgZW5kID0gb3V0RWRnZS5nZXRFbmQoKTtcclxuICAgICAgY29uc3QgaW5jb21pbmcgPSBlbmQ/LiRpbmNvbWluZztcclxuICAgICAgZm9yIChjb25zdCBpbktleSBpbiBpbmNvbWluZykge1xyXG4gICAgICAgIGlmIChvdXRFZGdlID09PSBpbmNvbWluZ1tpbktleV0pIHtcclxuICAgICAgICAgIGRlbGV0ZSBpbmNvbWluZ1tpbktleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG91dEVkZ2UucmVtb3ZlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgaW5LZXkgaW4gdGhpcy4kaW5jb21pbmcpIHtcclxuICAgICAgY29uc3QgaW5FZGdlID0gdGhpcy4kaW5jb21pbmdbaW5LZXldO1xyXG4gICAgICBpZiAoIWluRWRnZSkgY29udGludWU7XHJcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaW5FZGdlLmdldFN0YXJ0KCk7XHJcbiAgICAgIGNvbnN0IG91dGdvaW5nID0gc3RhcnQ/LiRvdXRnb2luZztcclxuICAgICAgZm9yIChjb25zdCBvdXRLZXkgaW4gb3V0Z29pbmcpIHtcclxuICAgICAgICBpZiAoaW5FZGdlID09PSBvdXRnb2luZ1tvdXRLZXldKSB7XHJcbiAgICAgICAgICBkZWxldGUgb3V0Z29pbmdbb3V0S2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5FZGdlLnJlbW92ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBzdXBlci5yZW1vdmUoKTtcclxuICAgIHRoaXMuX3VwZGF0ZU51bGxhcnkoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgc2V0Q2VudGVyKHg6IG51bWJlciwgeTogbnVtYmVyLCBhbmltYXRpb25EdXJhdGlvbjogbnVtYmVyID0gMCk6IHRoaXMge1xyXG4gICAgc3VwZXIuc2V0Q2VudGVyKHgsIHksIGFuaW1hdGlvbkR1cmF0aW9uKTtcclxuICAgIGZvciAoY29uc3QgZWRnZSBvZiB0aGlzLmdldE91dGdvaW5nRWRnZXMoKSkge1xyXG4gICAgICBlZGdlLnVwZGF0ZSh7IHgxOiB4LCB5MTogeSB9LCBhbmltYXRpb25EdXJhdGlvbik7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgdGhpcy5nZXRJbmNvbWluZ0VkZ2VzKCkpIHtcclxuICAgICAgZWRnZS51cGRhdGUoeyB4MjogeCwgeTI6IHkgfSwgYW5pbWF0aW9uRHVyYXRpb24pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBzZXRTaXplKHNpemU6IG51bWJlciwgYW5pbWF0aW9uRHVyYXRpb246IG51bWJlciA9IDApOiB0aGlzIHtcclxuICAgIHN1cGVyLnNldFNpemUoc2l6ZSwgYW5pbWF0aW9uRHVyYXRpb24pO1xyXG4gICAgZm9yIChjb25zdCBlZGdlIG9mIHRoaXMuZ2V0SW5jb21pbmdFZGdlcygpKSB7XHJcbiAgICAgIGVkZ2UudXBkYXRlKHsgcjI6IHNpemUgLyAyIH0sIGFuaW1hdGlvbkR1cmF0aW9uKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBQYXRoIH0gZnJvbSBcIkBzdmdkb3Rqcy9zdmcuanNcIjtcclxuaW1wb3J0IHsgQ29ubmVjdGlvbiB9IGZyb20gXCIuL2Nvbm5lY3Rpb25cIjtcclxuaW1wb3J0IHsgR3JhcGhOb2RlIH0gZnJvbSBcIi4vZ3JhcGgtbm9kZVwiO1xyXG5cclxudHlwZSBDaGlsZHJlbiA9IFwibGVmdFwiIHwgXCJyaWdodFwiO1xyXG5leHBvcnQgY2xhc3MgQmluYXJ5Tm9kZSBleHRlbmRzIEdyYXBoTm9kZSB7XHJcbiAgJGluY29taW5nOiB7IHBhcmVudDogQ29ubmVjdGlvbjxCaW5hcnlOb2RlPiB8IG51bGwgfSA9IHtcclxuICAgIHBhcmVudDogbnVsbCxcclxuICB9O1xyXG4gICRvdXRnb2luZzoge1xyXG4gICAgbGVmdDogQ29ubmVjdGlvbjxCaW5hcnlOb2RlPiB8IG51bGw7XHJcbiAgICByaWdodDogQ29ubmVjdGlvbjxCaW5hcnlOb2RlPiB8IG51bGw7XHJcbiAgfSA9IHtcclxuICAgIGxlZnQ6IG51bGwsXHJcbiAgICByaWdodDogbnVsbCxcclxuICB9O1xyXG4gICRudWxsYXJ5OiB7IGxlZnQ6IFBhdGggfCBudWxsOyByaWdodDogUGF0aCB8IG51bGwgfSA9IHtcclxuICAgIGxlZnQ6IG51bGwsXHJcbiAgICByaWdodDogbnVsbCxcclxuICB9O1xyXG4gICRlZGdlYmVuZHMgPSB7IGxlZnQ6IDAuMSwgcmlnaHQ6IC0wLjEgfTtcclxuICAkbGVmdFdpZHRoOiBudW1iZXIgPSAwO1xyXG4gICRyaWdodFdpZHRoOiBudW1iZXIgPSAwO1xyXG4gICR3aWR0aDogbnVtYmVyID0gMDtcclxuXHJcbiAgaW5pdChcclxuICAgIHRleHQ6IHN0cmluZyxcclxuICAgIHg6IG51bWJlcixcclxuICAgIHk6IG51bWJlcixcclxuICAgIHNpemU6IG51bWJlcixcclxuICAgIHN0cm9rZVdpZHRoOiBudW1iZXJcclxuICApOiB0aGlzIHtcclxuICAgIGNvbnN0IGQgPSBzaXplO1xyXG4gICAgY29uc3QgblggPSAwLjUgKiBkLFxyXG4gICAgICBuWSA9IDAuOCAqIGQsXHJcbiAgICAgIG5SID0gMiAqIHN0cm9rZVdpZHRoO1xyXG4gICAgY29uc3QgbnVsbHBhdGggPSAoczogbnVtYmVyKSA9PlxyXG4gICAgICBgTSAwLDAgTCAke3MgKiBuWH0sJHtuWX0gbSAke25SfSwwIGEgJHtuUn0sJHtuUn0gMCAxLDAgJHtcclxuICAgICAgICAtMiAqIG5SXHJcbiAgICAgIH0sMCBhICR7blJ9LCR7blJ9IDAgMSwwICR7MiAqIG5SfSwwYDtcclxuXHJcbiAgICB0aGlzLiRudWxsYXJ5LmxlZnQgPSB0aGlzLnBhdGgobnVsbHBhdGgoLTEpKVxyXG4gICAgICAuc3Ryb2tlKHsgd2lkdGg6IHN0cm9rZVdpZHRoIH0pXHJcbiAgICAgIC5hZGRDbGFzcyhcIm51bGxub2RlXCIpO1xyXG4gICAgdGhpcy4kbnVsbGFyeS5yaWdodCA9IHRoaXMucGF0aChudWxscGF0aCgxKSlcclxuICAgICAgLnN0cm9rZSh7IHdpZHRoOiBzdHJva2VXaWR0aCB9KVxyXG4gICAgICAuYWRkQ2xhc3MoXCJudWxsbm9kZVwiKTtcclxuICAgIHJldHVybiBzdXBlci5pbml0KHRleHQsIHgsIHksIHNpemUsIHN0cm9rZVdpZHRoKTtcclxuICB9XHJcblxyXG4gIGdldEJlbmQoYzogQ2hpbGRyZW4pOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuJGVkZ2ViZW5kc1tjXTtcclxuICB9XHJcblxyXG4gIGdldFBhcmVudCgpOiBCaW5hcnlOb2RlIHwgbnVsbCB7XHJcbiAgICByZXR1cm4gdGhpcy4kaW5jb21pbmcucGFyZW50Py5nZXRTdGFydCgpIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICBnZXRMZWZ0KCk6IEJpbmFyeU5vZGUgfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLiRvdXRnb2luZy5sZWZ0Py5nZXRFbmQoKSB8fCBudWxsO1xyXG4gIH1cclxuXHJcbiAgZ2V0UmlnaHQoKTogQmluYXJ5Tm9kZSB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuJG91dGdvaW5nLnJpZ2h0Py5nZXRFbmQoKSB8fCBudWxsO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q2hpbGQoYzogQ2hpbGRyZW4pOiBCaW5hcnlOb2RlIHwgbnVsbCB7XHJcbiAgICByZXR1cm4gdGhpcy4kb3V0Z29pbmdbY10/LmdldEVuZCgpIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICBnZXRTaWJsaW5nKCk6IEJpbmFyeU5vZGUgfCBudWxsIHtcclxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XHJcbiAgICBpZiAoIXBhcmVudCkgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gdGhpcyA9PT0gcGFyZW50LmdldExlZnQoKSA/IHBhcmVudC5nZXRSaWdodCgpIDogcGFyZW50LmdldExlZnQoKTtcclxuICB9XHJcblxyXG4gIGdldFBhcmVudEVkZ2UoKTogQ29ubmVjdGlvbjxCaW5hcnlOb2RlPiB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuJGluY29taW5nLnBhcmVudDtcclxuICB9XHJcblxyXG4gIGdldExlZnRFZGdlKCk6IENvbm5lY3Rpb248QmluYXJ5Tm9kZT4gfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLiRvdXRnb2luZy5sZWZ0O1xyXG4gIH1cclxuXHJcbiAgZ2V0UmlnaHRFZGdlKCk6IENvbm5lY3Rpb248QmluYXJ5Tm9kZT4gfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLiRvdXRnb2luZy5yaWdodDtcclxuICB9XHJcblxyXG4gIGdldENoaWxkRWRnZShjOiBDaGlsZHJlbik6IENvbm5lY3Rpb248QmluYXJ5Tm9kZT4gfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLiRvdXRnb2luZ1tjXTtcclxuICB9XHJcblxyXG4gIGlzTGVhZigpOiBib29sZWFuIHtcclxuICAgIHJldHVybiAhKHRoaXMuZ2V0TGVmdCgpIHx8IHRoaXMuZ2V0UmlnaHQoKSk7XHJcbiAgfVxyXG5cclxuICBpc0xlZnRDaGlsZCgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzID09PSB0aGlzLmdldFBhcmVudCgpPy5nZXRMZWZ0KCk7XHJcbiAgfVxyXG5cclxuICBpc1JpZ2h0Q2hpbGQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcyA9PT0gdGhpcy5nZXRQYXJlbnQoKT8uZ2V0UmlnaHQoKTtcclxuICB9XHJcblxyXG4gIGlzQ2hpbGQoYzogQ2hpbGRyZW4pOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzID09PSB0aGlzLmdldFBhcmVudCgpPy5nZXRDaGlsZChjKTtcclxuICB9XHJcblxyXG4gIHNldExlZnQoY2hpbGQ6IEJpbmFyeU5vZGUsIHN0cm9rZVdpZHRoOiBudW1iZXIpOiB0aGlzIHtcclxuICAgIHJldHVybiB0aGlzLnNldENoaWxkKFwibGVmdFwiLCBjaGlsZCwgc3Ryb2tlV2lkdGgpO1xyXG4gIH1cclxuXHJcbiAgc2V0UmlnaHQoY2hpbGQ6IEJpbmFyeU5vZGUsIHN0cm9rZVdpZHRoOiBudW1iZXIpOiB0aGlzIHtcclxuICAgIHJldHVybiB0aGlzLnNldENoaWxkKFwicmlnaHRcIiwgY2hpbGQsIHN0cm9rZVdpZHRoKTtcclxuICB9XHJcblxyXG4gIHNldENoaWxkKGM6IENoaWxkcmVuLCBjaGlsZDogQmluYXJ5Tm9kZSwgc3Ryb2tlV2lkdGg6IG51bWJlcik6IHRoaXMge1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0U3VjY2Vzc29yKGMsIFwicGFyZW50XCIsIGNoaWxkLCBzdHJva2VXaWR0aCk7XHJcbiAgfVxyXG5cclxuICBzZXRQYXJlbnRMZWZ0KHBhcmVudDogQmluYXJ5Tm9kZSwgc3Ryb2tlV2lkdGg6IG51bWJlcik6IHRoaXMge1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0UGFyZW50KFwibGVmdFwiLCBwYXJlbnQsIHN0cm9rZVdpZHRoKTtcclxuICB9XHJcblxyXG4gIHNldFBhcmVudFJpZ2h0KHBhcmVudDogQmluYXJ5Tm9kZSwgc3Ryb2tlV2lkdGg6IG51bWJlcik6IHRoaXMge1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0UGFyZW50KFwicmlnaHRcIiwgcGFyZW50LCBzdHJva2VXaWR0aCk7XHJcbiAgfVxyXG5cclxuICBzZXRQYXJlbnQoYzogQ2hpbGRyZW4sIHBhcmVudDogQmluYXJ5Tm9kZSwgc3Ryb2tlV2lkdGg6IG51bWJlcik6IHRoaXMge1xyXG4gICAgcGFyZW50LnNldENoaWxkKGMsIHRoaXMsIHN0cm9rZVdpZHRoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgc2V0UGFyZW50SGlnaGxpZ2h0KGhpZ2g6IGJvb2xlYW4gfCBudWxsKTogdGhpcyB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXRJbmNvbWluZ0hpZ2hsaWdodChcInBhcmVudFwiLCBoaWdoKTtcclxuICB9XHJcblxyXG4gIHNldFJpZ2h0SGlnaGxpZ2h0KGhpZ2g6IGJvb2xlYW4gfCBudWxsKTogdGhpcyB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXRDaGlsZEhpZ2hsaWdodChcInJpZ2h0XCIsIGhpZ2gpO1xyXG4gIH1cclxuXHJcbiAgc2V0TGVmdEhpZ2hsaWdodChoaWdoOiBib29sZWFuIHwgbnVsbCk6IHRoaXMge1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0Q2hpbGRIaWdobGlnaHQoXCJsZWZ0XCIsIGhpZ2gpO1xyXG4gIH1cclxuXHJcbiAgc2V0Q2hpbGRIaWdobGlnaHQoYzogQ2hpbGRyZW4sIGhpZ2g6IGJvb2xlYW4gfCBudWxsKTogdGhpcyB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXRPdXRnb2luZ0hpZ2hsaWdodChjLCBoaWdoKTtcclxuICB9XHJcblxyXG4gIGRlZXBTdHJpbmcoKTogc3RyaW5nIHtcclxuICAgIGxldCBzID0gXCJcIjtcclxuICAgIGlmICh0aGlzLmdldExlZnQoKSkgcyArPSBgKCR7dGhpcy5nZXRMZWZ0KCk/LmRlZXBTdHJpbmcoKX0pIGA7XHJcbiAgICBzICs9IHRoaXMuZ2V0VGV4dCgpO1xyXG4gICAgaWYgKHRoaXMuZ2V0UmlnaHQoKSkgcyArPSBgICgke3RoaXMuZ2V0UmlnaHQoKT8uZGVlcFN0cmluZygpfSlgO1xyXG4gICAgcmV0dXJuIHM7XHJcbiAgfVxyXG5cclxuICByZXNpemUoXHJcbiAgICBzdGFydFg6IG51bWJlcixcclxuICAgIHN0YXJ0WTogbnVtYmVyLFxyXG4gICAgc3ZnTWFyZ2luOiBudW1iZXIsXHJcbiAgICBub2RlU3BhY2luZzogbnVtYmVyLFxyXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IG51bWJlciA9IDBcclxuICApOiB0aGlzIHtcclxuICAgIHRoaXMuX3Jlc2l6ZVdpZHRocyhub2RlU3BhY2luZyk7XHJcbiAgICBjb25zdCBzdmdXaWR0aCA9IHRoaXMucm9vdCgpLnZpZXdib3goKS53aWR0aDtcclxuICAgIGlmIChzdGFydFggKyB0aGlzLiRyaWdodFdpZHRoID4gc3ZnV2lkdGggLSBzdmdNYXJnaW4pXHJcbiAgICAgIHN0YXJ0WCA9IHN2Z1dpZHRoIC0gdGhpcy4kcmlnaHRXaWR0aCAtIHN2Z01hcmdpbjtcclxuICAgIGlmIChzdGFydFggLSB0aGlzLiRsZWZ0V2lkdGggPCBzdmdNYXJnaW4pXHJcbiAgICAgIHN0YXJ0WCA9IHRoaXMuJGxlZnRXaWR0aCArIHN2Z01hcmdpbjtcclxuICAgIHRoaXMuX3NldE5ld1Bvc2l0aW9ucyhzdGFydFgsIHN0YXJ0WSwgbm9kZVNwYWNpbmcsIGFuaW1hdGlvbkR1cmF0aW9uKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gVE9ETzogTmFtaW5nIHNob3VsZCByZWZsZWN0IHRoYXQgbnVtYmVyIGlzIHJldHVybmVkXHJcbiAgX3Jlc2l6ZVdpZHRocyhub2RlU3BhY2luZzogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIGxldCB3aWR0aCA9IG5vZGVTcGFjaW5nO1xyXG4gICAgY29uc3QgbGVmdCA9IHRoaXMuZ2V0TGVmdCgpO1xyXG4gICAgaWYgKGxlZnQpIHdpZHRoICs9IGxlZnQuX3Jlc2l6ZVdpZHRocyhub2RlU3BhY2luZyk7XHJcbiAgICBjb25zdCByaWdodCA9IHRoaXMuZ2V0UmlnaHQoKTtcclxuICAgIGlmIChyaWdodCkgd2lkdGggKz0gcmlnaHQuX3Jlc2l6ZVdpZHRocyhub2RlU3BhY2luZyk7XHJcbiAgICB3aWR0aCA9IE1hdGgubWF4KHRoaXMuZ2V0U2l6ZSgpLCB3aWR0aCk7XHJcbiAgICBjb25zdCBsZWZ0V2lkdGggPSBsZWZ0Py4kbGVmdFdpZHRoIHx8IDA7XHJcbiAgICBjb25zdCByaWdodFdpZHRoID0gcmlnaHQ/LiRyaWdodFdpZHRoIHx8IDA7XHJcbiAgICBjb25zdCBtaWQgPSB3aWR0aCAtIGxlZnRXaWR0aCAtIHJpZ2h0V2lkdGg7XHJcbiAgICB0aGlzLiRsZWZ0V2lkdGggPSBtaWQgLyAyICsgbGVmdFdpZHRoO1xyXG4gICAgdGhpcy4kcmlnaHRXaWR0aCA9IG1pZCAvIDIgKyByaWdodFdpZHRoO1xyXG4gICAgdGhpcy4kd2lkdGggPSB3aWR0aDtcclxuICAgIHJldHVybiB3aWR0aDtcclxuICB9XHJcblxyXG4gIF9zZXROZXdQb3NpdGlvbnMoXHJcbiAgICB4OiBudW1iZXIsXHJcbiAgICB5OiBudW1iZXIsXHJcbiAgICBub2RlU3BhY2luZzogbnVtYmVyLFxyXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IG51bWJlciA9IDBcclxuICApOiB2b2lkIHtcclxuICAgIHRoaXMuc2V0Q2VudGVyKHgsIHksIGFuaW1hdGlvbkR1cmF0aW9uKTtcclxuICAgIGNvbnN0IHlTcGFjaW5nID0gbm9kZVNwYWNpbmc7XHJcbiAgICBjb25zdCBuZXh0WSA9IHkgKyB0aGlzLmdldFNpemUoKSArIHlTcGFjaW5nO1xyXG4gICAgY29uc3QgbGVmdCA9IHRoaXMuZ2V0TGVmdCgpO1xyXG4gICAgaWYgKGxlZnQpXHJcbiAgICAgIGxlZnQuX3NldE5ld1Bvc2l0aW9ucyhcclxuICAgICAgICB4IC0gdGhpcy4kbGVmdFdpZHRoICsgbGVmdC4kbGVmdFdpZHRoLFxyXG4gICAgICAgIG5leHRZLFxyXG4gICAgICAgIG5vZGVTcGFjaW5nLFxyXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uXHJcbiAgICAgICk7XHJcbiAgICBjb25zdCByaWdodCA9IHRoaXMuZ2V0UmlnaHQoKTtcclxuICAgIGlmIChyaWdodClcclxuICAgICAgcmlnaHQuX3NldE5ld1Bvc2l0aW9ucyhcclxuICAgICAgICB4ICsgdGhpcy4kcmlnaHRXaWR0aCAtIHJpZ2h0LiRyaWdodFdpZHRoLFxyXG4gICAgICAgIG5leHRZLFxyXG4gICAgICAgIG5vZGVTcGFjaW5nLFxyXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uXHJcbiAgICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPOiBOZXZlciB1c2VkPyB0aGlzLmdldEVkZ2VzIGRvZXMgbm90IGV4aXN0LlxyXG4gIHZhbGlkYXRlKCk6IHZvaWQge1xyXG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy4kaW5jb21pbmcucGFyZW50Py5nZXRTdGFydCgpO1xyXG4gICAgaWYgKHBhcmVudCkge1xyXG4gICAgICBwYXJlbnQuJGluY29taW5nO1xyXG4gICAgICBjb25zdCBjID0gdGhpcy5pc0xlZnRDaGlsZCgpID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCI7XHJcbiAgICAgIGlmIChwYXJlbnQuJG91dGdvaW5nW2NdPy5nZXRFbmQoKSAhPT0gdGhpcylcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiUGFyZW50IG1pc21hdGNoXCIpO1xyXG4gICAgICBsZXQgbiA9IDA7XHJcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVW5rbm93biBpZiBpdCBoYXMgZXZlciB3b3JrZWRcclxuICAgICAgZm9yIChjb25zdCBlZGdlIG9mIHRoaXMuZ2V0RWRnZXMoKSkge1xyXG4gICAgICAgIGlmIChlZGdlLmdldFN0YXJ0KCkgPT09IHBhcmVudCkge1xyXG4gICAgICAgICAgbisrO1xyXG4gICAgICAgICAgaWYgKGVkZ2UuZ2V0RW5kKCkgIT09IHRoaXMpIGNvbnNvbGUuZXJyb3IoXCJQYXJlbnQgZWRnZSBtaXNtYXRjaFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG4gIT09IDEpIGNvbnNvbGUuZXJyb3IoYFdyb25nIG46byBwYXJlbnQgZWRnZXMsICR7bn1gKTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgYyBvZiBbXCJsZWZ0XCIsIFwicmlnaHRcIl0pIHtcclxuICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLiRvdXRnb2luZ1tjIGFzIENoaWxkcmVuXT8uZ2V0RW5kKCk7XHJcbiAgICAgIGlmIChjaGlsZD8uJGluY29taW5nLnBhcmVudD8uZ2V0U3RhcnQoKSAhPT0gdGhpcylcclxuICAgICAgICBjb25zb2xlLmVycm9yKGAke2N9IGNoaWxkIG1pc21hdGNoYCk7XHJcbiAgICAgIGxldCBuID0gMDtcclxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBVbmtub3duIGlmIGl0IGhhcyBldmVyIHdvcmtlZFxyXG4gICAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgdGhpcy5nZXRFZGdlcygpKSB7XHJcbiAgICAgICAgaWYgKGVkZ2UuZ2V0RW5kKCkgPT09IGNoaWxkKSB7XHJcbiAgICAgICAgICBuKys7XHJcbiAgICAgICAgICBpZiAoZWRnZS5nZXRTdGFydCgpICE9PSB0aGlzKVxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGAke2N9IGNoaWxkIGVkZ2UgbWlzbWF0Y2hgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG4gIT09IDEpIGNvbnNvbGUuZXJyb3IoYFdyb25nIG46byAke2N9IGNoaWxkIGVkZ2VzLCAke259YCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IFRleHQgfSBmcm9tIFwiQHN2Z2RvdGpzL3N2Zy5qc1wiO1xyXG5pbXBvcnQgeyBCaW5hcnlOb2RlIH0gZnJvbSBcIi4vYmluYXJ5LW5vZGVcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBBVkxOb2RlIGV4dGVuZHMgQmluYXJ5Tm9kZSB7XHJcbiAgJGhlaWdodDogVGV4dCB8IG51bGwgPSBudWxsO1xyXG4gIGluaXQoXHJcbiAgICB0ZXh0OiBzdHJpbmcsXHJcbiAgICB4OiBudW1iZXIsXHJcbiAgICB5OiBudW1iZXIsXHJcbiAgICBzaXplOiBudW1iZXIsXHJcbiAgICBzdHJva2VXaWR0aDogbnVtYmVyXHJcbiAgKTogdGhpcyB7XHJcbiAgICBjb25zdCBkID0gc2l6ZTtcclxuICAgIHRoaXMuJGhlaWdodCA9IHRoaXMudGV4dChcIjFcIilcclxuICAgICAgLmNlbnRlcigtMC42ICogZCwgLTAuNSAqIGQpXHJcbiAgICAgIC5hZGRDbGFzcyhcImF2bGhlaWdodFwiKTtcclxuICAgIHJldHVybiBzdXBlci5pbml0KHRleHQsIHgsIHksIHNpemUsIHN0cm9rZVdpZHRoKTtcclxuICB9XHJcblxyXG4gIGdldEhlaWdodCgpOiBudW1iZXIge1xyXG4gICAgaWYgKHRoaXMuJGhlaWdodCkgcmV0dXJuIHBhcnNlSW50KHRoaXMuJGhlaWdodC50ZXh0KCkpO1xyXG4gICAgcmV0dXJuIDE7XHJcbiAgfVxyXG5cclxuICBzZXRIZWlnaHQoaGVpZ2h0OiBudW1iZXIpOiB0aGlzIHtcclxuICAgIHRoaXMuJGhlaWdodD8udGV4dChTdHJpbmcoaGVpZ2h0KSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHVwZGF0ZUhlaWdodFBvc2l0aW9uKCk6IHRoaXMge1xyXG4gICAgaWYgKCF0aGlzLiRoZWlnaHQpIHJldHVybiB0aGlzO1xyXG5cclxuICAgIGNvbnN0IGh4ID0gdGhpcy4kaGVpZ2h0LmN4KCk7XHJcbiAgICBjb25zdCBjeCA9IHRoaXMuY3goKTtcclxuXHJcbiAgICBpZiAodGhpcy5pc1JpZ2h0Q2hpbGQoKSAmJiBoeCAtIGN4IDwgMCkgdGhpcy4kaGVpZ2h0LmN4KDIgKiBjeCAtIGh4KTtcclxuICAgIGlmICh0aGlzLmlzTGVmdENoaWxkKCkgJiYgaHggLSBjeCA+IDApIHRoaXMuJGhlaWdodC5jeCgyICogY3ggLSBoeCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBnZXRIZWlnaHRIaWdobGlnaHQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy4kaGVpZ2h0Py5nZXRIaWdobGlnaHQoKSB8fCBmYWxzZTtcclxuICB9XHJcblxyXG4gIHNldEhlaWdodEhpZ2hsaWdodChoaWdoOiBib29sZWFuIHwgbnVsbCk6IHRoaXMge1xyXG4gICAgdGhpcy4kaGVpZ2h0Py5zZXRIaWdobGlnaHQoaGlnaCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgRWxlbWVudCwgTWFya2VyLCBQYXRoIH0gZnJvbSBcIkBzdmdkb3Rqcy9zdmcuanNcIjtcclxuaW1wb3J0IHsgQlRyZWVOb2RlIH0gZnJvbSBcIi4vYnRyZWUtbm9kZVwiO1xyXG5pbXBvcnQgeyBUZXh0Q2lyY2xlIH0gZnJvbSBcIi4vdGV4dC1jaXJjbGVcIjtcclxuXHJcbnR5cGUgQ29ubmVjdGlvbkNvb3JkaW5hdGVzID0ge1xyXG4gIHgxOiBudW1iZXI7XHJcbiAgeTE6IG51bWJlcjtcclxuICB4MjogbnVtYmVyO1xyXG4gIHkyOiBudW1iZXI7XHJcbiAgcjI6IG51bWJlcjtcclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBDb25uZWN0aW9uPFQgZXh0ZW5kcyBUZXh0Q2lyY2xlIHwgQlRyZWVOb2RlPiBleHRlbmRzIFBhdGgge1xyXG4gICRjb29yZHM6IENvbm5lY3Rpb25Db29yZGluYXRlcyA9IHtcclxuICAgIHIyOiAwLFxyXG4gICAgeDE6IDAsXHJcbiAgICB4MjogMCxcclxuICAgIHkxOiAwLFxyXG4gICAgeTI6IDAsXHJcbiAgfTtcclxuICAkc3RhcnQ6IFQgfCBudWxsID0gbnVsbDtcclxuICAkZW5kOiBUIHwgbnVsbCA9IG51bGw7XHJcbiAgJGJlbmQ6IG51bWJlciA9IDA7XHJcblxyXG4gIGluaXQoXHJcbiAgICBzdGFydDogVCxcclxuICAgIGVuZDogVCxcclxuICAgIHN0cm9rZVdpZHRoOiBudW1iZXIsXHJcbiAgICBiZW5kOiBudW1iZXIgPSAwLFxyXG4gICAgZGlyZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZVxyXG4gICk6IHRoaXMge1xyXG4gICAgdGhpcy4kc3RhcnQgPSBzdGFydDtcclxuICAgIHRoaXMuJGVuZCA9IGVuZDtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcy4kY29vcmRzLCB7XHJcbiAgICAgIHgxOiBzdGFydC5jeCgpLFxyXG4gICAgICB5MTogc3RhcnQuY3koKSxcclxuICAgICAgeDI6IGVuZC5jeCgpLFxyXG4gICAgICB5MjogZW5kLmN5KCksXHJcbiAgICAgIHIyOiBlbmQuZ2V0U2l6ZSgpIC8gMixcclxuICAgIH0pO1xyXG4gICAgdGhpcy5zdHJva2UoeyB3aWR0aDogc3Ryb2tlV2lkdGggfSk7XHJcbiAgICB0aGlzLmJhY2soKTtcclxuICAgIHRoaXMuc2V0QmVuZChiZW5kKTtcclxuICAgIGlmIChkaXJlY3RlZCkgdGhpcy5fY3JlYXRlQXJyb3coKTtcclxuICAgIHRoaXMudXBkYXRlKHRoaXMuJGNvb3Jkcyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGdldEJlbmQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLiRiZW5kO1xyXG4gIH1cclxuXHJcbiAgc2V0QmVuZChiZW5kOiBudW1iZXIpOiB0aGlzIHtcclxuICAgIHRoaXMuJGJlbmQgPSBiZW5kO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBpc0RpcmVjdGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5yZWZlcmVuY2UoXCJtYXJrZXItZW5kXCIpKTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZShcclxuICAgIG5ld0Nvb3JkczogUGFydGlhbDxDb25uZWN0aW9uQ29vcmRpbmF0ZXM+LFxyXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IG51bWJlciA9IDBcclxuICApOiB0aGlzIHtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcy4kY29vcmRzLCBuZXdDb29yZHMpO1xyXG4gICAgdGhpcy5hbmltYXRlU1ZHKGFuaW1hdGlvbkR1cmF0aW9uKS5wbG90KHRoaXMuX2dldFBhdGgoKSk7XHJcbiAgICBpZiAodGhpcy5pc0RpcmVjdGVkKCkpIHRoaXMuX3JlZHJhd0Fycm93KGFuaW1hdGlvbkR1cmF0aW9uKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgX2NyZWF0ZUFycm93KCk6IHZvaWQge1xyXG4gICAgdGhpcy5tYXJrZXIoXCJlbmRcIiwgNSwgNCwgZnVuY3Rpb24gKGFkZCkge1xyXG4gICAgICBhZGQucG9seWdvbihbMCwgMCwgNSwgMiwgMCwgNF0pLmFkZENsYXNzKFwiZmlsbGVkXCIpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBfcmVkcmF3QXJyb3coYW5pbWF0aW9uRHVyYXRpb246IG51bWJlciA9IDApOiB2b2lkIHtcclxuICAgIGNvbnN0IG1hcmtlciA9IHRoaXMucmVmZXJlbmNlKFwibWFya2VyLWVuZFwiKSBhcyBNYXJrZXI7XHJcbiAgICBjb25zdCByYWRpdXMgPSB0aGlzLiRjb29yZHMucjI7XHJcbiAgICBjb25zdCBzdHJva2UgPSB0aGlzLmF0dHIoXCJzdHJva2Utd2lkdGhcIik7XHJcbiAgICBtYXJrZXI/LmFuaW1hdGVTVkcoYW5pbWF0aW9uRHVyYXRpb24pLmF0dHIoeyByZWZYOiByYWRpdXMgLyBzdHJva2UgKyA1IH0pO1xyXG4gIH1cclxuXHJcbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiBgJHt0aGlzLmdldFN0YXJ0KCl9IC0tPiAke3RoaXMuZ2V0RW5kKCl9YDtcclxuICB9XHJcblxyXG4gIGdldFN0YXJ0KCk6IFQgfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLiRzdGFydDtcclxuICB9XHJcblxyXG4gIGdldEVuZCgpOiBUIHwgbnVsbCB7XHJcbiAgICByZXR1cm4gdGhpcy4kZW5kO1xyXG4gIH1cclxuXHJcbiAgc2V0U3RhcnQoc3RhcnQ6IFQsIGFuaW1hdGlvbkR1cmF0aW9uOiBudW1iZXIgPSAwKTogdGhpcyB7XHJcbiAgICBpZiAoc3RhcnQgPT09IHRoaXMuJHN0YXJ0KSByZXR1cm4gdGhpcztcclxuICAgIHRoaXMuJHN0YXJ0ID0gc3RhcnQ7XHJcbiAgICBpZiAoc3RhcnQpXHJcbiAgICAgIHRoaXMudXBkYXRlKHsgeDE6IHN0YXJ0LmN4KCksIHkxOiBzdGFydC5jeSgpIH0sIGFuaW1hdGlvbkR1cmF0aW9uKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgc2V0RW5kKGVuZDogVCwgYW5pbWF0aW9uRHVyYXRpb246IG51bWJlciA9IDApOiB0aGlzIHtcclxuICAgIGlmIChlbmQgPT09IHRoaXMuJGVuZCkgcmV0dXJuIHRoaXM7XHJcbiAgICB0aGlzLiRlbmQgPSBlbmQ7XHJcbiAgICBpZiAoZW5kKSB0aGlzLnVwZGF0ZSh7IHgyOiBlbmQuY3goKSwgeTI6IGVuZC5jeSgpIH0sIGFuaW1hdGlvbkR1cmF0aW9uKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgc2V0SGlnaGxpZ2h0KGhpZ2g6IGJvb2xlYW4gfCBudWxsKTogdGhpcyB7XHJcbiAgICBzdXBlci5zZXRIaWdobGlnaHQoaGlnaCk7XHJcbiAgICBjb25zdCBtYXJrZXIgPSB0aGlzLnJlZmVyZW5jZTxFbGVtZW50PihcIm1hcmtlci1lbmRcIik7XHJcbiAgICBpZiAobWFya2VyKSBtYXJrZXIuc2V0SGlnaGxpZ2h0KGhpZ2gpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBfZ2V0UGF0aCgpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgQyA9IHRoaXMuJGNvb3JkcztcclxuICAgIGNvbnN0IHhDb250cm9sID0gKEMueDEgKyBDLngyKSAvIDIgKyAoQy55MSAtIEMueTIpICogdGhpcy5nZXRCZW5kKCk7XHJcbiAgICBjb25zdCB5Q29udHJvbCA9IChDLnkxICsgQy55MikgLyAyICsgKEMueDIgLSBDLngxKSAqIHRoaXMuZ2V0QmVuZCgpO1xyXG4gICAgcmV0dXJuIGBNICR7Qy54MX0gJHtDLnkxfSBRICR7eENvbnRyb2x9ICR7eUNvbnRyb2x9ICR7Qy54Mn0gJHtDLnkyfWA7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IEJUcmVlTm9kZSB9IGZyb20gXCIuL2J0cmVlLW5vZGVcIjtcclxuaW1wb3J0IHsgQ29ubmVjdGlvbiB9IGZyb20gXCIuL2Nvbm5lY3Rpb25cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBCVHJlZUNvbm5lY3Rpb24gZXh0ZW5kcyBDb25uZWN0aW9uPEJUcmVlTm9kZT4ge1xyXG4gICRtYXhCZW5kID0gMC4xO1xyXG4gICRjb29yZHM6IHtcclxuICAgIHgxOiBudW1iZXI7XHJcbiAgICB4MjogbnVtYmVyO1xyXG4gICAgeTE6IG51bWJlcjtcclxuICAgIHkyOiBudW1iZXI7XHJcbiAgICByMjogbnVtYmVyO1xyXG4gICAgbjogbnVtYmVyO1xyXG4gICAgaTogbnVtYmVyO1xyXG4gIH0gPSB7XHJcbiAgICB4MTogMCxcclxuICAgIHgyOiAwLFxyXG4gICAgeTE6IDAsXHJcbiAgICB5MjogMCxcclxuICAgIHIyOiAwLFxyXG4gICAgbjogMCxcclxuICAgIGk6IDAsXHJcbiAgfTtcclxuXHJcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBTZXBhcmF0ZSBCVHJlZUNvbm5lY3Rpb24gZnJvbSBCU1RDb25uZWN0aW9uIGFuZCBoYXZlIGJvdGggZXh0ZW5kIGEgYmFzZSBjb25uZWN0aW9uXHJcbiAgaW5pdChcclxuICAgIHN0YXJ0OiBCVHJlZU5vZGUsXHJcbiAgICBlbmQ6IEJUcmVlTm9kZSxcclxuICAgIGNoaWxkOiBudW1iZXIsXHJcbiAgICBudW1DaGlsZHJlbjogbnVtYmVyLFxyXG4gICAgc3Ryb2tlV2lkdGg6IG51bWJlclxyXG4gICk6IHRoaXMge1xyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLiRjb29yZHMsIHsgaTogY2hpbGQsIG46IG51bUNoaWxkcmVuIH0pO1xyXG4gICAgcmV0dXJuIHN1cGVyLmluaXQoc3RhcnQsIGVuZCwgc3Ryb2tlV2lkdGgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0QmVuZCgpOiBudW1iZXIge1xyXG4gICAgaWYgKHRoaXMuJGNvb3Jkcy5uIDw9IDEpIHJldHVybiAwO1xyXG4gICAgcmV0dXJuIHRoaXMuJG1heEJlbmQgKiAoMSAtICgyICogdGhpcy4kY29vcmRzLmkpIC8gKHRoaXMuJGNvb3Jkcy5uIC0gMSkpO1xyXG4gIH1cclxuXHJcbiAgX2dldFBhdGgoKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IEMgPSB0aGlzLiRjb29yZHM7XHJcbiAgICBsZXQgeDEgPSBDLngxICsgKDIgKiBDLmkgLSBDLm4gKyAxKSAqIEMucjI7XHJcbiAgICBjb25zdCB5MSA9IEMueTEgKyBDLnIyO1xyXG4gICAgLy8gVG8gY29tcGVuc2F0ZSBmb3IgdGhlIHJvdW5kZWQgY29ybmVyczpcclxuICAgIGlmIChDLmkgPT09IDApIHgxICs9IEMucjIgLyA0O1xyXG4gICAgaWYgKEMuaSA9PT0gQy5uIC0gMSkgeDEgLT0gQy5yMiAvIDQ7XHJcbiAgICBjb25zdCB4Q29udHJvbCA9ICh4MSArIEMueDIpIC8gMiArICh5MSAtIEMueTIpICogdGhpcy5nZXRCZW5kKCk7XHJcbiAgICBjb25zdCB5Q29udHJvbCA9ICh5MSArIEMueTIpIC8gMiArIChDLngyIC0geDEpICogdGhpcy5nZXRCZW5kKCk7XHJcbiAgICByZXR1cm4gYE0gJHt4MX0gJHt5MX0gUSAke3hDb250cm9sfSAke3lDb250cm9sfSAke0MueDJ9ICR7Qy55Mn1gO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBHLCBMaW5lLCBSZWN0LCBUZXh0IH0gZnJvbSBcIkBzdmdkb3Rqcy9zdmcuanNcIjtcclxuaW1wb3J0IHsgTkJTUCB9IGZyb20gXCIuLi8uLi9zcmMvZW5naW5lXCI7XHJcbmltcG9ydCB7IEJUcmVlQ29ubmVjdGlvbiB9IGZyb20gXCIuL2J0cmVlLWNvbm5lY3Rpb25cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBCVHJlZU5vZGUgZXh0ZW5kcyBHIHtcclxuICAkcGFyZW50OiBCVHJlZUNvbm5lY3Rpb24gfCBudWxsID0gbnVsbDtcclxuICAkY2hpbGRyZW46IChCVHJlZUNvbm5lY3Rpb24gfCBudWxsKVtdIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICRyZWN0OiBSZWN0IHwgbnVsbCA9IG51bGw7XHJcbiAgJHZhbHVlczogVGV4dFtdID0gW107XHJcbiAgJGxpbmVzOiBMaW5lW10gPSBbXTtcclxuICAkcmlnaHRXaWR0aDogbnVtYmVyID0gMDtcclxuICAkbGVmdFdpZHRoOiBudW1iZXIgPSAwO1xyXG4gICRjaGlsZFdpZHRoczogbnVtYmVyID0gMDtcclxuICAkd2lkdGg6IG51bWJlciA9IDA7XHJcblxyXG4gIGluaXQoXHJcbiAgICBsZWFmOiBib29sZWFuLFxyXG4gICAgbnZhbHVlczogbnVtYmVyLFxyXG4gICAgeDogbnVtYmVyLFxyXG4gICAgeTogbnVtYmVyLFxyXG4gICAgb2JqZWN0U2l6ZTogbnVtYmVyLFxyXG4gICAgc3Ryb2tlV2lkdGg6IG51bWJlclxyXG4gICk6IHRoaXMge1xyXG4gICAgaWYgKG52YWx1ZXMgPCAxKSB0aHJvdyBuZXcgRXJyb3IoXCJCVHJlZU5vZGU6IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgdmFsdWVcIik7XHJcbiAgICB0aGlzLiRjaGlsZHJlbiA9IGxlYWYgPyBudWxsIDogQXJyYXkobnZhbHVlcyArIDEpO1xyXG4gICAgdGhpcy5zZXROdW1WYWx1ZXMobnZhbHVlcywgb2JqZWN0U2l6ZSwgc3Ryb2tlV2lkdGgpO1xyXG4gICAgaWYgKHggJiYgeSkgdGhpcy5jZW50ZXIoeCwgeSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gYFske3RoaXMuZ2V0VGV4dHMoKS5qb2luKFwiIHwgXCIpfV1gO1xyXG4gIH1cclxuXHJcbiAgbnVtVmFsdWVzKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy4kdmFsdWVzLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIG51bUNoaWxkcmVuKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy4kY2hpbGRyZW4/Lmxlbmd0aCB8fCAwO1xyXG4gIH1cclxuXHJcbiAgaXNMZWFmKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuJGNoaWxkcmVuID09PSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLy8gVE9ETzogVW5kZXJzdGFuZCB0aGlzIGZ1bmN0aW9uIFBTIG5vdCBpbiB1c2VcclxuICBzZXRMZWFmKGxlYWY6IGJvb2xlYW4sIHN0cm9rZVdpZHRoOiBudW1iZXIpOiB0aGlzIHtcclxuICAgIGlmIChsZWFmICYmIHRoaXMuJGNoaWxkcmVuKSB7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0aGlzLnNldENoaWxkKGksIG51bGwsIHN0cm9rZVdpZHRoKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLiRjaGlsZHJlbiA9IG51bGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLiRjaGlsZHJlbiA9IEFycmF5KHRoaXMubnVtVmFsdWVzKCkgKyAxKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgaW5zZXJ0VmFsdWUoXHJcbiAgICBpOiBudW1iZXIsXHJcbiAgICB0ZXh0OiBzdHJpbmcsXHJcbiAgICBvYmplY3RTaXplOiBudW1iZXIsXHJcbiAgICBzdHJva2VXaWR0aDogbnVtYmVyLFxyXG4gICAgbGVmdENoaWxkSW5zZXJ0ID0gZmFsc2VcclxuICApOiB0aGlzIHtcclxuICAgIGlmIChpIDwgdGhpcy5udW1WYWx1ZXMoKSkge1xyXG4gICAgICBjb25zdCBkeCA9IChpIC8gTWF0aC5tYXgoMSwgdGhpcy5udW1WYWx1ZXMoKSkgLSAxKSAqIG9iamVjdFNpemU7XHJcbiAgICAgIHRoaXMuZG1vdmVDZW50ZXIoZHgsIDApO1xyXG4gICAgfVxyXG4gICAgdGhpcy4kdmFsdWVzLnNwbGljZShpLCAwKTtcclxuICAgIHRoaXMuJGxpbmVzLnNwbGljZShpLCAwKTtcclxuICAgIGlmICghdGhpcy5pc0xlYWYoKSkge1xyXG4gICAgICBjb25zdCBqID0gbGVmdENoaWxkSW5zZXJ0ID8gaSA6IGkgKyAxO1xyXG4gICAgICB0aGlzLiRjaGlsZHJlbj8uc3BsaWNlKGosIDApO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zZXROdW1WYWx1ZXModGhpcy5udW1WYWx1ZXMoKSwgb2JqZWN0U2l6ZSwgc3Ryb2tlV2lkdGgpO1xyXG4gICAgdGhpcy5zZXRUZXh0KGksIHRleHQpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgZGVsZXRlVmFsdWUoXHJcbiAgICBpOiBudW1iZXIsXHJcbiAgICBvYmplY3RTaXplOiBudW1iZXIsXHJcbiAgICBzdHJva2VXaWR0aDogbnVtYmVyLFxyXG4gICAgbGVmdENoaWxkRGVsZXRlID0gdHJ1ZVxyXG4gICk6IHRoaXMge1xyXG4gICAgdGhpcy4kdmFsdWVzW2ldLnJlbW92ZSgpO1xyXG4gICAgdGhpcy4kdmFsdWVzLnNwbGljZShpLCAxKTtcclxuICAgIGNvbnN0IGwgPSBNYXRoLm1heChpLCAxKTtcclxuICAgIHRoaXMuJGxpbmVzW2xdLnJlbW92ZSgpO1xyXG4gICAgdGhpcy4kbGluZXMuc3BsaWNlKGwsIDEpO1xyXG4gICAgaWYgKCF0aGlzLmlzTGVhZigpKSB7XHJcbiAgICAgIGNvbnN0IGogPSBsZWZ0Q2hpbGREZWxldGUgPyBpIDogaSArIDE7XHJcbiAgICAgIHRoaXMuc2V0Q2hpbGQoaiwgbnVsbCwgc3Ryb2tlV2lkdGgpO1xyXG4gICAgICB0aGlzLiRjaGlsZHJlbj8uc3BsaWNlKGosIDEpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zZXROdW1WYWx1ZXModGhpcy5udW1WYWx1ZXMoKSwgb2JqZWN0U2l6ZSwgc3Ryb2tlV2lkdGgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgc2V0TnVtVmFsdWVzKG52YWx1ZXM6IG51bWJlciwgb2JqZWN0U2l6ZTogbnVtYmVyLCBzdHJva2VXaWR0aDogbnVtYmVyKTogdGhpcyB7XHJcbiAgICB3aGlsZSAobnZhbHVlcyA8IHRoaXMubnVtVmFsdWVzKCkpIHtcclxuICAgICAgaWYgKCF0aGlzLmlzTGVhZigpKSB7XHJcbiAgICAgICAgdGhpcy5zZXRDaGlsZCh0aGlzLiRjaGlsZHJlbj8ubGVuZ3RoIHx8IDAgLSAxLCBudWxsLCBzdHJva2VXaWR0aCk7XHJcbiAgICAgICAgdGhpcy4kY2hpbGRyZW4/LnBvcCgpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuJHZhbHVlcy5wb3AoKT8ucmVtb3ZlKCk7XHJcbiAgICAgIHRoaXMuJGxpbmVzLnBvcCgpPy5yZW1vdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB3MCA9IG9iamVjdFNpemUsXHJcbiAgICAgIGggPSBvYmplY3RTaXplLFxyXG4gICAgICBzdHJva2UgPSBzdHJva2VXaWR0aDtcclxuICAgIGlmICghdGhpcy4kcmVjdClcclxuICAgICAgdGhpcy4kcmVjdCA9IHRoaXMucmVjdCh3MCAqIG52YWx1ZXMsIGgpXHJcbiAgICAgICAgLnN0cm9rZSh7IHdpZHRoOiBzdHJva2UgfSlcclxuICAgICAgICAuY2VudGVyKDAsIDApO1xyXG4gICAgdGhpcy4kcmVjdC53aWR0aCh3MCAqIE1hdGgubWF4KDAuNSwgbnZhbHVlcykpLnJhZGl1cyhoIC8gNCk7XHJcbiAgICBjb25zdCBjeCA9IHRoaXMuJHJlY3QuY3goKSxcclxuICAgICAgY3kgPSB0aGlzLiRyZWN0LmN5KCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG52YWx1ZXM7IGkrKykge1xyXG4gICAgICBpZiAoIXRoaXMuJHZhbHVlc1tpXSkgdGhpcy4kdmFsdWVzW2ldID0gdGhpcy50ZXh0KE5CU1ApO1xyXG4gICAgICB0aGlzLiR2YWx1ZXNbaV0uY2VudGVyKGN4ICsgdzAgKiAoaSAtIG52YWx1ZXMgLyAyICsgMC41KSwgY3kpO1xyXG4gICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICBjb25zdCBkeCA9IHcwICogKGkgLSBudmFsdWVzIC8gMiksXHJcbiAgICAgICAgICBkeSA9IGggLyAyO1xyXG4gICAgICAgIGlmICghdGhpcy4kbGluZXNbaV0pXHJcbiAgICAgICAgICB0aGlzLiRsaW5lc1tpXSA9IHRoaXMubGluZSgwLCBjeSAtIGR5LCAwLCBjeSArIGR5KS5zdHJva2Uoe1xyXG4gICAgICAgICAgICB3aWR0aDogc3Ryb2tlLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy4kbGluZXNbaV0uY3goY3ggKyBkeCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghdGhpcy5pc0xlYWYoKSAmJiB0aGlzLiRjaGlsZHJlbikge1xyXG4gICAgICBjb25zdCBuID0gKHRoaXMuJGNoaWxkcmVuLmxlbmd0aCA9IG52YWx1ZXMgKyAxKTtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IGkgYW5kIG4gbm90IG9uIGJhc2Ugb2JqZWN0IGFuZCBjYW4gdGhlcmVmb3Igbm90IGJlIHBhc3NlZCBpblxyXG4gICAgICAgIHRoaXMuJGNoaWxkcmVuW2ldPy51cGRhdGUoeyBpOiBpLCBuOiBuIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBnZXRDWChpOiBudW1iZXIsIG9iamVjdFNpemU6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5jeCgpICsgb2JqZWN0U2l6ZSAqIChpIC0gdGhpcy5udW1WYWx1ZXMoKSAvIDIgKyAwLjUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0V2lkdGgoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBOdW1iZXIodGhpcy4kcmVjdD8ud2lkdGgoKSkgfHwgMDtcclxuICB9XHJcblxyXG4gIGdldEhlaWdodCgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIE51bWJlcih0aGlzLiRyZWN0Py5oZWlnaHQoKSkgfHwgMDtcclxuICB9XHJcblxyXG4gIGdldFNpemUoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmdldEhlaWdodCgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0VGV4dHMoKTogc3RyaW5nW10ge1xyXG4gICAgcmV0dXJuIHRoaXMuJHZhbHVlcy5tYXAoKHQpID0+IHQudGV4dCgpKTtcclxuICB9XHJcblxyXG4gIHNldFRleHRzKHRleHRzOiBzdHJpbmdbXSk6IHRoaXMge1xyXG4gICAgaWYgKHRleHRzLmxlbmd0aCAhPT0gdGhpcy5udW1WYWx1ZXMoKSlcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBXcm9uZyBudW1iZXIgb2YgdGV4dHM6ICR7dGV4dHMubGVuZ3RofSAhPSAke3RoaXMubnVtVmFsdWVzKCl9YFxyXG4gICAgICApO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB0aGlzLnNldFRleHQoaSwgdGV4dHNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgZ2V0VGV4dChjOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIHRoaXMuJHZhbHVlc1tjXS50ZXh0KCk7XHJcbiAgfVxyXG5cclxuICBzZXRUZXh0KGk6IG51bWJlciwgdGV4dDogc3RyaW5nKTogdGhpcyB7XHJcbiAgICBpZiAodGV4dCA9PSBudWxsKSB0ZXh0ID0gXCJcIjtcclxuICAgIHRleHQgPSBgJHt0ZXh0fWA7XHJcbiAgICAvLyBOb24tYnJlYWtpbmcgc3BhY2U6IFdlIG5lZWQgdG8gaGF2ZSBzb21lIHRleHQsIG90aGVyd2lzZSB0aGUgY29vcmRpbmF0ZXMgYXJlIHJlc2V0IHRvICgwLCAwKVxyXG4gICAgaWYgKHRleHQgPT09IFwiXCIpIHRleHQgPSBOQlNQO1xyXG4gICAgdGhpcy4kdmFsdWVzW2ldLnRleHQodGV4dCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGdldFBhcmVudCgpOiBCVHJlZU5vZGUgfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLiRwYXJlbnQ/LmdldFN0YXJ0KCkgfHwgbnVsbDtcclxuICB9XHJcblxyXG4gIGdldENoaWxkcmVuKCk6IEJUcmVlTm9kZVtdIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIHRoaXMuJGNoaWxkcmVuXHJcbiAgICAgICAgPy5tYXAoKGUpID0+IGU/LmdldEVuZCgpKVxyXG4gICAgICAgIC5maWx0ZXIoKGUpID0+IGUgIT09IG51bGwgJiYgZSAhPT0gdW5kZWZpbmVkKSB8fCBbXVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGdldENoaWxkKGk6IG51bWJlcik6IEJUcmVlTm9kZSB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuJGNoaWxkcmVuPy5baV0/LmdldEVuZCgpIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICBnZXRMZWZ0KCk6IEJUcmVlTm9kZSB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2hpbGQoMCk7XHJcbiAgfVxyXG5cclxuICBnZXRSaWdodCgpOiBCVHJlZU5vZGUgfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLmdldENoaWxkKHRoaXMubnVtQ2hpbGRyZW4oKSAtIDEpO1xyXG4gIH1cclxuXHJcbiAgaXNDaGlsZChjOiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzID09PSB0aGlzLmdldFBhcmVudCgpPy5nZXRDaGlsZChjKTtcclxuICB9XHJcblxyXG4gIGdldFBhcmVudEluZGV4KCk6IG51bWJlciB8IG51bGwge1xyXG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcclxuICAgIGlmICghcGFyZW50KSByZXR1cm4gbnVsbDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50Lm51bUNoaWxkcmVuKCk7IGkrKykge1xyXG4gICAgICBpZiAodGhpcyA9PT0gcGFyZW50LmdldENoaWxkKGkpKSByZXR1cm4gaTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgZ2V0UGFyZW50RWRnZSgpOiBCVHJlZUNvbm5lY3Rpb24gfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLiRwYXJlbnQ7XHJcbiAgfVxyXG5cclxuICBnZXRDaGlsZEVkZ2UoaTogbnVtYmVyKTogQlRyZWVDb25uZWN0aW9uIHwgbnVsbCB7XHJcbiAgICByZXR1cm4gdGhpcy4kY2hpbGRyZW4/LltpXSB8fCBudWxsO1xyXG4gIH1cclxuXHJcbiAgc2V0Q2hpbGQoaTogbnVtYmVyLCBjaGlsZDogQlRyZWVOb2RlIHwgbnVsbCwgc3Ryb2tlV2lkdGg6IG51bWJlcik6IHRoaXMge1xyXG4gICAgaWYgKHRoaXMuJGNoaWxkcmVuPy5baV0pIHtcclxuICAgICAgY29uc3Qgb2xkQ2hpbGQgPSB0aGlzLiRjaGlsZHJlbltpXS5nZXRFbmQoKSE7XHJcbiAgICAgIG9sZENoaWxkLiRwYXJlbnQgPSBudWxsO1xyXG4gICAgICB0aGlzLiRjaGlsZHJlbltpXS5yZW1vdmUoKTtcclxuICAgIH1cclxuICAgIGlmICghY2hpbGQpIHtcclxuICAgICAgaWYgKHRoaXMuJGNoaWxkcmVuPy5baV0pIHRoaXMuJGNoaWxkcmVuW2ldID0gbnVsbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChjaGlsZC4kcGFyZW50KSB7XHJcbiAgICAgICAgY29uc3Qgb2xkUGFyZW50ID0gY2hpbGQuJHBhcmVudC5nZXRTdGFydCgpO1xyXG4gICAgICAgIG9sZFBhcmVudD8uJGNoaWxkcmVuPy5mb3JFYWNoKChvbGRQYXJlbnRDaGlsZCkgPT4ge1xyXG4gICAgICAgICAgaWYgKGNoaWxkLiRwYXJlbnQgPT09IG9sZFBhcmVudENoaWxkKSB7XHJcbiAgICAgICAgICAgIG9sZFBhcmVudENoaWxkID0gbnVsbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjaGlsZC4kcGFyZW50LnJlbW92ZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGVkZ2UgPSB0aGlzLnJvb3QoKS5iVHJlZUNvbm5lY3Rpb24oXHJcbiAgICAgICAgdGhpcyxcclxuICAgICAgICBjaGlsZCxcclxuICAgICAgICBpLFxyXG4gICAgICAgIHRoaXMubnVtQ2hpbGRyZW4oKSxcclxuICAgICAgICBzdHJva2VXaWR0aFxyXG4gICAgICApO1xyXG4gICAgICBpZiAodGhpcy4kY2hpbGRyZW4/LltpXSkgdGhpcy4kY2hpbGRyZW5baV0gPSBlZGdlO1xyXG4gICAgICBjaGlsZC4kcGFyZW50ID0gZWRnZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgc2V0UGFyZW50KGM6IG51bWJlciwgcGFyZW50OiBCVHJlZU5vZGUsIHN0cm9rZVdpZHRoOiBudW1iZXIpOiB0aGlzIHtcclxuICAgIHBhcmVudC5zZXRDaGlsZChjLCB0aGlzLCBzdHJva2VXaWR0aCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHNldFBhcmVudEhpZ2hsaWdodChoaWdoOiBib29sZWFuIHwgbnVsbCk6IHRoaXMge1xyXG4gICAgdGhpcy5zZXRIaWdobGlnaHQoaGlnaCk7XHJcbiAgICB0aGlzLmdldFBhcmVudCgpPy5zZXRIaWdobGlnaHQoaGlnaCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHNldENoaWxkSGlnaGxpZ2h0KGk6IG51bWJlciwgaGlnaDogYm9vbGVhbiB8IG51bGwpOiB0aGlzIHtcclxuICAgIHRoaXMuc2V0SGlnaGxpZ2h0KGhpZ2gpO1xyXG4gICAgdGhpcy5nZXRDaGlsZChpKT8uc2V0SGlnaGxpZ2h0KGhpZ2gpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICByZW1vdmUoKTogdGhpcyB7XHJcbiAgICBpZiAoIXRoaXMuaXNMZWFmKCkpIHtcclxuICAgICAgdGhpcy4kY2hpbGRyZW4/LmZvckVhY2goKGNoaWxkKSA9PiB7XHJcbiAgICAgICAgaWYgKCFjaGlsZCkgcmV0dXJuO1xyXG4gICAgICAgIGNoaWxkLnJlbW92ZSgpO1xyXG4gICAgICAgIGNoaWxkID0gbnVsbDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuJHBhcmVudCkge1xyXG4gICAgICBjb25zdCBpID0gdGhpcy5nZXRQYXJlbnRJbmRleCgpO1xyXG4gICAgICBpZiAoaSAmJiB0aGlzLiRwYXJlbnQuZ2V0U3RhcnQoKT8uJGNoaWxkcmVuPy5baV0pXHJcbiAgICAgICAgdGhpcy4kcGFyZW50LmdldFN0YXJ0KCkhLiRjaGlsZHJlbiFbaV0gPSBudWxsO1xyXG4gICAgICB0aGlzLiRwYXJlbnQucmVtb3ZlKCk7XHJcbiAgICAgIHRoaXMuJHBhcmVudCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBzdXBlci5yZW1vdmUoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgc2V0Q2VudGVyKHg6IG51bWJlciwgeTogbnVtYmVyLCBhbmltYXRpb25EdXJhdGlvbjogbnVtYmVyID0gMCk6IHRoaXMge1xyXG4gICAgc3VwZXIuc2V0Q2VudGVyKHgsIHksIGFuaW1hdGlvbkR1cmF0aW9uKTtcclxuICAgIHRoaXMuJGNoaWxkcmVuPy5mb3JFYWNoKChjaGlsZCkgPT4ge1xyXG4gICAgICBjaGlsZD8udXBkYXRlKHsgeDE6IHgsIHkxOiB5IH0sIGFuaW1hdGlvbkR1cmF0aW9uKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy4kcGFyZW50Py51cGRhdGUoeyB4MjogeCwgeTI6IHkgfSwgYW5pbWF0aW9uRHVyYXRpb24pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICByZXNpemUoXHJcbiAgICBzdGFydFg6IG51bWJlcixcclxuICAgIHN0YXJ0WTogbnVtYmVyLFxyXG4gICAgc3ZnTWFyZ2luOiBudW1iZXIsXHJcbiAgICBub2RlU3BhY2luZzogbnVtYmVyLFxyXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IG51bWJlciA9IDBcclxuICApOiB0aGlzIHtcclxuICAgIHRoaXMuX3Jlc2l6ZVdpZHRocyhub2RlU3BhY2luZyk7XHJcbiAgICBjb25zdCBzdmdXaWR0aCA9IHRoaXMucm9vdCgpLnZpZXdib3goKS53aWR0aDtcclxuICAgIGlmIChzdGFydFggKyB0aGlzLiRyaWdodFdpZHRoID4gc3ZnV2lkdGggLSBzdmdNYXJnaW4pXHJcbiAgICAgIHN0YXJ0WCA9IHN2Z1dpZHRoIC0gdGhpcy4kcmlnaHRXaWR0aCAtIHN2Z01hcmdpbjtcclxuICAgIGlmIChzdGFydFggLSB0aGlzLiRsZWZ0V2lkdGggPCBzdmdNYXJnaW4pXHJcbiAgICAgIHN0YXJ0WCA9IHRoaXMuJGxlZnRXaWR0aCArIHN2Z01hcmdpbjtcclxuICAgIHRoaXMuX3NldE5ld1Bvc2l0aW9ucyhzdGFydFgsIHN0YXJ0WSwgYW5pbWF0aW9uRHVyYXRpb24pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gVE9ETzogVXBkYXRlIG5hbWUgdG8gcmVmbGVjdCB0aGF0IG51bWJlciBpcyByZXR1cm5lZFxyXG4gIF9yZXNpemVXaWR0aHMobm9kZVNwYWNpbmc6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICBsZXQgbGVmdCA9IDAsXHJcbiAgICAgIHJpZ2h0ID0gMDtcclxuICAgIHRoaXMuJGNoaWxkV2lkdGhzID0gMDtcclxuICAgIHRoaXMuJHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xyXG4gICAgaWYgKCF0aGlzLmlzTGVhZigpKSB7XHJcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5nZXRDaGlsZHJlbigpKSB7XHJcbiAgICAgICAgdGhpcy4kY2hpbGRXaWR0aHMgKz0gY2hpbGQ/Ll9yZXNpemVXaWR0aHMobm9kZVNwYWNpbmcpIHx8IDA7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgeFNwYWNpbmcgPSBub2RlU3BhY2luZztcclxuICAgICAgdGhpcy4kd2lkdGggPSBNYXRoLm1heChcclxuICAgICAgICB0aGlzLiR3aWR0aCxcclxuICAgICAgICB0aGlzLiRjaGlsZFdpZHRocyArIHRoaXMubnVtVmFsdWVzKCkgKiB4U3BhY2luZ1xyXG4gICAgICApO1xyXG4gICAgICBsZWZ0ID0gdGhpcy5nZXRMZWZ0KCk/LiRsZWZ0V2lkdGggfHwgMDtcclxuICAgICAgcmlnaHQgPSB0aGlzLmdldFJpZ2h0KCk/LiRyaWdodFdpZHRoIHx8IDA7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtaWQgPSB0aGlzLiR3aWR0aCAtIGxlZnQgLSByaWdodDtcclxuICAgIHRoaXMuJGxlZnRXaWR0aCA9IG1pZCAvIDIgKyBsZWZ0O1xyXG4gICAgdGhpcy4kcmlnaHRXaWR0aCA9IG1pZCAvIDIgKyByaWdodDtcclxuICAgIHJldHVybiB0aGlzLiR3aWR0aDtcclxuICB9XHJcblxyXG4gIF9zZXROZXdQb3NpdGlvbnMoXHJcbiAgICB4OiBudW1iZXIsXHJcbiAgICB5OiBudW1iZXIsXHJcbiAgICBub2RlU3BhY2luZzogbnVtYmVyLFxyXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IG51bWJlciA9IDBcclxuICApOiB2b2lkIHtcclxuICAgIHRoaXMuc2V0Q2VudGVyKHgsIHksIGFuaW1hdGlvbkR1cmF0aW9uKTtcclxuICAgIGlmICh0aGlzLmlzTGVhZigpKSByZXR1cm47XHJcbiAgICB4IC09IHRoaXMuJGxlZnRXaWR0aDtcclxuICAgIGNvbnN0IHhTcGFjaW5nID0gKHRoaXMuJHdpZHRoIC0gdGhpcy4kY2hpbGRXaWR0aHMpIC8gdGhpcy5udW1WYWx1ZXMoKTtcclxuICAgIGNvbnN0IHlTcGFjaW5nID0gbm9kZVNwYWNpbmc7XHJcbiAgICBjb25zdCBuZXh0WSA9IHkgKyB0aGlzLmdldEhlaWdodCgpICsgeVNwYWNpbmc7XHJcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuZ2V0Q2hpbGRyZW4oKSkge1xyXG4gICAgICBjaGlsZD8uX3NldE5ld1Bvc2l0aW9ucyh4ICsgY2hpbGQuJGxlZnRXaWR0aCwgbmV4dFksIGFuaW1hdGlvbkR1cmF0aW9uKTtcclxuICAgICAgeCArPSAoY2hpbGQ/LiR3aWR0aCB8fCAwKSArIHhTcGFjaW5nO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBDaXJjbGUgfSBmcm9tIFwiQHN2Z2RvdGpzL3N2Zy5qc1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEhpZ2hsaWdodENpcmNsZSBleHRlbmRzIENpcmNsZSB7XHJcbiAgaW5pdCh4OiBudW1iZXIsIHk6IG51bWJlciwgcmFkaXVzOiBudW1iZXIsIHN0cm9rZVdpZHRoOiBudW1iZXIpIHtcclxuICAgIHJldHVybiB0aGlzLnJhZGl1cyhyYWRpdXMpXHJcbiAgICAgIC5zdHJva2UoeyB3aWR0aDogc3Ryb2tlV2lkdGggfSlcclxuICAgICAgLmNlbnRlcih4LCB5KVxyXG4gICAgICAuYWRkQ2xhc3MoXCJoaWdobGlnaHQtY2lyY2xlXCIpO1xyXG4gIH1cclxuXHJcbiAgZ2V0U2l6ZSgpIHtcclxuICAgIGNvbnN0IHIgPSB0aGlzLmF0dHIoXCJyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiByID09PSBcIm51bWJlclwiKSByZXR1cm4gciAqIDI7XHJcbiAgICBpZiAodHlwZW9mIHIgPT09IFwic3RyaW5nXCIgJiYgIWlzTmFOKE51bWJlcihyKSkpIHJldHVybiBOdW1iZXIocikgKiAyO1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICBzZXRTaXplKGRpYW1ldGVyOiBudW1iZXIsIGFuaW1hdGlvbkR1cmF0aW9uOiBudW1iZXIpIHtcclxuICAgIHRoaXMuYW5pbWF0ZShhbmltYXRpb25EdXJhdGlvbikuYXR0cihcInJcIiwgU3RyaW5nKGRpYW1ldGVyIC8gMikpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IENvbnRhaW5lciwgRWxlbWVudCwgZXh0ZW5kLCBTdmcgfSBmcm9tIFwiQHN2Z2RvdGpzL3N2Zy5qc1wiO1xyXG5pbXBvcnQgeyBBVkxOb2RlIH0gZnJvbSBcIi4vYXZsLW5vZGVcIjtcclxuaW1wb3J0IHsgQmluYXJ5Tm9kZSB9IGZyb20gXCIuL2JpbmFyeS1ub2RlXCI7XHJcbmltcG9ydCB7IEJUcmVlQ29ubmVjdGlvbiB9IGZyb20gXCIuL2J0cmVlLWNvbm5lY3Rpb25cIjtcclxuaW1wb3J0IHsgQlRyZWVOb2RlIH0gZnJvbSBcIi4vYnRyZWUtbm9kZVwiO1xyXG5pbXBvcnQgeyBDb25uZWN0aW9uIH0gZnJvbSBcIi4vY29ubmVjdGlvblwiO1xyXG5pbXBvcnQgeyBHcmFwaE5vZGUgfSBmcm9tIFwiLi9ncmFwaC1ub2RlXCI7XHJcbmltcG9ydCB7IEhpZ2hsaWdodENpcmNsZSB9IGZyb20gXCIuL2hpZ2hsaWdodC1jaXJjbGVcIjtcclxuaW1wb3J0IHsgVGV4dENpcmNsZSB9IGZyb20gXCIuL3RleHQtY2lyY2xlXCI7XHJcblxyXG5kZWNsYXJlIG1vZHVsZSBcIkBzdmdkb3Rqcy9zdmcuanNcIiB7XHJcbiAgaW50ZXJmYWNlIEVsZW1lbnQge1xyXG4gICAgZ2V0SGlnaGxpZ2h0KCk6IGJvb2xlYW47XHJcbiAgICBzZXRIaWdobGlnaHQoaGlnaDogYm9vbGVhbiB8IG51bGwpOiB0aGlzO1xyXG4gICAgZ2V0Q2VudGVyKCk6IFtudW1iZXIsIG51bWJlcl07XHJcbiAgICBzZXRDZW50ZXIoeDogbnVtYmVyLCB5OiBudW1iZXIsIGFuaW1hdGlvbkR1cmF0aW9uPzogbnVtYmVyKTogdGhpcztcclxuICAgIGRtb3ZlQ2VudGVyKGR4OiBudW1iZXIsIGR5OiBudW1iZXIsIGFuaW1hdGlvbkR1cmF0aW9uPzogbnVtYmVyKTogdGhpcztcclxuICAgIGFuaW1hdGVTVkcoZHVyYXRpb246IG51bWJlcik6IHRoaXM7XHJcbiAgfVxyXG5cclxuICBpbnRlcmZhY2UgQ29udGFpbmVyIHtcclxuICAgIGhpZ2hsaWdodENpcmNsZShcclxuICAgICAgeDogbnVtYmVyLFxyXG4gICAgICB5OiBudW1iZXIsXHJcbiAgICAgIHJhZGl1czogbnVtYmVyLFxyXG4gICAgICBzdHJva2VXaWR0aDogbnVtYmVyXHJcbiAgICApOiBIaWdobGlnaHRDaXJjbGU7XHJcbiAgICB0ZXh0Q2lyY2xlKFxyXG4gICAgICB0ZXh0OiBzdHJpbmcsXHJcbiAgICAgIHg6IG51bWJlcixcclxuICAgICAgeTogbnVtYmVyLFxyXG4gICAgICBzaXplOiBudW1iZXIsXHJcbiAgICAgIHN0cm9rZVdpZHRoOiBudW1iZXJcclxuICAgICk6IFRleHRDaXJjbGU7XHJcbiAgICBncmFwaE5vZGUoXHJcbiAgICAgIHRleHQ6IHN0cmluZyxcclxuICAgICAgeDogbnVtYmVyLFxyXG4gICAgICB5OiBudW1iZXIsXHJcbiAgICAgIHNpemU6IG51bWJlcixcclxuICAgICAgc3Ryb2tlV2lkdGg6IG51bWJlclxyXG4gICAgKTogR3JhcGhOb2RlO1xyXG4gICAgYmluYXJ5Tm9kZShcclxuICAgICAgdGV4dDogc3RyaW5nLFxyXG4gICAgICB4OiBudW1iZXIsXHJcbiAgICAgIHk6IG51bWJlcixcclxuICAgICAgc2l6ZTogbnVtYmVyLFxyXG4gICAgICBzdHJva2VXaWR0aDogbnVtYmVyXHJcbiAgICApOiBCaW5hcnlOb2RlO1xyXG4gICAgYXZsTm9kZShcclxuICAgICAgdGV4dDogc3RyaW5nLFxyXG4gICAgICB4OiBudW1iZXIsXHJcbiAgICAgIHk6IG51bWJlcixcclxuICAgICAgc2l6ZTogbnVtYmVyLFxyXG4gICAgICBzdHJva2VXaWR0aDogbnVtYmVyXHJcbiAgICApOiBBVkxOb2RlO1xyXG4gICAgY29ubmVjdGlvbjxUIGV4dGVuZHMgVGV4dENpcmNsZT4oXHJcbiAgICAgIHN0YXJ0OiBULFxyXG4gICAgICBlbmQ6IFQsXHJcbiAgICAgIHN0cm9rZVdpZHRoOiBudW1iZXIsXHJcbiAgICAgIGJlbmQ/OiBudW1iZXIsXHJcbiAgICAgIGRpcmVjdGVkPzogYm9vbGVhblxyXG4gICAgKTogQ29ubmVjdGlvbjxUPjtcclxuICAgIGJUcmVlTm9kZShcclxuICAgICAgbGVhZjogYm9vbGVhbixcclxuICAgICAgbnZhbHVlczogbnVtYmVyLFxyXG4gICAgICB4OiBudW1iZXIsXHJcbiAgICAgIHk6IG51bWJlcixcclxuICAgICAgb2JqZWN0U2l6ZTogbnVtYmVyLFxyXG4gICAgICBzdHJva2VXaWR0aDogbnVtYmVyXHJcbiAgICApOiBCVHJlZU5vZGU7XHJcbiAgICBiVHJlZUNvbm5lY3Rpb24oXHJcbiAgICAgIHN0YXJ0OiBCVHJlZU5vZGUsXHJcbiAgICAgIGVuZDogQlRyZWVOb2RlLFxyXG4gICAgICBjaGlsZDogbnVtYmVyLFxyXG4gICAgICBudW1DaGlsZHJlbjogbnVtYmVyLFxyXG4gICAgICBzdHJva2VXaWR0aDogbnVtYmVyXHJcbiAgICApOiBCVHJlZUNvbm5lY3Rpb247XHJcbiAgfVxyXG59XHJcblxyXG5leHRlbmQoRWxlbWVudCwge1xyXG4gIGdldEhpZ2hsaWdodCgpIHtcclxuICAgIHJldHVybiAodGhpcyBhcyBFbGVtZW50KS5oYXNDbGFzcyhcImhpZ2hsaWdodFwiKTtcclxuICB9LFxyXG4gIHNldEhpZ2hsaWdodChoaWdoOiBib29sZWFuIHwgbnVsbCkge1xyXG4gICAgaWYgKGhpZ2ggPT0gbnVsbCkgKHRoaXMgYXMgRWxlbWVudCkudG9nZ2xlQ2xhc3MoXCJoaWdobGlnaHRcIik7XHJcbiAgICBlbHNlIGlmIChoaWdoKSAodGhpcyBhcyBFbGVtZW50KS5hZGRDbGFzcyhcImhpZ2hsaWdodFwiKTtcclxuICAgIGVsc2UgKHRoaXMgYXMgRWxlbWVudCkucmVtb3ZlQ2xhc3MoXCJoaWdobGlnaHRcIik7XHJcbiAgICByZXR1cm4gdGhpcyBhcyBFbGVtZW50O1xyXG4gIH0sXHJcbiAgZ2V0Q2VudGVyKCkge1xyXG4gICAgcmV0dXJuIFsodGhpcyBhcyBFbGVtZW50KS5jeCgpLCAodGhpcyBhcyBFbGVtZW50KS5jeSgpXSBhcyBbbnVtYmVyLCBudW1iZXJdO1xyXG4gIH0sXHJcbiAgc2V0Q2VudGVyKHg6IG51bWJlciwgeTogbnVtYmVyLCBhbmltYXRpb25EdXJhdGlvbjogbnVtYmVyID0gMCkge1xyXG4gICAgKHRoaXMgYXMgRWxlbWVudCkuYW5pbWF0ZVNWRyhhbmltYXRpb25EdXJhdGlvbikuY2VudGVyKHgsIHkpO1xyXG4gICAgcmV0dXJuIHRoaXMgYXMgRWxlbWVudDtcclxuICB9LFxyXG4gIGRtb3ZlQ2VudGVyKGR4OiBudW1iZXIsIGR5OiBudW1iZXIsIGFuaW1hdGlvbkR1cmF0aW9uOiBudW1iZXIgPSAwKSB7XHJcbiAgICAodGhpcyBhcyBFbGVtZW50KS5zZXRDZW50ZXIoXHJcbiAgICAgICh0aGlzIGFzIEVsZW1lbnQpLmN4KCkgKyBkeCxcclxuICAgICAgKHRoaXMgYXMgRWxlbWVudCkuY3koKSArIGR5LFxyXG4gICAgICBhbmltYXRpb25EdXJhdGlvblxyXG4gICAgKTtcclxuICAgIHJldHVybiB0aGlzIGFzIEVsZW1lbnQ7XHJcbiAgfSxcclxuICBhbmltYXRlU1ZHKGR1cmF0aW9uOiBudW1iZXIpIHtcclxuICAgIC8vIFRPRE86IENyZWF0ZWQgYnkgbWUsIHNob3VsZCBiZSBhYmxlIHRvIHNpbXBsaWZ5IGNvZGUgbGF0ZXJcclxuICAgICh0aGlzIGFzIEVsZW1lbnQpLmFuaW1hdGUoZHVyYXRpb24sIDAsIFwibm93XCIpO1xyXG4gICAgcmV0dXJuIHRoaXMgYXMgRWxlbWVudDtcclxuICB9LFxyXG59KTtcclxuXHJcbmV4dGVuZChDb250YWluZXIsIHtcclxuICBoaWdobGlnaHRDaXJjbGUoeDogbnVtYmVyLCB5OiBudW1iZXIsIHJhZGl1czogbnVtYmVyLCBzdHJva2VXaWR0aDogbnVtYmVyKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAodGhpcyBhcyBDb250YWluZXIpLnB1dChuZXcgSGlnaGxpZ2h0Q2lyY2xlKCkpIGFzIEhpZ2hsaWdodENpcmNsZVxyXG4gICAgKS5pbml0KHgsIHksIHJhZGl1cywgc3Ryb2tlV2lkdGgpO1xyXG4gIH0sXHJcbiAgdGV4dENpcmNsZShcclxuICAgIHRleHQ6IHN0cmluZyxcclxuICAgIHg6IG51bWJlcixcclxuICAgIHk6IG51bWJlcixcclxuICAgIHNpemU6IG51bWJlcixcclxuICAgIHN0cm9rZVdpZHRoOiBudW1iZXJcclxuICApIHtcclxuICAgIHJldHVybiAoKHRoaXMgYXMgQ29udGFpbmVyKS5wdXQobmV3IFRleHRDaXJjbGUoKSkgYXMgVGV4dENpcmNsZSkuaW5pdChcclxuICAgICAgdGV4dCxcclxuICAgICAgeCxcclxuICAgICAgeSxcclxuICAgICAgc2l6ZSxcclxuICAgICAgc3Ryb2tlV2lkdGhcclxuICAgICk7XHJcbiAgfSxcclxuICBncmFwaE5vZGUoXHJcbiAgICB0ZXh0OiBzdHJpbmcsXHJcbiAgICB4OiBudW1iZXIsXHJcbiAgICB5OiBudW1iZXIsXHJcbiAgICBzaXplOiBudW1iZXIsXHJcbiAgICBzdHJva2VXaWR0aDogbnVtYmVyXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gKCh0aGlzIGFzIENvbnRhaW5lcikucHV0KG5ldyBHcmFwaE5vZGUoKSkgYXMgR3JhcGhOb2RlKS5pbml0KFxyXG4gICAgICB0ZXh0LFxyXG4gICAgICB4LFxyXG4gICAgICB5LFxyXG4gICAgICBzaXplLFxyXG4gICAgICBzdHJva2VXaWR0aFxyXG4gICAgKTtcclxuICB9LFxyXG4gIGJpbmFyeU5vZGUoXHJcbiAgICB0ZXh0OiBzdHJpbmcsXHJcbiAgICB4OiBudW1iZXIsXHJcbiAgICB5OiBudW1iZXIsXHJcbiAgICBzaXplOiBudW1iZXIsXHJcbiAgICBzdHJva2VXaWR0aDogbnVtYmVyXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gKCh0aGlzIGFzIENvbnRhaW5lcikucHV0KG5ldyBCaW5hcnlOb2RlKCkpIGFzIEJpbmFyeU5vZGUpLmluaXQoXHJcbiAgICAgIHRleHQsXHJcbiAgICAgIHgsXHJcbiAgICAgIHksXHJcbiAgICAgIHNpemUsXHJcbiAgICAgIHN0cm9rZVdpZHRoXHJcbiAgICApO1xyXG4gIH0sXHJcbiAgYXZsTm9kZShcclxuICAgIHRleHQ6IHN0cmluZyxcclxuICAgIHg6IG51bWJlcixcclxuICAgIHk6IG51bWJlcixcclxuICAgIHNpemU6IG51bWJlcixcclxuICAgIHN0cm9rZVdpZHRoOiBudW1iZXJcclxuICApIHtcclxuICAgIHJldHVybiAoKHRoaXMgYXMgQ29udGFpbmVyKS5wdXQobmV3IEFWTE5vZGUoKSkgYXMgQVZMTm9kZSkuaW5pdChcclxuICAgICAgdGV4dCxcclxuICAgICAgeCxcclxuICAgICAgeSxcclxuICAgICAgc2l6ZSxcclxuICAgICAgc3Ryb2tlV2lkdGhcclxuICAgICk7XHJcbiAgfSxcclxuICBjb25uZWN0aW9uPFQgZXh0ZW5kcyBUZXh0Q2lyY2xlPihcclxuICAgIHN0YXJ0OiBULFxyXG4gICAgZW5kOiBULFxyXG4gICAgc3Ryb2tlV2lkdGg6IG51bWJlcixcclxuICAgIGJlbmQ/OiBudW1iZXIsXHJcbiAgICBkaXJlY3RlZD86IGJvb2xlYW5cclxuICApIHtcclxuICAgIHJldHVybiAoKHRoaXMgYXMgQ29udGFpbmVyKS5wdXQobmV3IENvbm5lY3Rpb248VD4oKSkgYXMgQ29ubmVjdGlvbjxUPikuaW5pdChcclxuICAgICAgc3RhcnQsXHJcbiAgICAgIGVuZCxcclxuICAgICAgc3Ryb2tlV2lkdGgsXHJcbiAgICAgIGJlbmQsXHJcbiAgICAgIGRpcmVjdGVkXHJcbiAgICApO1xyXG4gIH0sXHJcbiAgYlRyZWVOb2RlKFxyXG4gICAgbGVhZjogYm9vbGVhbixcclxuICAgIG52YWx1ZXM6IG51bWJlcixcclxuICAgIHg6IG51bWJlcixcclxuICAgIHk6IG51bWJlcixcclxuICAgIG9iamVjdFNpemU6IG51bWJlcixcclxuICAgIHN0cm9rZVdpZHRoOiBudW1iZXJcclxuICApIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICh0aGlzIGFzIENvbnRhaW5lcikucHV0KG5ldyBCVHJlZU5vZGUoKSkgYXMgdW5rbm93biBhcyBCVHJlZU5vZGVcclxuICAgICkuaW5pdChsZWFmLCBudmFsdWVzLCB4LCB5LCBvYmplY3RTaXplLCBzdHJva2VXaWR0aCk7XHJcbiAgfSxcclxuICBiVHJlZUNvbm5lY3Rpb24oXHJcbiAgICBzdGFydDogQlRyZWVOb2RlLFxyXG4gICAgZW5kOiBCVHJlZU5vZGUsXHJcbiAgICBjaGlsZDogbnVtYmVyLFxyXG4gICAgbnVtQ2hpbGRyZW46IG51bWJlcixcclxuICAgIHN0cm9rZVdpZHRoOiBudW1iZXJcclxuICApIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICh0aGlzIGFzIENvbnRhaW5lcikucHV0KG5ldyBCVHJlZUNvbm5lY3Rpb24oKSkgYXMgQlRyZWVDb25uZWN0aW9uXHJcbiAgICApLmluaXQoc3RhcnQsIGVuZCwgY2hpbGQsIG51bUNoaWxkcmVuLCBzdHJva2VXaWR0aCk7XHJcbiAgfSxcclxufSk7XHJcblxyXG5leHBvcnQgeyBTdmcgfTtcclxuIiwiaW1wb3J0IHsgRWxlbWVudCwgVGV4dCB9IGZyb20gXCJAc3ZnZG90anMvc3ZnLmpzXCI7XHJcbmltcG9ydCB7IFN2ZyB9IGZyb20gXCIuL29iamVjdHNcIjtcclxuXHJcbmV4cG9ydCB0eXBlIEVuZ2luZVRvb2xiYXJJdGVtcyA9IHtcclxuICBhbmltYXRpb25TcGVlZDogSFRNTFNlbGVjdEVsZW1lbnQ7XHJcbiAgb2JqZWN0U2l6ZTogSFRNTFNlbGVjdEVsZW1lbnQ7XHJcblxyXG4gIGdlbmVyYWxDb250cm9sczogSFRNTEZpZWxkU2V0RWxlbWVudDtcclxuICBhbGdvcml0aG1Db250cm9sczogSFRNTEZpZWxkU2V0RWxlbWVudDtcclxuXHJcbiAgc3RlcEZvcndhcmQ6IEhUTUxCdXR0b25FbGVtZW50O1xyXG4gIHN0ZXBCYWNrd2FyZDogSFRNTEJ1dHRvbkVsZW1lbnQ7XHJcbiAgdG9nZ2xlUnVubmVyOiBIVE1MQnV0dG9uRWxlbWVudDtcclxuICBmYXN0Rm9yd2FyZDogSFRNTEJ1dHRvbkVsZW1lbnQ7XHJcbiAgZmFzdEJhY2t3YXJkOiBIVE1MQnV0dG9uRWxlbWVudDtcclxufTtcclxuXHJcbnR5cGUgTGlzdGVuZXJzID0gXCJjbGlja1wiIHwgXCJjaGFuZ2VcIjsgLy8gVE9ETzogQmV0dGVyIG5hbWluZy5cclxudHlwZSBSZXNvbHZlID0gKHZhbHVlOiB1bmtub3duKSA9PiB2b2lkO1xyXG50eXBlIFJlamVjdCA9IChwcm9wczogeyB1bnRpbD86IG51bWJlcjsgcnVubmluZz86IGJvb2xlYW4gfSkgPT4gdm9pZDtcclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gQ29uc3RhbnRzIGFuZCBnbG9iYWwgdmFyaWFibGVzXHJcblxyXG5leHBvcnQgY2xhc3MgRW5naW5lIHtcclxuICAvLyBEZWZhdWx0IHZhcmlhYmxlIG5hbWVzIHN0YXJ0IHdpdGggJFxyXG5cclxuICBTdmc6IFN2ZztcclxuXHJcbiAgbWVzc2FnZXM6XHJcbiAgICB8IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIHN0cmluZyB8ICgoYXJnMDogc3RyaW5nKSA9PiBzdHJpbmcpPj5cclxuICAgIHwgdW5kZWZpbmVkO1xyXG5cclxuICAkU3ZnID0ge1xyXG4gICAgd2lkdGg6IDEwMDAsXHJcbiAgICBoZWlnaHQ6IDYwMCxcclxuICAgIG1hcmdpbjogMzAsXHJcbiAgICBvYmplY3RTaXplOiA0MCxcclxuICAgIGFuaW1hdGlvblNwZWVkOiAxMDAwLCAvLyBtaWxsaXNlY29uZHMgcGVyIHN0ZXBcclxuICB9O1xyXG5cclxuICAkQ29va2llRXhwaXJlRGF5cyA9IDMwO1xyXG4gICRDb29raWVzID0ge1xyXG4gICAgLy9UT0RPOiBjb25mdXNpbmcgbmFtaW5nXHJcbiAgICBhbmltYXRpb25TcGVlZDoge1xyXG4gICAgICBnZXRDb29raWU6ICh2YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMudG9vbGJhci5hbmltYXRpb25TcGVlZClcclxuICAgICAgICAgIHRoaXMudG9vbGJhci5hbmltYXRpb25TcGVlZC52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXRDb29raWU6ICgpID0+IHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKSxcclxuICAgIH0sXHJcbiAgICBvYmplY3RTaXplOiB7XHJcbiAgICAgIGdldENvb2tpZTogKHZhbHVlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBpZiAodGhpcy50b29sYmFyLm9iamVjdFNpemUpIHRoaXMudG9vbGJhci5vYmplY3RTaXplLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldENvb2tpZTogKCkgPT4gdGhpcy5nZXRPYmplY3RTaXplKCksXHJcbiAgICB9LFxyXG4gIH07XHJcblxyXG4gIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XHJcbiAgdG9vbGJhcjogRW5naW5lVG9vbGJhckl0ZW1zO1xyXG4gIGFjdGlvbnM6IHsgb3Blcjogc3RyaW5nOyBhcmdzOiB1bmtub3duW107IG5zdGVwczogbnVtYmVyIH1bXSA9IFtdO1xyXG4gIEN1cnJlbnRBY3Rpb246IG51bWJlciA9IDA7IC8vIHdhcyA9IG51bGwgYmVmb3JlLCB0aGlzIHNob3VsZCB3b3JrIGJldHRlclxyXG4gIEN1cnJlbnRTdGVwOiBudW1iZXIgPSAwOyAvLyB3YXMgPSBudWxsIGJlZm9yZSwgdGhpcyBzaG91bGQgd29yayBiZXR0ZXJcclxuICBERUJVRyA9IHRydWU7XHJcblxyXG4gIFN0YXRlOiB7XHJcbiAgICByZXNldHRpbmc6IGJvb2xlYW47XHJcbiAgICBhbmltYXRpbmc6IGJvb2xlYW47XHJcbiAgfSA9IHtcclxuICAgIHJlc2V0dGluZzogZmFsc2UsXHJcbiAgICBhbmltYXRpbmc6IGZhbHNlLFxyXG4gIH07XHJcblxyXG4gIEluZm86IHtcclxuICAgIHRpdGxlOiBUZXh0IHwgdW5kZWZpbmVkO1xyXG4gICAgYm9keTogVGV4dCB8IHVuZGVmaW5lZDtcclxuICAgIHByaW50ZXI6IFRleHQgfCB1bmRlZmluZWQ7XHJcbiAgICBzdGF0dXM6IFRleHQgfCB1bmRlZmluZWQ7XHJcbiAgfSA9IHtcclxuICAgIHRpdGxlOiB1bmRlZmluZWQsXHJcbiAgICBib2R5OiB1bmRlZmluZWQsXHJcbiAgICBwcmludGVyOiB1bmRlZmluZWQsXHJcbiAgICBzdGF0dXM6IHVuZGVmaW5lZCxcclxuICB9O1xyXG5cclxuICBFdmVudExpc3RlbmVyczogUmVjb3JkPHN0cmluZywgUGFydGlhbDxSZWNvcmQ8TGlzdGVuZXJzLCAoKSA9PiB2b2lkPj4+ID0ge1xyXG4gICAgc3RlcEZvcndhcmQ6IHt9LFxyXG4gICAgc3RlcEJhY2t3YXJkOiB7fSxcclxuICAgIGZhc3RGb3J3YXJkOiB7fSxcclxuICAgIGZhc3RCYWNrd2FyZDoge30sXHJcbiAgICB0b2dnbGVSdW5uZXI6IHt9LFxyXG4gIH07XHJcblxyXG4gIGdldEFuaW1hdGlvblNwZWVkKCk6IG51bWJlciB7XHJcbiAgICBpZiAodGhpcy50b29sYmFyLmFuaW1hdGlvblNwZWVkKVxyXG4gICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy50b29sYmFyLmFuaW1hdGlvblNwZWVkPy52YWx1ZSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuJFN2Zy5hbmltYXRpb25TcGVlZDtcclxuICB9XHJcblxyXG4gIGdldE9iamVjdFNpemUoKTogbnVtYmVyIHtcclxuICAgIGlmICh0aGlzLnRvb2xiYXIub2JqZWN0U2l6ZSlcclxuICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMudG9vbGJhci5vYmplY3RTaXplPy52YWx1ZSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuJFN2Zy5vYmplY3RTaXplO1xyXG4gIH1cclxuXHJcbiAgZ2V0Tm9kZVNwYWNpbmcoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmdldE9iamVjdFNpemUoKTtcclxuICB9XHJcblxyXG4gIGdldFN0cm9rZVdpZHRoKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RTaXplKCkgLyAxMjtcclxuICB9XHJcblxyXG4gIGdldE5vZGVTdGFydCgpOiBbbnVtYmVyLCBudW1iZXJdIHtcclxuICAgIHJldHVybiBbdGhpcy4kU3ZnLm1hcmdpbiArIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpIC8gMiwgdGhpcy4kU3ZnLm1hcmdpbiAqIDRdO1xyXG4gIH1cclxuXHJcbiAgZ2V0VHJlZVJvb3QoKTogW251bWJlciwgbnVtYmVyXSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICB0aGlzLlN2Zy52aWV3Ym94KCkud2lkdGggLyAyLFxyXG4gICAgICAyICogdGhpcy4kU3ZnLm1hcmdpbiArIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpIC8gMixcclxuICAgIF07XHJcbiAgfVxyXG5cclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gSW5pdGl0YWxpc2F0aW9uXHJcblxyXG4gIC8vIFRPRE86IFJlbW92ZSBkZWZhdWx0cz9cclxuICAvLyBJbXBvc2libGUgdG8gdHlwZSBkZWZhdWx0IGFuZCBpdCBpcyBub3QgdXNlZCBmb3IgcGFzc2luZyBpbiBhbnl0aGluZyBhbnl3ZXJlXHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVyU2VsZWN0b3I6IHN0cmluZywgZGVmYXVsdHMgPSB7fSkge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdHMpIHtcclxuICAgICAgaWYgKCFrZXkuc3RhcnRzV2l0aChcIiRcIikpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBkZWZhdWx0IGtleTogJHtrZXl9YCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVEZWZhdWx0KHRoaXMsIGRlZmF1bHRzLCB0cnVlKTtcclxuXHJcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yPEhUTUxFbGVtZW50Pihjb250YWluZXJTZWxlY3Rvcik7XHJcbiAgICBpZiAoIWNvbnRhaW5lcikgdGhyb3cgbmV3IEVycm9yKFwiTm8gY29udGFpbmVyIGZvdW5kXCIpO1xyXG5cclxuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgdGhpcy50b29sYmFyID0gdGhpcy5nZXRUb29sYmFyKCk7XHJcblxyXG4gICAgY29uc3Qgc3ZnQ29udGFpbmVyID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcInN2Z1wiKTtcclxuICAgIGlmICghc3ZnQ29udGFpbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdmcgZWxlbWVudCBmb3VuZFwiKTtcclxuXHJcbiAgICB0aGlzLlN2ZyA9IG5ldyBTdmcoc3ZnQ29udGFpbmVyKTtcclxuICAgIHRoaXMuU3ZnLnZpZXdib3goMCwgMCwgdGhpcy4kU3ZnLndpZHRoLCB0aGlzLiRTdmcuaGVpZ2h0KTtcclxuXHJcbiAgICBjb25zdCBkZWJ1Z1BhcmFtID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uaHJlZikuZ2V0KFwiZGVidWdcIik7XHJcbiAgICB0aGlzLkRFQlVHID0gQm9vbGVhbihkZWJ1Z1BhcmFtIHx8IGZhbHNlKTtcclxuICAgIGlmICh0aGlzLkRFQlVHKSB0aGlzLlN2Zy5hZGRDbGFzcyhcImRlYnVnXCIpO1xyXG4gIH1cclxuXHJcbiAgZ2V0VG9vbGJhcigpOiBFbmdpbmVUb29sYmFySXRlbXMge1xyXG4gICAgY29uc3QgZ2VuZXJhbENvbnRyb2xzID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcjxIVE1MRmllbGRTZXRFbGVtZW50PihcclxuICAgICAgXCJmaWVsZHNldC5nZW5lcmFsQ29udHJvbHNcIlxyXG4gICAgKTtcclxuICAgIGNvbnN0IGFsZ29yaXRobUNvbnRyb2xzID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcjxIVE1MRmllbGRTZXRFbGVtZW50PihcclxuICAgICAgXCJmaWVsZHNldC5hbGdvcml0aG1Db250cm9sc1wiXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IHN0ZXBGb3J3YXJkID1cclxuICAgICAgdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcjxIVE1MQnV0dG9uRWxlbWVudD4oXCJidXR0b24uc3RlcEZvcndhcmRcIik7XHJcbiAgICBjb25zdCBzdGVwQmFja3dhcmQgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yPEhUTUxCdXR0b25FbGVtZW50PihcclxuICAgICAgXCJidXR0b24uc3RlcEJhY2t3YXJkXCJcclxuICAgICk7XHJcbiAgICBjb25zdCB0b2dnbGVSdW5uZXIgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yPEhUTUxCdXR0b25FbGVtZW50PihcclxuICAgICAgXCJidXR0b24udG9nZ2xlUnVubmVyXCJcclxuICAgICk7XHJcbiAgICBjb25zdCBmYXN0Rm9yd2FyZCA9XHJcbiAgICAgIHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3I8SFRNTEJ1dHRvbkVsZW1lbnQ+KFwiYnV0dG9uLmZhc3RGb3J3YXJkXCIpO1xyXG4gICAgY29uc3QgZmFzdEJhY2t3YXJkID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcjxIVE1MQnV0dG9uRWxlbWVudD4oXHJcbiAgICAgIFwiYnV0dG9uLmZhc3RCYWNrd2FyZFwiXHJcbiAgICApO1xyXG4gICAgY29uc3Qgb2JqZWN0U2l6ZSA9XHJcbiAgICAgIHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3I8SFRNTFNlbGVjdEVsZW1lbnQ+KFwic2VsZWN0Lm9iamVjdFNpemVcIik7XHJcbiAgICBjb25zdCBhbmltYXRpb25TcGVlZCA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3I8SFRNTFNlbGVjdEVsZW1lbnQ+KFxyXG4gICAgICBcInNlbGVjdC5hbmltYXRpb25TcGVlZFwiXHJcbiAgICApO1xyXG5cclxuICAgIGlmICghZ2VuZXJhbENvbnRyb2xzKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGdlbmVyYWwgY29udHJvbHMgZmllbGRzZXRcIik7XHJcbiAgICBpZiAoIWFsZ29yaXRobUNvbnRyb2xzKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGFsZ29yaXRobSBjb250cm9scyBmaWVsZHNldFwiKTtcclxuXHJcbiAgICBpZiAoIXN0ZXBGb3J3YXJkKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHN0ZXAgZm9yd2FyZCBidXR0b25cIik7XHJcbiAgICBpZiAoIXN0ZXBCYWNrd2FyZCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBzdGVwIGJhY2t3YXJkIGJ1dHRvblwiKTtcclxuICAgIGlmICghdG9nZ2xlUnVubmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHRvZ2dsZSBydW5uZXIgYnV0dG9uXCIpO1xyXG4gICAgaWYgKCFmYXN0Rm9yd2FyZCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBmYXN0IGZvcndhcmQgYnV0dG9uXCIpO1xyXG4gICAgaWYgKCFmYXN0QmFja3dhcmQpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZmFzdCBiYWNrd2FyZCBidXR0b25cIik7XHJcbiAgICBpZiAoIW9iamVjdFNpemUpIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgb2JqZWN0IHNpemUgc2VsZWN0XCIpO1xyXG4gICAgaWYgKCFhbmltYXRpb25TcGVlZCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhbmltYXRpb24gc3BlZWQgc2VsZWN0XCIpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGdlbmVyYWxDb250cm9scyxcclxuICAgICAgYWxnb3JpdGhtQ29udHJvbHMsXHJcbiAgICAgIHN0ZXBGb3J3YXJkLFxyXG4gICAgICBzdGVwQmFja3dhcmQsXHJcbiAgICAgIHRvZ2dsZVJ1bm5lcixcclxuICAgICAgZmFzdEZvcndhcmQsXHJcbiAgICAgIGZhc3RCYWNrd2FyZCxcclxuICAgICAgb2JqZWN0U2l6ZSxcclxuICAgICAgYW5pbWF0aW9uU3BlZWQsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgaW5pdGlhbGlzZSgpOiB2b2lkIHtcclxuICAgIHRoaXMuaW5pdFRvb2xiYXIoKTtcclxuICAgIHRoaXMucmVzZXRBbGwoKTtcclxuICAgIHRoaXMuc2V0UnVubmluZyh0cnVlKTtcclxuICB9XHJcblxyXG4gIGluaXRUb29sYmFyKCk6IHZvaWQge1xyXG4gICAgdGhpcy50b29sYmFyLmFuaW1hdGlvblNwZWVkLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKCkgPT5cclxuICAgICAgdGhpcy5zYXZlQ29va2llcygpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcmVzZXRBbGwoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0aGlzLmFjdGlvbnMgPSBbXTtcclxuICAgIHRoaXMubG9hZENvb2tpZXMoKTtcclxuICAgIGF3YWl0IHRoaXMucmVzZXQoKTtcclxuICB9XHJcblxyXG4gIGNvbmZpcm1SZXNldEFsbCgpOiBib29sZWFuIHtcclxuICAgIGlmIChjb25maXJtKFwiVGhpcyBjbGVhcnMgdGhlIGNhbnZhcyBhbmQgeW91ciBoaXN0b3J5IVwiKSkge1xyXG4gICAgICB0aGlzLnJlc2V0QWxsKCk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcmVzZXQoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0aGlzLmNsZWFyQ2FudmFzKCk7XHJcbiAgICBhd2FpdCB0aGlzLnJlc2V0QWxnb3JpdGhtKCk7XHJcbiAgICB0aGlzLnJlc2V0TGlzdGVuZXJzKGZhbHNlKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHJlc2V0QWxnb3JpdGhtKCk6IFByb21pc2U8dm9pZD4ge31cclxuXHJcbiAgY2xlYXJDYW52YXMoKTogdm9pZCB7XHJcbiAgICB0aGlzLlN2Zy5jbGVhcigpO1xyXG4gICAgY29uc3QgdyA9IHRoaXMuU3ZnLnZpZXdib3goKS53aWR0aDtcclxuICAgIGNvbnN0IGggPSB0aGlzLlN2Zy52aWV3Ym94KCkuaGVpZ2h0O1xyXG4gICAgaWYgKHRoaXMuREVCVUcpIHtcclxuICAgICAgZm9yIChsZXQgeCA9IDE7IHggPCB3IC8gMTAwOyB4KyspXHJcbiAgICAgICAgdGhpcy5TdmcubGluZSh4ICogMTAwLCAwLCB4ICogMTAwLCBoKS5hZGRDbGFzcyhcImdyaWRsaW5lXCIpO1xyXG4gICAgICBmb3IgKGxldCB5ID0gMTsgeSA8IGggLyAxMDA7IHkrKylcclxuICAgICAgICB0aGlzLlN2Zy5saW5lKDAsIHkgKiAxMDAsIHcsIHkgKiAxMDApLmFkZENsYXNzKFwiZ3JpZGxpbmVcIik7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtYXJnaW4gPSB0aGlzLiRTdmcubWFyZ2luO1xyXG4gICAgdGhpcy5JbmZvLnRpdGxlID0gdGhpcy5TdmcudGV4dChOQlNQKS5hZGRDbGFzcyhcInRpdGxlXCIpLngobWFyZ2luKS55KG1hcmdpbik7XHJcbiAgICB0aGlzLkluZm8uYm9keSA9IHRoaXMuU3ZnLnRleHQoTkJTUClcclxuICAgICAgLmFkZENsYXNzKFwibWVzc2FnZVwiKVxyXG4gICAgICAueChtYXJnaW4pXHJcbiAgICAgIC55KDIgKiBtYXJnaW4pO1xyXG4gICAgdGhpcy5JbmZvLnByaW50ZXIgPSB0aGlzLlN2Zy50ZXh0KE5CU1ApXHJcbiAgICAgIC5hZGRDbGFzcyhcInByaW50ZXJcIilcclxuICAgICAgLngobWFyZ2luKVxyXG4gICAgICAuY3koaCAtIDIgKiBtYXJnaW4pO1xyXG4gICAgdGhpcy5JbmZvLnN0YXR1cyA9IHRoaXMuU3ZnLnRleHQoTkJTUClcclxuICAgICAgLmFkZENsYXNzKFwic3RhdHVzLXJlcG9ydFwiKVxyXG4gICAgICAueChtYXJnaW4pXHJcbiAgICAgIC5jeShoIC0gbWFyZ2luKTtcclxuICAgIHRoaXMudXBkYXRlQ1NTVmFyaWFibGVzKCk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVDU1NWYXJpYWJsZXMoKTogdm9pZCB7XHJcbiAgICBjb25zdCByZWxhdGl2ZVNpemUgPSBNYXRoLnJvdW5kKFxyXG4gICAgICAoMTAwICogdGhpcy5nZXRPYmplY3RTaXplKCkpIC8gdGhpcy4kU3ZnLm9iamVjdFNpemVcclxuICAgICk7XHJcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXHJcbiAgICAgIFwiLS1ub2RlLWZvbnQtc2l6ZVwiLFxyXG4gICAgICBgJHtyZWxhdGl2ZVNpemV9JWBcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBzZXRTdGF0dXMoc3RhdHVzOiBcInJ1bm5pbmdcIiB8IFwicGF1c2VkXCIgfCBcImluYWN0aXZlXCIsIHRpbWVvdXQgPSAxMCk6IHZvaWQge1xyXG4gICAgY29uc3QgY3VycmVudFN0YXR1cyA9IHRoaXMuSW5mby5zdGF0dXM7XHJcbiAgICBpZiAoY3VycmVudFN0YXR1cyA9PT0gdW5kZWZpbmVkKSByZXR1cm47XHJcblxyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIGlmIChzdGF0dXMgPT09IFwicnVubmluZ1wiKSB7XHJcbiAgICAgICAgY3VycmVudFN0YXR1c1xyXG4gICAgICAgICAgLnRleHQoXCJBbmltYXRpbmdcIilcclxuICAgICAgICAgIC5yZW1vdmVDbGFzcyhcInBhdXNlZFwiKVxyXG4gICAgICAgICAgLmFkZENsYXNzKFwicnVubmluZ1wiKTtcclxuICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IFwicGF1c2VkXCIpIHtcclxuICAgICAgICBjdXJyZW50U3RhdHVzLnRleHQoXCJQYXVzZWRcIikuYWRkQ2xhc3MoXCJwYXVzZWRcIikucmVtb3ZlQ2xhc3MoXCJydW5uaW5nXCIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN1cnJlbnRTdGF0dXMudGV4dChcIklkbGVcIikucmVtb3ZlQ2xhc3MoXCJwYXVzZWRcIikucmVtb3ZlQ2xhc3MoXCJydW5uaW5nXCIpO1xyXG4gICAgICB9XHJcbiAgICB9LCB0aW1lb3V0KTtcclxuICB9XHJcblxyXG4gIHNldElkbGVUaXRsZSgpOiB2b2lkIHtcclxuICAgIC8vIFRPRE86IFBlcmhhcHMgYWRkIGVycm9ycyBpZiBub3QgZm91bmRcclxuICAgIGlmICh0aGlzLkluZm8udGl0bGUgIT09IHVuZGVmaW5lZClcclxuICAgICAgdGhpcy5JbmZvLnRpdGxlLnRleHQoXCJTZWxlY3QgYW4gYWN0aW9uIGZyb20gdGhlIG1lbnUgYWJvdmVcIik7XHJcbiAgICBpZiAodGhpcy5JbmZvLmJvZHkgIT09IHVuZGVmaW5lZCkgdGhpcy5JbmZvLmJvZHkudGV4dChOQlNQKTtcclxuICB9XHJcblxyXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyBUaGUgZGVmYXVsdCBsaXN0ZW5lcnNcclxuXHJcbiAgJElkbGVMaXN0ZW5lcnM6IFJlY29yZDxcclxuICAgIHN0cmluZyxcclxuICAgIHsgdHlwZTogTGlzdGVuZXJzOyBjb25kaXRpb246ICgpID0+IGJvb2xlYW47IGhhbmRsZXI6ICgpID0+IHZvaWQgfVxyXG4gID4gPSB7XHJcbiAgICBzdGVwQmFja3dhcmQ6IHtcclxuICAgICAgdHlwZTogXCJjbGlja1wiLFxyXG4gICAgICBjb25kaXRpb246ICgpID0+IHRoaXMuYWN0aW9ucy5sZW5ndGggPiAwLFxyXG4gICAgICBoYW5kbGVyOiAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5zZXRSdW5uaW5nKGZhbHNlKTtcclxuICAgICAgICBjb25zdCBhY3Rpb24gPSB0aGlzLmFjdGlvbnMucG9wKCkhOyAvLyAhIGJlY2F1c2Ugd2Uga25vdyB0aGF0IGFycmF5IGlzIG5vbi1lbXB0eSAoYWN0aW9ucy5sZW5ndGggPiAwKTtcclxuICAgICAgICB0aGlzLmV4ZWN1dGUoYWN0aW9uLm9wZXIsIGFjdGlvbi5hcmdzLCBhY3Rpb24ubnN0ZXBzIC0gMSk7XHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgZmFzdEJhY2t3YXJkOiB7XHJcbiAgICAgIHR5cGU6IFwiY2xpY2tcIixcclxuICAgICAgY29uZGl0aW9uOiAoKSA9PiB0aGlzLmFjdGlvbnMubGVuZ3RoID4gMCxcclxuICAgICAgaGFuZGxlcjogKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuYWN0aW9ucy5wb3AoKTtcclxuICAgICAgICBpZiAodGhpcy5hY3Rpb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMuYWN0aW9ucy5wb3AoKSE7XHJcbiAgICAgICAgICB0aGlzLmV4ZWN1dGUoYWN0aW9uLm9wZXIsIGFjdGlvbi5hcmdzLCBhY3Rpb24ubnN0ZXBzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgICBvYmplY3RTaXplOiB7XHJcbiAgICAgIHR5cGU6IFwiY2hhbmdlXCIsXHJcbiAgICAgIGNvbmRpdGlvbjogKCkgPT4gdHJ1ZSxcclxuICAgICAgaGFuZGxlcjogKCkgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY29uc3QgYWN0aW9uID0gdGhpcy5hY3Rpb25zLnBvcCgpITsgLy8gISBiZWNhdXNlIHdlIGtub3cgdGhhdCBhcnJheSBpcyBub24tZW1wdHkgKGFjdGlvbnMubGVuZ3RoID4gMClcclxuICAgICAgICAgIHRoaXMuZXhlY3V0ZShhY3Rpb24ub3BlciwgYWN0aW9uLmFyZ3MsIGFjdGlvbi5uc3RlcHMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICB9O1xyXG5cclxuICAvLyBUT0RPOiBGaXggc29tZSBuaWNlIHR5cGUgZm9yIHRoaXNcclxuICAkQXN5bmNMaXN0ZW5lcnM6IFJlY29yZDxcclxuICAgIHN0cmluZyxcclxuICAgIHtcclxuICAgICAgdHlwZTogTGlzdGVuZXJzO1xyXG4gICAgICBoYW5kbGVyOiAocmVzb2x2ZTogUmVzb2x2ZSwgcmVqZWN0OiBSZWplY3QpID0+IHZvaWQ7XHJcbiAgICB9XHJcbiAgPiA9IHtcclxuICAgIHN0ZXBGb3J3YXJkOiB7XHJcbiAgICAgIHR5cGU6IFwiY2xpY2tcIixcclxuICAgICAgaGFuZGxlcjogKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHRoaXMuc2V0UnVubmluZyhmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5zdGVwRm9yd2FyZChyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICAgIGZhc3RGb3J3YXJkOiB7XHJcbiAgICAgIHR5cGU6IFwiY2xpY2tcIixcclxuICAgICAgaGFuZGxlcjogKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHRoaXMuYWN0aW9uc1t0aGlzLkN1cnJlbnRBY3Rpb25dLm5zdGVwcyA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xyXG4gICAgICAgIHRoaXMuZmFzdEZvcndhcmQocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgICB0b2dnbGVSdW5uZXI6IHtcclxuICAgICAgdHlwZTogXCJjbGlja1wiLFxyXG4gICAgICBoYW5kbGVyOiAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgdGhpcy50b2dnbGVSdW5uZXIoKTtcclxuICAgICAgICBpZiAodGhpcy5pc1J1bm5pbmcoKSkge1xyXG4gICAgICAgICAgdGhpcy5zdGVwRm9yd2FyZChyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLkN1cnJlbnRTdGVwKys7XHJcbiAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICAgIHN0ZXBCYWNrd2FyZDoge1xyXG4gICAgICB0eXBlOiBcImNsaWNrXCIsXHJcbiAgICAgIGhhbmRsZXI6IChyZXNvbHZlLCByZWplY3QpID0+XHJcbiAgICAgICAgcmVqZWN0KHsgdW50aWw6IHRoaXMuQ3VycmVudFN0ZXAgLSAxLCBydW5uaW5nOiBmYWxzZSB9KSxcclxuICAgIH0sXHJcbiAgICBmYXN0QmFja3dhcmQ6IHtcclxuICAgICAgdHlwZTogXCJjbGlja1wiLFxyXG4gICAgICBoYW5kbGVyOiAocmVzb2x2ZSwgcmVqZWN0KSA9PiByZWplY3QoeyB1bnRpbDogMCB9KSxcclxuICAgIH0sXHJcbiAgICBvYmplY3RTaXplOiB7XHJcbiAgICAgIHR5cGU6IFwiY2hhbmdlXCIsXHJcbiAgICAgIGhhbmRsZXI6IChyZXNvbHZlLCByZWplY3QpID0+IHJlamVjdCh7IHVudGlsOiB0aGlzLkN1cnJlbnRTdGVwIH0pLFxyXG4gICAgfSxcclxuICB9O1xyXG5cclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gVXBkYXRpbmcgbGlzdGVuZXJzXHJcblxyXG4gIGRpc2FibGVXaGVuUnVubmluZyhkaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgZm9yIChjb25zdCBlbGVtIG9mIHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGw8XHJcbiAgICAgIEhUTUxJbnB1dEVsZW1lbnQgfCBIVE1MU2VsZWN0RWxlbWVudFxyXG4gICAgPihcIi5kaXNhYmxlV2hlblJ1bm5pbmdcIikpXHJcbiAgICAgIGVsZW0uZGlzYWJsZWQgPSBkaXNhYmxlZDtcclxuICB9XHJcblxyXG4gIHJlc2V0TGlzdGVuZXJzKGlzUnVubmluZzogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgdGhpcy5zYXZlQ29va2llcygpO1xyXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBFbmdpbmUpIHtcclxuICAgICAgdGhpcy5kaXNhYmxlV2hlblJ1bm5pbmcodHJ1ZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuYWRkTGlzdGVuZXIoXCJ0b2dnbGVSdW5uZXJcIiwgXCJjbGlja1wiLCAoKSA9PiB0aGlzLnRvZ2dsZVJ1bm5lcigpKTtcclxuICAgIGlmIChpc1J1bm5pbmcpIHtcclxuICAgICAgdGhpcy5kaXNhYmxlV2hlblJ1bm5pbmcodHJ1ZSk7XHJcbiAgICAgIHRoaXMuc2V0U3RhdHVzKFwicGF1c2VkXCIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kaXNhYmxlV2hlblJ1bm5pbmcoZmFsc2UpO1xyXG4gICAgdGhpcy5zZXRJZGxlVGl0bGUoKTtcclxuICAgIHRoaXMuc2V0U3RhdHVzKFwiaW5hY3RpdmVcIik7XHJcbiAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMuJElkbGVMaXN0ZW5lcnMpIHtcclxuICAgICAgY29uc3QgbGlzdGVuZXIgPSB0aGlzLiRJZGxlTGlzdGVuZXJzW2lkXTtcclxuICAgICAgaWYgKGxpc3RlbmVyLmNvbmRpdGlvbigpKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuREVCVUcpXHJcbiAgICAgICAgICB0aGlzLmFkZExpc3RlbmVyKGlkLCBsaXN0ZW5lci50eXBlLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICAgIGAke2lkfSAke2xpc3RlbmVyLnR5cGV9OiAke0pTT04uc3RyaW5naWZ5KHRoaXMuYWN0aW9ucyl9YFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBsaXN0ZW5lci5oYW5kbGVyKCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICBlbHNlIHRoaXMuYWRkTGlzdGVuZXIoaWQsIGxpc3RlbmVyLnR5cGUsIGxpc3RlbmVyLmhhbmRsZXIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhZGRMaXN0ZW5lcihpZDogc3RyaW5nLCB0eXBlOiBMaXN0ZW5lcnMsIGhhbmRsZXI6ICgpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuRXZlbnRMaXN0ZW5lcnM7XHJcbiAgICBpZiAoIWxpc3RlbmVyc1tpZF0pIGxpc3RlbmVyc1tpZF0gPSB7fTtcclxuICAgIGNvbnN0IGVsZW0gPSB0aGlzLnRvb2xiYXJbaWQgYXMga2V5b2YgdHlwZW9mIHRoaXMudG9vbGJhcl07XHJcblxyXG4gICAgaWYgKCFlbGVtKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBlbGVtZW50IHRvIGFkZCBsaXN0ZW5lciB0b1wiKTtcclxuXHJcbiAgICBjb25zdCBvbGRIYW5kbGVyID0gbGlzdGVuZXJzW2lkXVt0eXBlXTtcclxuICAgIGlmIChvbGRIYW5kbGVyKSBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgb2xkSGFuZGxlcik7XHJcbiAgICBsaXN0ZW5lcnNbaWRdW3R5cGVdID0gaGFuZGxlcjtcclxuICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcclxuICAgIGVsZW0uZGlzYWJsZWQgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIHJlbW92ZUFsbExpc3RlbmVycygpOiB2b2lkIHtcclxuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuRXZlbnRMaXN0ZW5lcnM7XHJcblxyXG4gICAgZm9yIChjb25zdCBpZCBpbiBsaXN0ZW5lcnMpIHtcclxuICAgICAgY29uc3QgZWxlbSA9IHRoaXMudG9vbGJhcltpZCBhcyBrZXlvZiB0eXBlb2YgdGhpcy50b29sYmFyXTtcclxuXHJcbiAgICAgIGlmICghZWxlbSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBlbGVtZW50IHRvIHJlbW92ZSBsaXN0ZW5lciBmcm9tXCIpO1xyXG5cclxuICAgICAgZWxlbS5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgIGZvciAoY29uc3QgdHlwZSBpbiBsaXN0ZW5lcnNbaWRdKVxyXG4gICAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaWRdW3R5cGUgYXMgTGlzdGVuZXJzXSEpOyAvLyAhIGJlY2F1c2Ugd2Uga25vdyB0aGF0IHRoZSB0eXBlIGV4aXN0c1xyXG4gICAgICBsaXN0ZW5lcnNbaWRdID0ge307XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gRXhlY3V0aW5nIHRoZSBhY3Rpb25zXHJcblxyXG4gIGFzeW5jIHN1Ym1pdChtZXRob2Q6IHN0cmluZywgZmllbGQ6IEhUTUxJbnB1dEVsZW1lbnQpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJhd1ZhbHVlID0gZmllbGQudmFsdWU7XHJcbiAgICAgIGZpZWxkLnZhbHVlID0gXCJcIjtcclxuICAgICAgY29uc3QgdmFsdWVzID0gcGFyc2VWYWx1ZXMocmF3VmFsdWUpO1xyXG4gICAgICBpZiAodmFsdWVzKSBhd2FpdCB0aGlzLmV4ZWN1dGUobWV0aG9kLCB2YWx1ZXMpO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZXhlY3V0ZShcclxuICAgIG9wZXJhdGlvbjogc3RyaW5nLFxyXG4gICAgYXJnczogdW5rbm93bltdID0gW10sXHJcbiAgICB1bnRpbCA9IDBcclxuICApOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGF3YWl0IHRoaXMucmVzZXQoKTtcclxuICAgIHRoaXMuYWN0aW9ucy5wdXNoKHsgb3Blcjogb3BlcmF0aW9uLCBhcmdzOiBhcmdzLCBuc3RlcHM6IHVudGlsIH0pO1xyXG4gICAgaWYgKHRoaXMuREVCVUcpXHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGBFWEVDICR7dW50aWx9OiAke29wZXJhdGlvbn0gJHthcmdzLmpvaW4oXCIsIFwiKX0sICR7SlNPTi5zdHJpbmdpZnkoXHJcbiAgICAgICAgICB0aGlzLmFjdGlvbnNcclxuICAgICAgICApfWBcclxuICAgICAgKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCB0aGlzLnJ1bkFjdGlvbnNMb29wKCk7XHJcbiAgICAgIHRoaXMuYWN0aW9uc1t0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMV0ubnN0ZXBzID0gdGhpcy5DdXJyZW50U3RlcCB8fCAwOyAvLyBUT0RPOiBOb3Qgc3VyZSBpZiB0aGlzIGlzIGNvcnJlY3RcclxuICAgICAgaWYgKHRoaXMuREVCVUcpXHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBgRE9ORSAvICR7dGhpcy5DdXJyZW50U3RlcH06ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5hY3Rpb25zKX1gXHJcbiAgICAgICAgKTtcclxuICAgICAgdGhpcy5yZXNldExpc3RlbmVycyhmYWxzZSk7XHJcbiAgICB9IGNhdGNoIChyZWFzb24pIHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgIHR5cGVvZiByZWFzb24gIT09IFwib2JqZWN0XCIgfHxcclxuICAgICAgICByZWFzb24gPT09IG51bGwgfHwgLy8gQWRkZWQgbGluZSB0byBoZWxwIGNoZWNrcyBiZWxvd1xyXG4gICAgICAgIFwidW50aWxcIiBpbiByZWFzb24gPT09IGZhbHNlIHx8IC8vIEFkZGVkIGxpbmUgdG8gaGVscCBjaGVja3MgYmVsb3dcclxuICAgICAgICB0eXBlb2YgcmVhc29uLnVudGlsICE9PSBcIm51bWJlclwiIC8vIENoYW5nZWQgdG8gYmUgYWJsZSB0byBhc3NpZ24gdG8gdW50aWwgd2hpY2ggaXMgYSBudW1iZXJcclxuICAgICAgKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihyZWFzb24pO1xyXG4gICAgICAgIHRoaXMucmVzZXRMaXN0ZW5lcnMoZmFsc2UpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmFjdGlvbnMucG9wKCk7XHJcbiAgICAgIGlmIChcInJ1bm5pbmdcIiBpbiByZWFzb24gJiYgdHlwZW9mIHJlYXNvbi5ydW5uaW5nID09PSBcImJvb2xlYW5cIilcclxuICAgICAgICB0aGlzLnNldFJ1bm5pbmcocmVhc29uLnJ1bm5pbmcpO1xyXG4gICAgICB1bnRpbCA9IHJlYXNvbi51bnRpbDtcclxuICAgICAgaWYgKHRoaXMuREVCVUcpXHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBgUkVSVU4gJHt1bnRpbH0gLyAke3RoaXMuQ3VycmVudFN0ZXB9OiAke0pTT04uc3RyaW5naWZ5KFxyXG4gICAgICAgICAgICB0aGlzLmFjdGlvbnNcclxuICAgICAgICAgICl9YFxyXG4gICAgICAgICk7XHJcbiAgICAgIGlmICh1bnRpbCA8PSAwICYmIHRoaXMuYWN0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc3QgYWN0aW9uID0gdGhpcy5hY3Rpb25zLnBvcCgpITsgLy8gISBiZWNhdXNlIHdlIGtub3cgdGhhdCBhcnJheSBpcyBub24tZW1wdHkgKGFjdGlvbnMubGVuZ3RoID4gMClcclxuICAgICAgICAob3BlcmF0aW9uID0gYWN0aW9uLm9wZXIpLFxyXG4gICAgICAgICAgKGFyZ3MgPSBhY3Rpb24uYXJncyksXHJcbiAgICAgICAgICAodW50aWwgPSBhY3Rpb24ubnN0ZXBzKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodW50aWwgPiAwKSB7XHJcbiAgICAgICAgdGhpcy5leGVjdXRlKG9wZXJhdGlvbiwgYXJncywgdW50aWwpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgcnVuQWN0aW9uc0xvb3AoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBmb3IgKGxldCBuQWN0aW9uID0gMDsgbkFjdGlvbiA8IHRoaXMuYWN0aW9ucy5sZW5ndGg7IG5BY3Rpb24rKykge1xyXG4gICAgICB0aGlzLnJlc2V0TGlzdGVuZXJzKHRydWUpO1xyXG4gICAgICBjb25zdCBhY3Rpb24gPSB0aGlzLmFjdGlvbnNbbkFjdGlvbl07XHJcbiAgICAgIHRoaXMuQ3VycmVudEFjdGlvbiA9IG5BY3Rpb247XHJcbiAgICAgIHRoaXMuQ3VycmVudFN0ZXAgPSAwO1xyXG4gICAgICAvLyBNYWtlIGNhbWVsQ2FzZSBzZXBhcmF0ZSB3b3JkczogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxMTQ4NjMwXHJcbiAgICAgIGNvbnN0IG1lc3NhZ2VBcnIgPSBhY3Rpb24ub3Blci5tYXRjaCgvW0EtWmEtel1bYS16XSovZykgfHwgW107XHJcbiAgICAgIGxldCBtZXNzYWdlID0gbWVzc2FnZUFyci5qb2luKFwiIFwiKTtcclxuICAgICAgbWVzc2FnZSA9IGAke1xyXG4gICAgICAgIG1lc3NhZ2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBtZXNzYWdlLnN1YnN0cmluZygxKVxyXG4gICAgICB9ICR7YWN0aW9uLmFyZ3Muam9pbihcIiwgXCIpfWA7XHJcbiAgICAgIGlmICh0aGlzLkRFQlVHKVxyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgYENBTEwgJHtuQWN0aW9ufTogJHttZXNzYWdlfSwgJHtKU09OLnN0cmluZ2lmeSh0aGlzLmFjdGlvbnMpfWBcclxuICAgICAgICApO1xyXG4gICAgICB0aGlzLkluZm8udGl0bGU/LnRleHQobWVzc2FnZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UoXCJcIik7XHJcbiAgICAgIGlmIChcclxuICAgICAgICAhKFxyXG4gICAgICAgICAgYWN0aW9uLm9wZXIgaW4gdGhpcyAmJlxyXG4gICAgICAgICAgdHlwZW9mIHRoaXNbYWN0aW9uLm9wZXIgYXMga2V5b2YgRW5naW5lXSA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgKVxyXG4gICAgICApXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgYWN0aW9uIHRoYXQgZG9lcyBub3QgZXhpc3RcIik7XHJcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSGF2ZSBjaGVja2VkIHRoYXQgaXQgZXhpc3RzIGFuZCB0aGF0IGlzIGEgZnVuY3Rpb24uIE9ubHkgdGhpbmcgd291bGQgYmUgdG8gdmFsaWRhdGUgaW5wdXQuIEJldHRlciB0byBkbyBpbiBlYWNoIGZ1bmN0aW9uIGluIGFueSBjYXNlXHJcbiAgICAgIGF3YWl0IHRoaXNbYWN0aW9uLm9wZXJdKC4uLmFjdGlvbi5hcmdzKTsgLy8gS29tbWVyIGJsaSBrbsO2bGlnIGF0dCBsw7ZzYVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcGF1c2UoXHJcbiAgICBtZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQsXHJcbiAgICAuLi5hcmdzOiB1bmtub3duW11cclxuICApOiBQcm9taXNlPHVua25vd24+IHwgbnVsbCB7XHJcbiAgICBjb25zdCB0aXRsZSA9IHRoaXMuZ2V0TWVzc2FnZShtZXNzYWdlLCAuLi5hcmdzKTtcclxuICAgIGlmICh0aGlzLkRFQlVHKVxyXG4gICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICBgJHtcclxuICAgICAgICAgIHRoaXMuQ3VycmVudFN0ZXBcclxuICAgICAgICB9LiBEb2luZzogJHt0aXRsZX0gKHJ1bm5pbmc6ICR7dGhpcy5pc1J1bm5pbmcoKX0pLCAke0pTT04uc3RyaW5naWZ5KFxyXG4gICAgICAgICAgdGhpcy5hY3Rpb25zXHJcbiAgICAgICAgKX1gXHJcbiAgICAgICk7XHJcbiAgICBpZiAodGhpcy5TdGF0ZS5yZXNldHRpbmcpIHJldHVybiBudWxsO1xyXG4gICAgaWYgKHRpdGxlICE9PSBudWxsICYmIHRoaXMuSW5mby5ib2R5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy5JbmZvLmJvZHkudGV4dCh0aXRsZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBjb25zdCBhY3Rpb24gPSB0aGlzLmFjdGlvbnNbdGhpcy5DdXJyZW50QWN0aW9uXTtcclxuICAgICAgaWYgKGFjdGlvbi5uc3RlcHMgIT0gbnVsbCAmJiB0aGlzLkN1cnJlbnRTdGVwIDwgYWN0aW9uLm5zdGVwcykge1xyXG4gICAgICAgIHRoaXMuZmFzdEZvcndhcmQocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsZXQgcnVubmVyVGltZXI6IE5vZGVKUy5UaW1lb3V0IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGZvciAoY29uc3QgaWQgaW4gdGhpcy4kQXN5bmNMaXN0ZW5lcnMpIHtcclxuICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gdGhpcy4kQXN5bmNMaXN0ZW5lcnNbaWRdO1xyXG4gICAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcihpZCwgbGlzdGVuZXIudHlwZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQocnVubmVyVGltZXIpO1xyXG4gICAgICAgICAgICBsaXN0ZW5lci5oYW5kbGVyKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nKCkpIHtcclxuICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKFwicnVubmluZ1wiKTtcclxuICAgICAgICAgIHJ1bm5lclRpbWVyID0gc2V0VGltZW91dChcclxuICAgICAgICAgICAgKCkgPT4gdGhpcy5zdGVwRm9yd2FyZChyZXNvbHZlLCByZWplY3QpLFxyXG4gICAgICAgICAgICB0aGlzLmdldEFuaW1hdGlvblNwZWVkKCkgKiAxLjFcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIFRPRE86IEZpeCB0eXBlIG9mIHRpdGxlIGFuZCB1cGRhdGUgcmV0dXJuIHR5cGVcclxuICBnZXRNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCwgLi4uYXJnczogdW5rbm93bltdKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlKSkgW21lc3NhZ2UsIC4uLmFyZ3NdID0gWy4uLm1lc3NhZ2UsIC4uLmFyZ3NdOyAvLyBUT0RPOiBpcyB0aGlzIHVzZWQ/P1xyXG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIGNvbnNvbGUuZXJyb3IoXCJVbmtub3duIG1lc3NhZ2U6XCIsIG1lc3NhZ2UsIC4uLmFyZ3MpO1xyXG4gICAgICByZXR1cm4gbWVzc2FnZTtcclxuICAgIH1cclxuICAgIGlmICghbWVzc2FnZSkgcmV0dXJuIGFyZ3Muam9pbihcIlxcblwiKTtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdGhpcy5jb25zdHJ1Y3Rvci5tZXNzYWdlcyBkb250IGtub3cgd2hhdCBpdCBpc1xyXG4gICAgbGV0IHRpdGxlID0gdGhpcy5tZXNzYWdlcyB8fCB0aGlzLmNvbnN0cnVjdG9yLm1lc3NhZ2VzIHx8IHt9O1xyXG4gICAgY29uc3Qga2V5cyA9IG1lc3NhZ2Uuc3BsaXQoXCIuXCIpO1xyXG4gICAgaWYgKCEoa2V5c1swXSBpbiB0aXRsZSkpIHJldHVybiBbbWVzc2FnZSwgLi4uYXJnc10uam9pbihcIlxcblwiKTtcclxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcclxuICAgICAgaWYgKCEodHlwZW9mIHRpdGxlID09PSBcIm9iamVjdFwiICYmIGtleSBpbiB0aXRsZSkpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5rbm93biBtZXNzYWdlOlwiLCBtZXNzYWdlLCAuLi5hcmdzKTtcclxuICAgICAgICByZXR1cm4gW21lc3NhZ2UsIC4uLmFyZ3NdLmpvaW4oXCJcXG5cIik7XHJcbiAgICAgIH1cclxuICAgICAgdGl0bGUgPSB0aXRsZVtrZXldO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB0aXRsZSA9PT0gXCJmdW5jdGlvblwiKSB0aXRsZSA9IHRpdGxlKC4uLmFyZ3MpO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGl0bGUpKSB0aXRsZSA9IHRpdGxlLmpvaW4oXCJcXG5cIik7XHJcbiAgICBpZiAodHlwZW9mIHRpdGxlID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmtub3duIG1lc3NhZ2U6XCIsIG1lc3NhZ2UsIC4uLmFyZ3MpO1xyXG4gICAgICByZXR1cm4gW21lc3NhZ2UsIC4uLmFyZ3NdLmpvaW4oXCJcXG5cIik7XHJcbiAgICB9XHJcbiAgICBpZiAodGl0bGUgPT09IFwiXCIpIHRpdGxlID0gTkJTUDtcclxuICAgIHJldHVybiB0aXRsZTtcclxuICB9XHJcblxyXG4gIHN0ZXBGb3J3YXJkKHJlc29sdmU6IFJlc29sdmUsIHJlamVjdDogUmVqZWN0KTogdm9pZCB7XHJcbiAgICB0aGlzLkN1cnJlbnRTdGVwKys7XHJcbiAgICB0aGlzLlN0YXRlLmFuaW1hdGluZyA9IHRydWU7XHJcbiAgICByZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgfVxyXG5cclxuICBmYXN0Rm9yd2FyZChyZXNvbHZlOiBSZXNvbHZlLCByZWplY3Q6IFJlamVjdCk6IHZvaWQge1xyXG4gICAgY29uc3QgYWN0aW9uID0gdGhpcy5hY3Rpb25zW3RoaXMuQ3VycmVudEFjdGlvbl07XHJcbiAgICBpZiAodGhpcy5DdXJyZW50U3RlcCA+PSBhY3Rpb24ubnN0ZXBzKSB7XHJcbiAgICAgIGFjdGlvbi5uc3RlcHMgPSB0aGlzLkN1cnJlbnRTdGVwO1xyXG4gICAgfVxyXG4gICAgdGhpcy5DdXJyZW50U3RlcCsrO1xyXG4gICAgdGhpcy5TdGF0ZS5hbmltYXRpbmcgPSBmYWxzZTtcclxuICAgIGlmICh0aGlzLkRFQlVHKSBzZXRUaW1lb3V0KHJlc29sdmUsIDEwKTtcclxuICAgIGVsc2UgcmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gIH1cclxuXHJcbiAgaXNSdW5uaW5nKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMudG9vbGJhci50b2dnbGVSdW5uZXI/LmNsYXNzTGlzdC5jb250YWlucyhcInNlbGVjdGVkXCIpIHx8IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgc2V0UnVubmluZyhydW5uaW5nOiBib29sZWFuKTogdGhpcyB7XHJcbiAgICBjb25zdCBjbGFzc2VzID0gdGhpcy50b29sYmFyLnRvZ2dsZVJ1bm5lcj8uY2xhc3NMaXN0O1xyXG4gICAgaWYgKGNsYXNzZXMgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgdG9nZ2xlUnVubmVyXCIpO1xyXG4gICAgaWYgKHJ1bm5pbmcpIGNsYXNzZXMuYWRkKFwic2VsZWN0ZWRcIik7XHJcbiAgICBlbHNlIGNsYXNzZXMucmVtb3ZlKFwic2VsZWN0ZWRcIik7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHRvZ2dsZVJ1bm5lcigpOiB0aGlzIHtcclxuICAgIHJldHVybiB0aGlzLnNldFJ1bm5pbmcoIXRoaXMuaXNSdW5uaW5nKCkpO1xyXG4gIH1cclxuXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIENvb2tpZXNcclxuXHJcbiAgbG9hZENvb2tpZXMoKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5ERUJVRykgY29uc29sZS5sb2coXCJMb2FkaW5nIGNvb2tpZXNcIiwgZG9jdW1lbnQuY29va2llKTtcclxuICAgIGNvbnN0IGFsbENvb2tpZXMgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoXCI7XCIpO1xyXG4gICAgZm9yIChjb25zdCBjb29raWVOYW1lIGluIHRoaXMuJENvb2tpZXMpIHtcclxuICAgICAgZm9yIChjb25zdCBjb29raWUgb2YgYWxsQ29va2llcykge1xyXG4gICAgICAgIGNvbnN0IFtjb29raWVOYW1lMCwgdmFsdWUwXSA9IGNvb2tpZS5zcGxpdChcIj1cIiwgMik7XHJcbiAgICAgICAgaWYgKGNvb2tpZU5hbWUwLnRyaW0oKSA9PT0gY29va2llTmFtZSkge1xyXG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUwKTtcclxuICAgICAgICAgIHRoaXMuJENvb2tpZXNbY29va2llTmFtZSBhcyBrZXlvZiB0eXBlb2YgdGhpcy4kQ29va2llc10uZ2V0Q29va2llKFxyXG4gICAgICAgICAgICB2YWx1ZVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2F2ZUNvb2tpZXMoKTogdm9pZCB7XHJcbiAgICBsZXQgZXhwaXJlcyA9IFwiXCI7XHJcbiAgICBpZiAodGhpcy4kQ29va2llRXhwaXJlRGF5cyA+IDApIHtcclxuICAgICAgY29uc3QgZXhkYXRlID0gbmV3IERhdGUoKTtcclxuICAgICAgZXhkYXRlLnNldERhdGUoZXhkYXRlLmdldERhdGUoKSArIHRoaXMuJENvb2tpZUV4cGlyZURheXMpO1xyXG4gICAgICBleHBpcmVzID0gYDtleHBpcmVzPSR7ZXhkYXRlLnRvVVRDU3RyaW5nKCl9YDtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgY29va2llTmFtZSBpbiB0aGlzLiRDb29raWVzKSB7XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gZW5jb2RlVVJJQ29tcG9uZW50KFxyXG4gICAgICAgIHRoaXMuJENvb2tpZXNbY29va2llTmFtZSBhcyBrZXlvZiB0eXBlb2YgdGhpcy4kQ29va2llc10uc2V0Q29va2llKClcclxuICAgICAgKTtcclxuICAgICAgZG9jdW1lbnQuY29va2llID0gYCR7Y29va2llTmFtZX09JHt2YWx1ZX0ke2V4cGlyZXN9YDtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLkRFQlVHKSBjb25zb2xlLmxvZyhcIlNldHRpbmcgY29va2llc1wiLCBkb2N1bWVudC5jb29raWUpO1xyXG4gIH1cclxuXHJcbiAgLy8gVE9ETzogRml4IHRvIG1hdGNoIHRoZSBuZXcgbGF5b3V0IG9mIGJhc2ljIG9iamVjdHNcclxuICAvLyBXaWxsIG5vdCB3b3JrIHJpZ2h0IG5vd1xyXG4gIC8vIFRPRE86IEZpeCB0byB3b3JrIHdpdGggZ2VuZXJpYyBvYmplY3RzXHJcbiAgYW5pbWF0ZShlbGVtOiBFbGVtZW50LCBhbmltYXRlID0gdHJ1ZSkge1xyXG4gICAgaWYgKHRoaXMuU3RhdGUuYW5pbWF0aW5nICYmIGFuaW1hdGUpIHtcclxuICAgICAgdGhpcy5zZXRTdGF0dXMoXCJydW5uaW5nXCIpO1xyXG4gICAgICB0aGlzLnNldFN0YXR1cyhcInBhdXNlZFwiLCB0aGlzLmdldEFuaW1hdGlvblNwZWVkKCkpO1xyXG4gICAgICByZXR1cm4gZWxlbS5hbmltYXRlKHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKSwgMCwgXCJub3dcIik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZWxlbTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gSGVscGVyIGZ1bmN0aW9uc1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZU51bWJlcihpbnB1dDogc3RyaW5nKTogc3RyaW5nIHwgbnVtYmVyIHtcclxuICBpbnB1dCA9IGlucHV0LnRyaW0oKTtcclxuICByZXR1cm4gaW5wdXQgPT09IFwiXCIgfHwgaXNOYU4oTnVtYmVyKGlucHV0KSkgPyBpbnB1dCA6IE51bWJlcihpbnB1dCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVZhbHVlcyhcclxuICB2YWx1ZXM6IHN0cmluZyB8IHN0cmluZ1tdIHwgbnVsbCB8IHVuZGVmaW5lZFxyXG4pOiAoc3RyaW5nIHwgbnVtYmVyKVtdIHtcclxuICBpZiAoIXZhbHVlcykgcmV0dXJuIFtdO1xyXG4gIGlmICh0eXBlb2YgdmFsdWVzID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICB2YWx1ZXMgPSB2YWx1ZXMudHJpbSgpLnNwbGl0KC9cXHMrLyk7XHJcbiAgfVxyXG4gIHJldHVybiB2YWx1ZXMubWFwKCh2KSA9PiBub3JtYWxpemVOdW1iZXIodikpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWRkUmV0dXJuU3VibWl0KFxyXG4gIGZpZWxkOiBIVE1MSW5wdXRFbGVtZW50LFxyXG4gIGFsbG93ZWQ6IHN0cmluZyxcclxuICBhY3Rpb246ICgpID0+IHZvaWRcclxuKTogdm9pZCB7XHJcbiAgYWxsb3dlZCA9XHJcbiAgICBhbGxvd2VkID09PSBcImludFwiXHJcbiAgICAgID8gXCIwLTlcIlxyXG4gICAgICA6IGFsbG93ZWQgPT09IFwiaW50K1wiXHJcbiAgICAgID8gXCIwLTkgXCJcclxuICAgICAgOiBhbGxvd2VkID09PSBcImZsb2F0XCJcclxuICAgICAgPyBcIi0uMC05XCJcclxuICAgICAgOiBhbGxvd2VkID09PSBcImZsb2F0K1wiXHJcbiAgICAgID8gXCItLjAtOSBcIlxyXG4gICAgICA6IGFsbG93ZWQgPT09IFwiQUxQSEFcIlxyXG4gICAgICA/IFwiQS1aXCJcclxuICAgICAgOiBhbGxvd2VkID09PSBcIkFMUEhBK1wiXHJcbiAgICAgID8gXCJBLVogXCJcclxuICAgICAgOiBhbGxvd2VkID09PSBcImFscGhhXCJcclxuICAgICAgPyBcImEtekEtWlwiXHJcbiAgICAgIDogYWxsb3dlZCA9PT0gXCJhbHBoYStcIlxyXG4gICAgICA/IFwiYS16QS1aIFwiXHJcbiAgICAgIDogYWxsb3dlZCA9PT0gXCJBTFBIQU5VTVwiXHJcbiAgICAgID8gXCJBLVowLTlcIlxyXG4gICAgICA6IGFsbG93ZWQgPT09IFwiQUxQSEFOVU0rXCJcclxuICAgICAgPyBcIkEtWjAtOSBcIlxyXG4gICAgICA6IGFsbG93ZWQgPT09IFwiYWxwaGFudW1cIlxyXG4gICAgICA/IFwiYS16QS1aMC05XCJcclxuICAgICAgOiBhbGxvd2VkID09PSBcImFscGhhbnVtK1wiXHJcbiAgICAgID8gXCJhLXpBLVowLTkgXCJcclxuICAgICAgOiBhbGxvd2VkO1xyXG5cclxuICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYFteJHthbGxvd2VkfV1gLCBcImdcIik7XHJcblxyXG4gIGNvbnN0IHRyYW5zZm9ybTogKHM6IHN0cmluZykgPT4gc3RyaW5nID1cclxuICAgIGFsbG93ZWQgPT09IGFsbG93ZWQudG9VcHBlckNhc2UoKVxyXG4gICAgICA/IChzKSA9PiBzLnRvVXBwZXJDYXNlKClcclxuICAgICAgOiBhbGxvd2VkID09PSBhbGxvd2VkLnRvTG93ZXJDYXNlKClcclxuICAgICAgPyAocykgPT4gcy50b0xvd2VyQ2FzZSgpXHJcbiAgICAgIDogKHMpID0+IHM7XHJcblxyXG4gIC8vIElkZWEgdGFrZW4gZnJvbSBoZXJlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTQ3MTk4MThcclxuICBmaWVsZC5vbmlucHV0ID0gKGV2ZW50KSA9PiB7XHJcbiAgICBsZXQgcG9zID0gZmllbGQuc2VsZWN0aW9uU3RhcnQgfHwgMDsgLy8gQ29ycmVjdCB0byBhZGQgMD9cclxuICAgIGxldCB2YWx1ZSA9IHRyYW5zZm9ybShmaWVsZC52YWx1ZSk7XHJcbiAgICBpZiAocmVnZXgudGVzdCh2YWx1ZSkpIHtcclxuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlZ2V4LCBcIlwiKTtcclxuICAgICAgcG9zLS07XHJcbiAgICB9XHJcbiAgICBmaWVsZC52YWx1ZSA9IHZhbHVlO1xyXG4gICAgZmllbGQuc2V0U2VsZWN0aW9uUmFuZ2UocG9zLCBwb3MpO1xyXG4gIH07XHJcblxyXG4gIGlmIChhY3Rpb24pIHtcclxuICAgIGZpZWxkLm9ua2V5ZG93biA9IChldmVudCkgPT4ge1xyXG4gICAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGFjdGlvbigpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuLy8gVE9ETzogRml4IHR5cGVzXHJcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVEZWZhdWx0KFxyXG4gIG9iajogYW55LFxyXG4gIGRlZmF1bHRPYmo6IGFueSxcclxuICBvdmVycmlkZTogYm9vbGVhbiA9IGZhbHNlXHJcbik6IHZvaWQge1xyXG4gIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHRPYmopIHtcclxuICAgIGlmICghKGtleSBpbiBvYmopKSB7XHJcbiAgICAgIG9ialtrZXldID0gZGVmYXVsdE9ialtrZXldO1xyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgdHlwZW9mIG9ialtrZXldID09PSBcIm9iamVjdFwiICYmXHJcbiAgICAgIG9ialtrZXldICE9PSBudWxsICYmXHJcbiAgICAgIHR5cGVvZiBkZWZhdWx0T2JqW2tleV0gPT09IFwib2JqZWN0XCIgJiZcclxuICAgICAgZGVmYXVsdE9ialtrZXldICE9PSBudWxsXHJcbiAgICApIHtcclxuICAgICAgdXBkYXRlRGVmYXVsdChvYmpba2V5XSwgZGVmYXVsdE9ialtrZXldLCBvdmVycmlkZSk7XHJcbiAgICB9IGVsc2UgaWYgKG92ZXJyaWRlKSB7XHJcbiAgICAgIG9ialtrZXldID0gZGVmYXVsdE9ialtrZXldO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1vZHVsbyhuOiBudW1iZXIsIGQ6IG51bWJlcik6IG51bWJlciB7XHJcbiAgY29uc3QgcmVtID0gbiAlIGQ7XHJcbiAgcmV0dXJuIHJlbSA8IDAgPyByZW0gKyBkIDogcmVtO1xyXG59XHJcblxyXG4vLyBOb24tYnJlYWtpbmcgc3BhY2U6XHJcbmV4cG9ydCBjb25zdCBOQlNQID0gXCJcXHUwMEEwXCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZShhOiBzdHJpbmcgfCBudW1iZXIsIGI6IHN0cmluZyB8IG51bWJlcik6IC0xIHwgMCB8IDEge1xyXG4gIC8vIFdlIHVzZSBub24tYnJlYWtpbmcgc3BhY2UgYXMgYSBwcm94eSBmb3IgdGhlIGVtcHR5IHN0cmluZyxcclxuICAvLyBiZWNhdXNlIFNWRyB0ZXh0IG9iamVjdHMgcmVzZXQgY29vcmRpbmF0ZXMgdG8gKDAsIDApIGZvciB0aGUgZW1wdHkgc3RyaW5nLlxyXG4gIGlmIChhID09PSBOQlNQKSBhID0gXCJcIjtcclxuICBpZiAoYiA9PT0gTkJTUCkgYiA9IFwiXCI7XHJcbiAgaWYgKGlzTmFOKE51bWJlcihhKSkgPT09IGlzTmFOKE51bWJlcihiKSkpIHtcclxuICAgIC8vIGEgYW5kIGIgYXJlICgxKSBib3RoIG51bWJlcnMgb3IgKDIpIGJvdGggbm9uLW51bWJlcnNcclxuICAgIGlmICghaXNOYU4oTnVtYmVyKGEpKSkge1xyXG4gICAgICAvLyBhIGFuZCBiIGFyZSBib3RoIG51bWJlcnNcclxuICAgICAgYSA9IE51bWJlcihhKTtcclxuICAgICAgYiA9IE51bWJlcihiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhID09PSBiID8gMCA6IGEgPCBiID8gLTEgOiAxO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBhIGFuZCBiIGFyZSBvZiBkaWZmZXJlbnQgdHlwZXNcclxuICAgIC8vIGxldCdzIHNheSB0aGF0IG51bWJlcnMgYXJlIHNtYWxsZXIgdGhhbiBub24tbnVtYmVyc1xyXG4gICAgcmV0dXJuIGlzTmFOKE51bWJlcihhKSkgPyAxIDogLTE7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IFRleHQgfSBmcm9tIFwiQHN2Z2RvdGpzL3N2Zy5qc1wiO1xyXG5pbXBvcnQge1xyXG4gIGNvbXBhcmUsXHJcbiAgRW5naW5lLFxyXG4gIEVuZ2luZVRvb2xiYXJJdGVtcyxcclxuICBwYXJzZVZhbHVlcyxcclxufSBmcm9tIFwiLi4vLi4vc3JjL2VuZ2luZVwiO1xyXG5pbXBvcnQgeyBCaW5hcnlOb2RlIH0gZnJvbSBcIi4uL29iamVjdHMvYmluYXJ5LW5vZGVcIjtcclxuaW1wb3J0IHsgSGlnaGxpZ2h0Q2lyY2xlIH0gZnJvbSBcIi4uL29iamVjdHMvaGlnaGxpZ2h0LWNpcmNsZVwiO1xyXG5cclxudHlwZSBCU1RUb29sYmFySXRlbXMgPSBFbmdpbmVUb29sYmFySXRlbXMgJiB7XHJcbiAgc2hvd051bGxOb2RlczogSFRNTElucHV0RWxlbWVudDtcclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBCU1QgZXh0ZW5kcyBFbmdpbmUge1xyXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETyBmaXggbWVzc2FnZSB0eXBpbmdcclxuICBtZXNzYWdlcyA9IEJTVE1lc3NhZ2VzO1xyXG5cclxuICBpbml0aWFsVmFsdWVzOiAoc3RyaW5nIHwgbnVtYmVyKVtdID0gW107XHJcbiAgdHJlZVJvb3Q6IEJpbmFyeU5vZGUgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgdG9vbGJhcjogQlNUVG9vbGJhckl0ZW1zO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJTZWxlY3Rvcjogc3RyaW5nKSB7XHJcbiAgICBzdXBlcihjb250YWluZXJTZWxlY3Rvcik7XHJcbiAgICB0aGlzLnRvb2xiYXIgPSB0aGlzLmdldFRvb2xiYXIoKTtcclxuICB9XHJcblxyXG4gIGdldFRvb2xiYXIoKTogQlNUVG9vbGJhckl0ZW1zIHtcclxuICAgIGNvbnN0IHRvb2xiYXIgPSBzdXBlci5nZXRUb29sYmFyKCk7XHJcblxyXG4gICAgdG9vbGJhci5nZW5lcmFsQ29udHJvbHMuaW5zZXJ0QWRqYWNlbnRIVE1MKFxyXG4gICAgICBcImJlZm9yZWVuZFwiLFxyXG4gICAgICBgPHNwYW4gY2xhc3M9XCJmb3JtZ3JvdXBcIj48bGFiZWw+XHJcbiAgICAgICAgPGlucHV0IGNsYXNzPVwic2hvd051bGxOb2Rlc1wiIHR5cGU9XCJjaGVja2JveFwiLz4gU2hvdyBudWxsIG5vZGVzXHJcbiAgICAgICA8L2xhYmVsPjwvc3Bhbj5gXHJcbiAgICApO1xyXG4gICAgY29uc3Qgc2hvd051bGxOb2RlcyA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3I8SFRNTElucHV0RWxlbWVudD4oXHJcbiAgICAgIFwiaW5wdXQuc2hvd051bGxOb2Rlc1wiXHJcbiAgICApO1xyXG5cclxuICAgIGlmICghc2hvd051bGxOb2RlcykgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgc2hvdyBudWxsIG5vZGVzIGlucHV0XCIpO1xyXG5cclxuICAgIHJldHVybiB7IC4uLnRvb2xiYXIsIHNob3dOdWxsTm9kZXMgfTtcclxuICB9XHJcblxyXG4gIGluaXRpYWxpc2UoaW5pdGlhbFZhbHVlcyA9IG51bGwpOiB0aGlzIHtcclxuICAgIHRoaXMuaW5pdGlhbFZhbHVlcyA9IHBhcnNlVmFsdWVzKGluaXRpYWxWYWx1ZXMpO1xyXG4gICAgc3VwZXIuaW5pdGlhbGlzZSgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBhc3luYyByZXNldEFsZ29yaXRobSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGF3YWl0IHN1cGVyLnJlc2V0QWxnb3JpdGhtKCk7XHJcbiAgICB0aGlzLnRyZWVSb290ID0gbnVsbDtcclxuICAgIGlmICh0aGlzLmluaXRpYWxWYWx1ZXMpIHtcclxuICAgICAgdGhpcy5TdGF0ZS5yZXNldHRpbmcgPSB0cnVlO1xyXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IERlY2lkZSBob3cgd2Ugd2FudCB0byBoYW5kbGUgbnVtYmVycyBhbmQgdGhlbiB1cGRhdGUgdHlwZXNcclxuICAgICAgYXdhaXQgdGhpcy5pbnNlcnQoLi4udGhpcy5pbml0aWFsVmFsdWVzKTtcclxuICAgICAgdGhpcy5TdGF0ZS5yZXNldHRpbmcgPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGluaXRUb29sYmFyKCk6IHZvaWQge1xyXG4gICAgc3VwZXIuaW5pdFRvb2xiYXIoKTtcclxuXHJcbiAgICB0aGlzLnRvb2xiYXIuc2hvd051bGxOb2Rlcy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsICgpID0+XHJcbiAgICAgIHRoaXMudG9nZ2xlTnVsbE5vZGVzKG51bGwpXHJcbiAgICApO1xyXG4gICAgdGhpcy50b2dnbGVOdWxsTm9kZXModHJ1ZSk7XHJcbiAgfVxyXG5cclxuICB0b2dnbGVOdWxsTm9kZXMoc2hvdzogYm9vbGVhbiB8IG51bGwpOiB0aGlzIHtcclxuICAgIGlmIChzaG93ID09IG51bGwpIHNob3cgPSB0aGlzLnRvb2xiYXIuc2hvd051bGxOb2Rlcy5jaGVja2VkO1xyXG4gICAgdGhpcy50b29sYmFyLnNob3dOdWxsTm9kZXMuY2hlY2tlZCA9IHNob3c7XHJcbiAgICBpZiAoc2hvdykgdGhpcy5TdmcuYWRkQ2xhc3MoXCJzaG93bnVsbG5vZGVzXCIpO1xyXG4gICAgZWxzZSB0aGlzLlN2Zy5yZW1vdmVDbGFzcyhcInNob3dudWxsbm9kZXNcIik7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIG5ld05vZGUodGV4dDogc3RyaW5nKTogQmluYXJ5Tm9kZSB7XHJcbiAgICByZXR1cm4gdGhpcy5TdmcuYmluYXJ5Tm9kZShcclxuICAgICAgdGV4dCxcclxuICAgICAgLi4udGhpcy5nZXROb2RlU3RhcnQoKSxcclxuICAgICAgdGhpcy5nZXRPYmplY3RTaXplKCksXHJcbiAgICAgIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHJlc2l6ZVRyZWUoKTogdGhpcyB7XHJcbiAgICBjb25zdCBhbmltYXRlID0gIXRoaXMuU3RhdGUucmVzZXR0aW5nO1xyXG4gICAgdGhpcy50cmVlUm9vdD8ucmVzaXplKFxyXG4gICAgICAuLi50aGlzLmdldFRyZWVSb290KCksXHJcbiAgICAgIHRoaXMuJFN2Zy5tYXJnaW4sXHJcbiAgICAgIHRoaXMuZ2V0Tm9kZVNwYWNpbmcoKSxcclxuICAgICAgYW5pbWF0ZSA/IHRoaXMuJFN2Zy5hbmltYXRpb25TcGVlZCA6IDBcclxuICAgICk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGFzeW5jIGluc2VydCguLi52YWx1ZXM6IHN0cmluZ1tdKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiB2YWx1ZXMpIGF3YWl0IHRoaXMuaW5zZXJ0T25lKHZhbCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBmaW5kKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPHtcclxuICAgIHN1Y2Nlc3M6IGJvb2xlYW47XHJcbiAgICBub2RlOiBCaW5hcnlOb2RlIHwgbnVsbDtcclxuICB9PiB7XHJcbiAgICBpZiAoIXRoaXMudHJlZVJvb3QpIHtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZShcImdlbmVyYWwuZW1wdHlcIik7XHJcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBub2RlOiBudWxsIH07XHJcbiAgICB9XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZmluZC5zdGFydFwiLCB2YWx1ZSk7XHJcbiAgICBjb25zdCBmb3VuZCA9IGF3YWl0IHRoaXMuZmluZEhlbHBlcih2YWx1ZSk7XHJcbiAgICBmb3VuZC5ub2RlPy5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBjb25zdCBwYXRoID0gZm91bmQuc3VjY2VzcyA/IFwiZmluZC5mb3VuZFwiIDogXCJmaW5kLm5vdGZvdW5kXCI7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKHBhdGgsIHZhbHVlKTtcclxuICAgIGZvdW5kLm5vZGU/LnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICByZXR1cm4gZm91bmQ7XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPOiBGaXggc28gdGhhdCB3ZSBrbm93IHRoYXQgd2UgYWx3YXlzIHJldHVybiBhIG5vZGVcclxuICAvLyBUT0RPOiBDaGFuZ2Ugc3VjY2VzcyB0byBmb3VuZCBiZWNhdXNlIHdlIGFsd2F5cyBmaW5kIHNvbWV0aGluZ1xyXG4gIGFzeW5jIGZpbmRIZWxwZXIodmFsdWU6IHN0cmluZyB8IG51bWJlcik6IFByb21pc2U8XHJcbiAgICB8IHtcclxuICAgICAgICBzdWNjZXNzOiB0cnVlO1xyXG4gICAgICAgIG5vZGU6IEJpbmFyeU5vZGU7XHJcbiAgICAgIH1cclxuICAgIHwge1xyXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlO1xyXG4gICAgICAgIG5vZGU6IEJpbmFyeU5vZGUgfCBudWxsO1xyXG4gICAgICB9XHJcbiAgPiB7XHJcbiAgICBsZXQgcGFyZW50OiBCaW5hcnlOb2RlIHwgbnVsbCA9IG51bGw7XHJcbiAgICBsZXQgbm9kZTogQmluYXJ5Tm9kZSB8IG51bGwgPSB0aGlzLnRyZWVSb290O1xyXG4gICAgY29uc3QgcG9pbnRlciA9IHRoaXMuU3ZnLmhpZ2hsaWdodENpcmNsZShcclxuICAgICAgbm9kZT8uY3goKSB8fCAwLFxyXG4gICAgICBub2RlPy5jeSgpIHx8IDAsXHJcbiAgICAgIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpLFxyXG4gICAgICB0aGlzLmdldFN0cm9rZVdpZHRoKClcclxuICAgICk7XHJcbiAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICBub2RlLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgICAgY29uc3QgY21wID0gY29tcGFyZSh2YWx1ZSwgbm9kZS5nZXRUZXh0KCkpO1xyXG4gICAgICBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgcG9pbnRlci5yZW1vdmUoKTtcclxuICAgICAgICBub2RlLnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgbm9kZTogbm9kZSB9O1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGNtcCA8IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcclxuICAgICAgbm9kZS5zZXRDaGlsZEhpZ2hsaWdodChkaXJlY3Rpb24sIHRydWUpO1xyXG4gICAgICBwYXJlbnQgPSBub2RlO1xyXG4gICAgICBub2RlID0gcGFyZW50LmdldENoaWxkKGRpcmVjdGlvbik7XHJcbiAgICAgIGlmIChub2RlKVxyXG4gICAgICAgIHBvaW50ZXIuc2V0Q2VudGVyKG5vZGUuY3goKSwgbm9kZS5jeSgpLCB0aGlzLmdldEFuaW1hdGlvblNwZWVkKCkpO1xyXG4gICAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZmluZC5sb29rXCIsIGRpcmVjdGlvbik7XHJcbiAgICAgIHBhcmVudC5zZXRDaGlsZEhpZ2hsaWdodChkaXJlY3Rpb24sIGZhbHNlKTtcclxuICAgIH1cclxuICAgIHBvaW50ZXIucmVtb3ZlKCk7XHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbm9kZTogcGFyZW50IH07XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPOiBDb3VsZCBiZSBjaGFuZ2VkIHRvIG9ubHkgcmV0dXJuIHRoZSBzdWNjZXNzIHBhcnRcclxuICBhc3luYyBpbnNlcnRPbmUodmFsdWU6IHN0cmluZyk6IFByb21pc2U8e1xyXG4gICAgc3VjY2VzczogYm9vbGVhbjtcclxuICAgIG5vZGU6IEJpbmFyeU5vZGUgfCBudWxsO1xyXG4gIH0+IHtcclxuICAgIGlmICghdGhpcy50cmVlUm9vdCkge1xyXG4gICAgICB0aGlzLnRyZWVSb290ID0gdGhpcy5uZXdOb2RlKHZhbHVlKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZShcImluc2VydC5uZXdyb290XCIsIHZhbHVlKTtcclxuICAgICAgdGhpcy5yZXNpemVUcmVlKCk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgbm9kZTogdGhpcy50cmVlUm9vdCB9O1xyXG4gICAgfVxyXG5cclxuICAgIGF3YWl0IHRoaXMucGF1c2UoXCJpbnNlcnQuc2VhcmNoXCIsIHZhbHVlKTtcclxuICAgIGNvbnN0IGZvdW5kID0gYXdhaXQgdGhpcy5maW5kSGVscGVyKHZhbHVlKTtcclxuICAgIGlmIChmb3VuZC5zdWNjZXNzKSB7XHJcbiAgICAgIGZvdW5kLm5vZGU/LnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZShcImluc2VydC5leGlzdHNcIiwgZm91bmQubm9kZSk7XHJcbiAgICAgIGZvdW5kLm5vZGU/LnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBub2RlOiBmb3VuZC5ub2RlIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBjaGlsZCA9IHRoaXMubmV3Tm9kZSh2YWx1ZSk7XHJcbiAgICBjb25zdCBjbXAgPSBjb21wYXJlKHZhbHVlLCBmb3VuZC5ub2RlPy5nZXRUZXh0KCkgfHwgXCJcIik7XHJcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBjbXAgPCAwID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCI7XHJcbiAgICBmb3VuZC5ub2RlPy5zZXRDaGlsZChkaXJlY3Rpb24sIGNoaWxkLCB0aGlzLmdldFN0cm9rZVdpZHRoKCkpO1xyXG4gICAgY2hpbGQuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgZm91bmQubm9kZT8uc2V0Q2hpbGRIaWdobGlnaHQoZGlyZWN0aW9uLCB0cnVlKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UoXCJpbnNlcnQuY2hpbGRcIiwgdmFsdWUsIGRpcmVjdGlvbik7XHJcbiAgICBmb3VuZC5ub2RlPy5zZXRDaGlsZEhpZ2hsaWdodChkaXJlY3Rpb24sIGZhbHNlKTtcclxuICAgIGNoaWxkLnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICB0aGlzLnJlc2l6ZVRyZWUoKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIG5vZGU6IGNoaWxkIH07XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPOiB1cGRhdGUgdHlwZSB3aXRoIHNlcGFyYXRlIGZvciBzdWNjZXNzIHRydWUgYW5kIGZhbHNlXHJcbiAgYXN5bmMgZGVsZXRlKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPHtcclxuICAgIHN1Y2Nlc3M6IGJvb2xlYW47XHJcbiAgICBkaXJlY3Rpb246IFwibGVmdFwiIHwgXCJyaWdodFwiIHwgbnVsbDtcclxuICAgIHBhcmVudDogQmluYXJ5Tm9kZSB8IG51bGw7XHJcbiAgfSB8IG51bGw+IHtcclxuICAgIGlmICghdGhpcy50cmVlUm9vdCkge1xyXG4gICAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZ2VuZXJhbC5lbXB0eVwiKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZGVsZXRlLnNlYXJjaFwiLCB2YWx1ZSk7XHJcbiAgICBjb25zdCBmb3VuZCA9IGF3YWl0IHRoaXMuZmluZEhlbHBlcih2YWx1ZSk7XHJcbiAgICBpZiAoIWZvdW5kLnN1Y2Nlc3MpIHtcclxuICAgICAgZm91bmQubm9kZT8uc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZGVsZXRlLm5vdGV4aXN0c1wiLCB2YWx1ZSk7XHJcbiAgICAgIGZvdW5kLm5vZGU/LnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9XHJcbiAgICAgICAgY29tcGFyZSh2YWx1ZSwgZm91bmQubm9kZT8uZ2V0VGV4dCgpIHx8IFwiXCIpIDwgMCA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xyXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZGlyZWN0aW9uOiBkaXJlY3Rpb24sIHBhcmVudDogZm91bmQubm9kZSB9O1xyXG4gICAgfVxyXG4gICAgZm91bmQubm9kZT8uc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcImRlbGV0ZS5mb3VuZFwiLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kZWxldGVIZWxwZXIoZm91bmQubm9kZSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBkZWxldGVIZWxwZXIobm9kZTogQmluYXJ5Tm9kZSB8IG51bGwpOiBQcm9taXNlPHtcclxuICAgIHN1Y2Nlc3M6IGJvb2xlYW47XHJcbiAgICBkaXJlY3Rpb246IFwibGVmdFwiIHwgXCJyaWdodFwiIHwgbnVsbDtcclxuICAgIHBhcmVudDogQmluYXJ5Tm9kZSB8IG51bGw7XHJcbiAgfT4ge1xyXG4gICAgaWYgKCEobm9kZT8uZ2V0TGVmdCgpICYmIG5vZGU/LmdldFJpZ2h0KCkpKSB7XHJcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRlbGV0ZU5vZGUobm9kZSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwb2ludGVyID0gdGhpcy5TdmcuaGlnaGxpZ2h0Q2lyY2xlKFxyXG4gICAgICBub2RlLmN4KCksXHJcbiAgICAgIG5vZGUuY3koKSxcclxuICAgICAgdGhpcy5nZXRPYmplY3RTaXplKCksXHJcbiAgICAgIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKVxyXG4gICAgKTtcclxuICAgIG5vZGUuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgIG5vZGUuYWRkQ2xhc3MoXCJtYXJrZWRcIik7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZGVsZXRlLnByZWRlY2Vzc29yLnNlYXJjaFwiLCBub2RlKTtcclxuXHJcbiAgICBsZXQgcHJlZGVjZXNzb3IgPSBub2RlLmdldExlZnQoKTtcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgIHByZWRlY2Vzc29yPy5zZXRQYXJlbnRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICAgIHBvaW50ZXIuc2V0Q2VudGVyKFxyXG4gICAgICAgIHByZWRlY2Vzc29yPy5jeCgpIHx8IDAsXHJcbiAgICAgICAgcHJlZGVjZXNzb3I/LmN5KCkgfHwgMCxcclxuICAgICAgICB0aGlzLmdldEFuaW1hdGlvblNwZWVkKClcclxuICAgICAgKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgICBwcmVkZWNlc3Nvcj8uc2V0UGFyZW50SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgICAgaWYgKCFwcmVkZWNlc3Nvcj8uZ2V0UmlnaHQoKSkgYnJlYWs7XHJcbiAgICAgIHByZWRlY2Vzc29yID0gcHJlZGVjZXNzb3IuZ2V0UmlnaHQoKTtcclxuICAgIH1cclxuICAgIHByZWRlY2Vzc29yPy5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBwb2ludGVyLnJlbW92ZSgpO1xyXG4gICAgY29uc3QgbmV3VGV4dCA9IHByZWRlY2Vzc29yPy5nZXRUZXh0KCk7XHJcbiAgICBjb25zdCBtb3ZpbmcgPSB0aGlzLlN2Zy50ZXh0Q2lyY2xlKFxyXG4gICAgICBuZXdUZXh0IHx8IFwiXCIsXHJcbiAgICAgIHByZWRlY2Vzc29yPy5jeCgpIHx8IDAsXHJcbiAgICAgIHByZWRlY2Vzc29yPy5jeSgpIHx8IDAsXHJcbiAgICAgIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpLFxyXG4gICAgICB0aGlzLmdldFN0cm9rZVdpZHRoKClcclxuICAgICk7XHJcbiAgICBtb3ZpbmcuYWRkQ2xhc3MoXCJ1bmZpbGxlZFwiKTtcclxuICAgIG1vdmluZy5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZGVsZXRlLnByZWRlY2Vzc29yLnJlcGxhY2VcIiwgbm9kZSwgcHJlZGVjZXNzb3IpO1xyXG4gICAgbW92aW5nLnNldENlbnRlcihub2RlLmN4KCksIG5vZGUuY3koKSwgdGhpcy5nZXRBbmltYXRpb25TcGVlZCgpKTtcclxuICAgIG5vZGUuc2V0VGV4dChcIlwiKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgIG5vZGUuc2V0VGV4dChuZXdUZXh0IHx8IFwiXCIpO1xyXG4gICAgbW92aW5nLnJlbW92ZSgpO1xyXG4gICAgbm9kZS5yZW1vdmVDbGFzcyhcIm1hcmtlZFwiKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UoXCJkZWxldGUucHJlZGVjZXNzb3IuZGVsZXRlXCIsIHByZWRlY2Vzc29yKTtcclxuICAgIHJldHVybiBhd2FpdCB0aGlzLmRlbGV0ZU5vZGUocHJlZGVjZXNzb3IpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZGVsZXRlTm9kZShub2RlOiBCaW5hcnlOb2RlIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFByb21pc2U8e1xyXG4gICAgc3VjY2VzczogYm9vbGVhbjtcclxuICAgIGRpcmVjdGlvbjogXCJsZWZ0XCIgfCBcInJpZ2h0XCIgfCBudWxsO1xyXG4gICAgcGFyZW50OiBCaW5hcnlOb2RlIHwgbnVsbDtcclxuICB9PiB7XHJcbiAgICAvLyBUaGUgbm9kZSB3aWxsIE5PVCBoYXZlIHR3byBjaGlsZHJlbiAtIHRoaXMgaGFzIGJlZW4gdGFrZW4gY2FyZSBvZiBieSBkZWxldGVIZWxwZXJcclxuICAgIGNvbnN0IGNoaWxkID0gbm9kZT8uZ2V0TGVmdCgpIHx8IG5vZGU/LmdldFJpZ2h0KCk7XHJcbiAgICBjb25zdCBwYXJlbnQgPSBub2RlPy5nZXRQYXJlbnQoKTtcclxuICAgIGlmICghcGFyZW50KSB7XHJcbiAgICAgIGlmICghY2hpbGQpIHtcclxuICAgICAgICB0aGlzLnRyZWVSb290ID0gbnVsbDtcclxuICAgICAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZGVsZXRlLnJvb3Quc2luZ2xldG9uXCIsIG5vZGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMudHJlZVJvb3QgPSBjaGlsZDtcclxuICAgICAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZGVsZXRlLnJvb3Qub25lY2hpbGRcIiwgY2hpbGQsIG5vZGUpO1xyXG4gICAgICB9XHJcbiAgICAgIG5vZGU/LnJlbW92ZSgpO1xyXG4gICAgICB0aGlzLnJlc2l6ZVRyZWUoKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkaXJlY3Rpb246IG51bGwsIHBhcmVudDogbnVsbCB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHBhcmVudC5nZXRMZWZ0KCkgPT09IG5vZGUgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcclxuICAgIGlmIChjaGlsZCkge1xyXG4gICAgICBub2RlPy5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgICBpZiAoY2hpbGQgPT09IHBhcmVudC5nZXRMZWZ0KCk/LmdldExlZnQoKSlcclxuICAgICAgICBub2RlPy5kbW92ZUNlbnRlcihcclxuICAgICAgICAgIC1ub2RlLmdldFNpemUoKSxcclxuICAgICAgICAgIC1ub2RlLmdldFNpemUoKSAvIDIsXHJcbiAgICAgICAgICB0aGlzLmdldEFuaW1hdGlvblNwZWVkKClcclxuICAgICAgICApO1xyXG4gICAgICBpZiAoY2hpbGQgPT09IHBhcmVudC5nZXRSaWdodCgpPy5nZXRSaWdodCgpKVxyXG4gICAgICAgIG5vZGU/LmRtb3ZlQ2VudGVyKFxyXG4gICAgICAgICAgbm9kZS5nZXRTaXplKCksXHJcbiAgICAgICAgICAtbm9kZS5nZXRTaXplKCkgLyAyLFxyXG4gICAgICAgICAgdGhpcy5nZXRBbmltYXRpb25TcGVlZCgpXHJcbiAgICAgICAgKTtcclxuICAgICAgcGFyZW50LnNldENoaWxkKGRpcmVjdGlvbiwgY2hpbGQsIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKSk7XHJcbiAgICAgIGNoaWxkLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgICAgcGFyZW50LnNldENoaWxkSGlnaGxpZ2h0KGRpcmVjdGlvbiwgdHJ1ZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UoXCJkZWxldGUucmVkaXJlY3RcIiwgcGFyZW50LCBjaGlsZCk7XHJcbiAgICAgIHBhcmVudC5zZXRDaGlsZEhpZ2hsaWdodChkaXJlY3Rpb24sIGZhbHNlKTtcclxuICAgICAgY2hpbGQuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgICAgbm9kZT8uc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZGVsZXRlLm5vZGVcIiwgbm9kZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZGVsZXRlLmxlYWZcIiwgbm9kZSk7XHJcbiAgICB9XHJcbiAgICBub2RlPy5yZW1vdmUoKTtcclxuICAgIHRoaXMucmVzaXplVHJlZSgpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGlyZWN0aW9uOiBkaXJlY3Rpb24sIHBhcmVudDogcGFyZW50IH07XHJcbiAgfVxyXG5cclxuICBhc3luYyBwcmludCgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGlmICghdGhpcy50cmVlUm9vdCkge1xyXG4gICAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZ2VuZXJhbC5lbXB0eVwiKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLkluZm8ucHJpbnRlcj8uYmJveCgpIHx8IHsgeDogMCwgeTogMCB9O1xyXG4gICAgY29uc3QgcHJpbnRlZCA9IFtcclxuICAgICAgdGhpcy5TdmcudGV4dChcIlByaW50ZWQgbm9kZXM6IFwiKS5hZGRDbGFzcyhcInByaW50ZXJcIikueCh4KS55KHkpLFxyXG4gICAgXTtcclxuICAgIGNvbnN0IHBvaW50ZXIgPSB0aGlzLlN2Zy5oaWdobGlnaHRDaXJjbGUoXHJcbiAgICAgIC4uLnRoaXMuZ2V0Tm9kZVN0YXJ0KCksXHJcbiAgICAgIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpLFxyXG4gICAgICB0aGlzLmdldFN0cm9rZVdpZHRoKClcclxuICAgICk7XHJcbiAgICBhd2FpdCB0aGlzLnByaW50SGVscGVyKHRoaXMudHJlZVJvb3QsIHBvaW50ZXIsIHByaW50ZWQpO1xyXG4gICAgcG9pbnRlci5yZW1vdmUoKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgIGZvciAoY29uc3QgbGJsIG9mIHByaW50ZWQpIGxibC5yZW1vdmUoKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHByaW50SGVscGVyKFxyXG4gICAgbm9kZTogQmluYXJ5Tm9kZSxcclxuICAgIHBvaW50ZXI6IEhpZ2hsaWdodENpcmNsZSxcclxuICAgIHByaW50ZWQ6IFRleHRbXVxyXG4gICk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgcG9pbnRlci5zZXRDZW50ZXIobm9kZS5jeCgpLCBub2RlLmN5KCksIHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKSk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKHVuZGVmaW5lZCk7XHJcbiAgICBpZiAobm9kZS5nZXRMZWZ0KCkpIHtcclxuICAgICAgYXdhaXQgdGhpcy5wcmludEhlbHBlcihub2RlLmdldExlZnQoKSEsIHBvaW50ZXIsIHByaW50ZWQpOyAvLyAhIEJlY2F1c2UgY2hlY2tlZCBhYm92ZVxyXG4gICAgICBwb2ludGVyLnNldENlbnRlcihub2RlLmN4KCksIG5vZGUuY3koKSwgdGhpcy5nZXRBbmltYXRpb25TcGVlZCgpKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGJsID0gdGhpcy5TdmcudGV4dChub2RlLmdldFRleHQoKSkuY2VudGVyKG5vZGUuY3goKSwgbm9kZS5jeSgpKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgIGNvbnN0IGxhc3QgPSBwcmludGVkW3ByaW50ZWQubGVuZ3RoIC0gMV07XHJcbiAgICBjb25zdCBzcGFjaW5nID0gdGhpcy5nZXROb2RlU3BhY2luZygpIC8gMjtcclxuICAgIHRoaXMuYW5pbWF0ZShsYmwpXHJcbiAgICAgIC5jeShsYXN0LmN5KCkpXHJcbiAgICAgIC54KGxhc3QuYmJveCgpLngyICsgc3BhY2luZyk7XHJcbiAgICBwcmludGVkLnB1c2gobGJsKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgIGlmIChub2RlLmdldFJpZ2h0KCkpIHtcclxuICAgICAgYXdhaXQgdGhpcy5wcmludEhlbHBlcihub2RlLmdldFJpZ2h0KCkhLCBwb2ludGVyLCBwcmludGVkKTtcclxuICAgICAgdGhpcy5hbmltYXRlKHBvaW50ZXIpOyAvLyBUZW1wb3JhcnkgdW50aWwgd2UgZmluZCBhIHdheSB0byBhbmltYXRlIHNldENlbnRlclxyXG4gICAgICBwb2ludGVyLnNldENlbnRlcihub2RlLmN4KCksIG5vZGUuY3koKSwgdGhpcy5nZXRBbmltYXRpb25TcGVlZCgpKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFJvdGF0ZSB0aGUgdHJlZVxyXG4gIC8vIFRoZXNlIGFyZSBub3QgdXNlZCBieSBCU1QsIGJ1dCBieSBzZWxmLWJhbGFuY2luZyBzdWJjbGFzc2VzXHJcbiAgLy8gVGhlIGZvbGxvd2luZyByb3RhdGlvbnMgYXJlIGltcGxlbWVudGVkOlxyXG4gIC8vICAtIFNpbmdsZSBSb3RhdGU6IExlZnQgYW5kIFJpZ2h0IChhbHNvIGtub3duIGFzIFppZylcclxuICAvLyAgLSBEb3VibGUgUm90YXRlOiBMZWZ0LVJpZ2h0IGFuZCBSaWdodC1MZWZ0IChhbHNvIGtub3duIGFzIFppZy1aYWcpXHJcblxyXG4gIGFzeW5jIHJlc2V0SGVpZ2h0KG5vZGU6IHVua25vd24pIHtcclxuICAgIC8vIEJTVHMgZG8gbm90IHN0b3JlIHRoZSBoZWlnaHQgaW4gdGhlIG5vZGVzLCBzbyBkbyBub3RoaW5nXHJcbiAgICAvLyBUaGlzIGlzIGltcGxlbWVudGVkIGJ5LCBlLmcuLCBBVkwgdHJlZXNcclxuICB9XHJcblxyXG4gIGFzeW5jIGRvdWJsZVJvdGF0ZShcclxuICAgIGZpcnN0RGlyOiBcImxlZnRcIiB8IFwicmlnaHRcIixcclxuICAgIG5vZGU6IEJpbmFyeU5vZGVcclxuICApOiBQcm9taXNlPEJpbmFyeU5vZGU+IHtcclxuICAgIC8vIE5vdGU6ICdsZWZ0JyBhbmQgJ3JpZ2h0JyBhcmUgdmFyaWFibGVzIHRoYXQgY2FuIGhhdmUgdmFsdWVzIFwibGVmdFwiIG9yIFwicmlnaHRcIiFcclxuICAgIGNvbnN0IHNlY29uZERpciA9IGZpcnN0RGlyID09PSBcImxlZnRcIiA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xyXG4gICAgY29uc3QgY2hpbGQgPSBub2RlLmdldENoaWxkKHNlY29uZERpcik7XHJcblxyXG4gICAgaWYgKGNoaWxkID09PSB1bmRlZmluZWQgfHwgY2hpbGQgPT09IG51bGwpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgQiBub2RlIGluIHNpbmdsZVJvdGF0ZVwiKTtcclxuXHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwicm90YXRlLnppZ3phZ1wiLCBjaGlsZCwgc2Vjb25kRGlyLCBub2RlLCBmaXJzdERpcik7XHJcbiAgICBhd2FpdCB0aGlzLnNpbmdsZVJvdGF0ZShzZWNvbmREaXIsIGNoaWxkKTtcclxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNpbmdsZVJvdGF0ZShmaXJzdERpciwgbm9kZSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBzaW5nbGVSb3RhdGUoXHJcbiAgICBmaXJzdERpcjogXCJsZWZ0XCIgfCBcInJpZ2h0XCIsXHJcbiAgICBub2RlOiBCaW5hcnlOb2RlXHJcbiAgKTogUHJvbWlzZTxCaW5hcnlOb2RlPiB7XHJcbiAgICAvLyBOb3RlOiAnbGVmdCcgYW5kICdyaWdodCcgYXJlIHZhcmlhYmxlcyB0aGF0IGNhbiBoYXZlIHZhbHVlcyBcImxlZnRcIiBvciBcInJpZ2h0XCIhXHJcbiAgICAvLyBTbywgaWYgbGVmdD09PVwicmlnaHRcIiwgdGhlbiB3ZSByb3RhdGUgcmlnaHQuXHJcbiAgICBjb25zdCBzZWNvbmREaXIgPSBmaXJzdERpciA9PT0gXCJsZWZ0XCIgPyBcInJpZ2h0XCIgOiBcImxlZnRcIjtcclxuXHJcbiAgICBjb25zdCBBID0gbm9kZTtcclxuICAgIGNvbnN0IEIgPSBBLmdldENoaWxkKHNlY29uZERpcik7XHJcblxyXG4gICAgaWYgKEIgPT09IHVuZGVmaW5lZCB8fCBCID09PSBudWxsKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEIgbm9kZSBpbiBzaW5nbGVSb3RhdGVcIik7XHJcblxyXG4gICAgY29uc3QgQyA9IEIuZ2V0Q2hpbGQoZmlyc3REaXIpO1xyXG5cclxuICAgIEEuc2V0Q2hpbGRIaWdobGlnaHQoc2Vjb25kRGlyLCB0cnVlKTtcclxuICAgIEI/LnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UoXCJyb3RhdGUuc2luZ2xlXCIsIEEsIGZpcnN0RGlyKTtcclxuXHJcbiAgICBjb25zdCBwYXJlbnQgPSBBLmdldFBhcmVudCgpO1xyXG4gICAgaWYgKHBhcmVudCkge1xyXG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBwYXJlbnQuZ2V0TGVmdCgpID09PSBBID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCI7XHJcbiAgICAgIEI/LnNldFBhcmVudChkaXJlY3Rpb24sIHBhcmVudCwgdGhpcy5nZXRTdHJva2VXaWR0aCgpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMudHJlZVJvb3QgPSBCO1xyXG4gICAgfVxyXG4gICAgQS5zZXRDaGlsZChzZWNvbmREaXIsIEMgYXMgQmluYXJ5Tm9kZSwgdGhpcy5nZXRTdHJva2VXaWR0aCgpKTtcclxuICAgIEIuc2V0Q2hpbGQoZmlyc3REaXIsIEEsIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKSk7XHJcblxyXG4gICAgQi5zZXRDaGlsZEhpZ2hsaWdodChmaXJzdERpciwgdHJ1ZSk7XHJcbiAgICBBLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgIHRoaXMucmVzaXplVHJlZSgpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG5cclxuICAgIEIuc2V0Q2hpbGRIaWdobGlnaHQoZmlyc3REaXIsIGZhbHNlKTtcclxuICAgIEEuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgIGF3YWl0IHRoaXMucmVzZXRIZWlnaHQoQSk7XHJcbiAgICBhd2FpdCB0aGlzLnJlc2V0SGVpZ2h0KEIpO1xyXG4gICAgcmV0dXJuIEI7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgQlNUTWVzc2FnZXMgPSB7XHJcbiAgZ2VuZXJhbDoge1xyXG4gICAgZW1wdHk6IFwiVHJlZSBpcyBlbXB0eVwiLFxyXG4gIH0sXHJcbiAgZmluZDoge1xyXG4gICAgc3RhcnQ6ICh2YWx1ZTogc3RyaW5nKSA9PiBgU2VhcmNoaW5nIGZvciAke3ZhbHVlfWAsXHJcbiAgICBmb3VuZDogKHZhbHVlOiBzdHJpbmcpID0+IGBGb3VuZCAke3ZhbHVlfWAsXHJcbiAgICBub3Rmb3VuZDogKHZhbHVlOiBzdHJpbmcpID0+IGBEaWQgbm90IGZpbmQgJHt2YWx1ZX1gLFxyXG4gICAgbG9vazogKGRpcmVjdGlvbjogXCJsZWZ0XCIgfCBcInJpZ2h0XCIpID0+IGBMb29rIGludG8gJHtkaXJlY3Rpb259IGNoaWxkYCxcclxuICB9LFxyXG4gIGluc2VydDoge1xyXG4gICAgbmV3cm9vdDogKHZhbHVlOiBzdHJpbmcpID0+IGBDcmVhdGUgYSBuZXcgdHJlZSByb290ICR7dmFsdWV9YCxcclxuICAgIHNlYXJjaDogKHZhbHVlOiBzdHJpbmcpID0+IGBTZWFyY2hpbmcgZm9yIG5vZGUgdG8gaW5zZXJ0ICR7dmFsdWV9YCxcclxuICAgIGV4aXN0czogKG5vZGU6IHN0cmluZykgPT4gYFRoZXJlIGlzIGFscmVhZHkgYSBub2RlICR7bm9kZX1gLFxyXG4gICAgY2hpbGQ6ICh2YWx1ZTogc3RyaW5nLCBkaXJlY3Rpb246IFwibGVmdFwiIHwgXCJyaWdodFwiKSA9PlxyXG4gICAgICBgSW5zZXJ0ICR7dmFsdWV9IGFzICR7ZGlyZWN0aW9ufSBjaGlsZGAsXHJcbiAgfSxcclxuICBkZWxldGU6IHtcclxuICAgIHNlYXJjaDogKHZhbHVlOiBzdHJpbmcpID0+IGBTZWFyY2hpbmcgZm9yIG5vZGUgdG8gZGVsZXRlICR7dmFsdWV9YCxcclxuICAgIG5vdGV4aXN0czogKHZhbHVlOiBzdHJpbmcpID0+IGBUaGVyZSBpcyBubyBub2RlICR7dmFsdWV9YCxcclxuICAgIGZvdW5kOiAodmFsdWU6IHN0cmluZykgPT4gYEZvdW5kIG5vZGUgJHt2YWx1ZX0gdG8gZGVsZXRlYCxcclxuICAgIHByZWRlY2Vzc29yOiB7XHJcbiAgICAgIHNlYXJjaDogKG5vZGU6IHN0cmluZykgPT4gYEZpbmRpbmcgdGhlIHByZWRlY2Vzc29yIG5vZGUgb2YgJHtub2RlfWAsXHJcbiAgICAgIHJlcGxhY2U6IChub2RlOiBzdHJpbmcsIHByZWRlY2Vzc29yOiBzdHJpbmcpID0+XHJcbiAgICAgICAgYFJlcGxhY2UgdGhlIHZhbHVlIG9mICR7bm9kZX0gd2l0aCAke3ByZWRlY2Vzc29yfWAsXHJcbiAgICAgIGRlbGV0ZTogKHByZWRlY2Vzc29yOiBzdHJpbmcpID0+XHJcbiAgICAgICAgYE5vdyBkZWxldGUgdGhlIHByZWRlY2Vzc29yICR7cHJlZGVjZXNzb3J9YCxcclxuICAgIH0sXHJcbiAgICByZWRpcmVjdDogKHBhcmVudDogc3RyaW5nLCBjaGlsZDogc3RyaW5nKSA9PlxyXG4gICAgICBgUmVkaXJlY3QgcGFyZW50ICR7cGFyZW50fSB0byBjaGlsZCAke2NoaWxkfWAsXHJcbiAgICByb290OiB7XHJcbiAgICAgIHNpbmdsZXRvbjogKHJvb3Q6IHN0cmluZykgPT4gYFJlbW92ZSB0aGUgcm9vdCBub2RlICR7cm9vdH1gLFxyXG4gICAgICBvbmVjaGlsZDogKGNoaWxkOiBzdHJpbmcsIHJvb3Q6IHN0cmluZykgPT4gW1xyXG4gICAgICAgIGBNYWtlIHRoZSBjaGlsZCAke2NoaWxkfSB0aGUgbmV3IHJvb3QsYCxcclxuICAgICAgICBgYW5kIHJlbW92ZSBub2RlICR7cm9vdH1gLFxyXG4gICAgICBdLFxyXG4gICAgfSxcclxuICAgIG5vZGU6IChub2RlOiBzdHJpbmcpID0+IGBSZW1vdmUgbm9kZSAke25vZGV9YCxcclxuICAgIGxlYWY6IChub2RlOiBzdHJpbmcpID0+IGBSZW1vdmUgbGVhZiBub2RlICR7bm9kZX1gLFxyXG4gIH0sXHJcbiAgcm90YXRlOiB7XHJcbiAgICBzaW5nbGU6IChub2RlOiBzdHJpbmcsIGRpcjogXCJsZWZ0XCIgfCBcInJpZ2h0XCIpID0+IGBSb3RhdGUgJHtub2RlfSAke2Rpcn1gLFxyXG4gICAgemlnemFnOiAoXHJcbiAgICAgIGNoaWxkOiBzdHJpbmcsXHJcbiAgICAgIGRpcjE6IFwibGVmdFwiIHwgXCJyaWdodFwiLFxyXG4gICAgICBub2RlOiBzdHJpbmcsXHJcbiAgICAgIGRpcjI6IFwibGVmdFwiIHwgXCJyaWdodFwiXHJcbiAgICApID0+IGBaaWctemFnOiBSb3RhdGUgJHtjaGlsZH0gJHtkaXIxfSwgdGhlbiByb3RhdGUgJHtub2RlfSAke2RpcjJ9YCxcclxuICB9LFxyXG59IGFzIGNvbnN0O1xyXG4iLCJpbXBvcnQgeyB1cGRhdGVEZWZhdWx0IH0gZnJvbSBcIi4uLy4uL3NyYy9lbmdpbmVcIjtcclxuaW1wb3J0IHsgQVZMTm9kZSB9IGZyb20gXCIuLi8uLi9zcmMvb2JqZWN0cy9hdmwtbm9kZVwiO1xyXG5pbXBvcnQgeyBIaWdobGlnaHRDaXJjbGUgfSBmcm9tIFwiLi4vLi4vc3JjL29iamVjdHMvaGlnaGxpZ2h0LWNpcmNsZVwiO1xyXG5pbXBvcnQgeyBCU1QsIEJTVE1lc3NhZ2VzIH0gZnJvbSBcIi4vQlNUXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgQVZMIGV4dGVuZHMgQlNUIHtcclxuICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE8gZml4IG1lc3NhZ2UgdHlwaW5nXHJcbiAgbWVzc2FnZXMgPSB1cGRhdGVEZWZhdWx0KEFWTG1lc3NhZ2VzLCBCU1RNZXNzYWdlcyk7XHJcbiAgdHJlZVJvb3Q6IEFWTE5vZGUgfCBudWxsID0gbnVsbDtcclxuICBwb2ludGVyOiBIaWdobGlnaHRDaXJjbGUgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgbmV3Tm9kZSh0ZXh0OiBzdHJpbmcpIHtcclxuICAgIHJldHVybiB0aGlzLlN2Zy5hdmxOb2RlKFxyXG4gICAgICB0ZXh0LFxyXG4gICAgICAuLi50aGlzLmdldE5vZGVTdGFydCgpLFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgZ2V0SGVpZ2h0KG5vZGU6IEFWTE5vZGUgfCBudWxsIHwgdW5kZWZpbmVkKSB7XHJcbiAgICByZXR1cm4gbm9kZSA/IG5vZGUuZ2V0SGVpZ2h0KCkgOiAwO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgaW5zZXJ0T25lKHZhbHVlOiBzdHJpbmcpOiBQcm9taXNlPHtcclxuICAgIHN1Y2Nlc3M6IGJvb2xlYW47XHJcbiAgICBub2RlOiBBVkxOb2RlIHwgbnVsbDtcclxuICB9PiB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdXBlci5pbnNlcnRPbmUodmFsdWUpO1xyXG4gICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5ub2RlKSB7XHJcbiAgICAgIChyZXN1bHQubm9kZSBhcyBBVkxOb2RlKS51cGRhdGVIZWlnaHRQb3NpdGlvbigpO1xyXG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZUhlaWdodHMocmVzdWx0Lm5vZGUgYXMgQVZMTm9kZSwgdW5kZWZpbmVkKTtcclxuICAgICAgYXdhaXQgdGhpcy51cGRhdGVIZWlnaHRQb3NpdGlvbnMoKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQgYXMge1xyXG4gICAgICBzdWNjZXNzOiBib29sZWFuO1xyXG4gICAgICBub2RlOiBBVkxOb2RlIHwgbnVsbDtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBhc3luYyBkZWxldGUodmFsdWU6IHN0cmluZyB8IG51bWJlcikge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VwZXIuZGVsZXRlKHZhbHVlKTtcclxuICAgIGlmIChyZXN1bHQ/LnN1Y2Nlc3MpIHtcclxuICAgICAgaWYgKHJlc3VsdC5wYXJlbnQpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZUhlaWdodHMocmVzdWx0LnBhcmVudCBhcyBBVkxOb2RlLCByZXN1bHQuZGlyZWN0aW9uKTtcclxuICAgICAgfVxyXG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZUhlaWdodFBvc2l0aW9ucygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIGFzeW5jIHVwZGF0ZUhlaWdodFBvc2l0aW9ucygpIHtcclxuICAgIHRoaXMuU3ZnLmZpbmQoXCJnXCIpLmZvckVhY2goKG5vZGUpID0+IHtcclxuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBVkxOb2RlKSBub2RlLnVwZGF0ZUhlaWdodFBvc2l0aW9uKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHVwZGF0ZUhlaWdodHMoXHJcbiAgICBub2RlOiBBVkxOb2RlLFxyXG4gICAgZnJvbWNoaWxkOiBcImxlZnRcIiB8IFwicmlnaHRcIiB8IHVuZGVmaW5lZCB8IG51bGxcclxuICApIHtcclxuICAgIGNvbnN0IGNoaWxkID0gKGZyb21jaGlsZCAmJiBub2RlLmdldENoaWxkKGZyb21jaGlsZCkpIHx8IG5vZGU7XHJcbiAgICB0aGlzLnBvaW50ZXIgPSB0aGlzLlN2Zy5oaWdobGlnaHRDaXJjbGUoXHJcbiAgICAgIGNoaWxkLmN4KCksXHJcbiAgICAgIGNoaWxkLmN5KCksXHJcbiAgICAgIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpLFxyXG4gICAgICB0aGlzLmdldFN0cm9rZVdpZHRoKClcclxuICAgICk7XHJcbiAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICB0aGlzLnBvaW50ZXIuc2V0Q2VudGVyKG5vZGUuY3goKSwgbm9kZS5jeSgpLCB0aGlzLmdldEFuaW1hdGlvblNwZWVkKCkpO1xyXG4gICAgICBhd2FpdCB0aGlzLnBhdXNlKFwibm9kZS51cGRhdGVIZWlnaHRcIik7XHJcbiAgICAgIGNvbnN0IGxlZnRIZWlnaHQgPSB0aGlzLmdldEhlaWdodChcclxuICAgICAgICAgIG5vZGUuZ2V0TGVmdCgpIGFzIEFWTE5vZGUgfCBudWxsIHwgdW5kZWZpbmVkXHJcbiAgICAgICAgKSxcclxuICAgICAgICByaWdodEhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KFxyXG4gICAgICAgICAgbm9kZS5nZXRSaWdodCgpIGFzIEFWTE5vZGUgfCBudWxsIHwgdW5kZWZpbmVkXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IGhlaWdodCA9IDEgKyBNYXRoLm1heChsZWZ0SGVpZ2h0LCByaWdodEhlaWdodCk7XHJcblxyXG4gICAgICBpZiAoaGVpZ2h0ICE9PSB0aGlzLmdldEhlaWdodChub2RlKSkge1xyXG4gICAgICAgIG5vZGUuc2V0SGVpZ2h0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgICAgIG5vZGUuc2V0SGVpZ2h0KGhlaWdodCk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIG5vZGUuc2V0SGVpZ2h0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbm9kZSA9IGF3YWl0IHRoaXMucmViYWxhbmNlKG5vZGUpO1xyXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE8gdXBkYXRlIHR5cGVzXHJcbiAgICAgIG5vZGUgPSBub2RlLmdldFBhcmVudCgpIGFzIEFWTE5vZGUgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgdGhpcy5wb2ludGVyLnJlbW92ZSgpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcmViYWxhbmNlKG5vZGU6IEFWTE5vZGUpIHtcclxuICAgIGNvbnN0IGxlZnRIZWlnaHQgPSB0aGlzLmdldEhlaWdodChcclxuICAgICAgICBub2RlLmdldExlZnQoKSBhcyBBVkxOb2RlIHwgbnVsbCB8IHVuZGVmaW5lZFxyXG4gICAgICApLFxyXG4gICAgICByaWdodEhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KFxyXG4gICAgICAgIG5vZGUuZ2V0UmlnaHQoKSBhcyBBVkxOb2RlIHwgbnVsbCB8IHVuZGVmaW5lZFxyXG4gICAgICApO1xyXG4gICAgaWYgKE1hdGguYWJzKGxlZnRIZWlnaHQgLSByaWdodEhlaWdodCkgPD0gMSkgcmV0dXJuIG5vZGU7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwibm9kZS51bmJhbGFuY2VkXCIpO1xyXG4gICAgY29uc3QgbGVmdCA9IGxlZnRIZWlnaHQgPCByaWdodEhlaWdodCA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xyXG4gICAgY29uc3QgcmlnaHQgPSBsZWZ0ID09PSBcImxlZnRcIiA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xyXG4gICAgY29uc3QgY2hpbGQgPSBub2RlLmdldENoaWxkKHJpZ2h0KTtcclxuICAgIGNvbnN0IGNoaWxkTGVmdCA9IHRoaXMuZ2V0SGVpZ2h0KFxyXG4gICAgICAgIGNoaWxkPy5nZXRDaGlsZChsZWZ0KSBhcyBBVkxOb2RlIHwgbnVsbCB8IHVuZGVmaW5lZFxyXG4gICAgICApLFxyXG4gICAgICBjaGlsZFJpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoXHJcbiAgICAgICAgY2hpbGQ/LmdldENoaWxkKHJpZ2h0KSBhcyBBVkxOb2RlIHwgbnVsbCB8IHVuZGVmaW5lZFxyXG4gICAgICApO1xyXG4gICAgdGhpcy5wb2ludGVyPy5oaWRlKCk7XHJcbiAgICBpZiAoY2hpbGRMZWZ0IDw9IGNoaWxkUmlnaHQpIHtcclxuICAgICAgbm9kZSA9IChhd2FpdCB0aGlzLnNpbmdsZVJvdGF0ZShsZWZ0LCBub2RlKSkgYXMgQVZMTm9kZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG5vZGUgPSAoYXdhaXQgdGhpcy5kb3VibGVSb3RhdGUobGVmdCwgbm9kZSkpIGFzIEFWTE5vZGU7XHJcbiAgICB9XHJcbiAgICB0aGlzLnBvaW50ZXIgPSB0aGlzLlN2Zy5oaWdobGlnaHRDaXJjbGUoXHJcbiAgICAgIG5vZGUuY3goKSxcclxuICAgICAgbm9kZS5jeSgpLFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICApO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcIm5vZGUuYmFsYW5jZWRcIik7XHJcbiAgICByZXR1cm4gbm9kZTtcclxuICB9XHJcblxyXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyBSb3RhdGUgdGhlIHRyZWVcclxuXHJcbiAgYXN5bmMgcmVzZXRIZWlnaHQobm9kZTogQVZMTm9kZSkge1xyXG4gICAgY29uc3QgaGVpZ2h0ID1cclxuICAgICAgMSArXHJcbiAgICAgIE1hdGgubWF4KFxyXG4gICAgICAgIHRoaXMuZ2V0SGVpZ2h0KG5vZGUuZ2V0TGVmdCgpIGFzIEFWTE5vZGUpLFxyXG4gICAgICAgIHRoaXMuZ2V0SGVpZ2h0KG5vZGUuZ2V0UmlnaHQoKSBhcyBBVkxOb2RlKVxyXG4gICAgICApO1xyXG4gICAgaWYgKGhlaWdodCAhPT0gdGhpcy5nZXRIZWlnaHQobm9kZSkpIHtcclxuICAgICAgbm9kZS5zZXRIZWlnaHQoaGVpZ2h0KTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBBVkxtZXNzYWdlcyA9IHtcclxuICBub2RlOiB7XHJcbiAgICB1cGRhdGVIZWlnaHQ6IFwiVXBkYXRlIG5vZGUgaGVpZ2h0c1wiLFxyXG4gICAgdW5iYWxhbmNlZDogXCJOb2RlIGlzIHVuYmFsYW5jZWQhXCIsXHJcbiAgICBiYWxhbmNlZDogXCJOb2RlIGlzIG5vdyBiYWxhbmNlZFwiLFxyXG4gIH0sXHJcbn07XHJcbiIsIi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gSW1wb3J0IGFuZCBleHBvcnQgaW5mb3JtYXRpb24gdXNlZCBieSB0aGUgSmF2YXNjcmlwdCBsaW50ZXIgRVNMaW50OlxyXG4vKiBnbG9iYWxzIERTVmlzICovXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbmltcG9ydCB7IFRleHQgfSBmcm9tIFwiQHN2Z2RvdGpzL3N2Zy5qc1wiO1xyXG5pbXBvcnQgeyBIaWdobGlnaHRDaXJjbGUgfSBmcm9tIFwic3JjL29iamVjdHMvaGlnaGxpZ2h0LWNpcmNsZVwiO1xyXG5pbXBvcnQge1xyXG4gIGNvbXBhcmUsXHJcbiAgRW5naW5lLFxyXG4gIEVuZ2luZVRvb2xiYXJJdGVtcyxcclxuICBwYXJzZVZhbHVlcyxcclxufSBmcm9tIFwiLi4vLi4vc3JjL2VuZ2luZVwiO1xyXG5pbXBvcnQgeyBCVHJlZU5vZGUgfSBmcm9tIFwiLi4vLi4vc3JjL29iamVjdHMvYnRyZWUtbm9kZVwiO1xyXG5cclxudHlwZSBCVHJlZVRvb2xiYXJJdGVtcyA9IEVuZ2luZVRvb2xiYXJJdGVtcyAmIHtcclxuICBtYXhEZWdyZWU6IEhUTUxTZWxlY3RFbGVtZW50O1xyXG59O1xyXG5cclxuZXhwb3J0IGNsYXNzIEJUcmVlIGV4dGVuZHMgRW5naW5lIHtcclxuICBpbml0aWFsVmFsdWVzOiAoc3RyaW5nIHwgbnVtYmVyKVtdID0gW107XHJcbiAgdHJlZVJvb3Q6IEJUcmVlTm9kZSB8IG51bGwgPSBudWxsO1xyXG5cclxuICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE8gZml4IG1lc3NhZ2UgdHlwaW5nXHJcbiAgbWVzc2FnZXMgPSBCVHJlZU1lc3NhZ2VzO1xyXG5cclxuICB0b29sYmFyOiBCVHJlZVRvb2xiYXJJdGVtcztcclxuXHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVyU2VsZWN0b3I6IHN0cmluZykge1xyXG4gICAgc3VwZXIoY29udGFpbmVyU2VsZWN0b3IpO1xyXG4gICAgdGhpcy50b29sYmFyID0gdGhpcy5nZXRUb29sYmFyKCk7XHJcbiAgfVxyXG5cclxuICBnZXRUb29sYmFyKCk6IEJUcmVlVG9vbGJhckl0ZW1zIHtcclxuICAgIGNvbnN0IHRvb2xiYXIgPSBzdXBlci5nZXRUb29sYmFyKCk7XHJcblxyXG4gICAgdGhpcy50b29sYmFyLmFsZ29yaXRobUNvbnRyb2xzLmluc2VydEFkamFjZW50SFRNTChcclxuICAgICAgXCJiZWZvcmVlbmRcIixcclxuICAgICAgYDxzcGFuIGNsYXNzPVwiZm9ybWdyb3VwXCI+PGxhYmVsPlxyXG4gICAgICAgIE1heCBkZWdyZWU6XHJcbiAgICAgICAgPHNlbGVjdCBjbGFzcz1cIm1heERlZ3JlZSBkaXNhYmxlV2hlblJ1bm5pbmdcIj5cclxuICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIzXCI+Mi8zLXRyZWU8L29wdGlvbj5cclxuICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI0XCI+Mi8zLzQtdHJlZTwvb3B0aW9uPlxyXG4gICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjVcIj5NYXggZGVncmVlIDU8L29wdGlvbj5cclxuICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI2XCI+TWF4IGRlZ3JlZSA2PC9vcHRpb24+XHJcbiAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgIDwvbGFiZWw+PC9zcGFuPmBcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgbWF4RGVncmVlID1cclxuICAgICAgdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcjxIVE1MU2VsZWN0RWxlbWVudD4oXCJzZWxlY3QubWF4RGVncmVlXCIpO1xyXG5cclxuICAgIGlmICghbWF4RGVncmVlKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBtYXggZGVncmVlIHNlbGVjdCBlbGVtZW50XCIpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIC4uLnRvb2xiYXIsXHJcbiAgICAgIG1heERlZ3JlZSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBpbml0aWFsaXNlKGluaXRpYWxWYWx1ZXMgPSBudWxsKSB7XHJcbiAgICB0aGlzLmluaXRpYWxWYWx1ZXMgPSBwYXJzZVZhbHVlcyhpbml0aWFsVmFsdWVzKTtcclxuICAgIHN1cGVyLmluaXRpYWxpc2UoKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHJlc2V0QWxnb3JpdGhtKCkge1xyXG4gICAgYXdhaXQgc3VwZXIucmVzZXRBbGdvcml0aG0oKTtcclxuICAgIHRoaXMudHJlZVJvb3QgPSBudWxsO1xyXG4gICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlcykge1xyXG4gICAgICB0aGlzLlN0YXRlLnJlc2V0dGluZyA9IHRydWU7XHJcbiAgICAgIGF3YWl0IHRoaXMuaW5zZXJ0KC4uLnRoaXMuaW5pdGlhbFZhbHVlcyk7XHJcbiAgICAgIHRoaXMuU3RhdGUucmVzZXR0aW5nID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpbml0VG9vbGJhcigpIHtcclxuICAgIHN1cGVyLmluaXRUb29sYmFyKCk7XHJcblxyXG4gICAgdGhpcy50b29sYmFyLm1heERlZ3JlZT8uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoKSA9PlxyXG4gICAgICB0aGlzLmNvbmZpcm1SZXNldEFsbCgpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgZ2V0TWF4RGVncmVlKCkge1xyXG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMudG9vbGJhci5tYXhEZWdyZWU/LnZhbHVlIHx8IFwiMFwiKTtcclxuICB9XHJcblxyXG4gIGdldE1heEtleXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRNYXhEZWdyZWUoKSAtIDE7XHJcbiAgfVxyXG5cclxuICBnZXRNaW5LZXlzKCkge1xyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoKHRoaXMuZ2V0TWF4RGVncmVlKCkgKyAxKSAvIDIpIC0gMTtcclxuICB9XHJcblxyXG4gIGdldFNwbGl0SW5kZXgoKSB7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcigodGhpcy5nZXRNYXhEZWdyZWUoKSAtIDEpIC8gMik7XHJcbiAgfVxyXG5cclxuICByZXNpemVUcmVlKHN2Z01hcmdpbjogbnVtYmVyLCBub2RlU3BhY2luZzogbnVtYmVyKSB7XHJcbiAgICBjb25zdCBhbmltYXRlID0gIXRoaXMuU3RhdGUucmVzZXR0aW5nO1xyXG4gICAgdGhpcy50cmVlUm9vdD8ucmVzaXplKFxyXG4gICAgICAuLi50aGlzLmdldFRyZWVSb290KCksXHJcbiAgICAgIHN2Z01hcmdpbixcclxuICAgICAgbm9kZVNwYWNpbmcsXHJcbiAgICAgIGFuaW1hdGUgPyB0aGlzLmdldEFuaW1hdGlvblNwZWVkKCkgOiAwXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgaW5zZXJ0KC4uLnZhbHVlczogKG51bWJlciB8IHN0cmluZylbXSkge1xyXG4gICAgZm9yIChjb25zdCB2YWwgb2YgdmFsdWVzKSBhd2FpdCB0aGlzLmluc2VydE9uZSh2YWwpO1xyXG4gIH1cclxuXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gRmluZCBhIHZhbHVlXHJcblxyXG4gIGFzeW5jIGZpbmQodmFsdWU6IG51bWJlciB8IHN0cmluZykge1xyXG4gICAgaWYgKCF0aGlzLnRyZWVSb290KSB7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UoXCJnZW5lcmFsLmVtcHR5XCIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZmluZC5zdGFydFwiLCB2YWx1ZSk7XHJcbiAgICBjb25zdCBmb3VuZCA9IGF3YWl0IHRoaXMuZmluZEhlbHBlcih2YWx1ZSk7XHJcbiAgICBmb3VuZC5ub2RlPy5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBjb25zdCBwYXRoID0gZm91bmQuc3VjY2VzcyA/IFwiZmluZC5mb3VuZFwiIDogXCJmaW5kLm5vdGZvdW5kXCI7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKHBhdGgsIHZhbHVlKTtcclxuICAgIGZvdW5kLm5vZGU/LnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBmaW5kSGVscGVyKHZhbHVlOiBudW1iZXIgfCBzdHJpbmcsIGZpbmRMZWFmID0gZmFsc2UpIHtcclxuICAgIGxldCBwYXJlbnQgPSBudWxsO1xyXG4gICAgbGV0IG5vZGUgPSB0aGlzLnRyZWVSb290O1xyXG4gICAgY29uc3QgcG9pbnRlciA9IHRoaXMuU3ZnLmhpZ2hsaWdodENpcmNsZShcclxuICAgICAgLi4udGhpcy5nZXROb2RlU3RhcnQoKSxcclxuICAgICAgdGhpcy5nZXRPYmplY3RTaXplKCksXHJcbiAgICAgIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKVxyXG4gICAgKTtcclxuICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgIHBvaW50ZXIuc2V0Q2VudGVyKFxyXG4gICAgICAgIG5vZGUuZ2V0Q1goMCwgdGhpcy5nZXRPYmplY3RTaXplKCkpLFxyXG4gICAgICAgIG5vZGUuY3koKSxcclxuICAgICAgICB0aGlzLmdldEFuaW1hdGlvblNwZWVkKClcclxuICAgICAgKTtcclxuICAgICAgbm9kZS5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICBsZXQgY21wU3RyID0gU3RyaW5nKHZhbHVlKTtcclxuICAgICAgd2hpbGUgKGkgPCBub2RlLm51bVZhbHVlcygpKSB7XHJcbiAgICAgICAgY29uc3QgdHh0ID0gbm9kZS5nZXRUZXh0KGkpO1xyXG4gICAgICAgIGNvbnN0IGNtcCA9IGNvbXBhcmUodmFsdWUsIHR4dCk7XHJcbiAgICAgICAgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgY21wU3RyID0gYCR7dHh0fSA9ICR7dmFsdWV9YDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgY21wU3RyID0gYCR7Y21wU3RyfSA8ICR7dHh0fWA7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY21wU3RyID0gYCR7dHh0fSA8ICR7dmFsdWV9YDtcclxuICAgICAgICBpKys7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgZm91bmQgPVxyXG4gICAgICAgIGkgPCBub2RlLm51bVZhbHVlcygpICYmIGNvbXBhcmUodmFsdWUsIG5vZGUuZ2V0VGV4dChpKSkgPT09IDA7XHJcbiAgICAgIHBvaW50ZXIuc2V0Q2VudGVyKFxyXG4gICAgICAgIG5vZGUuZ2V0Q1goaSAtIChmb3VuZCA/IDAgOiAwLjUpLCB0aGlzLmdldE9iamVjdFNpemUoKSksXHJcbiAgICAgICAgbm9kZS5jeSgpLFxyXG4gICAgICAgIHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKG5vZGUuaXNMZWFmKCkgfHwgKGZvdW5kICYmICFmaW5kTGVhZikpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLnBhdXNlKGNtcFN0cik7XHJcbiAgICAgICAgcG9pbnRlci5yZW1vdmUoKTtcclxuICAgICAgICBub2RlLnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZm91bmQsIG5vZGU6IG5vZGUsIGk6IGkgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGZvdW5kKSBpKys7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UoXHJcbiAgICAgICAgYCR7Y21wU3RyfTogJHt0aGlzLmdldE1lc3NhZ2UoXHJcbiAgICAgICAgICBcIm5vZGUubG9va050aENoaWxkXCIsXHJcbiAgICAgICAgICB0aGlzLmdldE9yZGluYWwoaSwgbm9kZS5udW1DaGlsZHJlbigpKVxyXG4gICAgICAgICl9YFxyXG4gICAgICApO1xyXG4gICAgICBub2RlLnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICAgIHBhcmVudCA9IG5vZGU7XHJcbiAgICAgIG5vZGUgPSBwYXJlbnQuZ2V0Q2hpbGQoaSk7XHJcbiAgICB9XHJcbiAgICBwb2ludGVyLnJlbW92ZSgpO1xyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG5vZGU6IHBhcmVudCwgaTogbnVsbCB9O1xyXG4gIH1cclxuXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gSW5zZXJ0IGEgdmFsdWVcclxuXHJcbiAgYXN5bmMgaW5zZXJ0T25lKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpIHtcclxuICAgIGlmICh0aGlzLnRyZWVSb290KSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuaW5zZXJ0Qm90dG9tdXAodmFsdWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy50cmVlUm9vdCA9IHRoaXMuU3ZnLmJUcmVlTm9kZShcclxuICAgICAgICB0cnVlLFxyXG4gICAgICAgIDEsXHJcbiAgICAgICAgLi4udGhpcy5nZXROb2RlU3RhcnQoKSxcclxuICAgICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgICB0aGlzLmdldFN0cm9rZVdpZHRoKClcclxuICAgICAgKTtcclxuICAgICAgdGhpcy50cmVlUm9vdC5zZXRUZXh0KDAsIFN0cmluZyh2YWx1ZSkpO1xyXG4gICAgICBhd2FpdCB0aGlzLnBhdXNlKFwiaW5zZXJ0Lm5ld3Jvb3RcIiwgdmFsdWUpO1xyXG4gICAgICB0aGlzLnJlc2l6ZVRyZWUodGhpcy4kU3ZnLm1hcmdpbiwgdGhpcy5nZXROb2RlU3BhY2luZygpKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgaW5zZXJ0Qm90dG9tdXAodmFsdWU6IG51bWJlciB8IHN0cmluZykge1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcImluc2VydC5zZWFyY2hcIiwgdmFsdWUpO1xyXG4gICAgY29uc3QgZm91bmQgPSBhd2FpdCB0aGlzLmZpbmRIZWxwZXIodmFsdWUpO1xyXG4gICAgY29uc3Qgbm9kZSA9IGZvdW5kLm5vZGU7XHJcblxyXG4gICAgaWYgKCFub2RlKSByZXR1cm47XHJcblxyXG4gICAgbm9kZS5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBpZiAoZm91bmQuc3VjY2Vzcykge1xyXG4gICAgICBhd2FpdCB0aGlzLnBhdXNlKFwiaW5zZXJ0LmV4aXN0c1wiLCBmb3VuZC5ub2RlKTtcclxuICAgICAgbm9kZS5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbm9kZS5pbnNlcnRWYWx1ZShcclxuICAgICAgICBmb3VuZC5pIHx8IDAsXHJcbiAgICAgICAgU3RyaW5nKHZhbHVlKSxcclxuICAgICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgICB0aGlzLmdldFN0cm9rZVdpZHRoKClcclxuICAgICAgKTtcclxuICAgICAgdGhpcy5yZXNpemVUcmVlKHRoaXMuJFN2Zy5tYXJnaW4sIHRoaXMuZ2V0Tm9kZVNwYWNpbmcoKSk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UoXHJcbiAgICAgICAgXCJpbnNlcnQubnRoXCIsXHJcbiAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgdGhpcy5nZXRPcmRpbmFsKGZvdW5kLmkgfHwgMCwgbm9kZT8ubnVtVmFsdWVzKCkpXHJcbiAgICAgICk7XHJcbiAgICAgIG5vZGU/LnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMuaW5zZXJ0UmVwYWlyKG5vZGUpO1xyXG4gICAgICBhd2FpdCB0aGlzLnBhdXNlKHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBpbnNlcnRSZXBhaXIobm9kZTogQlRyZWVOb2RlKSB7XHJcbiAgICBpZiAobm9kZS5udW1WYWx1ZXMoKSA+IHRoaXMuZ2V0TWF4S2V5cygpKSB7XHJcbiAgICAgIGlmICghbm9kZS5nZXRQYXJlbnQoKSkge1xyXG4gICAgICAgIHRoaXMudHJlZVJvb3QgPSBhd2FpdCB0aGlzLnNwbGl0KG5vZGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSBhd2FpdCB0aGlzLnNwbGl0KG5vZGUpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMuaW5zZXJ0UmVwYWlyKG5ld05vZGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBzcGxpdChub2RlOiBCVHJlZU5vZGUpIHtcclxuICAgIG5vZGUuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcIm5vZGUuc3BsaXRcIiwgbm9kZSk7XHJcbiAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xyXG4gICAgY29uc3QgcGFyZW50SW5kZXggPSBub2RlLmdldFBhcmVudEluZGV4KCk7XHJcblxyXG4gICAgY29uc3QgcmlzaW5nVmFsdWUgPSBub2RlLmdldFRleHQodGhpcy5nZXRTcGxpdEluZGV4KCkpO1xyXG4gICAgY29uc3QgcmlnaHRTcGxpdCA9IHRoaXMuZ2V0U3BsaXRJbmRleCgpICsgMTtcclxuICAgIGNvbnN0IHJpc2luZ1ggPSBub2RlLmdldENYKHJpZ2h0U3BsaXQgLSAxLCB0aGlzLmdldE9iamVjdFNpemUoKSk7XHJcbiAgICBjb25zdCByaXNpbmdOb2RlID0gdGhpcy5TdmcuYlRyZWVOb2RlKFxyXG4gICAgICBmYWxzZSxcclxuICAgICAgMSxcclxuICAgICAgcmlzaW5nWCxcclxuICAgICAgbm9kZS5jeSgpLFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICApO1xyXG4gICAgcmlzaW5nTm9kZS5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICByaXNpbmdOb2RlLnNldFRleHQoMCwgcmlzaW5nVmFsdWUpO1xyXG5cclxuICAgIGNvbnN0IHJpZ2h0VmFsdWVzID0gbm9kZS5udW1WYWx1ZXMoKSAtIHJpZ2h0U3BsaXQ7XHJcbiAgICBjb25zdCByaWdodFggPSBub2RlLmdldENYKFxyXG4gICAgICByaWdodFNwbGl0ICsgcmlnaHRWYWx1ZXMgLyAyIC0gMC41LFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKVxyXG4gICAgKTtcclxuICAgIGNvbnN0IHJpZ2h0Tm9kZSA9IHRoaXMuU3ZnLmJUcmVlTm9kZShcclxuICAgICAgbm9kZS5pc0xlYWYoKSxcclxuICAgICAgcmlnaHRWYWx1ZXMsXHJcbiAgICAgIHJpZ2h0WCxcclxuICAgICAgbm9kZS5jeSgpLFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICApO1xyXG4gICAgcmlnaHROb2RlLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgIGZvciAobGV0IGkgPSByaWdodFNwbGl0OyBpIDwgbm9kZS5udW1WYWx1ZXMoKTsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGogPSBpIC0gcmlnaHRTcGxpdDtcclxuICAgICAgcmlnaHROb2RlLnNldFRleHQoaiwgbm9kZS5nZXRUZXh0KGkpKTtcclxuICAgIH1cclxuICAgIGlmICghbm9kZS5pc0xlYWYoKSkge1xyXG4gICAgICBmb3IgKGxldCBpID0gcmlnaHRTcGxpdDsgaSA8IG5vZGUubnVtQ2hpbGRyZW4oKTsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgaiA9IGkgLSByaWdodFNwbGl0O1xyXG4gICAgICAgIHJpZ2h0Tm9kZS5zZXRDaGlsZChqLCBub2RlLmdldENoaWxkKGkpLCB0aGlzLmdldFN0cm9rZVdpZHRoKCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBub2RlLnNldE51bVZhbHVlcyhcclxuICAgICAgdGhpcy5nZXRTcGxpdEluZGV4KCksXHJcbiAgICAgIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpLFxyXG4gICAgICB0aGlzLmdldFN0cm9rZVdpZHRoKClcclxuICAgICk7XHJcbiAgICByaXNpbmdOb2RlLnNldENoaWxkKDAsIG5vZGUsIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKSk7XHJcbiAgICByaXNpbmdOb2RlLnNldENoaWxkKDEsIHJpZ2h0Tm9kZSwgdGhpcy5nZXRTdHJva2VXaWR0aCgpKTtcclxuXHJcbiAgICBpZiAocGFyZW50ICYmIHBhcmVudEluZGV4ICE9PSBudWxsKSB7XHJcbiAgICAgIHBhcmVudC5zZXRDaGlsZChwYXJlbnRJbmRleCwgcmlzaW5nTm9kZSwgdGhpcy5nZXRTdHJva2VXaWR0aCgpKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgICByaXNpbmdOb2RlLnNldENlbnRlcihcclxuICAgICAgICBwYXJlbnQuZ2V0Q1gocGFyZW50SW5kZXggLSAwLjUsIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpKSxcclxuICAgICAgICBwYXJlbnQuY3koKSxcclxuICAgICAgICB0aGlzLmdldEFuaW1hdGlvblNwZWVkKClcclxuICAgICAgKTtcclxuICAgICAgbm9kZS5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgICByaWdodE5vZGUuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgICBwYXJlbnQuaW5zZXJ0VmFsdWUoXHJcbiAgICAgICAgcGFyZW50SW5kZXgsXHJcbiAgICAgICAgcmlzaW5nVmFsdWUsXHJcbiAgICAgICAgdGhpcy5nZXRPYmplY3RTaXplKCksXHJcbiAgICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICAgICk7XHJcbiAgICAgIHBhcmVudC5zZXRDaGlsZChwYXJlbnRJbmRleCwgbm9kZSwgdGhpcy5nZXRTdHJva2VXaWR0aCgpKTtcclxuICAgICAgcGFyZW50LnNldENoaWxkKHBhcmVudEluZGV4ICsgMSwgcmlnaHROb2RlLCB0aGlzLmdldFN0cm9rZVdpZHRoKCkpO1xyXG4gICAgICByaXNpbmdOb2RlLnJlbW92ZSgpO1xyXG4gICAgICB0aGlzLnJlc2l6ZVRyZWUodGhpcy4kU3ZnLm1hcmdpbiwgdGhpcy5nZXROb2RlU3BhY2luZygpKTtcclxuICAgICAgcmV0dXJuIHBhcmVudDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnRyZWVSb290ID0gcmlzaW5nTm9kZTtcclxuICAgIHRoaXMucmVzaXplVHJlZSh0aGlzLiRTdmcubWFyZ2luLCB0aGlzLmdldE5vZGVTcGFjaW5nKCkpO1xyXG4gICAgdGhpcy50cmVlUm9vdC5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgbm9kZS5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgcmlnaHROb2RlLnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICByZXR1cm4gdGhpcy50cmVlUm9vdDtcclxuICB9XHJcblxyXG4gIGdldE9yZGluYWwoaTogbnVtYmVyLCBuOiBudW1iZXIpIHtcclxuICAgIGlmIChuID09PSAxKSB7XHJcbiAgICAgIHJldHVybiBcIm9ubHlcIjtcclxuICAgIH0gZWxzZSBpZiAobiA8PSAzKSB7XHJcbiAgICAgIHJldHVybiBpID09PSAwID8gXCJsZWZ0XCIgOiBpID09PSBuIC0gMSA/IFwicmlnaHRcIiA6IFwibWlkZGxlXCI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gaSA9PT0gMFxyXG4gICAgICAgID8gXCJmaXJzdFwiXHJcbiAgICAgICAgOiBpID09PSAxXHJcbiAgICAgICAgPyBcInNlY29uZFwiXHJcbiAgICAgICAgOiBpID09PSBuIC0gMVxyXG4gICAgICAgID8gXCJsYXN0XCJcclxuICAgICAgICA6IGAke2l9cmRgO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gUHJpbnQgYWxsIHZhbHVlc1xyXG5cclxuICBhc3luYyBwcmludCgpIHtcclxuICAgIGlmICghdGhpcy50cmVlUm9vdCkge1xyXG4gICAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZ2VuZXJhbC5lbXB0eVwiKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5JbmZvLnByaW50ZXIpIHRocm93IG5ldyBFcnJvcihcIk5vIGluZm8gcHJpbnRlclwiKTtcclxuXHJcbiAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMuSW5mby5wcmludGVyLmJib3goKTtcclxuICAgIGNvbnN0IHByaW50ZWQgPSBbXHJcbiAgICAgIHRoaXMuU3ZnLnRleHQoXCJQcmludGVkIG5vZGVzOiBcIikuYWRkQ2xhc3MoXCJwcmludGVyXCIpLngoeCkueSh5KSxcclxuICAgIF07XHJcbiAgICBjb25zdCBwb2ludGVyID0gdGhpcy5TdmcuaGlnaGxpZ2h0Q2lyY2xlKFxyXG4gICAgICAuLi50aGlzLmdldE5vZGVTdGFydCgpLFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICApO1xyXG4gICAgYXdhaXQgdGhpcy5wcmludEhlbHBlcih0aGlzLnRyZWVSb290LCBwb2ludGVyLCBwcmludGVkKTtcclxuICAgIHBvaW50ZXIucmVtb3ZlKCk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKHVuZGVmaW5lZCk7XHJcbiAgICBmb3IgKGNvbnN0IGxibCBvZiBwcmludGVkKSBsYmwucmVtb3ZlKCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBwcmludEhlbHBlcihcclxuICAgIG5vZGU6IEJUcmVlTm9kZSxcclxuICAgIHBvaW50ZXI6IEhpZ2hsaWdodENpcmNsZSxcclxuICAgIHByaW50ZWQ6IFRleHRbXVxyXG4gICkge1xyXG4gICAgaWYgKG5vZGUuaXNMZWFmKCkpIHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLm51bVZhbHVlcygpOyBpKyspIHtcclxuICAgICAgICBwb2ludGVyLnNldENlbnRlcihcclxuICAgICAgICAgIG5vZGUuZ2V0Q1goaSwgdGhpcy5nZXRPYmplY3RTaXplKCkpLFxyXG4gICAgICAgICAgbm9kZS5jeSgpLFxyXG4gICAgICAgICAgdGhpcy5nZXRBbmltYXRpb25TcGVlZCgpXHJcbiAgICAgICAgKTtcclxuICAgICAgICBhd2FpdCB0aGlzLnByaW50T25lTGFiZWwobm9kZSwgaSwgcHJpbnRlZCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5udW1DaGlsZHJlbigpOyBpKyspIHtcclxuICAgICAgICBwb2ludGVyLnNldENlbnRlcihcclxuICAgICAgICAgIG5vZGUuZ2V0Q1goaSAtIDAuNSwgdGhpcy5nZXRPYmplY3RTaXplKCkpLFxyXG4gICAgICAgICAgTnVtYmVyKG5vZGUueSgpKSArIE51bWJlcihub2RlLmhlaWdodCgpKSxcclxuICAgICAgICAgIHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMucHJpbnRIZWxwZXIobm9kZS5nZXRDaGlsZChpKSEsIHBvaW50ZXIsIHByaW50ZWQpO1xyXG4gICAgICAgIGlmIChpIDwgbm9kZS5udW1WYWx1ZXMoKSkge1xyXG4gICAgICAgICAgcG9pbnRlci5zZXRDZW50ZXIoXHJcbiAgICAgICAgICAgIG5vZGUuZ2V0Q1goaSwgdGhpcy5nZXRPYmplY3RTaXplKCkpLFxyXG4gICAgICAgICAgICBub2RlLmN5KCksXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGF3YWl0IHRoaXMucHJpbnRPbmVMYWJlbChub2RlLCBpLCBwcmludGVkKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcG9pbnRlci5zZXRDZW50ZXIoXHJcbiAgICAgICAgICAgIG5vZGUuZ2V0Q1goaSAtIDAuNSwgdGhpcy5nZXRPYmplY3RTaXplKCkpLFxyXG4gICAgICAgICAgICBub2RlLmN5KCksXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIHByaW50T25lTGFiZWwobm9kZTogQlRyZWVOb2RlLCBpOiBudW1iZXIsIHByaW50ZWQ6IFRleHRbXSkge1xyXG4gICAgY29uc3QgbGJsID0gdGhpcy5TdmcudGV4dChub2RlLmdldFRleHQoaSkpLmNlbnRlcihcclxuICAgICAgbm9kZS5nZXRDWChpLCB0aGlzLmdldE9iamVjdFNpemUoKSksXHJcbiAgICAgIG5vZGUuY3koKVxyXG4gICAgKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgIGNvbnN0IGxhc3QgPSBwcmludGVkW3ByaW50ZWQubGVuZ3RoIC0gMV07XHJcbiAgICBjb25zdCBzcGFjaW5nID0gdGhpcy5nZXROb2RlU3BhY2luZygpIC8gMjtcclxuICAgIHRoaXMuYW5pbWF0ZShsYmwpXHJcbiAgICAgIC5jeShsYXN0LmN5KCkpXHJcbiAgICAgIC54KGxhc3QuYmJveCgpLngyICsgc3BhY2luZyk7XHJcbiAgICBwcmludGVkLnB1c2gobGJsKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICB9XHJcblxyXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIERlbGV0ZSBhIHZhbHVlXHJcblxyXG4gIGFzeW5jIGRlbGV0ZSh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nKSB7XHJcbiAgICBpZiAoIXRoaXMudHJlZVJvb3QpIHtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZShcImdlbmVyYWwuZW1wdHlcIik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGF3YWl0IHRoaXMucGF1c2UoXCJkZWxldGUuc2VhcmNoXCIsIHZhbHVlKTtcclxuICAgIGNvbnN0IGZvdW5kID0gYXdhaXQgdGhpcy5maW5kSGVscGVyKHZhbHVlKTtcclxuICAgIGlmICghZm91bmQuc3VjY2Vzcykge1xyXG4gICAgICBmb3VuZC5ub2RlPy5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UoXCJkZWxldGUubm90ZXhpc3RzXCIsIHZhbHVlKTtcclxuICAgICAgZm91bmQubm9kZT8uc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm91bmQubm9kZT8uc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcImRlbGV0ZS5mb3VuZFwiLCB2YWx1ZSk7XHJcbiAgICBmb3VuZC5ub2RlPy5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgaWYgKGZvdW5kLm5vZGU/LmlzTGVhZigpKSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuZGVsZXRlTGVhZihmb3VuZC5ub2RlLCBmb3VuZC5pIHx8IDApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYXdhaXQgdGhpcy5kZWxldGVOb25sZWFmKGZvdW5kLm5vZGUgYXMgQlRyZWVOb2RlLCBmb3VuZC5pIHx8IDApO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMudHJlZVJvb3QubnVtVmFsdWVzKCkgPT09IDApIHtcclxuICAgICAgdGhpcy50cmVlUm9vdC5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UoXCJkZWxldGUucm9vdC5lbXB0eVwiKTtcclxuICAgICAgY29uc3QgbmV3Um9vdCA9IHRoaXMudHJlZVJvb3QuaXNMZWFmKCkgPyBudWxsIDogdGhpcy50cmVlUm9vdC5nZXRMZWZ0KCk7XHJcbiAgICAgIHRoaXMudHJlZVJvb3QucmVtb3ZlKCk7XHJcbiAgICAgIHRoaXMudHJlZVJvb3QgPSBuZXdSb290O1xyXG4gICAgICB0aGlzLnJlc2l6ZVRyZWUodGhpcy4kU3ZnLm1hcmdpbiwgdGhpcy5nZXROb2RlU3BhY2luZygpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGRlbGV0ZUxlYWYobm9kZTogQlRyZWVOb2RlLCBpOiBudW1iZXIpIHtcclxuICAgIG5vZGUuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcclxuICAgICAgXCJkZWxldGUubGVhZi5udGhcIixcclxuICAgICAgbm9kZSxcclxuICAgICAgdGhpcy5nZXRPcmRpbmFsKGksIG5vZGUubnVtVmFsdWVzKCkpXHJcbiAgICApO1xyXG4gICAgbm9kZS5kZWxldGVWYWx1ZShpLCB0aGlzLmdldE9iamVjdFNpemUoKSwgdGhpcy5nZXRTdHJva2VXaWR0aCgpKTtcclxuICAgIHRoaXMucmVzaXplVHJlZSh0aGlzLiRTdmcubWFyZ2luLCB0aGlzLmdldE5vZGVTcGFjaW5nKCkpO1xyXG4gICAgbm9kZS5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgYXdhaXQgdGhpcy5yZXBhaXJBZnRlckRlbGV0ZShub2RlKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGRlbGV0ZU5vbmxlYWYobm9kZTogQlRyZWVOb2RlLCBpOiBudW1iZXIpIHtcclxuICAgIG5vZGUuYWRkQ2xhc3MoXCJtYXJrZWRcIik7XHJcbiAgICBjb25zdCBwb2ludGVyID0gdGhpcy5TdmcuaGlnaGxpZ2h0Q2lyY2xlKFxyXG4gICAgICBub2RlLmdldENYKGksIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpKSxcclxuICAgICAgbm9kZS5jeSgpLFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICApO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcImZpbmQucHJlZGVjZXNzb3JcIiwgbm9kZS5nZXRUZXh0KGkpKTtcclxuICAgIGxldCBtYXhOb2RlID0gbm9kZS5nZXRDaGlsZChpKTtcclxuICAgIGxldCBqO1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgaiA9IChtYXhOb2RlPy5udW1WYWx1ZXMoKSB8fCAwKSAtIDE7XHJcbiAgICAgIHBvaW50ZXIuc2V0Q2VudGVyKFxyXG4gICAgICAgIG1heE5vZGU/LmdldENYKGosIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpKSB8fCAwLFxyXG4gICAgICAgIG1heE5vZGU/LmN5KCkgfHwgMCxcclxuICAgICAgICB0aGlzLmdldEFuaW1hdGlvblNwZWVkKClcclxuICAgICAgKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgICBpZiAobWF4Tm9kZT8uaXNMZWFmKCkpIGJyZWFrO1xyXG4gICAgICBtYXhOb2RlID0gbWF4Tm9kZT8uZ2V0UmlnaHQoKSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWF4VmFsdWUgPSBtYXhOb2RlLmdldFRleHQoaik7XHJcbiAgICBjb25zdCByaXNpbmdOb2RlID0gdGhpcy5TdmcuYlRyZWVOb2RlKFxyXG4gICAgICBmYWxzZSxcclxuICAgICAgMSxcclxuICAgICAgbWF4Tm9kZS5nZXRDWChqLCB0aGlzLmdldE9iamVjdFNpemUoKSksXHJcbiAgICAgIG1heE5vZGUuY3koKSxcclxuICAgICAgdGhpcy5nZXRPYmplY3RTaXplKCksXHJcbiAgICAgIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKVxyXG4gICAgKTtcclxuICAgIHJpc2luZ05vZGUuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgcmlzaW5nTm9kZS5zZXRUZXh0KDAsIG1heFZhbHVlKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UoXCJkZWxldGUucmVwbGFjZVwiLCBub2RlLmdldFRleHQoaSksIG1heFZhbHVlKTtcclxuICAgIHBvaW50ZXIucmVtb3ZlKCk7XHJcbiAgICByaXNpbmdOb2RlLnNldENlbnRlcihcclxuICAgICAgbm9kZS5nZXRDWChpLCB0aGlzLmdldE9iamVjdFNpemUoKSksXHJcbiAgICAgIG5vZGUuY3koKSxcclxuICAgICAgdGhpcy5nZXRBbmltYXRpb25TcGVlZCgpXHJcbiAgICApO1xyXG4gICAgbm9kZS5zZXRUZXh0KGksIFwiXCIpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgbm9kZS5zZXRUZXh0KGksIG1heFZhbHVlKTtcclxuICAgIHJpc2luZ05vZGUucmVtb3ZlKCk7XHJcbiAgICBub2RlLnJlbW92ZUNsYXNzKFwibWFya2VkXCIpO1xyXG4gICAgbWF4Tm9kZS5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZGVsZXRlLmxlYWYudmFsdWVcIiwgbWF4VmFsdWUsIG1heE5vZGUpO1xyXG4gICAgYXdhaXQgdGhpcy5kZWxldGVMZWFmKG1heE5vZGUsIGopO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcmVwYWlyQWZ0ZXJEZWxldGUobm9kZTogQlRyZWVOb2RlKSB7XHJcbiAgICBpZiAobm9kZS5udW1WYWx1ZXMoKSA+PSB0aGlzLmdldE1pbktleXMoKSkgcmV0dXJuO1xyXG4gICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcclxuICAgIGlmICghcGFyZW50KSByZXR1cm47XHJcblxyXG4gICAgbm9kZS5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwibm9kZS50b29GZXdcIiwgbm9kZSk7XHJcbiAgICBjb25zdCBpID0gbm9kZS5nZXRQYXJlbnRJbmRleCgpIHx8IDA7XHJcbiAgICBpZiAoXHJcbiAgICAgIGkgPiAwICYmXHJcbiAgICAgIHBhcmVudC5nZXRDaGlsZChpIC0gMSkgIT09IG51bGwgJiZcclxuICAgICAgcGFyZW50LmdldENoaWxkKGkgLSAxKSEubnVtVmFsdWVzKCkgPiB0aGlzLmdldE1pbktleXMoKVxyXG4gICAgKSB7XHJcbiAgICAgIC8vIFN0ZWFsIGZyb20gbGVmdCBzaWJsaW5nXHJcbiAgICAgIGF3YWl0IHRoaXMuc3RlYWxGcm9tTGVmdChub2RlLCBpKTtcclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgIGkgPCBwYXJlbnQubnVtVmFsdWVzKCkgJiZcclxuICAgICAgcGFyZW50LmdldENoaWxkKGkgKyAxKSAhPT0gbnVsbCAmJlxyXG4gICAgICBwYXJlbnQuZ2V0Q2hpbGQoaSArIDEpIS5udW1WYWx1ZXMoKSA+IHRoaXMuZ2V0TWluS2V5cygpXHJcbiAgICApIHtcclxuICAgICAgLy8gU3RlYWwgZnJvbSByaWdodCBzaWJsaW5nXHJcbiAgICAgIGF3YWl0IHRoaXMuc3RlYWxGcm9tUmlnaHQobm9kZSwgaSk7XHJcbiAgICB9IGVsc2UgaWYgKGkgPCBwYXJlbnQubnVtQ2hpbGRyZW4oKSAtIDEpIHtcclxuICAgICAgLy8gTWVyZ2Ugd2l0aCByaWdodCBzaWJsaW5nXHJcbiAgICAgIGNvbnN0IG5leHROb2RlID0gYXdhaXQgdGhpcy5tZXJnZVJpZ2h0KG5vZGUpO1xyXG4gICAgICBhd2FpdCB0aGlzLnJlcGFpckFmdGVyRGVsZXRlKG5leHROb2RlLmdldFBhcmVudCgpIGFzIEJUcmVlTm9kZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBNZXJnZSB3aXRoIGxlZnQgc2libGluZ1xyXG4gICAgICBjb25zdCBuZXh0Tm9kZSA9IGF3YWl0IHRoaXMubWVyZ2VSaWdodChcclxuICAgICAgICBwYXJlbnQuZ2V0Q2hpbGQoaSAtIDEpIGFzIEJUcmVlTm9kZVxyXG4gICAgICApO1xyXG4gICAgICBhd2FpdCB0aGlzLnJlcGFpckFmdGVyRGVsZXRlKG5leHROb2RlLmdldFBhcmVudCgpIGFzIEJUcmVlTm9kZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBtZXJnZVJpZ2h0KG5vZGU6IEJUcmVlTm9kZSkge1xyXG4gICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcclxuICAgIGNvbnN0IHBhcmVudEluZGV4ID0gbm9kZS5nZXRQYXJlbnRJbmRleCgpO1xyXG5cclxuICAgIGlmICghcGFyZW50IHx8IHBhcmVudEluZGV4ID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhcmVudFwiKTtcclxuXHJcbiAgICBjb25zdCBwYXJlbnRWYWx1ZSA9IHBhcmVudD8uZ2V0VGV4dChwYXJlbnRJbmRleCk7XHJcbiAgICBjb25zdCByaWdodFNpYiA9IHBhcmVudC5nZXRDaGlsZChwYXJlbnRJbmRleCArIDEpO1xyXG4gICAgbm9kZS5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBwYXJlbnQuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgcmlnaHRTaWI/LnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UoXCJub2RlLm1lcmdlUmlnaHRcIiwgbm9kZSwgcGFyZW50VmFsdWUsIHJpZ2h0U2liKTtcclxuXHJcbiAgICBjb25zdCBzaW5raW5nTm9kZSA9IHRoaXMuU3ZnLmJUcmVlTm9kZShcclxuICAgICAgZmFsc2UsXHJcbiAgICAgIDEsXHJcbiAgICAgIHBhcmVudC5nZXRDWChwYXJlbnRJbmRleCwgdGhpcy5nZXRPYmplY3RTaXplKCkpLFxyXG4gICAgICBwYXJlbnQuY3koKSxcclxuICAgICAgdGhpcy5nZXRPYmplY3RTaXplKCksXHJcbiAgICAgIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKVxyXG4gICAgKTtcclxuICAgIHNpbmtpbmdOb2RlLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgIHNpbmtpbmdOb2RlLnNldFRleHQoMCwgcGFyZW50VmFsdWUpO1xyXG4gICAgcGFyZW50LnNldFRleHQocGFyZW50SW5kZXgsIFwiXCIpO1xyXG4gICAgY29uc3Qgc2lua2luZ1ggPVxyXG4gICAgICAoTnVtYmVyKG5vZGUueCgpKSArIE51bWJlcihub2RlLndpZHRoKCkpICsgTnVtYmVyKHJpZ2h0U2liPy54KCkpKSAvIDI7XHJcbiAgICBzaW5raW5nTm9kZS5zZXRDZW50ZXIoc2lua2luZ1gsIG5vZGUuY3koKSwgdGhpcy5nZXRBbmltYXRpb25TcGVlZCgpKTtcclxuICAgIG5vZGUuc2V0Q2VudGVyKFxyXG4gICAgICBzaW5raW5nWCAtICh0aGlzLmdldE9iamVjdFNpemUoKSArIE51bWJlcihub2RlLndpZHRoKCkpKSAvIDIsXHJcbiAgICAgIG5vZGUuY3koKSxcclxuICAgICAgdGhpcy5nZXRBbmltYXRpb25TcGVlZCgpXHJcbiAgICApO1xyXG4gICAgcmlnaHRTaWI/LnNldENlbnRlcihcclxuICAgICAgc2lua2luZ1ggKyAodGhpcy5nZXRPYmplY3RTaXplKCkgKyBOdW1iZXIocmlnaHRTaWIud2lkdGgoKSkpIC8gMixcclxuICAgICAgbm9kZS5jeSgpLFxyXG4gICAgICB0aGlzLmdldEFuaW1hdGlvblNwZWVkKClcclxuICAgICk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKHVuZGVmaW5lZCk7XHJcblxyXG4gICAgY29uc3Qgbm9kZVNpemUgPSBub2RlLm51bVZhbHVlcygpO1xyXG4gICAgY29uc3QgdGV4dHNUb0luc2VydCA9IFtwYXJlbnRWYWx1ZV0uY29uY2F0KHJpZ2h0U2liPy5nZXRUZXh0cygpIHx8IFtdKTtcclxuICAgIG5vZGUuc2V0TnVtVmFsdWVzKFxyXG4gICAgICBub2RlU2l6ZSArIHRleHRzVG9JbnNlcnQubGVuZ3RoLFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICApO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0c1RvSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIG5vZGUuc2V0VGV4dChub2RlU2l6ZSArIGksIHRleHRzVG9JbnNlcnRbaV0pO1xyXG4gICAgICBpZiAoIW5vZGUuaXNMZWFmKCkpIHtcclxuICAgICAgICBub2RlLnNldENoaWxkKFxyXG4gICAgICAgICAgbm9kZVNpemUgKyBpICsgMSxcclxuICAgICAgICAgIHJpZ2h0U2liPy5nZXRDaGlsZChpKSBhcyBCVHJlZU5vZGUsXHJcbiAgICAgICAgICB0aGlzLmdldFN0cm9rZVdpZHRoKClcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBwYXJlbnQuZGVsZXRlVmFsdWUoXHJcbiAgICAgIHBhcmVudEluZGV4LFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpLFxyXG4gICAgICBmYWxzZVxyXG4gICAgKTtcclxuICAgIHNpbmtpbmdOb2RlLnJlbW92ZSgpO1xyXG4gICAgcmlnaHRTaWI/LnJlbW92ZSgpO1xyXG4gICAgdGhpcy5yZXNpemVUcmVlKHRoaXMuJFN2Zy5tYXJnaW4sIHRoaXMuZ2V0Tm9kZVNwYWNpbmcoKSk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKHVuZGVmaW5lZCk7XHJcbiAgICBub2RlLnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICBwYXJlbnQuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgIHJldHVybiBub2RlO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc3RlYWxGcm9tUmlnaHQobm9kZTogQlRyZWVOb2RlLCBwYXJlbnRJbmRleDogbnVtYmVyKSB7XHJcbiAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xyXG4gICAgY29uc3QgcmlnaHRTaWIgPSBwYXJlbnQ/LmdldENoaWxkKHBhcmVudEluZGV4ICsgMSk7XHJcblxyXG4gICAgaWYgKCFwYXJlbnQgfHwgIXJpZ2h0U2liKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgXCJDYW4gbm90IHN0ZWFsIGZyb20gcmlnaHQsIG1pc3NpbmcgcGFyZW50IG9yIHJpZ2h0IHNpYmxpbmdcIlxyXG4gICAgICApO1xyXG5cclxuICAgIG5vZGUuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgcGFyZW50LnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgIHJpZ2h0U2liLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuXHJcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBwYXJlbnQuZ2V0VGV4dChwYXJlbnRJbmRleCk7XHJcbiAgICBjb25zdCByaWdodFZhbHVlID0gcmlnaHRTaWIuZ2V0VGV4dCgwKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UoXCJub2RlLnN0ZWFsLnJpZ2h0XCIsIG5vZGUsIGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZSk7XHJcblxyXG4gICAgY29uc3QgbGVmdE5vZGUgPSB0aGlzLlN2Zy5iVHJlZU5vZGUoXHJcbiAgICAgIGZhbHNlLFxyXG4gICAgICAxLFxyXG4gICAgICBwYXJlbnQ/LmdldENYKHBhcmVudEluZGV4LCB0aGlzLmdldE9iamVjdFNpemUoKSksXHJcbiAgICAgIHBhcmVudD8uY3koKSxcclxuICAgICAgdGhpcy5nZXRPYmplY3RTaXplKCksXHJcbiAgICAgIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKVxyXG4gICAgKTtcclxuICAgIGxlZnROb2RlLnNldFRleHQoMCwgbGVmdFZhbHVlIHx8IFwiXCIpO1xyXG4gICAgbGVmdE5vZGUuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgY29uc3QgcmlnaHROb2RlID0gdGhpcy5TdmcuYlRyZWVOb2RlKFxyXG4gICAgICBmYWxzZSxcclxuICAgICAgMSxcclxuICAgICAgcmlnaHRTaWI/LmdldENYKDAsIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpKSxcclxuICAgICAgcmlnaHRTaWI/LmN5KCksXHJcbiAgICAgIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpLFxyXG4gICAgICB0aGlzLmdldFN0cm9rZVdpZHRoKClcclxuICAgICk7XHJcbiAgICByaWdodE5vZGUuc2V0VGV4dCgwLCByaWdodFZhbHVlIHx8IFwiXCIpO1xyXG4gICAgcmlnaHROb2RlLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuXHJcbiAgICBub2RlLmluc2VydFZhbHVlKFxyXG4gICAgICBub2RlLm51bVZhbHVlcygpLFxyXG4gICAgICBcIlwiLFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICApO1xyXG4gICAgcGFyZW50LnNldFRleHQocGFyZW50SW5kZXgsIFwiXCIpO1xyXG4gICAgcmlnaHRTaWIuc2V0VGV4dCgwLCBcIlwiKTtcclxuXHJcbiAgICBsZWZ0Tm9kZS5zZXRDZW50ZXIoXHJcbiAgICAgIG5vZGUuZ2V0Q1gobm9kZS5udW1WYWx1ZXMoKSAtIDEsIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpKSxcclxuICAgICAgbm9kZS5jeSgpLFxyXG4gICAgICB0aGlzLmdldEFuaW1hdGlvblNwZWVkKClcclxuICAgICk7XHJcbiAgICByaWdodE5vZGUuc2V0Q2VudGVyKFxyXG4gICAgICBwYXJlbnQuZ2V0Q1gocGFyZW50SW5kZXgsIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpKSxcclxuICAgICAgcGFyZW50LmN5KCksXHJcbiAgICAgIHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKVxyXG4gICAgKTtcclxuICAgIGlmICghbm9kZS5pc0xlYWYoKSlcclxuICAgICAgbm9kZS5zZXRDaGlsZChcclxuICAgICAgICBub2RlLm51bUNoaWxkcmVuKCkgLSAxLFxyXG4gICAgICAgIHJpZ2h0U2liLmdldENoaWxkKDApLFxyXG4gICAgICAgIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKVxyXG4gICAgICApO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG5cclxuICAgIGxlZnROb2RlLnJlbW92ZSgpO1xyXG4gICAgcmlnaHROb2RlLnJlbW92ZSgpO1xyXG4gICAgcmlnaHRTaWIuZGVsZXRlVmFsdWUoMCwgdGhpcy5nZXRPYmplY3RTaXplKCksIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKSk7XHJcbiAgICBwYXJlbnQuc2V0VGV4dChwYXJlbnRJbmRleCwgcmlnaHRWYWx1ZSk7XHJcbiAgICBub2RlLnNldFRleHQobm9kZS5udW1WYWx1ZXMoKSAtIDEsIGxlZnRWYWx1ZSk7XHJcbiAgICB0aGlzLnJlc2l6ZVRyZWUodGhpcy4kU3ZnLm1hcmdpbiwgdGhpcy5nZXROb2RlU3BhY2luZygpKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgIG5vZGUuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgIHBhcmVudC5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgcmlnaHRTaWIuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgIHJldHVybiBub2RlO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc3RlYWxGcm9tTGVmdChub2RlOiBCVHJlZU5vZGUsIHBhcmVudEluZGV4OiBudW1iZXIpIHtcclxuICAgIHBhcmVudEluZGV4LS07XHJcbiAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xyXG4gICAgY29uc3QgbGVmdFNpYiA9IHBhcmVudD8uZ2V0Q2hpbGQocGFyZW50SW5kZXgpO1xyXG5cclxuICAgIGlmICghcGFyZW50IHx8ICFsZWZ0U2liKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgXCJDYW4gbm90IHN0ZWFsIGZyb20gbGVmdCwgbWlzc2luZyBwYXJlbnQgb3IgbGVmdCBzaWJsaW5nXCJcclxuICAgICAgKTtcclxuXHJcbiAgICBub2RlLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgIHBhcmVudC5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBsZWZ0U2liLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuXHJcbiAgICBjb25zdCByaWdodFZhbHVlID0gcGFyZW50LmdldFRleHQocGFyZW50SW5kZXgpO1xyXG4gICAgY29uc3QgbGVmdFZhbHVlID0gbGVmdFNpYi5nZXRUZXh0KGxlZnRTaWIubnVtVmFsdWVzKCkgLSAxKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UoXCJub2RlLnN0ZWFsLmxlZnRcIiwgbm9kZSwgbGVmdFZhbHVlLCByaWdodFZhbHVlKTtcclxuXHJcbiAgICBjb25zdCByaWdodE5vZGUgPSB0aGlzLlN2Zy5iVHJlZU5vZGUoXHJcbiAgICAgIGZhbHNlLFxyXG4gICAgICAxLFxyXG4gICAgICBwYXJlbnQuZ2V0Q1gocGFyZW50SW5kZXgsIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpKSxcclxuICAgICAgcGFyZW50LmN5KCksXHJcbiAgICAgIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpLFxyXG4gICAgICB0aGlzLmdldFN0cm9rZVdpZHRoKClcclxuICAgICk7XHJcbiAgICByaWdodE5vZGUuc2V0VGV4dCgwLCByaWdodFZhbHVlKTtcclxuICAgIHJpZ2h0Tm9kZS5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBjb25zdCBsZWZ0Tm9kZSA9IHRoaXMuU3ZnLmJUcmVlTm9kZShcclxuICAgICAgZmFsc2UsXHJcbiAgICAgIDEsXHJcbiAgICAgIGxlZnRTaWIuZ2V0Q1gobGVmdFNpYi5udW1WYWx1ZXMoKSAtIDEsIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpKSxcclxuICAgICAgbGVmdFNpYi5jeSgpLFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICApO1xyXG4gICAgbGVmdE5vZGUuc2V0VGV4dCgwLCBsZWZ0VmFsdWUpO1xyXG4gICAgbGVmdE5vZGUuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG5cclxuICAgIG5vZGUuaW5zZXJ0VmFsdWUoMCwgXCJcIiwgdGhpcy5nZXRPYmplY3RTaXplKCksIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKSwgdHJ1ZSk7XHJcbiAgICBwYXJlbnQuc2V0VGV4dChwYXJlbnRJbmRleCwgXCJcIik7XHJcbiAgICBsZWZ0U2liLnNldFRleHQobGVmdFNpYi5udW1WYWx1ZXMoKSAtIDEsIFwiXCIpO1xyXG5cclxuICAgIHJpZ2h0Tm9kZS5zZXRDZW50ZXIoXHJcbiAgICAgIG5vZGUuZ2V0Q1goMCwgdGhpcy5nZXRPYmplY3RTaXplKCkpLFxyXG4gICAgICBub2RlLmN5KCksXHJcbiAgICAgIHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKVxyXG4gICAgKTtcclxuICAgIGxlZnROb2RlLnNldENlbnRlcihcclxuICAgICAgcGFyZW50LmdldENYKHBhcmVudEluZGV4LCB0aGlzLmdldE9iamVjdFNpemUoKSksXHJcbiAgICAgIHBhcmVudC5jeSgpLFxyXG4gICAgICB0aGlzLmdldEFuaW1hdGlvblNwZWVkKClcclxuICAgICk7XHJcbiAgICBpZiAoIW5vZGUuaXNMZWFmKCkpXHJcbiAgICAgIG5vZGUuc2V0Q2hpbGQoXHJcbiAgICAgICAgMCxcclxuICAgICAgICBsZWZ0U2liLmdldENoaWxkKGxlZnRTaWIubnVtQ2hpbGRyZW4oKSAtIDEpLFxyXG4gICAgICAgIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKVxyXG4gICAgICApO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG5cclxuICAgIHJpZ2h0Tm9kZS5yZW1vdmUoKTtcclxuICAgIGxlZnROb2RlLnJlbW92ZSgpO1xyXG4gICAgbGVmdFNpYi5kZWxldGVWYWx1ZShcclxuICAgICAgbGVmdFNpYi5udW1WYWx1ZXMoKSAtIDEsXHJcbiAgICAgIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpLFxyXG4gICAgICB0aGlzLmdldFN0cm9rZVdpZHRoKCksXHJcbiAgICAgIGZhbHNlXHJcbiAgICApO1xyXG4gICAgcGFyZW50LnNldFRleHQocGFyZW50SW5kZXgsIGxlZnRWYWx1ZSk7XHJcbiAgICBub2RlLnNldFRleHQoMCwgcmlnaHRWYWx1ZSk7XHJcbiAgICB0aGlzLnJlc2l6ZVRyZWUodGhpcy4kU3ZnLm1hcmdpbiwgdGhpcy5nZXROb2RlU3BhY2luZygpKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgIG5vZGUuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgIHBhcmVudC5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgbGVmdFNpYi5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgcmV0dXJuIG5vZGU7XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBCVHJlZU1lc3NhZ2VzID0ge1xyXG4gIGZpbmQ6IHtcclxuICAgIHByZWRlY2Vzc29yOiAodmFsOiBzdHJpbmcpID0+IGBGaW5kIHRoZSBwcmVkZWNlc3NvciB2YWx1ZSBvZiAke3ZhbH1gLFxyXG4gIH0sXHJcbiAgaW5zZXJ0OiB7XHJcbiAgICBudGg6ICh2YWw6IHN0cmluZywgbnRoOiBudW1iZXIpID0+XHJcbiAgICAgIGBJbnNlcnQgJHt2YWx9IGFzICR7bnRofSB2YWx1ZSBpbiB0aGUgbm9kZWAsXHJcbiAgfSxcclxuICBkZWxldGU6IHtcclxuICAgIHJvb3Q6IHtcclxuICAgICAgZW1wdHk6IFwiUmVtb3ZlIGVtcHR5IHRyZWUgcm9vdFwiLFxyXG4gICAgfSxcclxuICAgIGxlYWY6IHtcclxuICAgICAgbnRoOiAobGVhZjogQlRyZWVOb2RlLCBudGg6IG51bWJlcikgPT5cclxuICAgICAgICBgRGVsZXRlIHRoZSAke250aH0gdmFsdWUgaW4gbGVhZiAke2xlYWZ9YCxcclxuICAgICAgdmFsdWU6ICh2YWw6IHN0cmluZywgbGVhZjogQlRyZWVOb2RlKSA9PlxyXG4gICAgICAgIGBOb3cgZGVsZXRlICR7dmFsfSBpbiB0aGUgbGVhZiBub2RlICR7bGVhZn1gLFxyXG4gICAgfSxcclxuICAgIHJlcGxhY2U6ICh2YWw6IHN0cmluZywgbmV3VmFsOiBzdHJpbmcpID0+XHJcbiAgICAgIGBSZXBsYWNlIHRoZSB2YWx1ZSAke3ZhbH0gd2l0aCAke25ld1ZhbH1gLFxyXG4gIH0sXHJcbiAgbm9kZToge1xyXG4gICAgbG9va050aENoaWxkOiAobnRoOiBudW1iZXIpID0+IGBMb29rIGludG8gJHtudGh9IGNoaWxkYCxcclxuICAgIHNwbGl0OiAobm9kZTogQlRyZWVOb2RlKSA9PiBgU3BsaXR0aW5nIG5vZGUgJHtub2RlfWAsXHJcbiAgICB0b29GZXc6IChub2RlOiBCVHJlZU5vZGUpID0+IGBOb2RlICR7bm9kZX0gaGFzIHRvbyBmZXcgdmFsdWVzYCxcclxuICAgIG1lcmdlUmlnaHQ6IChub2RlOiBCVHJlZU5vZGUsIHBhcmVudDogQlRyZWVOb2RlLCByaWdodFNpYjogQlRyZWVOb2RlKSA9PiBbXHJcbiAgICAgIFwiTWVyZ2luZyBub2RlczpcIixcclxuICAgICAgYCR7bm9kZX0gKyBbJHtwYXJlbnR9XSArICR7cmlnaHRTaWJ9YCxcclxuICAgIF0sXHJcbiAgICBzdGVhbDoge1xyXG4gICAgICByaWdodDogKG5vZGU6IEJUcmVlTm9kZSwgbGVmdDogQlRyZWVOb2RlLCByaWdodDogQlRyZWVOb2RlKSA9PiBbXHJcbiAgICAgICAgXCJTdGVhbGluZyBmcm9tIHJpZ2h0IHNpYmxpbmc6XCIsXHJcbiAgICAgICAgYCR7bm9kZX0g4oaQIFske2xlZnR9XSDihpAgWyR7cmlnaHR9XWAsXHJcbiAgICAgIF0sXHJcbiAgICAgIGxlZnQ6IChub2RlOiBCVHJlZU5vZGUsIGxlZnQ6IEJUcmVlTm9kZSwgcmlnaHQ6IEJUcmVlTm9kZSkgPT4gW1xyXG4gICAgICAgIFwiU3RlYWxpbmcgZnJvbSBsZWZ0IHNpYmxpbmc6XCIsXHJcbiAgICAgICAgYFske2xlZnR9XSDihpIgWyR7cmlnaHR9XSDihpIgJHtub2RlfWAsXHJcbiAgICAgIF0sXHJcbiAgICB9LFxyXG4gIH0sXHJcbn0gYXMgY29uc3Q7XHJcbiIsIi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gSW1wb3J0IGFuZCBleHBvcnQgaW5mb3JtYXRpb24gdXNlZCBieSB0aGUgSmF2YXNjcmlwdCBsaW50ZXIgRVNMaW50OlxyXG4vKiBnbG9iYWxzIERTVmlzICovXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbmltcG9ydCB7IEJpbmFyeU5vZGUgfSBmcm9tIFwic3JjL29iamVjdHMvYmluYXJ5LW5vZGVcIjtcclxuaW1wb3J0IHsgQlNULCBCU1RNZXNzYWdlcyB9IGZyb20gXCIuL0JTVFwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFJlZEJsYWNrIGV4dGVuZHMgQlNUIHtcclxuICBtZXNzYWdlcyA9IHtcclxuICAgIC4uLkJTVE1lc3NhZ2VzLFxyXG4gICAgLi4uUmVkQmxhY2tNZXNzYWdlcyxcclxuICAgIHJvdGF0ZToge1xyXG4gICAgICAuLi5CU1RNZXNzYWdlcy5yb3RhdGUsXHJcbiAgICAgIC4uLlJlZEJsYWNrTWVzc2FnZXMucm90YXRlLFxyXG4gICAgfSxcclxuICB9O1xyXG5cclxuICBuZXdOb2RlKHRleHQ6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIHN1cGVyLm5ld05vZGUodGV4dCkuYWRkQ2xhc3MoXCJyZWRcIik7XHJcbiAgfVxyXG5cclxuICBhc3luYyBpbnNlcnRPbmUodmFsdWU6IHN0cmluZykge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VwZXIuaW5zZXJ0T25lKHZhbHVlKTtcclxuICAgIGlmIChyZXN1bHQ/LnN1Y2Nlc3MgJiYgcmVzdWx0Lm5vZGUpIHtcclxuICAgICAgYXdhaXQgdGhpcy5maXhEb3VibGVSZWQocmVzdWx0Lm5vZGUpO1xyXG4gICAgICBpZiAodGhpcy50cmVlUm9vdCAmJiB0aGlzLmlzUmVkKHRoaXMudHJlZVJvb3QpKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wYXVzZShcImNvbG9yLnJlZFJvb3RCbGFja1wiKTtcclxuICAgICAgICB0aGlzLmNvbG9yQmxhY2sodGhpcy50cmVlUm9vdCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBhc3luYyBmaXhEb3VibGVSZWQobm9kZTogQmluYXJ5Tm9kZSkge1xyXG4gICAgbGV0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XHJcbiAgICBpZiAoIXBhcmVudCkgcmV0dXJuO1xyXG4gICAgaWYgKCF0aGlzLmlzUmVkKHBhcmVudCkpIHJldHVybjtcclxuXHJcbiAgICBsZXQgZ3JhbmRwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XHJcbiAgICBpZiAoIWdyYW5kcGFyZW50KSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgcGlibGluZyA9IHBhcmVudC5nZXRTaWJsaW5nKCk7XHJcbiAgICBpZiAocGlibGluZyAmJiB0aGlzLmlzUmVkKHBpYmxpbmcpKSB7XHJcbiAgICAgIG5vZGUuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgICBwYXJlbnQuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgICBwaWJsaW5nLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZShcImNvbG9yLnB1c2hEb3duQmxhY2tcIiwgbm9kZSwgcGFyZW50LCBwaWJsaW5nKTtcclxuICAgICAgbm9kZS5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgICBwYXJlbnQuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgICAgcGlibGluZy5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgICB0aGlzLmNvbG9yQmxhY2socGlibGluZyk7XHJcbiAgICAgIHRoaXMuY29sb3JCbGFjayhwYXJlbnQpO1xyXG4gICAgICB0aGlzLmNvbG9yUmVkKGdyYW5kcGFyZW50KTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgICBhd2FpdCB0aGlzLmZpeERvdWJsZVJlZChncmFuZHBhcmVudCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgc2lkZTogXCJsZWZ0XCIgfCBcInJpZ2h0XCIgPSBub2RlLmlzTGVmdENoaWxkKCkgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcclxuICAgIGxldCByb3RhdGU6IFwibGVmdFwiIHwgXCJyaWdodFwiID0gcGFyZW50LmlzTGVmdENoaWxkKCkgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcclxuICAgIGlmIChzaWRlICE9PSByb3RhdGUpIHtcclxuICAgICAgbm9kZS5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICAgIHBhcmVudC5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICAgIGdyYW5kcGFyZW50LnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZShcInJvdGF0ZS5wYXJlbnRcIiwgbm9kZSwgc2lkZSwgcm90YXRlLCBwYXJlbnQpLFxyXG4gICAgICAgIG5vZGUuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgICAgcGFyZW50LnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICAgIGdyYW5kcGFyZW50LnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICAgIG5vZGUgPSAoYXdhaXQgdGhpcy5zaW5nbGVSb3RhdGUocm90YXRlLCBwYXJlbnQpKS5nZXRDaGlsZChcclxuICAgICAgICByb3RhdGVcclxuICAgICAgKSBhcyBCaW5hcnlOb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHNpZGUgPSBub2RlLmlzTGVmdENoaWxkKCkgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcclxuICAgIHJvdGF0ZSA9IHNpZGUgPT09IFwibGVmdFwiID8gXCJyaWdodFwiIDogXCJsZWZ0XCI7XHJcbiAgICBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xyXG4gICAgZ3JhbmRwYXJlbnQgPSBwYXJlbnQ/LmdldFBhcmVudCgpIHx8IG51bGw7XHJcblxyXG4gICAgaWYgKCFwYXJlbnQgfHwgIWdyYW5kcGFyZW50KVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHBhcmVudCBvciBncmFuZHBhcmVudFwiKTtcclxuXHJcbiAgICBub2RlLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgIHBhcmVudC5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBncmFuZHBhcmVudD8uc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcInJvdGF0ZS5ncmFuZHBhcmVudFwiLCBub2RlLCBzaWRlLCBncmFuZHBhcmVudCwgcm90YXRlKTtcclxuICAgIG5vZGUuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgIHBhcmVudC5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgZ3JhbmRwYXJlbnQ/LnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICB0aGlzLmNvbG9yQmxhY2socGFyZW50KTtcclxuICAgIHRoaXMuY29sb3JSZWQoZ3JhbmRwYXJlbnQpO1xyXG4gICAgYXdhaXQgdGhpcy5zaW5nbGVSb3RhdGUocm90YXRlLCBncmFuZHBhcmVudCBhcyBCaW5hcnlOb2RlKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGRlbGV0ZSh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdXBlci5kZWxldGUodmFsdWUpO1xyXG4gICAgaWYgKHJlc3VsdD8uc3VjY2Vzcykge1xyXG4gICAgICBpZiAocmVzdWx0LnBhcmVudCAmJiByZXN1bHQuZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5maXhEZWxldGVJbWJhbGFuY2UocmVzdWx0LnBhcmVudCwgcmVzdWx0LmRpcmVjdGlvbik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMudHJlZVJvb3QgJiYgdGhpcy5pc1JlZCh0aGlzLnRyZWVSb290KSkge1xyXG4gICAgICAgIHRoaXMuY29sb3JCbGFjayh0aGlzLnRyZWVSb290KTtcclxuICAgICAgICBhd2FpdCB0aGlzLnBhdXNlKFwiY29sb3Iucm9vdEJsYWNrXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZml4RGVsZXRlSW1iYWxhbmNlKHBhcmVudDogQmluYXJ5Tm9kZSwgZGlyOiBcImxlZnRcIiB8IFwicmlnaHRcIikge1xyXG4gICAgY29uc3QgY2hpbGQgPSBwYXJlbnQuZ2V0Q2hpbGQoZGlyKTtcclxuICAgIGlmIChjaGlsZCAmJiB0aGlzLmlzUmVkKGNoaWxkKSkge1xyXG4gICAgICB0aGlzLmNvbG9yQmxhY2soY2hpbGQpO1xyXG4gICAgICBjaGlsZC5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UoXCJjb2xvci5ub2RlQmxhY2tcIiwgY2hpbGQpO1xyXG4gICAgICBjaGlsZC5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgfSBlbHNlIGlmICghcGFyZW50LmlzTGVhZigpKSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuZml4RG91YmxlQmxhY2socGFyZW50LCBkaXIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZml4RG91YmxlQmxhY2socGFyZW50OiBCaW5hcnlOb2RlLCBsZWZ0OiBcImxlZnRcIiB8IFwicmlnaHRcIikge1xyXG4gICAgLy8gVE9ETzogRml4IHZhcmlhYmxlIG5hbWVzXHJcbiAgICBjb25zdCByaWdodCA9IGxlZnQgPT09IFwibGVmdFwiID8gXCJyaWdodFwiIDogXCJsZWZ0XCI7XHJcbiAgICBjb25zdCByaWdodENoaWxkID0gcGFyZW50LmdldENoaWxkKHJpZ2h0KTtcclxuICAgIGNvbnN0IHJpZ2h0R3JhbmRjaGlsZCA9IHJpZ2h0Q2hpbGQ/LmdldENoaWxkKHJpZ2h0KTtcclxuICAgIGNvbnN0IGxlZnRHcmFuZGNoaWxkID0gcmlnaHRDaGlsZD8uZ2V0Q2hpbGQobGVmdCk7XHJcbiAgICBwYXJlbnQuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcImJhbGFuY2luZy5wYXJlbnRJbWJhbGFuY2VkXCIsIHBhcmVudCk7XHJcblxyXG4gICAgLy8gU2libGluZyBpcyByZWRcclxuICAgIGlmIChyaWdodENoaWxkICYmIHRoaXMuaXNSZWQocmlnaHRDaGlsZCkpIHtcclxuICAgICAgcGFyZW50LnNldENoaWxkSGlnaGxpZ2h0KHJpZ2h0LCB0cnVlKTtcclxuICAgICAgcmlnaHRDaGlsZC5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UoXCJyb3RhdGUucmVkU2libGluZ1wiLCBwYXJlbnQsIHJpZ2h0LCByaWdodENoaWxkLCBsZWZ0KTtcclxuICAgICAgcGFyZW50LnNldENoaWxkSGlnaGxpZ2h0KHJpZ2h0LCBmYWxzZSk7XHJcbiAgICAgIHJpZ2h0Q2hpbGQuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuXHJcbiAgICAgIHRoaXMuY29sb3JCbGFjayhyaWdodENoaWxkKTtcclxuICAgICAgdGhpcy5jb2xvclJlZChwYXJlbnQpO1xyXG4gICAgICBhd2FpdCB0aGlzLnNpbmdsZVJvdGF0ZShsZWZ0LCBwYXJlbnQpO1xyXG4gICAgICBhd2FpdCB0aGlzLmZpeERvdWJsZUJsYWNrKHBhcmVudCwgbGVmdCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTaWJsaW5nJ3MgZGlzdGFudCBjaGlsZCBpcyByZWRcclxuICAgIGlmIChyaWdodEdyYW5kY2hpbGQgJiYgdGhpcy5pc1JlZChyaWdodEdyYW5kY2hpbGQpKSB7XHJcbiAgICAgIHBhcmVudC5zZXRDaGlsZEhpZ2hsaWdodChyaWdodCwgdHJ1ZSk7XHJcbiAgICAgIHJpZ2h0Q2hpbGQ/LnNldENoaWxkSGlnaGxpZ2h0KHJpZ2h0LCB0cnVlKTtcclxuICAgICAgcmlnaHRHcmFuZGNoaWxkLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZShcInJvdGF0ZS5yZWREaXN0YW50Q2hpbGRcIiwgcmlnaHQsIHJpZ2h0Q2hpbGQsIGxlZnQpO1xyXG4gICAgICBwYXJlbnQuc2V0Q2hpbGRIaWdobGlnaHQocmlnaHQsIGZhbHNlKTtcclxuICAgICAgcmlnaHRDaGlsZD8uc2V0Q2hpbGRIaWdobGlnaHQocmlnaHQsIGZhbHNlKTtcclxuICAgICAgcmlnaHRHcmFuZGNoaWxkLnNldEhpZ2hsaWdodChmYWxzZSk7XHJcblxyXG4gICAgICBpZiAodGhpcy5pc0JsYWNrKHBhcmVudCkpIHRoaXMuY29sb3JCbGFjayhyaWdodENoaWxkIGFzIEJpbmFyeU5vZGUpO1xyXG4gICAgICBlbHNlIHRoaXMuY29sb3JSZWQocmlnaHRDaGlsZCBhcyBCaW5hcnlOb2RlKTtcclxuICAgICAgdGhpcy5jb2xvckJsYWNrKHBhcmVudCk7XHJcbiAgICAgIHRoaXMuY29sb3JCbGFjayhyaWdodEdyYW5kY2hpbGQpO1xyXG4gICAgICBhd2FpdCB0aGlzLnNpbmdsZVJvdGF0ZShsZWZ0LCBwYXJlbnQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2libGluZydzIGNsb3NlIGNoaWxkIGlzIHJlZFxyXG4gICAgaWYgKHJpZ2h0Q2hpbGQgJiYgbGVmdEdyYW5kY2hpbGQgJiYgdGhpcy5pc1JlZChsZWZ0R3JhbmRjaGlsZCkpIHtcclxuICAgICAgcGFyZW50LnNldENoaWxkSGlnaGxpZ2h0KHJpZ2h0LCB0cnVlKTtcclxuICAgICAgcmlnaHRDaGlsZC5zZXRDaGlsZEhpZ2hsaWdodChsZWZ0LCB0cnVlKTtcclxuICAgICAgbGVmdEdyYW5kY2hpbGQuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgICBhd2FpdCB0aGlzLnBhdXNlKFwicm90YXRlLnJlZENsb3NlQ2hpbGRcIiwgcmlnaHQsIHJpZ2h0Q2hpbGQsIGxlZnQpO1xyXG4gICAgICBwYXJlbnQuc2V0Q2hpbGRIaWdobGlnaHQocmlnaHQsIGZhbHNlKTtcclxuICAgICAgcmlnaHRDaGlsZC5zZXRDaGlsZEhpZ2hsaWdodChsZWZ0LCBmYWxzZSk7XHJcbiAgICAgIGxlZnRHcmFuZGNoaWxkLnNldEhpZ2hsaWdodChmYWxzZSk7XHJcblxyXG4gICAgICB0aGlzLmNvbG9yUmVkKHJpZ2h0Q2hpbGQpO1xyXG4gICAgICB0aGlzLmNvbG9yQmxhY2sobGVmdEdyYW5kY2hpbGQpO1xyXG4gICAgICBhd2FpdCB0aGlzLnNpbmdsZVJvdGF0ZShyaWdodCwgcmlnaHRDaGlsZCk7XHJcbiAgICAgIGF3YWl0IHRoaXMuZml4RG91YmxlQmxhY2socGFyZW50LCBsZWZ0KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBhcmVudCBpcyByZWRcclxuICAgIGlmICh0aGlzLmlzUmVkKHBhcmVudCkpIHtcclxuICAgICAgcGFyZW50LnNldENoaWxkSGlnaGxpZ2h0KHJpZ2h0LCB0cnVlKTtcclxuICAgICAgcmlnaHRDaGlsZD8uc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgICBhd2FpdCB0aGlzLnBhdXNlKFwiY29sb3Iuc3dpdGNoXCIsIHBhcmVudCwgcmlnaHQsIHJpZ2h0Q2hpbGQpO1xyXG4gICAgICBwYXJlbnQuc2V0Q2hpbGRIaWdobGlnaHQocmlnaHQsIGZhbHNlKTtcclxuICAgICAgcmlnaHRDaGlsZD8uc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuXHJcbiAgICAgIHRoaXMuY29sb3JCbGFjayhwYXJlbnQpO1xyXG4gICAgICB0aGlzLmNvbG9yUmVkKHJpZ2h0Q2hpbGQgYXMgQmluYXJ5Tm9kZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBbGwgYXJlIGJsYWNrXHJcbiAgICBwYXJlbnQuc2V0Q2hpbGRIaWdobGlnaHQocmlnaHQsIHRydWUpO1xyXG4gICAgcmlnaHRDaGlsZD8uc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcImNvbG9yLmNoaWxkUmVkXCIsIHBhcmVudCwgcmlnaHQsIHJpZ2h0Q2hpbGQpO1xyXG4gICAgcGFyZW50LnNldENoaWxkSGlnaGxpZ2h0KHJpZ2h0LCBmYWxzZSk7XHJcbiAgICByaWdodENoaWxkPy5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG5cclxuICAgIHRoaXMuY29sb3JSZWQocmlnaHRDaGlsZCBhcyBCaW5hcnlOb2RlKTtcclxuICAgIGNvbnN0IGdyYW5kcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xyXG4gICAgaWYgKGdyYW5kcGFyZW50KSB7XHJcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHBhcmVudCA9PT0gZ3JhbmRwYXJlbnQuZ2V0TGVmdCgpID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCI7XHJcbiAgICAgIGF3YWl0IHRoaXMuZml4RG91YmxlQmxhY2soZ3JhbmRwYXJlbnQsIGRpcmVjdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gUmVkL2JsYWNrIGxldmVsXHJcblxyXG4gIGlzQmxhY2sobm9kZTogQmluYXJ5Tm9kZSkge1xyXG4gICAgcmV0dXJuICFub2RlIHx8IG5vZGUuaGFzQ2xhc3MoXCJibGFja1wiKTtcclxuICB9XHJcblxyXG4gIGlzUmVkKG5vZGU6IEJpbmFyeU5vZGUpIHtcclxuICAgIHJldHVybiAhdGhpcy5pc0JsYWNrKG5vZGUpO1xyXG4gIH1cclxuXHJcbiAgY29sb3JCbGFjayhub2RlOiBCaW5hcnlOb2RlKSB7XHJcbiAgICBub2RlLmFkZENsYXNzKFwiYmxhY2tcIik7XHJcbiAgfVxyXG5cclxuICBjb2xvclJlZChub2RlOiBCaW5hcnlOb2RlKSB7XHJcbiAgICBub2RlLnJlbW92ZUNsYXNzKFwiYmxhY2tcIik7XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBSZWRCbGFja01lc3NhZ2VzID0ge1xyXG4gIGNvbG9yOiB7XHJcbiAgICByZWRSb290QmxhY2s6IFwiVHJlZSByb290IGlzIHJlZDogQ29sb3IgaXQgYmxhY2tcIixcclxuICAgIHJvb3RCbGFjazogXCJDb2xvciB0aGUgcm9vdCBibGFja1wiLFxyXG4gICAgbm9kZUJsYWNrOiAobjogQmluYXJ5Tm9kZSkgPT4gYENvbG9yIG5vZGUgJHtufSBibGFja2AsXHJcbiAgICBwdXNoRG93bkJsYWNrOiAoXHJcbiAgICAgIG5vZGU6IEJpbmFyeU5vZGUsXHJcbiAgICAgIHBhcmVudDogQmluYXJ5Tm9kZSxcclxuICAgICAgcGlibGluZzogQmluYXJ5Tm9kZVxyXG4gICAgKSA9PiBbXHJcbiAgICAgIGBOb2RlICR7bm9kZX0sIHBhcmVudCAke3BhcmVudH0gYW5kIHBhcmVudCdzIHNpYmxpbmcgJHtwaWJsaW5nfSBhcmUgYWxsIHJlZGAsXHJcbiAgICAgIFwiUHVzaCBibGFja25lc3MgZG93biBmcm9tIGdyYW5kcGFyZW50XCIsXHJcbiAgICBdLFxyXG4gICAgc3dpdGNoOiAoXHJcbiAgICAgIHBhcmVudDogQmluYXJ5Tm9kZSxcclxuICAgICAgZGlyOiBcImxlZnRcIiB8IFwicmlnaHRcIixcclxuICAgICAgZGlyQ2hpbGQ6IEJpbmFyeU5vZGVcclxuICAgICkgPT4gW1xyXG4gICAgICBgUGFyZW50ICR7cGFyZW50fSBpcyByZWQsYCxcclxuICAgICAgYCR7ZGlyfSBjaGlsZCAke2RpckNoaWxkfSBhbmQgaXRzIGNoaWxkcmVuIGFyZSBibGFjazpgLFxyXG4gICAgICBcIlN3aXRjaCBjb2xvcnNcIixcclxuICAgIF0sXHJcbiAgICBjaGlsZFJlZDogKFxyXG4gICAgICBwYXJlbnQ6IEJpbmFyeU5vZGUsXHJcbiAgICAgIGRpcjogXCJsZWZ0XCIgfCBcInJpZ2h0XCIsXHJcbiAgICAgIGRpckNoaWxkOiBCaW5hcnlOb2RlXHJcbiAgICApID0+IFtcclxuICAgICAgYFBhcmVudCAke3BhcmVudH0sICR7ZGlyfSBjaGlsZCAke2RpckNoaWxkfSBhbmQgaXRzIGNoaWxkcmVuIGFyZSBibGFjazpgLFxyXG4gICAgICBgQ29sb3IgJHtkaXJ9IGNoaWxkIHJlZGAsXHJcbiAgICBdLFxyXG4gIH0sXHJcbiAgYmFsYW5jaW5nOiB7XHJcbiAgICBwYXJlbnRJbWJhbGFuY2VkOiAocGFyZW50OiBCaW5hcnlOb2RlKSA9PiBgUGFyZW50ICR7cGFyZW50fSBpcyBpbWJhbGFuY2VkYCxcclxuICB9LFxyXG4gIHJvdGF0ZToge1xyXG4gICAgcGFyZW50OiAoXHJcbiAgICAgIG5vZGU6IEJpbmFyeU5vZGUsXHJcbiAgICAgIHNpZGU6IFwibGVmdFwiIHwgXCJyaWdodFwiLFxyXG4gICAgICByb3RhdGU6IFwibGVmdFwiIHwgXCJyaWdodFwiLFxyXG4gICAgICBwYXJlbnQ6IEJpbmFyeU5vZGVcclxuICAgICkgPT4gW1xyXG4gICAgICBgTm9kZSAke25vZGV9IGlzIGEgcmVkICR7c2lkZX0gY2hpbGQgb2YgYSByZWQgJHtyb3RhdGV9IGNoaWxkYCxcclxuICAgICAgYFJvdGF0ZSBwYXJlbnQgJHtwYXJlbnR9ICR7cm90YXRlfWAsXHJcbiAgICBdLFxyXG4gICAgZ3JhbmRwYXJlbnQ6IChcclxuICAgICAgbm9kZTogQmluYXJ5Tm9kZSxcclxuICAgICAgc2lkZTogXCJsZWZ0XCIgfCBcInJpZ2h0XCIsXHJcbiAgICAgIGdyYW5kcGFyZW50OiBCaW5hcnlOb2RlLFxyXG4gICAgICByb3RhdGU6IFwibGVmdFwiIHwgXCJyaWdodFwiXHJcbiAgICApID0+IFtcclxuICAgICAgYE5vZGUgJHtub2RlfSBpcyBhIHJlZCAke3NpZGV9IGNoaWxkIG9mIGEgcmVkICR7c2lkZX0gY2hpbGRgLFxyXG4gICAgICBgU3dpdGNoIGNvbG9ycyBhbmQgcm90YXRlIGdyYW5kcGFyZW50ICR7Z3JhbmRwYXJlbnR9ICR7cm90YXRlfWAsXHJcbiAgICBdLFxyXG4gICAgcmVkU2libGluZzogKFxyXG4gICAgICBwYXJlbnQ6IEJpbmFyeU5vZGUsXHJcbiAgICAgIHJpZ2h0OiBcImxlZnRcIiB8IFwicmlnaHRcIixcclxuICAgICAgcmlnaHRDaGlsZDogQmluYXJ5Tm9kZSxcclxuICAgICAgbGVmdDogXCJsZWZ0XCIgfCBcInJpZ2h0XCJcclxuICAgICkgPT4gW1xyXG4gICAgICBgUGFyZW50ICR7cGFyZW50fSBpcyBibGFjaywgYW5kIGl0cyAke3JpZ2h0fSBjaGlsZCAke3JpZ2h0Q2hpbGR9IGlzIHJlZDpgLFxyXG4gICAgICBgU3dpdGNoIGNvbG9ycyBhbmQgcm90YXRlICR7bGVmdH1gLFxyXG4gICAgXSxcclxuICAgIHJlZERpc3RhbnRDaGlsZDogKFxyXG4gICAgICByaWdodDogXCJsZWZ0XCIgfCBcInJpZ2h0XCIsXHJcbiAgICAgIHJpZ2h0Q2hpbGQ6IEJpbmFyeU5vZGUsXHJcbiAgICAgIGxlZnQ6IFwibGVmdFwiIHwgXCJyaWdodFwiXHJcbiAgICApID0+IFtcclxuICAgICAgYCR7cmlnaHR9IGNoaWxkICR7cmlnaHRDaGlsZH0gaXMgYmxhY2ssIGl0cyAke3JpZ2h0fSBjaGlsZCBpcyByZWQ6YCxcclxuICAgICAgYFN3aXRjaCBjb2xvcnMgYW5kIHJvdGF0ZSAke2xlZnR9YCxcclxuICAgIF0sXHJcbiAgICByZWRDbG9zZUNoaWxkOiAoXHJcbiAgICAgIHJpZ2h0OiBcImxlZnRcIiB8IFwicmlnaHRcIixcclxuICAgICAgcmlnaHRDaGlsZDogQmluYXJ5Tm9kZSxcclxuICAgICAgbGVmdDogXCJsZWZ0XCIgfCBcInJpZ2h0XCJcclxuICAgICkgPT4gW1xyXG4gICAgICBgJHtyaWdodH0gY2hpbGQgJHtyaWdodENoaWxkfSBpcyBibGFjaywgaXRzICR7bGVmdH0gY2hpbGQgaXMgcmVkOmAsXHJcbiAgICAgIGBTd2l0Y2ggY29sb3JzIGFuZCByb3RhdGUgY2hpbGQgJHtyaWdodH1gLFxyXG4gICAgXSxcclxuICB9LFxyXG59IGFzIGNvbnN0O1xyXG4iLCIvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIEltcG9ydCBhbmQgZXhwb3J0IGluZm9ybWF0aW9uIHVzZWQgYnkgdGhlIEphdmFzY3JpcHQgbGludGVyIEVTTGludDpcclxuLyogZ2xvYmFscyBEU1ZpcyAqL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5pbXBvcnQgeyBjb21wYXJlIH0gZnJvbSBcIi4uLy4uL3NyYy9lbmdpbmVcIjtcclxuaW1wb3J0IHsgQmluYXJ5Tm9kZSB9IGZyb20gXCIuLi8uLi9zcmMvb2JqZWN0cy9iaW5hcnktbm9kZVwiO1xyXG5pbXBvcnQgeyBCU1QsIEJTVE1lc3NhZ2VzIH0gZnJvbSBcIi4vQlNUXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgU3BsYXlUcmVlIGV4dGVuZHMgQlNUIHtcclxuICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IEVycm9yIGJlY2F1c2UgY2hhbmdlIG9mIGRlbGV0ZS5yb290IGZyb20gb2JqZWN0IHRvIHN0cmluZ1xyXG4gIG1lc3NhZ2VzID0ge1xyXG4gICAgLi4uQlNUTWVzc2FnZXMsXHJcbiAgICAuLi5TcGxheVRyZWVNZXNzYWdlcyxcclxuICAgIHJvdGF0ZToge1xyXG4gICAgICAuLi5CU1RNZXNzYWdlcy5yb3RhdGUsXHJcbiAgICAgIC4uLlNwbGF5VHJlZU1lc3NhZ2VzLnJvdGF0ZSxcclxuICAgIH0sXHJcbiAgICBkZWxldGU6IHtcclxuICAgICAgLi4uQlNUTWVzc2FnZXMuZGVsZXRlLFxyXG4gICAgICAuLi5TcGxheVRyZWVNZXNzYWdlcy5kZWxldGUsXHJcbiAgICB9LFxyXG4gIH07XHJcbiAgYXN5bmMgZmluZCh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKSB7XHJcbiAgICBjb25zdCBmb3VuZCA9IGF3YWl0IHN1cGVyLmZpbmQodmFsdWUpO1xyXG4gICAgaWYgKGZvdW5kPy5ub2RlKSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuc3BsYXlVcChmb3VuZC5ub2RlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmb3VuZDtcclxuICB9XHJcblxyXG4gIGFzeW5jIGluc2VydE9uZSh2YWx1ZTogc3RyaW5nKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdXBlci5pbnNlcnRPbmUodmFsdWUpO1xyXG4gICAgaWYgKHJlc3VsdD8ubm9kZSkge1xyXG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSBhd2FpdCB0aGlzLnBhdXNlKFwiaW5zZXJ0LmV4aXN0c1wiLCByZXN1bHQubm9kZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMuc3BsYXlVcChyZXN1bHQubm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZGVsZXRlKHZhbHVlOiBzdHJpbmcpOiBQcm9taXNlPHtcclxuICAgIHN1Y2Nlc3M6IGJvb2xlYW47XHJcbiAgICBkaXJlY3Rpb246IFwibGVmdFwiIHwgXCJyaWdodFwiIHwgbnVsbDtcclxuICAgIHBhcmVudDogQmluYXJ5Tm9kZSB8IG51bGw7XHJcbiAgfSB8IG51bGw+IHtcclxuICAgIGlmICghdGhpcy50cmVlUm9vdClcclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGRpcmVjdGlvbjogbnVsbCwgcGFyZW50OiBudWxsIH07XHJcblxyXG4gICAgYXdhaXQgdGhpcy5maW5kKHZhbHVlKTtcclxuICAgIGlmIChjb21wYXJlKHZhbHVlLCB0aGlzLnRyZWVSb290Py5nZXRUZXh0KCkpICE9PSAwKSB7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UoXCJkZWxldGUubm90ZXhpc3RzXCIsIHZhbHVlKTtcclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIHBhcmVudDogbnVsbCwgZGlyZWN0aW9uOiBudWxsIH07XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy50cmVlUm9vdC5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZGVsZXRlLnJvb3RcIik7XHJcbiAgICBpZiAoISh0aGlzLnRyZWVSb290LmdldExlZnQoKSAmJiB0aGlzLnRyZWVSb290LmdldFJpZ2h0KCkpKSB7XHJcbiAgICAgIC8vIFRPRE86IEZpeCB2YXJpYWJsZSBuYW1lc1xyXG4gICAgICBjb25zdCBsZWZ0ID0gdGhpcy50cmVlUm9vdC5nZXRMZWZ0KCkgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcclxuICAgICAgY29uc3QgcmlnaHQgPSBsZWZ0ID09PSBcImxlZnRcIiA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xyXG4gICAgICBjb25zdCBjaGlsZCA9XHJcbiAgICAgICAgdGhpcy50cmVlUm9vdC5nZXRMZWZ0KCkgfHwgKHRoaXMudHJlZVJvb3QuZ2V0UmlnaHQoKSBhcyBCaW5hcnlOb2RlKTtcclxuICAgICAgY29uc3QgbmV3Um9vdCA9IGNoaWxkLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZShcImRlbGV0ZS5zaW5nbGVDaGlsZFwiLCByaWdodCwgbGVmdCk7XHJcbiAgICAgIHRoaXMudHJlZVJvb3QucmVtb3ZlKCk7XHJcbiAgICAgIHRoaXMudHJlZVJvb3QgPSBuZXdSb290O1xyXG4gICAgICB0aGlzLnJlc2l6ZVRyZWUoKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBwYXJlbnQ6IHRoaXMudHJlZVJvb3QsIGRpcmVjdGlvbjogbGVmdCB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy50cmVlUm9vdC5nZXRSaWdodCgpO1xyXG4gICAgY29uc3QgbGVmdCA9IHRoaXMudHJlZVJvb3QuZ2V0TGVmdCgpO1xyXG4gICAgdGhpcy50cmVlUm9vdC5yZW1vdmUoKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UoXCJkZWxldGUuc3BsYXlMYXJnZXN0XCIpO1xyXG5cclxuICAgIGxldCBsYXJnZXN0TGVmdCA9IGxlZnQgYXMgQmluYXJ5Tm9kZTsgLy8gVE9ETzogQ2hlY2sgaWYgaSBjYW4gZG8gdGhpc1xyXG4gICAgbGFyZ2VzdExlZnQuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgaWYgKGxhcmdlc3RMZWZ0LmdldFJpZ2h0KCkpIHtcclxuICAgICAgd2hpbGUgKGxhcmdlc3RMZWZ0LmdldFJpZ2h0KCkpIHtcclxuICAgICAgICBsYXJnZXN0TGVmdC5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgICAgIGxhcmdlc3RMZWZ0ID0gbGFyZ2VzdExlZnQuZ2V0UmlnaHQoKSE7XHJcbiAgICAgICAgbGFyZ2VzdExlZnQuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGFyZ2VzdExlZnQuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgIGF3YWl0IHRoaXMuc3BsYXlVcChsYXJnZXN0TGVmdCk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZGVsZXRlLmNvbm5lY3RMZWZ0UmlnaHRcIik7XHJcbiAgICBsYXJnZXN0TGVmdC5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKHVuZGVmaW5lZCk7XHJcbiAgICBsYXJnZXN0TGVmdC5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgbGFyZ2VzdExlZnQuc2V0UmlnaHQocmlnaHQgYXMgQmluYXJ5Tm9kZSwgdGhpcy5nZXRTdHJva2VXaWR0aCgpKTtcclxuICAgIHRoaXMudHJlZVJvb3QgPSBsYXJnZXN0TGVmdDtcclxuICAgIHRoaXMucmVzaXplVHJlZSgpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgcGFyZW50OiB0aGlzLnRyZWVSb290LCBkaXJlY3Rpb246IG51bGwgfTsgLy8gVE9ETzogdXBkYXRlIGRpcmVjdGlvblxyXG4gIH1cclxuXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFNwbGF5IGEgbm9kZSB0byB0aGUgcm9vdCBvZiB0aGUgdHJlZVxyXG5cclxuICBhc3luYyBzcGxheVVwKG5vZGU6IEJpbmFyeU5vZGUpIHtcclxuICAgIGlmIChub2RlID09PSB0aGlzLnRyZWVSb290KSByZXR1cm47XHJcbiAgICBub2RlLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UoXCJyb3RhdGUuc3BsYXlVcFwiLCBub2RlKTtcclxuICAgIG5vZGUuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgIHdoaWxlIChub2RlLmdldFBhcmVudCgpKSB7XHJcbiAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCkhO1xyXG4gICAgICBjb25zdCBsZWZ0ID0gbm9kZS5pc0xlZnRDaGlsZCgpID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCI7XHJcbiAgICAgIGNvbnN0IHJpZ2h0ID0gbGVmdCA9PT0gXCJsZWZ0XCIgPyBcInJpZ2h0XCIgOiBcImxlZnRcIjtcclxuICAgICAgaWYgKCFwYXJlbnQuZ2V0UGFyZW50KCkpIHtcclxuICAgICAgICBub2RlID0gYXdhaXQgdGhpcy5zaW5nbGVSb3RhdGUocmlnaHQsIHBhcmVudCk7XHJcbiAgICAgIH0gZWxzZSBpZiAocGFyZW50LmlzQ2hpbGQocmlnaHQpKSB7XHJcbiAgICAgICAgbm9kZSA9IGF3YWl0IHRoaXMuZG91YmxlUm90YXRlKGxlZnQsIHBhcmVudC5nZXRQYXJlbnQoKSEpO1xyXG4gICAgICAgIC8vIHRoaXMuc3BsYXlIZWxwZXIobm9kZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gbm9kZSA9IGF3YWl0IHRoaXMuc2luZ2xlUm90YXRlKHJpZ2h0LCBwYXJlbnQpO1xyXG4gICAgICAgIG5vZGUgPSBhd2FpdCB0aGlzLnppZ1ppZyhyaWdodCwgcGFyZW50LmdldFBhcmVudCgpISk7XHJcbiAgICAgICAgLy8gdGhpcy5zcGxheUhlbHBlcihub2RlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgc3BsYXlIZWxwZXIobm9kZTogQmluYXJ5Tm9kZSkge1xyXG4gICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcclxuICAgIGlmICghcGFyZW50KSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgbGVmdCA9IG5vZGUuaXNMZWZ0Q2hpbGQoKSA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xyXG4gICAgY29uc3QgcmlnaHQgPSBsZWZ0ID09PSBcImxlZnRcIiA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xyXG4gICAgaWYgKCFwYXJlbnQ/LmdldFBhcmVudCgpKSB7XHJcbiAgICAgIHRoaXMuc2luZ2xlUm90YXRlKGxlZnQsIHBhcmVudCk7XHJcbiAgICB9IGVsc2UgaWYgKHBhcmVudC5pc0NoaWxkKHJpZ2h0KSkge1xyXG4gICAgICB0aGlzLmRvdWJsZVJvdGF0ZShsZWZ0LCBwYXJlbnQuZ2V0UGFyZW50KCkhKTtcclxuICAgICAgdGhpcy5zcGxheUhlbHBlcihub2RlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuemlnWmlnKHJpZ2h0LCBwYXJlbnQuZ2V0UGFyZW50KCkhKTtcclxuICAgICAgdGhpcy5zcGxheUhlbHBlcihub2RlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIHppZ1ppZyhsZWZ0OiBcImxlZnRcIiB8IFwicmlnaHRcIiwgbm9kZTogQmluYXJ5Tm9kZSkge1xyXG4gICAgLy8gTm90ZTogJ2xlZnQnIGFuZCAncmlnaHQnIGFyZSB2YXJpYWJsZXMgdGhhdCBjYW4gaGF2ZSB2YWx1ZXMgXCJsZWZ0XCIgb3IgXCJyaWdodFwiIVxyXG4gICAgY29uc3QgcmlnaHQgPSBsZWZ0ID09PSBcImxlZnRcIiA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xyXG4gICAgY29uc3QgY2hpbGQgPSBub2RlLmdldENoaWxkKHJpZ2h0KTtcclxuXHJcbiAgICBpZiAoIWNoaWxkKSByZXR1cm4gbm9kZTtcclxuXHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwicm90YXRlLnppZ3ppZ1wiLCBub2RlLCBsZWZ0LCBjaGlsZCk7XHJcbiAgICBhd2FpdCB0aGlzLnNpbmdsZVJvdGF0ZShsZWZ0LCBub2RlKTtcclxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNpbmdsZVJvdGF0ZShsZWZ0LCBjaGlsZCk7XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBTcGxheVRyZWVNZXNzYWdlcyA9IHtcclxuICBkZWxldGU6IHtcclxuICAgIHJvb3Q6IFwiUmVtb3ZlIHJvb3QsIGxlYXZpbmcgbGVmdCBhbmQgcmlnaHQgdHJlZXNcIixcclxuICAgIHNpbmdsZUNoaWxkOiAocmlnaHQ6IFwibGVmdFwiIHwgXCJyaWdodFwiLCBsZWZ0OiBcImxlZnRcIiB8IFwicmlnaHRcIikgPT5cclxuICAgICAgYE5vICR7cmlnaHR9IHRyZWUsIG1ha2UgJHtsZWZ0fSB0cmVlIHRoZSByb290YCxcclxuICAgIHNwbGF5TGFyZ2VzdDogXCJTcGxheSBsYXJnZXN0IGVsZW1lbnQgaW4gbGVmdCB0cmVlIHRvIHJvb3RcIixcclxuICAgIGNvbm5lY3RMZWZ0UmlnaHQ6XHJcbiAgICAgIFwiTGVmdCB0cmVlIG5vdyBoYXMgbm8gcmlnaHQgc3VidHJlZSwgY29ubmVjdCBsZWZ0IGFuZCByaWdodCB0cmVlc1wiLFxyXG4gIH0sXHJcbiAgcm90YXRlOiB7XHJcbiAgICBzcGxheVVwOiAobm9kZTogQmluYXJ5Tm9kZSkgPT4gYE5vdyBzcGxheWluZyAke25vZGV9IHVwIHRvIHRoZSByb290YCxcclxuICAgIHppZ3ppZzogKG5vZGU6IEJpbmFyeU5vZGUsIGxlZnQ6IFwibGVmdFwiIHwgXCJyaWdodFwiLCBjaGlsZDogQmluYXJ5Tm9kZSkgPT5cclxuICAgICAgYFppZy16aWc6IFJvdGF0ZSAke25vZGV9ICR7bGVmdH0sIHRoZW4gcm90YXRlICR7Y2hpbGR9ICR7bGVmdH1gLFxyXG4gIH0sXHJcbn07XHJcbiIsImltcG9ydCB7IGFkZFJldHVyblN1Ym1pdCwgRW5naW5lIH0gZnJvbSBcIi4vZW5naW5lXCI7XHJcbmltcG9ydCB7IEFWTCB9IGZyb20gXCIuL3RyZWVzL0FWTFwiO1xyXG5pbXBvcnQgeyBCU1QgfSBmcm9tIFwiLi90cmVlcy9CU1RcIjtcclxuaW1wb3J0IHsgQlRyZWUgfSBmcm9tIFwiLi90cmVlcy9CVHJlZVwiO1xyXG5pbXBvcnQgeyBSZWRCbGFjayB9IGZyb20gXCIuL3RyZWVzL1JlZEJsYWNrXCI7XHJcbmltcG9ydCB7IFNwbGF5VHJlZSB9IGZyb20gXCIuL3RyZWVzL1NwbGF5VHJlZVwiO1xyXG5cclxuY29uc3QgQ09MTEVDVElPTlMgPSB7XHJcbiAgQlNUOiBCU1QsXHJcbiAgQVZMOiBBVkwsXHJcbiAgUmVkQmxhY2s6IFJlZEJsYWNrLFxyXG4gIFNwbGF5VHJlZTogU3BsYXlUcmVlLFxyXG4gIEJUcmVlOiBCVHJlZSxcclxufSBhcyBjb25zdDtcclxuXHJcbnR5cGUgQ29sbGVjdGlvblRvb2xiYXJJdGVtcyA9IHtcclxuICBpbnNlcnRTZWxlY3Q6IEhUTUxTZWxlY3RFbGVtZW50O1xyXG4gIGluc2VydEZpZWxkOiBIVE1MSW5wdXRFbGVtZW50O1xyXG4gIGluc2VydFN1Ym1pdDogSFRNTElucHV0RWxlbWVudDtcclxuICBmaW5kRmllbGQ6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgZmluZFN1Ym1pdDogSFRNTElucHV0RWxlbWVudDtcclxuICBkZWxldGVGaWVsZDogSFRNTElucHV0RWxlbWVudDtcclxuICBkZWxldGVTdWJtaXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgcHJpbnRTdWJtaXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgY2xlYXJTdWJtaXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbn07XHJcblxyXG5pbml0aWFsaXNlQ29sbGVjdGlvbnMoXCIjY29sbGVjdGlvbnNDb250YWluZXJcIik7XHJcblxyXG5mdW5jdGlvbiBpbml0aWFsaXNlQ29sbGVjdGlvbnMoY29udGFpbmVySUQ6IHN0cmluZykge1xyXG4gIGNvbnN0IGFsZ29TZWxlY3RvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXHJcbiAgICBgJHtjb250YWluZXJJRH0gc2VsZWN0LmFsZ29yaXRobVNlbGVjdG9yYFxyXG4gICkgYXMgSFRNTFNlbGVjdEVsZW1lbnQ7XHJcblxyXG4gIGlmICghYWxnb1NlbGVjdG9yKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBhbGdvIHNlbGVjdG9yXCIpO1xyXG5cclxuICBhbGdvU2VsZWN0b3IuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoKSA9PiB7XHJcbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XHJcblxyXG4gICAgaWYgKGFsZ29TZWxlY3Rvci52YWx1ZSBpbiBDT0xMRUNUSU9OUylcclxuICAgICAgc2VhcmNoUGFyYW1zLnNldChcImFsZ29yaXRobVwiLCBhbGdvU2VsZWN0b3IudmFsdWUpO1xyXG4gICAgZWxzZSBzZWFyY2hQYXJhbXMuZGVsZXRlKFwiYWxnb3JpdGhtXCIpO1xyXG5cclxuICAgIGlmIChDb2xsZWN0aW9uRW5naW5lLkRFQlVHKSBzZWFyY2hQYXJhbXMuc2V0KFwiZGVidWdcIiwgXCJ0cnVlXCIpO1xyXG4gICAgZWxzZSBzZWFyY2hQYXJhbXMuZGVsZXRlKFwiZGVidWdcIik7XHJcblxyXG4gICAgY29uc3QgdXJsID0gYCR7d2luZG93LmxvY2F0aW9uLnBhdGhuYW1lfT8ke3NlYXJjaFBhcmFtc31gO1xyXG4gICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKFwiXCIsIFwiXCIsIHVybCk7XHJcbiAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgfSk7XHJcblxyXG4gIGxldCBhbGdvID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZikuc2VhcmNoUGFyYW1zLmdldChcImFsZ29yaXRobVwiKTtcclxuICBpZiAoIShhbGdvICYmIC9eW1xcdy5dKyQvLnRlc3QoYWxnbykgJiYgYWxnbyBpbiBDT0xMRUNUSU9OUykpIHtcclxuICAgIGFsZ28gPSBcIlwiO1xyXG4gIH1cclxuICBjb25zdCBhbGdvQ2xhc3MgPSBhbGdvIGFzIGtleW9mIHR5cGVvZiBDT0xMRUNUSU9OUyB8IFwiXCI7XHJcbiAgYWxnb1NlbGVjdG9yLnZhbHVlID0gYWxnbztcclxuICBjb25zdCBDb2xsZWN0aW9uID0gYWxnb0NsYXNzID8gQ09MTEVDVElPTlNbYWxnb0NsYXNzXSA6IEVuZ2luZTtcclxuICBjb25zdCBDb2xsZWN0aW9uRW5naW5lID0gbmV3IENvbGxlY3Rpb24oY29udGFpbmVySUQpO1xyXG4gIENvbGxlY3Rpb25FbmdpbmUuaW5pdGlhbGlzZSgpO1xyXG5cclxuICBjb25zdCB0b29sYmFyID0gZ2V0Q29sbGVjdGlvbnNUb29sYmFyKENvbGxlY3Rpb25FbmdpbmUuY29udGFpbmVyKTtcclxuXHJcbiAgdG9vbGJhci5pbnNlcnRTZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoKSA9PiB7XHJcbiAgICB0b29sYmFyLmluc2VydEZpZWxkLnZhbHVlID0gdG9vbGJhci5pbnNlcnRTZWxlY3QudmFsdWU7XHJcbiAgICB0b29sYmFyLmluc2VydFNlbGVjdC52YWx1ZSA9IFwiXCI7XHJcbiAgfSk7XHJcblxyXG4gIGFkZFJldHVyblN1Ym1pdCh0b29sYmFyLmluc2VydEZpZWxkLCBcIkFMUEhBTlVNK1wiLCAoKSA9PlxyXG4gICAgQ29sbGVjdGlvbkVuZ2luZS5zdWJtaXQoXCJpbnNlcnRcIiwgdG9vbGJhci5pbnNlcnRGaWVsZClcclxuICApO1xyXG5cclxuICB0b29sYmFyLmluc2VydFN1Ym1pdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgQ29sbGVjdGlvbkVuZ2luZS5zdWJtaXQoXCJpbnNlcnRcIiwgdG9vbGJhci5pbnNlcnRGaWVsZCk7XHJcbiAgfSk7XHJcblxyXG4gIGFkZFJldHVyblN1Ym1pdCh0b29sYmFyLmZpbmRGaWVsZCwgXCJBTFBIQU5VTVwiLCAoKSA9PlxyXG4gICAgQ29sbGVjdGlvbkVuZ2luZS5zdWJtaXQoXCJmaW5kXCIsIHRvb2xiYXIuZmluZEZpZWxkKVxyXG4gICk7XHJcbiAgdG9vbGJhci5maW5kU3VibWl0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PlxyXG4gICAgQ29sbGVjdGlvbkVuZ2luZS5zdWJtaXQoXCJmaW5kXCIsIHRvb2xiYXIuZmluZEZpZWxkKVxyXG4gICk7XHJcbiAgYWRkUmV0dXJuU3VibWl0KHRvb2xiYXIuZGVsZXRlRmllbGQsIFwiQUxQSEFOVU1cIiwgKCkgPT5cclxuICAgIENvbGxlY3Rpb25FbmdpbmUuc3VibWl0KFwiZGVsZXRlXCIsIHRvb2xiYXIuZGVsZXRlRmllbGQpXHJcbiAgKTtcclxuICB0b29sYmFyLmRlbGV0ZVN1Ym1pdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT5cclxuICAgIENvbGxlY3Rpb25FbmdpbmUuc3VibWl0KFwiZGVsZXRlXCIsIHRvb2xiYXIuZGVsZXRlRmllbGQpXHJcbiAgKTtcclxuICB0b29sYmFyLnByaW50U3VibWl0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PlxyXG4gICAgQ29sbGVjdGlvbkVuZ2luZS5zdWJtaXQoXCJwcmludFwiLCB0b29sYmFyLnByaW50U3VibWl0KVxyXG4gICk7XHJcbiAgdG9vbGJhci5jbGVhclN1Ym1pdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT5cclxuICAgIENvbGxlY3Rpb25FbmdpbmUuY29uZmlybVJlc2V0QWxsKClcclxuICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDb2xsZWN0aW9uc1Rvb2xiYXIoY29udGFpbmVyOiBIVE1MRWxlbWVudCkge1xyXG4gIGNvbnN0IGluc2VydFNlbGVjdCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yPEhUTUxTZWxlY3RFbGVtZW50PihcclxuICAgIFwic2VsZWN0Lmluc2VydFNlbGVjdFwiXHJcbiAgKTtcclxuICBjb25zdCBpbnNlcnRGaWVsZCA9XHJcbiAgICBjb250YWluZXIucXVlcnlTZWxlY3RvcjxIVE1MSW5wdXRFbGVtZW50PihcImlucHV0Lmluc2VydEZpZWxkXCIpO1xyXG4gIGNvbnN0IGluc2VydFN1Ym1pdCA9XHJcbiAgICBjb250YWluZXIucXVlcnlTZWxlY3RvcjxIVE1MSW5wdXRFbGVtZW50PihcImlucHV0Lmluc2VydFN1Ym1pdFwiKTtcclxuICBjb25zdCBmaW5kRmllbGQgPVxyXG4gICAgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3I8SFRNTElucHV0RWxlbWVudD4oXCJpbnB1dC5maW5kRmllbGRcIik7XHJcbiAgY29uc3QgZmluZFN1Ym1pdCA9XHJcbiAgICBjb250YWluZXIucXVlcnlTZWxlY3RvcjxIVE1MSW5wdXRFbGVtZW50PihcImlucHV0LmZpbmRTdWJtaXRcIik7XHJcbiAgY29uc3QgZGVsZXRlRmllbGQgPVxyXG4gICAgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3I8SFRNTElucHV0RWxlbWVudD4oXCJpbnB1dC5kZWxldGVGaWVsZFwiKTtcclxuICBjb25zdCBkZWxldGVTdWJtaXQgPVxyXG4gICAgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3I8SFRNTElucHV0RWxlbWVudD4oXCJpbnB1dC5kZWxldGVTdWJtaXRcIik7XHJcbiAgY29uc3QgcHJpbnRTdWJtaXQgPVxyXG4gICAgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3I8SFRNTElucHV0RWxlbWVudD4oXCJpbnB1dC5wcmludFN1Ym1pdFwiKTtcclxuICBjb25zdCBjbGVhclN1Ym1pdCA9XHJcbiAgICBjb250YWluZXIucXVlcnlTZWxlY3RvcjxIVE1MSW5wdXRFbGVtZW50PihcImlucHV0LmNsZWFyU3VibWl0XCIpO1xyXG5cclxuICBpZiAoIWluc2VydFNlbGVjdCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBpbnNlcnQgc2VsZWN0XCIpO1xyXG4gIGlmICghaW5zZXJ0RmllbGQpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgaW5zZXJ0IGZpZWxkXCIpO1xyXG4gIGlmICghaW5zZXJ0U3VibWl0KSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGluc2VydCBzdWJtaXRcIik7XHJcbiAgaWYgKCFmaW5kRmllbGQpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZmluZCBmaWVsZFwiKTtcclxuICBpZiAoIWZpbmRTdWJtaXQpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZmluZCBzdWJtaXRcIik7XHJcbiAgaWYgKCFkZWxldGVGaWVsZCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBkZWxldGUgZmllbGRcIik7XHJcbiAgaWYgKCFkZWxldGVTdWJtaXQpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZGVsZXRlIHN1Ym1pdFwiKTtcclxuICBpZiAoIXByaW50U3VibWl0KSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHByaW50IHN1Ym1pdFwiKTtcclxuICBpZiAoIWNsZWFyU3VibWl0KSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGNsZWFyIHN1Ym1pdFwiKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGluc2VydFNlbGVjdCxcclxuICAgIGluc2VydEZpZWxkLFxyXG4gICAgaW5zZXJ0U3VibWl0LFxyXG4gICAgZmluZEZpZWxkLFxyXG4gICAgZmluZFN1Ym1pdCxcclxuICAgIGRlbGV0ZUZpZWxkLFxyXG4gICAgZGVsZXRlU3VibWl0LFxyXG4gICAgcHJpbnRTdWJtaXQsXHJcbiAgICBjbGVhclN1Ym1pdCxcclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///166\n")}},__webpack_require__={d:(Q,B)=>{for(var n in B)__webpack_require__.o(B,n)&&!__webpack_require__.o(Q,n)&&Object.defineProperty(Q,n,{enumerable:!0,get:B[n]})},o:(Q,B)=>Object.prototype.hasOwnProperty.call(Q,B),r:Q=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})}},__webpack_exports__={};__webpack_modules__[166](0,__webpack_exports__,__webpack_require__)})();