(()=>{"use strict";var __webpack_modules__={166:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval("\n// NAMESPACE OBJECT: ./node_modules/@svgdotjs/svg.js/src/modules/core/circled.js\nvar circled_namespaceObject = {};\n__webpack_require__.r(circled_namespaceObject);\n__webpack_require__.d(circled_namespaceObject, {\n  cx: () => (cx),\n  cy: () => (cy),\n  height: () => (height),\n  rx: () => (rx),\n  ry: () => (ry),\n  width: () => (width),\n  x: () => (x),\n  y: () => (y)\n});\n\n// NAMESPACE OBJECT: ./node_modules/@svgdotjs/svg.js/src/modules/core/gradiented.js\nvar gradiented_namespaceObject = {};\n__webpack_require__.r(gradiented_namespaceObject);\n__webpack_require__.d(gradiented_namespaceObject, {\n  from: () => (from),\n  to: () => (to)\n});\n\n// NAMESPACE OBJECT: ./node_modules/@svgdotjs/svg.js/src/modules/core/pointed.js\nvar pointed_namespaceObject = {};\n__webpack_require__.r(pointed_namespaceObject);\n__webpack_require__.d(pointed_namespaceObject, {\n  MorphArray: () => (MorphArray),\n  height: () => (pointed_height),\n  width: () => (pointed_width),\n  x: () => (pointed_x),\n  y: () => (pointed_y)\n});\n\n// NAMESPACE OBJECT: ./node_modules/@svgdotjs/svg.js/src/modules/core/poly.js\nvar poly_namespaceObject = {};\n__webpack_require__.r(poly_namespaceObject);\n__webpack_require__.d(poly_namespaceObject, {\n  array: () => (array),\n  clear: () => (clear),\n  move: () => (move),\n  plot: () => (plot),\n  size: () => (size)\n});\n\n// NAMESPACE OBJECT: ./node_modules/@svgdotjs/svg.js/src/modules/core/textable.js\nvar textable_namespaceObject = {};\n__webpack_require__.r(textable_namespaceObject);\n__webpack_require__.d(textable_namespaceObject, {\n  amove: () => (amove),\n  ax: () => (ax),\n  ay: () => (ay),\n  build: () => (build),\n  center: () => (center),\n  cx: () => (textable_cx),\n  cy: () => (textable_cy),\n  length: () => (textable_length),\n  move: () => (textable_move),\n  plain: () => (plain),\n  x: () => (textable_x),\n  y: () => (textable_y)\n});\n\n// NAMESPACE OBJECT: ./node_modules/@svgdotjs/svg.js/src/modules/core/containerGeometry.js\nvar containerGeometry_namespaceObject = {};\n__webpack_require__.r(containerGeometry_namespaceObject);\n__webpack_require__.d(containerGeometry_namespaceObject, {\n  dmove: () => (dmove),\n  dx: () => (dx),\n  dy: () => (dy),\n  height: () => (containerGeometry_height),\n  move: () => (containerGeometry_move),\n  size: () => (containerGeometry_size),\n  width: () => (containerGeometry_width),\n  x: () => (containerGeometry_x),\n  y: () => (containerGeometry_y)\n});\n\n;// ./node_modules/@svgdotjs/svg.js/src/utils/methods.js\nconst methods = {}\nconst names = []\n\nfunction registerMethods(name, m) {\n  if (Array.isArray(name)) {\n    for (const _name of name) {\n      registerMethods(_name, m)\n    }\n    return\n  }\n\n  if (typeof name === 'object') {\n    for (const _name in name) {\n      registerMethods(_name, name[_name])\n    }\n    return\n  }\n\n  addMethodNames(Object.getOwnPropertyNames(m))\n  methods[name] = Object.assign(methods[name] || {}, m)\n}\n\nfunction getMethodsFor(name) {\n  return methods[name] || {}\n}\n\nfunction getMethodNames() {\n  return [...new Set(names)]\n}\n\nfunction addMethodNames(_names) {\n  names.push(..._names)\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/utils/utils.js\n// Map function\nfunction map(array, block) {\n  let i\n  const il = array.length\n  const result = []\n\n  for (i = 0; i < il; i++) {\n    result.push(block(array[i]))\n  }\n\n  return result\n}\n\n// Filter function\nfunction filter(array, block) {\n  let i\n  const il = array.length\n  const result = []\n\n  for (i = 0; i < il; i++) {\n    if (block(array[i])) {\n      result.push(array[i])\n    }\n  }\n\n  return result\n}\n\n// Degrees to radians\nfunction radians(d) {\n  return ((d % 360) * Math.PI) / 180\n}\n\n// Radians to degrees\nfunction degrees(r) {\n  return ((r * 180) / Math.PI) % 360\n}\n\n// Convert camel cased string to dash separated\nfunction unCamelCase(s) {\n  return s.replace(/([A-Z])/g, function (m, g) {\n    return '-' + g.toLowerCase()\n  })\n}\n\n// Capitalize first letter of a string\nfunction capitalize(s) {\n  return s.charAt(0).toUpperCase() + s.slice(1)\n}\n\n// Calculate proportional width and height values when necessary\nfunction proportionalSize(element, width, height, box) {\n  if (width == null || height == null) {\n    box = box || element.bbox()\n\n    if (width == null) {\n      width = (box.width / box.height) * height\n    } else if (height == null) {\n      height = (box.height / box.width) * width\n    }\n  }\n\n  return {\n    width: width,\n    height: height\n  }\n}\n\n/**\n * This function adds support for string origins.\n * It searches for an origin in o.origin o.ox and o.originX.\n * This way, origin: {x: 'center', y: 50} can be passed as well as ox: 'center', oy: 50\n **/\nfunction getOrigin(o, element) {\n  const origin = o.origin\n  // First check if origin is in ox or originX\n  let ox = o.ox != null ? o.ox : o.originX != null ? o.originX : 'center'\n  let oy = o.oy != null ? o.oy : o.originY != null ? o.originY : 'center'\n\n  // Then check if origin was used and overwrite in that case\n  if (origin != null) {\n    ;[ox, oy] = Array.isArray(origin)\n      ? origin\n      : typeof origin === 'object'\n        ? [origin.x, origin.y]\n        : [origin, origin]\n  }\n\n  // Make sure to only call bbox when actually needed\n  const condX = typeof ox === 'string'\n  const condY = typeof oy === 'string'\n  if (condX || condY) {\n    const { height, width, x, y } = element.bbox()\n\n    // And only overwrite if string was passed for this specific axis\n    if (condX) {\n      ox = ox.includes('left')\n        ? x\n        : ox.includes('right')\n          ? x + width\n          : x + width / 2\n    }\n\n    if (condY) {\n      oy = oy.includes('top')\n        ? y\n        : oy.includes('bottom')\n          ? y + height\n          : y + height / 2\n    }\n  }\n\n  // Return the origin as it is if it wasn't a string\n  return [ox, oy]\n}\n\nconst descriptiveElements = new Set(['desc', 'metadata', 'title'])\nconst isDescriptive = (element) =>\n  descriptiveElements.has(element.nodeName)\n\nconst writeDataToDom = (element, data, defaults = {}) => {\n  const cloned = { ...data }\n\n  for (const key in cloned) {\n    if (cloned[key].valueOf() === defaults[key]) {\n      delete cloned[key]\n    }\n  }\n\n  if (Object.keys(cloned).length) {\n    element.node.setAttribute('data-svgjs', JSON.stringify(cloned)) // see #428\n  } else {\n    element.node.removeAttribute('data-svgjs')\n    element.node.removeAttribute('svgjs:data')\n  }\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/namespaces.js\n// Default namespaces\nconst svg = 'http://www.w3.org/2000/svg'\nconst html = 'http://www.w3.org/1999/xhtml'\nconst xmlns = 'http://www.w3.org/2000/xmlns/'\nconst xlink = 'http://www.w3.org/1999/xlink'\n\n;// ./node_modules/@svgdotjs/svg.js/src/utils/window.js\nconst globals = {\n  window: typeof window === 'undefined' ? null : window,\n  document: typeof document === 'undefined' ? null : document\n}\n\nfunction registerWindow(win = null, doc = null) {\n  globals.window = win\n  globals.document = doc\n}\n\nconst save = {}\n\nfunction saveWindow() {\n  save.window = globals.window\n  save.document = globals.document\n}\n\nfunction restoreWindow() {\n  globals.window = save.window\n  globals.document = save.document\n}\n\nfunction withWindow(win, fn) {\n  saveWindow()\n  registerWindow(win, win.document)\n  fn(win, win.document)\n  restoreWindow()\n}\n\nfunction getWindow() {\n  return globals.window\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/Base.js\nclass Base {\n  // constructor (node/*, {extensions = []} */) {\n  //   // this.tags = []\n  //   //\n  //   // for (let extension of extensions) {\n  //   //   extension.setup.call(this, node)\n  //   //   this.tags.push(extension.name)\n  //   // }\n  // }\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/utils/adopter.js\n\n\n\n\n\n\nconst adopter_elements = {}\nconst root = '___SYMBOL___ROOT___'\n\n// Method for element creation\nfunction create(name, ns = svg) {\n  // create element\n  return globals.document.createElementNS(ns, name)\n}\n\nfunction adopter_makeInstance(element, isHTML = false) {\n  if (element instanceof Base) return element\n\n  if (typeof element === 'object') {\n    return adopter(element)\n  }\n\n  if (element == null) {\n    return new adopter_elements[root]()\n  }\n\n  if (typeof element === 'string' && element.charAt(0) !== '<') {\n    return adopter(globals.document.querySelector(element))\n  }\n\n  // Make sure, that HTML elements are created with the correct namespace\n  const wrapper = isHTML ? globals.document.createElement('div') : create('svg')\n  wrapper.innerHTML = element\n\n  // We can use firstChild here because we know,\n  // that the first char is < and thus an element\n  element = adopter(wrapper.firstChild)\n\n  // make sure, that element doesn't have its wrapper attached\n  wrapper.removeChild(wrapper.firstChild)\n  return element\n}\n\nfunction nodeOrNew(name, node) {\n  return node &&\n    (node instanceof globals.window.Node ||\n      (node.ownerDocument &&\n        node instanceof node.ownerDocument.defaultView.Node))\n    ? node\n    : create(name)\n}\n\n// Adopt existing svg elements\nfunction adopt(node) {\n  // check for presence of node\n  if (!node) return null\n\n  // make sure a node isn't already adopted\n  if (node.instance instanceof Base) return node.instance\n\n  if (node.nodeName === '#document-fragment') {\n    return new adopter_elements.Fragment(node)\n  }\n\n  // initialize variables\n  let className = capitalize(node.nodeName || 'Dom')\n\n  // Make sure that gradients are adopted correctly\n  if (className === 'LinearGradient' || className === 'RadialGradient') {\n    className = 'Gradient'\n\n    // Fallback to Dom if element is not known\n  } else if (!adopter_elements[className]) {\n    className = 'Dom'\n  }\n\n  return new adopter_elements[className](node)\n}\n\nlet adopter = adopt\n\nfunction mockAdopt(mock = adopt) {\n  adopter = mock\n}\n\nfunction register(element, name = element.name, asRoot = false) {\n  adopter_elements[name] = element\n  if (asRoot) adopter_elements[root] = element\n\n  addMethodNames(Object.getOwnPropertyNames(element.prototype))\n\n  return element\n}\n\nfunction getClass(name) {\n  return adopter_elements[name]\n}\n\n// Element id sequence\nlet did = 1000\n\n// Get next named element id\nfunction eid(name) {\n  return 'Svgjs' + capitalize(name) + did++\n}\n\n// Deep new id assignment\nfunction assignNewId(node) {\n  // do the same for SVG child nodes as well\n  for (let i = node.children.length - 1; i >= 0; i--) {\n    assignNewId(node.children[i])\n  }\n\n  if (node.id) {\n    node.id = eid(node.nodeName)\n    return node\n  }\n\n  return node\n}\n\n// Method for extending objects\nfunction extend(modules, methods) {\n  let key, i\n\n  modules = Array.isArray(modules) ? modules : [modules]\n\n  for (i = modules.length - 1; i >= 0; i--) {\n    for (key in methods) {\n      modules[i].prototype[key] = methods[key]\n    }\n  }\n}\n\nfunction wrapWithAttrCheck(fn) {\n  return function (...args) {\n    const o = args[args.length - 1]\n\n    if (o && o.constructor === Object && !(o instanceof Array)) {\n      return fn.apply(this, args.slice(0, -1)).attr(o)\n    } else {\n      return fn.apply(this, args)\n    }\n  }\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/optional/arrange.js\n\n\n\n// Get all siblings, including myself\nfunction siblings() {\n  return this.parent().children()\n}\n\n// Get the current position siblings\nfunction position() {\n  return this.parent().index(this)\n}\n\n// Get the next element (will return null if there is none)\nfunction next() {\n  return this.siblings()[this.position() + 1]\n}\n\n// Get the next element (will return null if there is none)\nfunction prev() {\n  return this.siblings()[this.position() - 1]\n}\n\n// Send given element one step forward\nfunction forward() {\n  const i = this.position()\n  const p = this.parent()\n\n  // move node one step forward\n  p.add(this.remove(), i + 1)\n\n  return this\n}\n\n// Send given element one step backward\nfunction backward() {\n  const i = this.position()\n  const p = this.parent()\n\n  p.add(this.remove(), i ? i - 1 : 0)\n\n  return this\n}\n\n// Send given element all the way to the front\nfunction front() {\n  const p = this.parent()\n\n  // Move node forward\n  p.add(this.remove())\n\n  return this\n}\n\n// Send given element all the way to the back\nfunction back() {\n  const p = this.parent()\n\n  // Move node back\n  p.add(this.remove(), 0)\n\n  return this\n}\n\n// Inserts a given element before the targeted element\nfunction before(element) {\n  element = adopter_makeInstance(element)\n  element.remove()\n\n  const i = this.position()\n\n  this.parent().add(element, i)\n\n  return this\n}\n\n// Inserts a given element after the targeted element\nfunction after(element) {\n  element = adopter_makeInstance(element)\n  element.remove()\n\n  const i = this.position()\n\n  this.parent().add(element, i + 1)\n\n  return this\n}\n\nfunction insertBefore(element) {\n  element = adopter_makeInstance(element)\n  element.before(this)\n  return this\n}\n\nfunction insertAfter(element) {\n  element = adopter_makeInstance(element)\n  element.after(this)\n  return this\n}\n\nregisterMethods('Dom', {\n  siblings,\n  position,\n  next,\n  prev,\n  forward,\n  backward,\n  front,\n  back,\n  before,\n  after,\n  insertBefore,\n  insertAfter\n})\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/regex.js\n// Parse unit value\nconst numberAndUnit =\n  /^([+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?)([a-z%]*)$/i\n\n// Parse hex value\nconst hex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i\n\n// Parse rgb value\nconst rgb = /rgb\\((\\d+),(\\d+),(\\d+)\\)/\n\n// Parse reference id\nconst reference = /(#[a-z_][a-z0-9\\-_]*)/i\n\n// splits a transformation chain\nconst transforms = /\\)\\s*,?\\s*/\n\n// Whitespace\nconst whitespace = /\\s/g\n\n// Test hex value\nconst isHex = /^#[a-f0-9]{3}$|^#[a-f0-9]{6}$/i\n\n// Test rgb value\nconst isRgb = /^rgb\\(/\n\n// Test for blank string\nconst isBlank = /^(\\s+)?$/\n\n// Test for numeric string\nconst isNumber = /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i\n\n// Test for image url\nconst isImage = /\\.(jpg|jpeg|png|gif|svg)(\\?[^=]+.*)?/i\n\n// split at whitespace and comma\nconst delimiter = /[\\s,]+/\n\n// Test for path letter\nconst isPathLetter = /[MLHVCSQTAZ]/i\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/optional/class.js\n\n\n\n// Return array of classes on the node\nfunction classes() {\n  const attr = this.attr('class')\n  return attr == null ? [] : attr.trim().split(delimiter)\n}\n\n// Return true if class exists on the node, false otherwise\nfunction hasClass(name) {\n  return this.classes().indexOf(name) !== -1\n}\n\n// Add class to the node\nfunction addClass(name) {\n  if (!this.hasClass(name)) {\n    const array = this.classes()\n    array.push(name)\n    this.attr('class', array.join(' '))\n  }\n\n  return this\n}\n\n// Remove class from the node\nfunction removeClass(name) {\n  if (this.hasClass(name)) {\n    this.attr(\n      'class',\n      this.classes()\n        .filter(function (c) {\n          return c !== name\n        })\n        .join(' ')\n    )\n  }\n\n  return this\n}\n\n// Toggle the presence of a class on the node\nfunction toggleClass(name) {\n  return this.hasClass(name) ? this.removeClass(name) : this.addClass(name)\n}\n\nregisterMethods('Dom', {\n  classes,\n  hasClass,\n  addClass,\n  removeClass,\n  toggleClass\n})\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/optional/css.js\n\n\n\n// Dynamic style generator\nfunction css(style, val) {\n  const ret = {}\n  if (arguments.length === 0) {\n    // get full style as object\n    this.node.style.cssText\n      .split(/\\s*;\\s*/)\n      .filter(function (el) {\n        return !!el.length\n      })\n      .forEach(function (el) {\n        const t = el.split(/\\s*:\\s*/)\n        ret[t[0]] = t[1]\n      })\n    return ret\n  }\n\n  if (arguments.length < 2) {\n    // get style properties as array\n    if (Array.isArray(style)) {\n      for (const name of style) {\n        const cased = name\n        ret[name] = this.node.style.getPropertyValue(cased)\n      }\n      return ret\n    }\n\n    // get style for property\n    if (typeof style === 'string') {\n      return this.node.style.getPropertyValue(style)\n    }\n\n    // set styles in object\n    if (typeof style === 'object') {\n      for (const name in style) {\n        // set empty string if null/undefined/'' was given\n        this.node.style.setProperty(\n          name,\n          style[name] == null || isBlank.test(style[name]) ? '' : style[name]\n        )\n      }\n    }\n  }\n\n  // set style for property\n  if (arguments.length === 2) {\n    this.node.style.setProperty(\n      style,\n      val == null || isBlank.test(val) ? '' : val\n    )\n  }\n\n  return this\n}\n\n// Show element\nfunction show() {\n  return this.css('display', '')\n}\n\n// Hide element\nfunction hide() {\n  return this.css('display', 'none')\n}\n\n// Is element visible?\nfunction visible() {\n  return this.css('display') !== 'none'\n}\n\nregisterMethods('Dom', {\n  css,\n  show,\n  hide,\n  visible\n})\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/optional/data.js\n\n\n\n// Store data values on svg nodes\nfunction data(a, v, r) {\n  if (a == null) {\n    // get an object of attributes\n    return this.data(\n      map(\n        filter(\n          this.node.attributes,\n          (el) => el.nodeName.indexOf('data-') === 0\n        ),\n        (el) => el.nodeName.slice(5)\n      )\n    )\n  } else if (a instanceof Array) {\n    const data = {}\n    for (const key of a) {\n      data[key] = this.data(key)\n    }\n    return data\n  } else if (typeof a === 'object') {\n    for (v in a) {\n      this.data(v, a[v])\n    }\n  } else if (arguments.length < 2) {\n    try {\n      return JSON.parse(this.attr('data-' + a))\n    } catch (e) {\n      return this.attr('data-' + a)\n    }\n  } else {\n    this.attr(\n      'data-' + a,\n      v === null\n        ? null\n        : r === true || typeof v === 'string' || typeof v === 'number'\n          ? v\n          : JSON.stringify(v)\n    )\n  }\n\n  return this\n}\n\nregisterMethods('Dom', { data })\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/optional/memory.js\n\n\n// Remember arbitrary data\nfunction remember(k, v) {\n  // remember every item in an object individually\n  if (typeof arguments[0] === 'object') {\n    for (const key in k) {\n      this.remember(key, k[key])\n    }\n  } else if (arguments.length === 1) {\n    // retrieve memory\n    return this.memory()[k]\n  } else {\n    // store memory\n    this.memory()[k] = v\n  }\n\n  return this\n}\n\n// Erase a given memory\nfunction forget() {\n  if (arguments.length === 0) {\n    this._memory = {}\n  } else {\n    for (let i = arguments.length - 1; i >= 0; i--) {\n      delete this.memory()[arguments[i]]\n    }\n  }\n  return this\n}\n\n// This triggers creation of a new hidden class which is not performant\n// However, this function is not rarely used so it will not happen frequently\n// Return local memory object\nfunction memory() {\n  return (this._memory = this._memory || {})\n}\n\nregisterMethods('Dom', { remember, forget, memory })\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/Color.js\n\n\nfunction sixDigitHex(hex) {\n  return hex.length === 4\n    ? [\n        '#',\n        hex.substring(1, 2),\n        hex.substring(1, 2),\n        hex.substring(2, 3),\n        hex.substring(2, 3),\n        hex.substring(3, 4),\n        hex.substring(3, 4)\n      ].join('')\n    : hex\n}\n\nfunction componentHex(component) {\n  const integer = Math.round(component)\n  const bounded = Math.max(0, Math.min(255, integer))\n  const hex = bounded.toString(16)\n  return hex.length === 1 ? '0' + hex : hex\n}\n\nfunction is(object, space) {\n  for (let i = space.length; i--; ) {\n    if (object[space[i]] == null) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getParameters(a, b) {\n  const params = is(a, 'rgb')\n    ? { _a: a.r, _b: a.g, _c: a.b, _d: 0, space: 'rgb' }\n    : is(a, 'xyz')\n      ? { _a: a.x, _b: a.y, _c: a.z, _d: 0, space: 'xyz' }\n      : is(a, 'hsl')\n        ? { _a: a.h, _b: a.s, _c: a.l, _d: 0, space: 'hsl' }\n        : is(a, 'lab')\n          ? { _a: a.l, _b: a.a, _c: a.b, _d: 0, space: 'lab' }\n          : is(a, 'lch')\n            ? { _a: a.l, _b: a.c, _c: a.h, _d: 0, space: 'lch' }\n            : is(a, 'cmyk')\n              ? { _a: a.c, _b: a.m, _c: a.y, _d: a.k, space: 'cmyk' }\n              : { _a: 0, _b: 0, _c: 0, space: 'rgb' }\n\n  params.space = b || params.space\n  return params\n}\n\nfunction cieSpace(space) {\n  if (space === 'lab' || space === 'xyz' || space === 'lch') {\n    return true\n  } else {\n    return false\n  }\n}\n\nfunction hueToRgb(p, q, t) {\n  if (t < 0) t += 1\n  if (t > 1) t -= 1\n  if (t < 1 / 6) return p + (q - p) * 6 * t\n  if (t < 1 / 2) return q\n  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6\n  return p\n}\n\nclass Color {\n  constructor(...inputs) {\n    this.init(...inputs)\n  }\n\n  // Test if given value is a color\n  static isColor(color) {\n    return (\n      color && (color instanceof Color || this.isRgb(color) || this.test(color))\n    )\n  }\n\n  // Test if given value is an rgb object\n  static isRgb(color) {\n    return (\n      color &&\n      typeof color.r === 'number' &&\n      typeof color.g === 'number' &&\n      typeof color.b === 'number'\n    )\n  }\n\n  /*\n  Generating random colors\n  */\n  static random(mode = 'vibrant', t) {\n    // Get the math modules\n    const { random, round, sin, PI: pi } = Math\n\n    // Run the correct generator\n    if (mode === 'vibrant') {\n      const l = (81 - 57) * random() + 57\n      const c = (83 - 45) * random() + 45\n      const h = 360 * random()\n      const color = new Color(l, c, h, 'lch')\n      return color\n    } else if (mode === 'sine') {\n      t = t == null ? random() : t\n      const r = round(80 * sin((2 * pi * t) / 0.5 + 0.01) + 150)\n      const g = round(50 * sin((2 * pi * t) / 0.5 + 4.6) + 200)\n      const b = round(100 * sin((2 * pi * t) / 0.5 + 2.3) + 150)\n      const color = new Color(r, g, b)\n      return color\n    } else if (mode === 'pastel') {\n      const l = (94 - 86) * random() + 86\n      const c = (26 - 9) * random() + 9\n      const h = 360 * random()\n      const color = new Color(l, c, h, 'lch')\n      return color\n    } else if (mode === 'dark') {\n      const l = 10 + 10 * random()\n      const c = (125 - 75) * random() + 86\n      const h = 360 * random()\n      const color = new Color(l, c, h, 'lch')\n      return color\n    } else if (mode === 'rgb') {\n      const r = 255 * random()\n      const g = 255 * random()\n      const b = 255 * random()\n      const color = new Color(r, g, b)\n      return color\n    } else if (mode === 'lab') {\n      const l = 100 * random()\n      const a = 256 * random() - 128\n      const b = 256 * random() - 128\n      const color = new Color(l, a, b, 'lab')\n      return color\n    } else if (mode === 'grey') {\n      const grey = 255 * random()\n      const color = new Color(grey, grey, grey)\n      return color\n    } else {\n      throw new Error('Unsupported random color mode')\n    }\n  }\n\n  // Test if given value is a color string\n  static test(color) {\n    return typeof color === 'string' && (isHex.test(color) || isRgb.test(color))\n  }\n\n  cmyk() {\n    // Get the rgb values for the current color\n    const { _a, _b, _c } = this.rgb()\n    const [r, g, b] = [_a, _b, _c].map((v) => v / 255)\n\n    // Get the cmyk values in an unbounded format\n    const k = Math.min(1 - r, 1 - g, 1 - b)\n\n    if (k === 1) {\n      // Catch the black case\n      return new Color(0, 0, 0, 1, 'cmyk')\n    }\n\n    const c = (1 - r - k) / (1 - k)\n    const m = (1 - g - k) / (1 - k)\n    const y = (1 - b - k) / (1 - k)\n\n    // Construct the new color\n    const color = new Color(c, m, y, k, 'cmyk')\n    return color\n  }\n\n  hsl() {\n    // Get the rgb values\n    const { _a, _b, _c } = this.rgb()\n    const [r, g, b] = [_a, _b, _c].map((v) => v / 255)\n\n    // Find the maximum and minimum values to get the lightness\n    const max = Math.max(r, g, b)\n    const min = Math.min(r, g, b)\n    const l = (max + min) / 2\n\n    // If the r, g, v values are identical then we are grey\n    const isGrey = max === min\n\n    // Calculate the hue and saturation\n    const delta = max - min\n    const s = isGrey\n      ? 0\n      : l > 0.5\n        ? delta / (2 - max - min)\n        : delta / (max + min)\n    const h = isGrey\n      ? 0\n      : max === r\n        ? ((g - b) / delta + (g < b ? 6 : 0)) / 6\n        : max === g\n          ? ((b - r) / delta + 2) / 6\n          : max === b\n            ? ((r - g) / delta + 4) / 6\n            : 0\n\n    // Construct and return the new color\n    const color = new Color(360 * h, 100 * s, 100 * l, 'hsl')\n    return color\n  }\n\n  init(a = 0, b = 0, c = 0, d = 0, space = 'rgb') {\n    // This catches the case when a falsy value is passed like ''\n    a = !a ? 0 : a\n\n    // Reset all values in case the init function is rerun with new color space\n    if (this.space) {\n      for (const component in this.space) {\n        delete this[this.space[component]]\n      }\n    }\n\n    if (typeof a === 'number') {\n      // Allow for the case that we don't need d...\n      space = typeof d === 'string' ? d : space\n      d = typeof d === 'string' ? 0 : d\n\n      // Assign the values straight to the color\n      Object.assign(this, { _a: a, _b: b, _c: c, _d: d, space })\n      // If the user gave us an array, make the color from it\n    } else if (a instanceof Array) {\n      this.space = b || (typeof a[3] === 'string' ? a[3] : a[4]) || 'rgb'\n      Object.assign(this, { _a: a[0], _b: a[1], _c: a[2], _d: a[3] || 0 })\n    } else if (a instanceof Object) {\n      // Set the object up and assign its values directly\n      const values = getParameters(a, b)\n      Object.assign(this, values)\n    } else if (typeof a === 'string') {\n      if (isRgb.test(a)) {\n        const noWhitespace = a.replace(whitespace, '')\n        const [_a, _b, _c] = rgb\n          .exec(noWhitespace)\n          .slice(1, 4)\n          .map((v) => parseInt(v))\n        Object.assign(this, { _a, _b, _c, _d: 0, space: 'rgb' })\n      } else if (isHex.test(a)) {\n        const hexParse = (v) => parseInt(v, 16)\n        const [, _a, _b, _c] = hex.exec(sixDigitHex(a)).map(hexParse)\n        Object.assign(this, { _a, _b, _c, _d: 0, space: 'rgb' })\n      } else throw Error(\"Unsupported string format, can't construct Color\")\n    }\n\n    // Now add the components as a convenience\n    const { _a, _b, _c, _d } = this\n    const components =\n      this.space === 'rgb'\n        ? { r: _a, g: _b, b: _c }\n        : this.space === 'xyz'\n          ? { x: _a, y: _b, z: _c }\n          : this.space === 'hsl'\n            ? { h: _a, s: _b, l: _c }\n            : this.space === 'lab'\n              ? { l: _a, a: _b, b: _c }\n              : this.space === 'lch'\n                ? { l: _a, c: _b, h: _c }\n                : this.space === 'cmyk'\n                  ? { c: _a, m: _b, y: _c, k: _d }\n                  : {}\n    Object.assign(this, components)\n  }\n\n  lab() {\n    // Get the xyz color\n    const { x, y, z } = this.xyz()\n\n    // Get the lab components\n    const l = 116 * y - 16\n    const a = 500 * (x - y)\n    const b = 200 * (y - z)\n\n    // Construct and return a new color\n    const color = new Color(l, a, b, 'lab')\n    return color\n  }\n\n  lch() {\n    // Get the lab color directly\n    const { l, a, b } = this.lab()\n\n    // Get the chromaticity and the hue using polar coordinates\n    const c = Math.sqrt(a ** 2 + b ** 2)\n    let h = (180 * Math.atan2(b, a)) / Math.PI\n    if (h < 0) {\n      h *= -1\n      h = 360 - h\n    }\n\n    // Make a new color and return it\n    const color = new Color(l, c, h, 'lch')\n    return color\n  }\n  /*\n  Conversion Methods\n  */\n\n  rgb() {\n    if (this.space === 'rgb') {\n      return this\n    } else if (cieSpace(this.space)) {\n      // Convert to the xyz color space\n      let { x, y, z } = this\n      if (this.space === 'lab' || this.space === 'lch') {\n        // Get the values in the lab space\n        let { l, a, b } = this\n        if (this.space === 'lch') {\n          const { c, h } = this\n          const dToR = Math.PI / 180\n          a = c * Math.cos(dToR * h)\n          b = c * Math.sin(dToR * h)\n        }\n\n        // Undo the nonlinear function\n        const yL = (l + 16) / 116\n        const xL = a / 500 + yL\n        const zL = yL - b / 200\n\n        // Get the xyz values\n        const ct = 16 / 116\n        const mx = 0.008856\n        const nm = 7.787\n        x = 0.95047 * (xL ** 3 > mx ? xL ** 3 : (xL - ct) / nm)\n        y = 1.0 * (yL ** 3 > mx ? yL ** 3 : (yL - ct) / nm)\n        z = 1.08883 * (zL ** 3 > mx ? zL ** 3 : (zL - ct) / nm)\n      }\n\n      // Convert xyz to unbounded rgb values\n      const rU = x * 3.2406 + y * -1.5372 + z * -0.4986\n      const gU = x * -0.9689 + y * 1.8758 + z * 0.0415\n      const bU = x * 0.0557 + y * -0.204 + z * 1.057\n\n      // Convert the values to true rgb values\n      const pow = Math.pow\n      const bd = 0.0031308\n      const r = rU > bd ? 1.055 * pow(rU, 1 / 2.4) - 0.055 : 12.92 * rU\n      const g = gU > bd ? 1.055 * pow(gU, 1 / 2.4) - 0.055 : 12.92 * gU\n      const b = bU > bd ? 1.055 * pow(bU, 1 / 2.4) - 0.055 : 12.92 * bU\n\n      // Make and return the color\n      const color = new Color(255 * r, 255 * g, 255 * b)\n      return color\n    } else if (this.space === 'hsl') {\n      // https://bgrins.github.io/TinyColor/docs/tinycolor.html\n      // Get the current hsl values\n      let { h, s, l } = this\n      h /= 360\n      s /= 100\n      l /= 100\n\n      // If we are grey, then just make the color directly\n      if (s === 0) {\n        l *= 255\n        const color = new Color(l, l, l)\n        return color\n      }\n\n      // TODO I have no idea what this does :D If you figure it out, tell me!\n      const q = l < 0.5 ? l * (1 + s) : l + s - l * s\n      const p = 2 * l - q\n\n      // Get the rgb values\n      const r = 255 * hueToRgb(p, q, h + 1 / 3)\n      const g = 255 * hueToRgb(p, q, h)\n      const b = 255 * hueToRgb(p, q, h - 1 / 3)\n\n      // Make a new color\n      const color = new Color(r, g, b)\n      return color\n    } else if (this.space === 'cmyk') {\n      // https://gist.github.com/felipesabino/5066336\n      // Get the normalised cmyk values\n      const { c, m, y, k } = this\n\n      // Get the rgb values\n      const r = 255 * (1 - Math.min(1, c * (1 - k) + k))\n      const g = 255 * (1 - Math.min(1, m * (1 - k) + k))\n      const b = 255 * (1 - Math.min(1, y * (1 - k) + k))\n\n      // Form the color and return it\n      const color = new Color(r, g, b)\n      return color\n    } else {\n      return this\n    }\n  }\n\n  toArray() {\n    const { _a, _b, _c, _d, space } = this\n    return [_a, _b, _c, _d, space]\n  }\n\n  toHex() {\n    const [r, g, b] = this._clamped().map(componentHex)\n    return `#${r}${g}${b}`\n  }\n\n  toRgb() {\n    const [rV, gV, bV] = this._clamped()\n    const string = `rgb(${rV},${gV},${bV})`\n    return string\n  }\n\n  toString() {\n    return this.toHex()\n  }\n\n  xyz() {\n    // Normalise the red, green and blue values\n    const { _a: r255, _b: g255, _c: b255 } = this.rgb()\n    const [r, g, b] = [r255, g255, b255].map((v) => v / 255)\n\n    // Convert to the lab rgb space\n    const rL = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92\n    const gL = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92\n    const bL = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92\n\n    // Convert to the xyz color space without bounding the values\n    const xU = (rL * 0.4124 + gL * 0.3576 + bL * 0.1805) / 0.95047\n    const yU = (rL * 0.2126 + gL * 0.7152 + bL * 0.0722) / 1.0\n    const zU = (rL * 0.0193 + gL * 0.1192 + bL * 0.9505) / 1.08883\n\n    // Get the proper xyz values by applying the bounding\n    const x = xU > 0.008856 ? Math.pow(xU, 1 / 3) : 7.787 * xU + 16 / 116\n    const y = yU > 0.008856 ? Math.pow(yU, 1 / 3) : 7.787 * yU + 16 / 116\n    const z = zU > 0.008856 ? Math.pow(zU, 1 / 3) : 7.787 * zU + 16 / 116\n\n    // Make and return the color\n    const color = new Color(x, y, z, 'xyz')\n    return color\n  }\n\n  /*\n  Input and Output methods\n  */\n\n  _clamped() {\n    const { _a, _b, _c } = this.rgb()\n    const { max, min, round } = Math\n    const format = (v) => max(0, min(round(v), 255))\n    return [_a, _b, _c].map(format)\n  }\n\n  /*\n  Constructing colors\n  */\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/Point.js\n\n\nclass Point {\n  // Initialize\n  constructor(...args) {\n    this.init(...args)\n  }\n\n  // Clone point\n  clone() {\n    return new Point(this)\n  }\n\n  init(x, y) {\n    const base = { x: 0, y: 0 }\n\n    // ensure source as object\n    const source = Array.isArray(x)\n      ? { x: x[0], y: x[1] }\n      : typeof x === 'object'\n        ? { x: x.x, y: x.y }\n        : { x: x, y: y }\n\n    // merge source\n    this.x = source.x == null ? base.x : source.x\n    this.y = source.y == null ? base.y : source.y\n\n    return this\n  }\n\n  toArray() {\n    return [this.x, this.y]\n  }\n\n  transform(m) {\n    return this.clone().transformO(m)\n  }\n\n  // Transform point with matrix\n  transformO(m) {\n    if (!Matrix.isMatrixLike(m)) {\n      m = new Matrix(m)\n    }\n\n    const { x, y } = this\n\n    // Perform the matrix multiplication\n    this.x = m.a * x + m.c * y + m.e\n    this.y = m.b * x + m.d * y + m.f\n\n    return this\n  }\n}\n\nfunction point(x, y) {\n  return new Point(x, y).transformO(this.screenCTM().inverseO())\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/Matrix.js\n\n\n\n\n\n\nfunction closeEnough(a, b, threshold) {\n  return Math.abs(b - a) < (threshold || 1e-6)\n}\n\nclass Matrix {\n  constructor(...args) {\n    this.init(...args)\n  }\n\n  static formatTransforms(o) {\n    // Get all of the parameters required to form the matrix\n    const flipBoth = o.flip === 'both' || o.flip === true\n    const flipX = o.flip && (flipBoth || o.flip === 'x') ? -1 : 1\n    const flipY = o.flip && (flipBoth || o.flip === 'y') ? -1 : 1\n    const skewX =\n      o.skew && o.skew.length\n        ? o.skew[0]\n        : isFinite(o.skew)\n          ? o.skew\n          : isFinite(o.skewX)\n            ? o.skewX\n            : 0\n    const skewY =\n      o.skew && o.skew.length\n        ? o.skew[1]\n        : isFinite(o.skew)\n          ? o.skew\n          : isFinite(o.skewY)\n            ? o.skewY\n            : 0\n    const scaleX =\n      o.scale && o.scale.length\n        ? o.scale[0] * flipX\n        : isFinite(o.scale)\n          ? o.scale * flipX\n          : isFinite(o.scaleX)\n            ? o.scaleX * flipX\n            : flipX\n    const scaleY =\n      o.scale && o.scale.length\n        ? o.scale[1] * flipY\n        : isFinite(o.scale)\n          ? o.scale * flipY\n          : isFinite(o.scaleY)\n            ? o.scaleY * flipY\n            : flipY\n    const shear = o.shear || 0\n    const theta = o.rotate || o.theta || 0\n    const origin = new Point(\n      o.origin || o.around || o.ox || o.originX,\n      o.oy || o.originY\n    )\n    const ox = origin.x\n    const oy = origin.y\n    // We need Point to be invalid if nothing was passed because we cannot default to 0 here. That is why NaN\n    const position = new Point(\n      o.position || o.px || o.positionX || NaN,\n      o.py || o.positionY || NaN\n    )\n    const px = position.x\n    const py = position.y\n    const translate = new Point(\n      o.translate || o.tx || o.translateX,\n      o.ty || o.translateY\n    )\n    const tx = translate.x\n    const ty = translate.y\n    const relative = new Point(\n      o.relative || o.rx || o.relativeX,\n      o.ry || o.relativeY\n    )\n    const rx = relative.x\n    const ry = relative.y\n\n    // Populate all of the values\n    return {\n      scaleX,\n      scaleY,\n      skewX,\n      skewY,\n      shear,\n      theta,\n      rx,\n      ry,\n      tx,\n      ty,\n      ox,\n      oy,\n      px,\n      py\n    }\n  }\n\n  static fromArray(a) {\n    return { a: a[0], b: a[1], c: a[2], d: a[3], e: a[4], f: a[5] }\n  }\n\n  static isMatrixLike(o) {\n    return (\n      o.a != null ||\n      o.b != null ||\n      o.c != null ||\n      o.d != null ||\n      o.e != null ||\n      o.f != null\n    )\n  }\n\n  // left matrix, right matrix, target matrix which is overwritten\n  static matrixMultiply(l, r, o) {\n    // Work out the product directly\n    const a = l.a * r.a + l.c * r.b\n    const b = l.b * r.a + l.d * r.b\n    const c = l.a * r.c + l.c * r.d\n    const d = l.b * r.c + l.d * r.d\n    const e = l.e + l.a * r.e + l.c * r.f\n    const f = l.f + l.b * r.e + l.d * r.f\n\n    // make sure to use local variables because l/r and o could be the same\n    o.a = a\n    o.b = b\n    o.c = c\n    o.d = d\n    o.e = e\n    o.f = f\n\n    return o\n  }\n\n  around(cx, cy, matrix) {\n    return this.clone().aroundO(cx, cy, matrix)\n  }\n\n  // Transform around a center point\n  aroundO(cx, cy, matrix) {\n    const dx = cx || 0\n    const dy = cy || 0\n    return this.translateO(-dx, -dy).lmultiplyO(matrix).translateO(dx, dy)\n  }\n\n  // Clones this matrix\n  clone() {\n    return new Matrix(this)\n  }\n\n  // Decomposes this matrix into its affine parameters\n  decompose(cx = 0, cy = 0) {\n    // Get the parameters from the matrix\n    const a = this.a\n    const b = this.b\n    const c = this.c\n    const d = this.d\n    const e = this.e\n    const f = this.f\n\n    // Figure out if the winding direction is clockwise or counterclockwise\n    const determinant = a * d - b * c\n    const ccw = determinant > 0 ? 1 : -1\n\n    // Since we only shear in x, we can use the x basis to get the x scale\n    // and the rotation of the resulting matrix\n    const sx = ccw * Math.sqrt(a * a + b * b)\n    const thetaRad = Math.atan2(ccw * b, ccw * a)\n    const theta = (180 / Math.PI) * thetaRad\n    const ct = Math.cos(thetaRad)\n    const st = Math.sin(thetaRad)\n\n    // We can then solve the y basis vector simultaneously to get the other\n    // two affine parameters directly from these parameters\n    const lam = (a * c + b * d) / determinant\n    const sy = (c * sx) / (lam * a - b) || (d * sx) / (lam * b + a)\n\n    // Use the translations\n    const tx = e - cx + cx * ct * sx + cy * (lam * ct * sx - st * sy)\n    const ty = f - cy + cx * st * sx + cy * (lam * st * sx + ct * sy)\n\n    // Construct the decomposition and return it\n    return {\n      // Return the affine parameters\n      scaleX: sx,\n      scaleY: sy,\n      shear: lam,\n      rotate: theta,\n      translateX: tx,\n      translateY: ty,\n      originX: cx,\n      originY: cy,\n\n      // Return the matrix parameters\n      a: this.a,\n      b: this.b,\n      c: this.c,\n      d: this.d,\n      e: this.e,\n      f: this.f\n    }\n  }\n\n  // Check if two matrices are equal\n  equals(other) {\n    if (other === this) return true\n    const comp = new Matrix(other)\n    return (\n      closeEnough(this.a, comp.a) &&\n      closeEnough(this.b, comp.b) &&\n      closeEnough(this.c, comp.c) &&\n      closeEnough(this.d, comp.d) &&\n      closeEnough(this.e, comp.e) &&\n      closeEnough(this.f, comp.f)\n    )\n  }\n\n  // Flip matrix on x or y, at a given offset\n  flip(axis, around) {\n    return this.clone().flipO(axis, around)\n  }\n\n  flipO(axis, around) {\n    return axis === 'x'\n      ? this.scaleO(-1, 1, around, 0)\n      : axis === 'y'\n        ? this.scaleO(1, -1, 0, around)\n        : this.scaleO(-1, -1, axis, around || axis) // Define an x, y flip point\n  }\n\n  // Initialize\n  init(source) {\n    const base = Matrix.fromArray([1, 0, 0, 1, 0, 0])\n\n    // ensure source as object\n    source =\n      source instanceof Element\n        ? source.matrixify()\n        : typeof source === 'string'\n          ? Matrix.fromArray(source.split(delimiter).map(parseFloat))\n          : Array.isArray(source)\n            ? Matrix.fromArray(source)\n            : typeof source === 'object' && Matrix.isMatrixLike(source)\n              ? source\n              : typeof source === 'object'\n                ? new Matrix().transform(source)\n                : arguments.length === 6\n                  ? Matrix.fromArray([].slice.call(arguments))\n                  : base\n\n    // Merge the source matrix with the base matrix\n    this.a = source.a != null ? source.a : base.a\n    this.b = source.b != null ? source.b : base.b\n    this.c = source.c != null ? source.c : base.c\n    this.d = source.d != null ? source.d : base.d\n    this.e = source.e != null ? source.e : base.e\n    this.f = source.f != null ? source.f : base.f\n\n    return this\n  }\n\n  inverse() {\n    return this.clone().inverseO()\n  }\n\n  // Inverses matrix\n  inverseO() {\n    // Get the current parameters out of the matrix\n    const a = this.a\n    const b = this.b\n    const c = this.c\n    const d = this.d\n    const e = this.e\n    const f = this.f\n\n    // Invert the 2x2 matrix in the top left\n    const det = a * d - b * c\n    if (!det) throw new Error('Cannot invert ' + this)\n\n    // Calculate the top 2x2 matrix\n    const na = d / det\n    const nb = -b / det\n    const nc = -c / det\n    const nd = a / det\n\n    // Apply the inverted matrix to the top right\n    const ne = -(na * e + nc * f)\n    const nf = -(nb * e + nd * f)\n\n    // Construct the inverted matrix\n    this.a = na\n    this.b = nb\n    this.c = nc\n    this.d = nd\n    this.e = ne\n    this.f = nf\n\n    return this\n  }\n\n  lmultiply(matrix) {\n    return this.clone().lmultiplyO(matrix)\n  }\n\n  lmultiplyO(matrix) {\n    const r = this\n    const l = matrix instanceof Matrix ? matrix : new Matrix(matrix)\n\n    return Matrix.matrixMultiply(l, r, this)\n  }\n\n  // Left multiplies by the given matrix\n  multiply(matrix) {\n    return this.clone().multiplyO(matrix)\n  }\n\n  multiplyO(matrix) {\n    // Get the matrices\n    const l = this\n    const r = matrix instanceof Matrix ? matrix : new Matrix(matrix)\n\n    return Matrix.matrixMultiply(l, r, this)\n  }\n\n  // Rotate matrix\n  rotate(r, cx, cy) {\n    return this.clone().rotateO(r, cx, cy)\n  }\n\n  rotateO(r, cx = 0, cy = 0) {\n    // Convert degrees to radians\n    r = radians(r)\n\n    const cos = Math.cos(r)\n    const sin = Math.sin(r)\n\n    const { a, b, c, d, e, f } = this\n\n    this.a = a * cos - b * sin\n    this.b = b * cos + a * sin\n    this.c = c * cos - d * sin\n    this.d = d * cos + c * sin\n    this.e = e * cos - f * sin + cy * sin - cx * cos + cx\n    this.f = f * cos + e * sin - cx * sin - cy * cos + cy\n\n    return this\n  }\n\n  // Scale matrix\n  scale() {\n    return this.clone().scaleO(...arguments)\n  }\n\n  scaleO(x, y = x, cx = 0, cy = 0) {\n    // Support uniform scaling\n    if (arguments.length === 3) {\n      cy = cx\n      cx = y\n      y = x\n    }\n\n    const { a, b, c, d, e, f } = this\n\n    this.a = a * x\n    this.b = b * y\n    this.c = c * x\n    this.d = d * y\n    this.e = e * x - cx * x + cx\n    this.f = f * y - cy * y + cy\n\n    return this\n  }\n\n  // Shear matrix\n  shear(a, cx, cy) {\n    return this.clone().shearO(a, cx, cy)\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  shearO(lx, cx = 0, cy = 0) {\n    const { a, b, c, d, e, f } = this\n\n    this.a = a + b * lx\n    this.c = c + d * lx\n    this.e = e + f * lx - cy * lx\n\n    return this\n  }\n\n  // Skew Matrix\n  skew() {\n    return this.clone().skewO(...arguments)\n  }\n\n  skewO(x, y = x, cx = 0, cy = 0) {\n    // support uniformal skew\n    if (arguments.length === 3) {\n      cy = cx\n      cx = y\n      y = x\n    }\n\n    // Convert degrees to radians\n    x = radians(x)\n    y = radians(y)\n\n    const lx = Math.tan(x)\n    const ly = Math.tan(y)\n\n    const { a, b, c, d, e, f } = this\n\n    this.a = a + b * lx\n    this.b = b + a * ly\n    this.c = c + d * lx\n    this.d = d + c * ly\n    this.e = e + f * lx - cy * lx\n    this.f = f + e * ly - cx * ly\n\n    return this\n  }\n\n  // SkewX\n  skewX(x, cx, cy) {\n    return this.skew(x, 0, cx, cy)\n  }\n\n  // SkewY\n  skewY(y, cx, cy) {\n    return this.skew(0, y, cx, cy)\n  }\n\n  toArray() {\n    return [this.a, this.b, this.c, this.d, this.e, this.f]\n  }\n\n  // Convert matrix to string\n  toString() {\n    return (\n      'matrix(' +\n      this.a +\n      ',' +\n      this.b +\n      ',' +\n      this.c +\n      ',' +\n      this.d +\n      ',' +\n      this.e +\n      ',' +\n      this.f +\n      ')'\n    )\n  }\n\n  // Transform a matrix into another matrix by manipulating the space\n  transform(o) {\n    // Check if o is a matrix and then left multiply it directly\n    if (Matrix.isMatrixLike(o)) {\n      const matrix = new Matrix(o)\n      return matrix.multiplyO(this)\n    }\n\n    // Get the proposed transformations and the current transformations\n    const t = Matrix.formatTransforms(o)\n    const current = this\n    const { x: ox, y: oy } = new Point(t.ox, t.oy).transform(current)\n\n    // Construct the resulting matrix\n    const transformer = new Matrix()\n      .translateO(t.rx, t.ry)\n      .lmultiplyO(current)\n      .translateO(-ox, -oy)\n      .scaleO(t.scaleX, t.scaleY)\n      .skewO(t.skewX, t.skewY)\n      .shearO(t.shear)\n      .rotateO(t.theta)\n      .translateO(ox, oy)\n\n    // If we want the origin at a particular place, we force it there\n    if (isFinite(t.px) || isFinite(t.py)) {\n      const origin = new Point(ox, oy).transform(transformer)\n      // TODO: Replace t.px with isFinite(t.px)\n      // Doesn't work because t.px is also 0 if it wasn't passed\n      const dx = isFinite(t.px) ? t.px - origin.x : 0\n      const dy = isFinite(t.py) ? t.py - origin.y : 0\n      transformer.translateO(dx, dy)\n    }\n\n    // Translate now after positioning\n    transformer.translateO(t.tx, t.ty)\n    return transformer\n  }\n\n  // Translate matrix\n  translate(x, y) {\n    return this.clone().translateO(x, y)\n  }\n\n  translateO(x, y) {\n    this.e += x || 0\n    this.f += y || 0\n    return this\n  }\n\n  valueOf() {\n    return {\n      a: this.a,\n      b: this.b,\n      c: this.c,\n      d: this.d,\n      e: this.e,\n      f: this.f\n    }\n  }\n}\n\nfunction ctm() {\n  return new Matrix(this.node.getCTM())\n}\n\nfunction screenCTM() {\n  try {\n    /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537\n       This is needed because FF does not return the transformation matrix\n       for the inner coordinate system when getScreenCTM() is called on nested svgs.\n       However all other Browsers do that */\n    if (typeof this.isRoot === 'function' && !this.isRoot()) {\n      const rect = this.rect(1, 1)\n      const m = rect.node.getScreenCTM()\n      rect.remove()\n      return new Matrix(m)\n    }\n    return new Matrix(this.node.getScreenCTM())\n  } catch (e) {\n    console.warn(\n      `Cannot get CTM from SVG node ${this.node.nodeName}. Is the element rendered?`\n    )\n    return new Matrix()\n  }\n}\n\nregister(Matrix, 'Matrix')\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/parser.js\n\n\n\nfunction parser() {\n  // Reuse cached element if possible\n  if (!parser.nodes) {\n    const svg = adopter_makeInstance().size(2, 0)\n    svg.node.style.cssText = [\n      'opacity: 0',\n      'position: absolute',\n      'left: -100%',\n      'top: -100%',\n      'overflow: hidden'\n    ].join(';')\n\n    svg.attr('focusable', 'false')\n    svg.attr('aria-hidden', 'true')\n\n    const path = svg.path().node\n\n    parser.nodes = { svg, path }\n  }\n\n  if (!parser.nodes.svg.node.parentNode) {\n    const b = globals.document.body || globals.document.documentElement\n    parser.nodes.svg.addTo(b)\n  }\n\n  return parser.nodes\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/Box.js\n\n\n\n\n\n\n\n\nfunction isNulledBox(box) {\n  return !box.width && !box.height && !box.x && !box.y\n}\n\nfunction domContains(node) {\n  return (\n    node === globals.document ||\n    (\n      globals.document.documentElement.contains ||\n      function (node) {\n        // This is IE - it does not support contains() for top-level SVGs\n        while (node.parentNode) {\n          node = node.parentNode\n        }\n        return node === globals.document\n      }\n    ).call(globals.document.documentElement, node)\n  )\n}\n\nclass Box {\n  constructor(...args) {\n    this.init(...args)\n  }\n\n  addOffset() {\n    // offset by window scroll position, because getBoundingClientRect changes when window is scrolled\n    this.x += globals.window.pageXOffset\n    this.y += globals.window.pageYOffset\n    return new Box(this)\n  }\n\n  init(source) {\n    const base = [0, 0, 0, 0]\n    source =\n      typeof source === 'string'\n        ? source.split(delimiter).map(parseFloat)\n        : Array.isArray(source)\n          ? source\n          : typeof source === 'object'\n            ? [\n                source.left != null ? source.left : source.x,\n                source.top != null ? source.top : source.y,\n                source.width,\n                source.height\n              ]\n            : arguments.length === 4\n              ? [].slice.call(arguments)\n              : base\n\n    this.x = source[0] || 0\n    this.y = source[1] || 0\n    this.width = this.w = source[2] || 0\n    this.height = this.h = source[3] || 0\n\n    // Add more bounding box properties\n    this.x2 = this.x + this.w\n    this.y2 = this.y + this.h\n    this.cx = this.x + this.w / 2\n    this.cy = this.y + this.h / 2\n\n    return this\n  }\n\n  isNulled() {\n    return isNulledBox(this)\n  }\n\n  // Merge rect box with another, return a new instance\n  merge(box) {\n    const x = Math.min(this.x, box.x)\n    const y = Math.min(this.y, box.y)\n    const width = Math.max(this.x + this.width, box.x + box.width) - x\n    const height = Math.max(this.y + this.height, box.y + box.height) - y\n\n    return new Box(x, y, width, height)\n  }\n\n  toArray() {\n    return [this.x, this.y, this.width, this.height]\n  }\n\n  toString() {\n    return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height\n  }\n\n  transform(m) {\n    if (!(m instanceof Matrix)) {\n      m = new Matrix(m)\n    }\n\n    let xMin = Infinity\n    let xMax = -Infinity\n    let yMin = Infinity\n    let yMax = -Infinity\n\n    const pts = [\n      new Point(this.x, this.y),\n      new Point(this.x2, this.y),\n      new Point(this.x, this.y2),\n      new Point(this.x2, this.y2)\n    ]\n\n    pts.forEach(function (p) {\n      p = p.transform(m)\n      xMin = Math.min(xMin, p.x)\n      xMax = Math.max(xMax, p.x)\n      yMin = Math.min(yMin, p.y)\n      yMax = Math.max(yMax, p.y)\n    })\n\n    return new Box(xMin, yMin, xMax - xMin, yMax - yMin)\n  }\n}\n\nfunction getBox(el, getBBoxFn, retry) {\n  let box\n\n  try {\n    // Try to get the box with the provided function\n    box = getBBoxFn(el.node)\n\n    // If the box is worthless and not even in the dom, retry\n    // by throwing an error here...\n    if (isNulledBox(box) && !domContains(el.node)) {\n      throw new Error('Element not in the dom')\n    }\n  } catch (e) {\n    // ... and calling the retry handler here\n    box = retry(el)\n  }\n\n  return box\n}\n\nfunction bbox() {\n  // Function to get bbox is getBBox()\n  const getBBox = (node) => node.getBBox()\n\n  // Take all measures so that a stupid browser renders the element\n  // so we can get the bbox from it when we try again\n  const retry = (el) => {\n    try {\n      const clone = el.clone().addTo(parser().svg).show()\n      const box = clone.node.getBBox()\n      clone.remove()\n      return box\n    } catch (e) {\n      // We give up...\n      throw new Error(\n        `Getting bbox of element \"${\n          el.node.nodeName\n        }\" is not possible: ${e.toString()}`\n      )\n    }\n  }\n\n  const box = getBox(this, getBBox, retry)\n  const bbox = new Box(box)\n\n  return bbox\n}\n\nfunction rbox(el) {\n  const getRBox = (node) => node.getBoundingClientRect()\n  const retry = (el) => {\n    // There is no point in trying tricks here because if we insert the element into the dom ourselves\n    // it obviously will be at the wrong position\n    throw new Error(\n      `Getting rbox of element \"${el.node.nodeName}\" is not possible`\n    )\n  }\n\n  const box = getBox(this, getRBox, retry)\n  const rbox = new Box(box)\n\n  // If an element was passed, we want the bbox in the coordinate system of that element\n  if (el) {\n    return rbox.transform(el.screenCTM().inverseO())\n  }\n\n  // Else we want it in absolute screen coordinates\n  // Therefore we need to add the scrollOffset\n  return rbox.addOffset()\n}\n\n// Checks whether the given point is inside the bounding box\nfunction inside(x, y) {\n  const box = this.bbox()\n\n  return (\n    x > box.x && y > box.y && x < box.x + box.width && y < box.y + box.height\n  )\n}\n\nregisterMethods({\n  viewbox: {\n    viewbox(x, y, width, height) {\n      // act as getter\n      if (x == null) return new Box(this.attr('viewBox'))\n\n      // act as setter\n      return this.attr('viewBox', new Box(x, y, width, height))\n    },\n\n    zoom(level, point) {\n      // Its best to rely on the attributes here and here is why:\n      // clientXYZ: Doesn't work on non-root svgs because they dont have a CSSBox (silly!)\n      // getBoundingClientRect: Doesn't work because Chrome just ignores width and height of nested svgs completely\n      //                        that means, their clientRect is always as big as the content.\n      //                        Furthermore this size is incorrect if the element is further transformed by its parents\n      // computedStyle: Only returns meaningful values if css was used with px. We dont go this route here!\n      // getBBox: returns the bounding box of its content - that doesn't help!\n      let { width, height } = this.attr(['width', 'height'])\n\n      // Width and height is a string when a number with a unit is present which we can't use\n      // So we try clientXYZ\n      if (\n        (!width && !height) ||\n        typeof width === 'string' ||\n        typeof height === 'string'\n      ) {\n        width = this.node.clientWidth\n        height = this.node.clientHeight\n      }\n\n      // Giving up...\n      if (!width || !height) {\n        throw new Error(\n          'Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element'\n        )\n      }\n\n      const v = this.viewbox()\n\n      const zoomX = width / v.width\n      const zoomY = height / v.height\n      const zoom = Math.min(zoomX, zoomY)\n\n      if (level == null) {\n        return zoom\n      }\n\n      let zoomAmount = zoom / level\n\n      // Set the zoomAmount to the highest value which is safe to process and recover from\n      // The * 100 is a bit of wiggle room for the matrix transformation\n      if (zoomAmount === Infinity) zoomAmount = Number.MAX_SAFE_INTEGER / 100\n\n      point =\n        point || new Point(width / 2 / zoomX + v.x, height / 2 / zoomY + v.y)\n\n      const box = new Box(v).transform(\n        new Matrix({ scale: zoomAmount, origin: point })\n      )\n\n      return this.viewbox(box)\n    }\n  }\n})\n\nregister(Box, 'Box')\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/List.js\n\n// import { subClassArray } from './ArrayPolyfill.js'\n\nclass List extends Array {\n  constructor(arr = [], ...args) {\n    super(arr, ...args)\n    if (typeof arr === 'number') return this\n    this.length = 0\n    this.push(...arr)\n  }\n}\n\n/* = subClassArray('List', Array, function (arr = []) {\n  // This catches the case, that native map tries to create an array with new Array(1)\n  if (typeof arr === 'number') return this\n  this.length = 0\n  this.push(...arr)\n}) */\n\n/* harmony default export */ const types_List = (List);\n\nextend([List], {\n  each(fnOrMethodName, ...args) {\n    if (typeof fnOrMethodName === 'function') {\n      return this.map((el, i, arr) => {\n        return fnOrMethodName.call(el, el, i, arr)\n      })\n    } else {\n      return this.map((el) => {\n        return el[fnOrMethodName](...args)\n      })\n    }\n  },\n\n  toArray() {\n    return Array.prototype.concat.apply([], this)\n  }\n})\n\nconst reserved = ['toArray', 'constructor', 'each']\n\nList.extend = function (methods) {\n  methods = methods.reduce((obj, name) => {\n    // Don't overwrite own methods\n    if (reserved.includes(name)) return obj\n\n    // Don't add private methods\n    if (name[0] === '_') return obj\n\n    // Allow access to original Array methods through a prefix\n    if (name in Array.prototype) {\n      obj['$' + name] = Array.prototype[name]\n    }\n\n    // Relay every call to each()\n    obj[name] = function (...attrs) {\n      return this.each(name, ...attrs)\n    }\n    return obj\n  }, {})\n\n  extend([List], methods)\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/selector.js\n\n\n\n\n\nfunction baseFind(query, parent) {\n  return new types_List(\n    map((parent || globals.document).querySelectorAll(query), function (node) {\n      return adopt(node)\n    })\n  )\n}\n\n// Scoped find method\nfunction find(query) {\n  return baseFind(query, this.node)\n}\n\nfunction findOne(query) {\n  return adopt(this.node.querySelector(query))\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/event.js\n\n\n\n\nlet listenerId = 0\nconst windowEvents = {}\n\nfunction getEvents(instance) {\n  let n = instance.getEventHolder()\n\n  // We dont want to save events in global space\n  if (n === globals.window) n = windowEvents\n  if (!n.events) n.events = {}\n  return n.events\n}\n\nfunction getEventTarget(instance) {\n  return instance.getEventTarget()\n}\n\nfunction clearEvents(instance) {\n  let n = instance.getEventHolder()\n  if (n === globals.window) n = windowEvents\n  if (n.events) n.events = {}\n}\n\n// Add event binder in the SVG namespace\nfunction on(node, events, listener, binding, options) {\n  const l = listener.bind(binding || node)\n  const instance = adopter_makeInstance(node)\n  const bag = getEvents(instance)\n  const n = getEventTarget(instance)\n\n  // events can be an array of events or a string of events\n  events = Array.isArray(events) ? events : events.split(delimiter)\n\n  // add id to listener\n  if (!listener._svgjsListenerId) {\n    listener._svgjsListenerId = ++listenerId\n  }\n\n  events.forEach(function (event) {\n    const ev = event.split('.')[0]\n    const ns = event.split('.')[1] || '*'\n\n    // ensure valid object\n    bag[ev] = bag[ev] || {}\n    bag[ev][ns] = bag[ev][ns] || {}\n\n    // reference listener\n    bag[ev][ns][listener._svgjsListenerId] = l\n\n    // add listener\n    n.addEventListener(ev, l, options || false)\n  })\n}\n\n// Add event unbinder in the SVG namespace\nfunction off(node, events, listener, options) {\n  const instance = adopter_makeInstance(node)\n  const bag = getEvents(instance)\n  const n = getEventTarget(instance)\n\n  // listener can be a function or a number\n  if (typeof listener === 'function') {\n    listener = listener._svgjsListenerId\n    if (!listener) return\n  }\n\n  // events can be an array of events or a string or undefined\n  events = Array.isArray(events) ? events : (events || '').split(delimiter)\n\n  events.forEach(function (event) {\n    const ev = event && event.split('.')[0]\n    const ns = event && event.split('.')[1]\n    let namespace, l\n\n    if (listener) {\n      // remove listener reference\n      if (bag[ev] && bag[ev][ns || '*']) {\n        // removeListener\n        n.removeEventListener(\n          ev,\n          bag[ev][ns || '*'][listener],\n          options || false\n        )\n\n        delete bag[ev][ns || '*'][listener]\n      }\n    } else if (ev && ns) {\n      // remove all listeners for a namespaced event\n      if (bag[ev] && bag[ev][ns]) {\n        for (l in bag[ev][ns]) {\n          off(n, [ev, ns].join('.'), l)\n        }\n\n        delete bag[ev][ns]\n      }\n    } else if (ns) {\n      // remove all listeners for a specific namespace\n      for (event in bag) {\n        for (namespace in bag[event]) {\n          if (ns === namespace) {\n            off(n, [event, ns].join('.'))\n          }\n        }\n      }\n    } else if (ev) {\n      // remove all listeners for the event\n      if (bag[ev]) {\n        for (namespace in bag[ev]) {\n          off(n, [ev, namespace].join('.'))\n        }\n\n        delete bag[ev]\n      }\n    } else {\n      // remove all listeners on a given node\n      for (event in bag) {\n        off(n, event)\n      }\n\n      clearEvents(instance)\n    }\n  })\n}\n\nfunction dispatch(node, event, data, options) {\n  const n = getEventTarget(node)\n\n  // Dispatch event\n  if (event instanceof globals.window.Event) {\n    n.dispatchEvent(event)\n  } else {\n    event = new globals.window.CustomEvent(event, {\n      detail: data,\n      cancelable: true,\n      ...options\n    })\n    n.dispatchEvent(event)\n  }\n  return event\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/EventTarget.js\n\n\n\n\nclass EventTarget extends Base {\n  addEventListener() {}\n\n  dispatch(event, data, options) {\n    return dispatch(this, event, data, options)\n  }\n\n  dispatchEvent(event) {\n    const bag = this.getEventHolder().events\n    if (!bag) return true\n\n    const events = bag[event.type]\n\n    for (const i in events) {\n      for (const j in events[i]) {\n        events[i][j](event)\n      }\n    }\n\n    return !event.defaultPrevented\n  }\n\n  // Fire given event\n  fire(event, data, options) {\n    this.dispatch(event, data, options)\n    return this\n  }\n\n  getEventHolder() {\n    return this\n  }\n\n  getEventTarget() {\n    return this\n  }\n\n  // Unbind event from listener\n  off(event, listener, options) {\n    off(this, event, listener, options)\n    return this\n  }\n\n  // Bind given event to listener\n  on(event, listener, binding, options) {\n    on(this, event, listener, binding, options)\n    return this\n  }\n\n  removeEventListener() {}\n}\n\nregister(EventTarget, 'EventTarget')\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/defaults.js\nfunction noop() {}\n\n// Default animation values\nconst timeline = {\n  duration: 400,\n  ease: '>',\n  delay: 0\n}\n\n// Default attribute values\nconst attrs = {\n  // fill and stroke\n  'fill-opacity': 1,\n  'stroke-opacity': 1,\n  'stroke-width': 0,\n  'stroke-linejoin': 'miter',\n  'stroke-linecap': 'butt',\n  fill: '#000000',\n  stroke: '#000000',\n  opacity: 1,\n\n  // position\n  x: 0,\n  y: 0,\n  cx: 0,\n  cy: 0,\n\n  // size\n  width: 0,\n  height: 0,\n\n  // radius\n  r: 0,\n  rx: 0,\n  ry: 0,\n\n  // gradient\n  offset: 0,\n  'stop-opacity': 1,\n  'stop-color': '#000000',\n\n  // text\n  'text-anchor': 'start'\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/SVGArray.js\n\n\nclass SVGArray extends Array {\n  constructor(...args) {\n    super(...args)\n    this.init(...args)\n  }\n\n  clone() {\n    return new this.constructor(this)\n  }\n\n  init(arr) {\n    // This catches the case, that native map tries to create an array with new Array(1)\n    if (typeof arr === 'number') return this\n    this.length = 0\n    this.push(...this.parse(arr))\n    return this\n  }\n\n  // Parse whitespace separated string\n  parse(array = []) {\n    // If already is an array, no need to parse it\n    if (array instanceof Array) return array\n\n    return array.trim().split(delimiter).map(parseFloat)\n  }\n\n  toArray() {\n    return Array.prototype.concat.apply([], this)\n  }\n\n  toSet() {\n    return new Set(this)\n  }\n\n  toString() {\n    return this.join(' ')\n  }\n\n  // Flattens the array if needed\n  valueOf() {\n    const ret = []\n    ret.push(...this)\n    return ret\n  }\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/SVGNumber.js\n\n\n// Module for unit conversions\nclass SVGNumber {\n  // Initialize\n  constructor(...args) {\n    this.init(...args)\n  }\n\n  convert(unit) {\n    return new SVGNumber(this.value, unit)\n  }\n\n  // Divide number\n  divide(number) {\n    number = new SVGNumber(number)\n    return new SVGNumber(this / number, this.unit || number.unit)\n  }\n\n  init(value, unit) {\n    unit = Array.isArray(value) ? value[1] : unit\n    value = Array.isArray(value) ? value[0] : value\n\n    // initialize defaults\n    this.value = 0\n    this.unit = unit || ''\n\n    // parse value\n    if (typeof value === 'number') {\n      // ensure a valid numeric value\n      this.value = isNaN(value)\n        ? 0\n        : !isFinite(value)\n          ? value < 0\n            ? -3.4e38\n            : +3.4e38\n          : value\n    } else if (typeof value === 'string') {\n      unit = value.match(numberAndUnit)\n\n      if (unit) {\n        // make value numeric\n        this.value = parseFloat(unit[1])\n\n        // normalize\n        if (unit[5] === '%') {\n          this.value /= 100\n        } else if (unit[5] === 's') {\n          this.value *= 1000\n        }\n\n        // store unit\n        this.unit = unit[5]\n      }\n    } else {\n      if (value instanceof SVGNumber) {\n        this.value = value.valueOf()\n        this.unit = value.unit\n      }\n    }\n\n    return this\n  }\n\n  // Subtract number\n  minus(number) {\n    number = new SVGNumber(number)\n    return new SVGNumber(this - number, this.unit || number.unit)\n  }\n\n  // Add number\n  plus(number) {\n    number = new SVGNumber(number)\n    return new SVGNumber(this + number, this.unit || number.unit)\n  }\n\n  // Multiply number\n  times(number) {\n    number = new SVGNumber(number)\n    return new SVGNumber(this * number, this.unit || number.unit)\n  }\n\n  toArray() {\n    return [this.value, this.unit]\n  }\n\n  toJSON() {\n    return this.toString()\n  }\n\n  toString() {\n    return (\n      (this.unit === '%'\n        ? ~~(this.value * 1e8) / 1e6\n        : this.unit === 's'\n          ? this.value / 1e3\n          : this.value) + this.unit\n    )\n  }\n\n  valueOf() {\n    return this.value\n  }\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/attr.js\n\n\n\n\n\n\nconst colorAttributes = new Set([\n  'fill',\n  'stroke',\n  'color',\n  'bgcolor',\n  'stop-color',\n  'flood-color',\n  'lighting-color'\n])\n\nconst hooks = []\nfunction registerAttrHook(fn) {\n  hooks.push(fn)\n}\n\n// Set svg element attribute\nfunction attr(attr, val, ns) {\n  // act as full getter\n  if (attr == null) {\n    // get an object of attributes\n    attr = {}\n    val = this.node.attributes\n\n    for (const node of val) {\n      attr[node.nodeName] = isNumber.test(node.nodeValue)\n        ? parseFloat(node.nodeValue)\n        : node.nodeValue\n    }\n\n    return attr\n  } else if (attr instanceof Array) {\n    // loop through array and get all values\n    return attr.reduce((last, curr) => {\n      last[curr] = this.attr(curr)\n      return last\n    }, {})\n  } else if (typeof attr === 'object' && attr.constructor === Object) {\n    // apply every attribute individually if an object is passed\n    for (val in attr) this.attr(val, attr[val])\n  } else if (val === null) {\n    // remove value\n    this.node.removeAttribute(attr)\n  } else if (val == null) {\n    // act as a getter if the first and only argument is not an object\n    val = this.node.getAttribute(attr)\n    return val == null\n      ? attrs[attr]\n      : isNumber.test(val)\n        ? parseFloat(val)\n        : val\n  } else {\n    // Loop through hooks and execute them to convert value\n    val = hooks.reduce((_val, hook) => {\n      return hook(attr, _val, this)\n    }, val)\n\n    // ensure correct numeric values (also accepts NaN and Infinity)\n    if (typeof val === 'number') {\n      val = new SVGNumber(val)\n    } else if (colorAttributes.has(attr) && Color.isColor(val)) {\n      // ensure full hex color\n      val = new Color(val)\n    } else if (val.constructor === Array) {\n      // Check for plain arrays and parse array values\n      val = new SVGArray(val)\n    }\n\n    // if the passed attribute is leading...\n    if (attr === 'leading') {\n      // ... call the leading method instead\n      if (this.leading) {\n        this.leading(val)\n      }\n    } else {\n      // set given attribute on node\n      typeof ns === 'string'\n        ? this.node.setAttributeNS(ns, attr, val.toString())\n        : this.node.setAttribute(attr, val.toString())\n    }\n\n    // rebuild if required\n    if (this.rebuild && (attr === 'font-size' || attr === 'x')) {\n      this.rebuild()\n    }\n  }\n\n  return this\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Dom.js\n\n\n\n\n\n\n\n\n\nclass Dom extends EventTarget {\n  constructor(node, attrs) {\n    super()\n    this.node = node\n    this.type = node.nodeName\n\n    if (attrs && node !== attrs) {\n      this.attr(attrs)\n    }\n  }\n\n  // Add given element at a position\n  add(element, i) {\n    element = adopter_makeInstance(element)\n\n    // If non-root svg nodes are added we have to remove their namespaces\n    if (\n      element.removeNamespace &&\n      this.node instanceof globals.window.SVGElement\n    ) {\n      element.removeNamespace()\n    }\n\n    if (i == null) {\n      this.node.appendChild(element.node)\n    } else if (element.node !== this.node.childNodes[i]) {\n      this.node.insertBefore(element.node, this.node.childNodes[i])\n    }\n\n    return this\n  }\n\n  // Add element to given container and return self\n  addTo(parent, i) {\n    return adopter_makeInstance(parent).put(this, i)\n  }\n\n  // Returns all child elements\n  children() {\n    return new types_List(\n      map(this.node.children, function (node) {\n        return adopt(node)\n      })\n    )\n  }\n\n  // Remove all elements in this container\n  clear() {\n    // remove children\n    while (this.node.hasChildNodes()) {\n      this.node.removeChild(this.node.lastChild)\n    }\n\n    return this\n  }\n\n  // Clone element\n  clone(deep = true, assignNewIds = true) {\n    // write dom data to the dom so the clone can pickup the data\n    this.writeDataToDom()\n\n    // clone element\n    let nodeClone = this.node.cloneNode(deep)\n    if (assignNewIds) {\n      // assign new id\n      nodeClone = assignNewId(nodeClone)\n    }\n    return new this.constructor(nodeClone)\n  }\n\n  // Iterates over all children and invokes a given block\n  each(block, deep) {\n    const children = this.children()\n    let i, il\n\n    for (i = 0, il = children.length; i < il; i++) {\n      block.apply(children[i], [i, children])\n\n      if (deep) {\n        children[i].each(block, deep)\n      }\n    }\n\n    return this\n  }\n\n  element(nodeName, attrs) {\n    return this.put(new Dom(create(nodeName), attrs))\n  }\n\n  // Get first child\n  first() {\n    return adopt(this.node.firstChild)\n  }\n\n  // Get a element at the given index\n  get(i) {\n    return adopt(this.node.childNodes[i])\n  }\n\n  getEventHolder() {\n    return this.node\n  }\n\n  getEventTarget() {\n    return this.node\n  }\n\n  // Checks if the given element is a child\n  has(element) {\n    return this.index(element) >= 0\n  }\n\n  html(htmlOrFn, outerHTML) {\n    return this.xml(htmlOrFn, outerHTML, html)\n  }\n\n  // Get / set id\n  id(id) {\n    // generate new id if no id set\n    if (typeof id === 'undefined' && !this.node.id) {\n      this.node.id = eid(this.type)\n    }\n\n    // don't set directly with this.node.id to make `null` work correctly\n    return this.attr('id', id)\n  }\n\n  // Gets index of given element\n  index(element) {\n    return [].slice.call(this.node.childNodes).indexOf(element.node)\n  }\n\n  // Get the last child\n  last() {\n    return adopt(this.node.lastChild)\n  }\n\n  // matches the element vs a css selector\n  matches(selector) {\n    const el = this.node\n    const matcher =\n      el.matches ||\n      el.matchesSelector ||\n      el.msMatchesSelector ||\n      el.mozMatchesSelector ||\n      el.webkitMatchesSelector ||\n      el.oMatchesSelector ||\n      null\n    return matcher && matcher.call(el, selector)\n  }\n\n  // Returns the parent element instance\n  parent(type) {\n    let parent = this\n\n    // check for parent\n    if (!parent.node.parentNode) return null\n\n    // get parent element\n    parent = adopt(parent.node.parentNode)\n\n    if (!type) return parent\n\n    // loop through ancestors if type is given\n    do {\n      if (\n        typeof type === 'string' ? parent.matches(type) : parent instanceof type\n      )\n        return parent\n    } while ((parent = adopt(parent.node.parentNode)))\n\n    return parent\n  }\n\n  // Basically does the same as `add()` but returns the added element instead\n  put(element, i) {\n    element = adopter_makeInstance(element)\n    this.add(element, i)\n    return element\n  }\n\n  // Add element to given container and return container\n  putIn(parent, i) {\n    return adopter_makeInstance(parent).add(this, i)\n  }\n\n  // Remove element\n  remove() {\n    if (this.parent()) {\n      this.parent().removeElement(this)\n    }\n\n    return this\n  }\n\n  // Remove a given child\n  removeElement(element) {\n    this.node.removeChild(element.node)\n\n    return this\n  }\n\n  // Replace this with element\n  replace(element) {\n    element = adopter_makeInstance(element)\n\n    if (this.node.parentNode) {\n      this.node.parentNode.replaceChild(element.node, this.node)\n    }\n\n    return element\n  }\n\n  round(precision = 2, map = null) {\n    const factor = 10 ** precision\n    const attrs = this.attr(map)\n\n    for (const i in attrs) {\n      if (typeof attrs[i] === 'number') {\n        attrs[i] = Math.round(attrs[i] * factor) / factor\n      }\n    }\n\n    this.attr(attrs)\n    return this\n  }\n\n  // Import / Export raw svg\n  svg(svgOrFn, outerSVG) {\n    return this.xml(svgOrFn, outerSVG, svg)\n  }\n\n  // Return id on string conversion\n  toString() {\n    return this.id()\n  }\n\n  words(text) {\n    // This is faster than removing all children and adding a new one\n    this.node.textContent = text\n    return this\n  }\n\n  wrap(node) {\n    const parent = this.parent()\n\n    if (!parent) {\n      return this.addTo(node)\n    }\n\n    const position = parent.index(this)\n    return parent.put(node, position).put(this)\n  }\n\n  // write svgjs data to the dom\n  writeDataToDom() {\n    // dump variables recursively\n    this.each(function () {\n      this.writeDataToDom()\n    })\n\n    return this\n  }\n\n  // Import / Export raw svg\n  xml(xmlOrFn, outerXML, ns) {\n    if (typeof xmlOrFn === 'boolean') {\n      ns = outerXML\n      outerXML = xmlOrFn\n      xmlOrFn = null\n    }\n\n    // act as getter if no svg string is given\n    if (xmlOrFn == null || typeof xmlOrFn === 'function') {\n      // The default for exports is, that the outerNode is included\n      outerXML = outerXML == null ? true : outerXML\n\n      // write svgjs data to the dom\n      this.writeDataToDom()\n      let current = this\n\n      // An export modifier was passed\n      if (xmlOrFn != null) {\n        current = adopt(current.node.cloneNode(true))\n\n        // If the user wants outerHTML we need to process this node, too\n        if (outerXML) {\n          const result = xmlOrFn(current)\n          current = result || current\n\n          // The user does not want this node? Well, then he gets nothing\n          if (result === false) return ''\n        }\n\n        // Deep loop through all children and apply modifier\n        current.each(function () {\n          const result = xmlOrFn(this)\n          const _this = result || this\n\n          // If modifier returns false, discard node\n          if (result === false) {\n            this.remove()\n\n            // If modifier returns new node, use it\n          } else if (result && this !== _this) {\n            this.replace(_this)\n          }\n        }, true)\n      }\n\n      // Return outer or inner content\n      return outerXML ? current.node.outerHTML : current.node.innerHTML\n    }\n\n    // Act as setter if we got a string\n\n    // The default for import is, that the current node is not replaced\n    outerXML = outerXML == null ? false : outerXML\n\n    // Create temporary holder\n    const well = create('wrapper', ns)\n    const fragment = globals.document.createDocumentFragment()\n\n    // Dump raw svg\n    well.innerHTML = xmlOrFn\n\n    // Transplant nodes into the fragment\n    for (let len = well.children.length; len--; ) {\n      fragment.appendChild(well.firstElementChild)\n    }\n\n    const parent = this.parent()\n\n    // Add the whole fragment at once\n    return outerXML ? this.replace(fragment) && parent : this.add(fragment)\n  }\n}\n\nextend(Dom, { attr: attr, find: find, findOne: findOne })\nregister(Dom, 'Dom')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Element.js\n\n\n\n\n\n\n\n\n\n\n\nclass Element extends Dom {\n  constructor(node, attrs) {\n    super(node, attrs)\n\n    // initialize data object\n    this.dom = {}\n\n    // create circular reference\n    this.node.instance = this\n\n    if (node.hasAttribute('data-svgjs') || node.hasAttribute('svgjs:data')) {\n      // pull svgjs data from the dom (getAttributeNS doesn't work in html5)\n      this.setData(\n        JSON.parse(node.getAttribute('data-svgjs')) ??\n          JSON.parse(node.getAttribute('svgjs:data')) ??\n          {}\n      )\n    }\n  }\n\n  // Move element by its center\n  center(x, y) {\n    return this.cx(x).cy(y)\n  }\n\n  // Move by center over x-axis\n  cx(x) {\n    return x == null\n      ? this.x() + this.width() / 2\n      : this.x(x - this.width() / 2)\n  }\n\n  // Move by center over y-axis\n  cy(y) {\n    return y == null\n      ? this.y() + this.height() / 2\n      : this.y(y - this.height() / 2)\n  }\n\n  // Get defs\n  defs() {\n    const root = this.root()\n    return root && root.defs()\n  }\n\n  // Relative move over x and y axes\n  dmove(x, y) {\n    return this.dx(x).dy(y)\n  }\n\n  // Relative move over x axis\n  dx(x = 0) {\n    return this.x(new SVGNumber(x).plus(this.x()))\n  }\n\n  // Relative move over y axis\n  dy(y = 0) {\n    return this.y(new SVGNumber(y).plus(this.y()))\n  }\n\n  getEventHolder() {\n    return this\n  }\n\n  // Set height of element\n  height(height) {\n    return this.attr('height', height)\n  }\n\n  // Move element to given x and y values\n  move(x, y) {\n    return this.x(x).y(y)\n  }\n\n  // return array of all ancestors of given type up to the root svg\n  parents(until = this.root()) {\n    const isSelector = typeof until === 'string'\n    if (!isSelector) {\n      until = adopter_makeInstance(until)\n    }\n    const parents = new types_List()\n    let parent = this\n\n    while (\n      (parent = parent.parent()) &&\n      parent.node !== globals.document &&\n      parent.nodeName !== '#document-fragment'\n    ) {\n      parents.push(parent)\n\n      if (!isSelector && parent.node === until.node) {\n        break\n      }\n      if (isSelector && parent.matches(until)) {\n        break\n      }\n      if (parent.node === this.root().node) {\n        // We worked our way to the root and didn't match `until`\n        return null\n      }\n    }\n\n    return parents\n  }\n\n  // Get referenced element form attribute value\n  reference(attr) {\n    attr = this.attr(attr)\n    if (!attr) return null\n\n    const m = (attr + '').match(reference)\n    return m ? adopter_makeInstance(m[1]) : null\n  }\n\n  // Get parent document\n  root() {\n    const p = this.parent(getClass(root))\n    return p && p.root()\n  }\n\n  // set given data to the elements data property\n  setData(o) {\n    this.dom = o\n    return this\n  }\n\n  // Set element size to given width and height\n  size(width, height) {\n    const p = proportionalSize(this, width, height)\n\n    return this.width(new SVGNumber(p.width)).height(new SVGNumber(p.height))\n  }\n\n  // Set width of element\n  width(width) {\n    return this.attr('width', width)\n  }\n\n  // write svgjs data to the dom\n  writeDataToDom() {\n    writeDataToDom(this, this.dom)\n    return super.writeDataToDom()\n  }\n\n  // Move over x-axis\n  x(x) {\n    return this.attr('x', x)\n  }\n\n  // Move over y-axis\n  y(y) {\n    return this.attr('y', y)\n  }\n}\n\nextend(Element, {\n  bbox: bbox,\n  rbox: rbox,\n  inside: inside,\n  point: point,\n  ctm: ctm,\n  screenCTM: screenCTM\n})\n\nregister(Element, 'Element')\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/optional/sugar.js\n\n\n\n\n\n\n\n// Define list of available attributes for stroke and fill\nconst sugar = {\n  stroke: [\n    'color',\n    'width',\n    'opacity',\n    'linecap',\n    'linejoin',\n    'miterlimit',\n    'dasharray',\n    'dashoffset'\n  ],\n  fill: ['color', 'opacity', 'rule'],\n  prefix: function (t, a) {\n    return a === 'color' ? t : t + '-' + a\n  }\n}\n\n// Add sugar for fill and stroke\n;['fill', 'stroke'].forEach(function (m) {\n  const extension = {}\n  let i\n\n  extension[m] = function (o) {\n    if (typeof o === 'undefined') {\n      return this.attr(m)\n    }\n    if (\n      typeof o === 'string' ||\n      o instanceof Color ||\n      Color.isRgb(o) ||\n      o instanceof Element\n    ) {\n      this.attr(m, o)\n    } else {\n      // set all attributes from sugar.fill and sugar.stroke list\n      for (i = sugar[m].length - 1; i >= 0; i--) {\n        if (o[sugar[m][i]] != null) {\n          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]])\n        }\n      }\n    }\n\n    return this\n  }\n\n  registerMethods(['Element', 'Runner'], extension)\n})\n\nregisterMethods(['Element', 'Runner'], {\n  // Let the user set the matrix directly\n  matrix: function (mat, b, c, d, e, f) {\n    // Act as a getter\n    if (mat == null) {\n      return new Matrix(this)\n    }\n\n    // Act as a setter, the user can pass a matrix or a set of numbers\n    return this.attr('transform', new Matrix(mat, b, c, d, e, f))\n  },\n\n  // Map rotation to transform\n  rotate: function (angle, cx, cy) {\n    return this.transform({ rotate: angle, ox: cx, oy: cy }, true)\n  },\n\n  // Map skew to transform\n  skew: function (x, y, cx, cy) {\n    return arguments.length === 1 || arguments.length === 3\n      ? this.transform({ skew: x, ox: y, oy: cx }, true)\n      : this.transform({ skew: [x, y], ox: cx, oy: cy }, true)\n  },\n\n  shear: function (lam, cx, cy) {\n    return this.transform({ shear: lam, ox: cx, oy: cy }, true)\n  },\n\n  // Map scale to transform\n  scale: function (x, y, cx, cy) {\n    return arguments.length === 1 || arguments.length === 3\n      ? this.transform({ scale: x, ox: y, oy: cx }, true)\n      : this.transform({ scale: [x, y], ox: cx, oy: cy }, true)\n  },\n\n  // Map translate to transform\n  translate: function (x, y) {\n    return this.transform({ translate: [x, y] }, true)\n  },\n\n  // Map relative translations to transform\n  relative: function (x, y) {\n    return this.transform({ relative: [x, y] }, true)\n  },\n\n  // Map flip to transform\n  flip: function (direction = 'both', origin = 'center') {\n    if ('xybothtrue'.indexOf(direction) === -1) {\n      origin = direction\n      direction = 'both'\n    }\n\n    return this.transform({ flip: direction, origin: origin }, true)\n  },\n\n  // Opacity\n  opacity: function (value) {\n    return this.attr('opacity', value)\n  }\n})\n\nregisterMethods('radius', {\n  // Add x and y radius\n  radius: function (x, y = x) {\n    const type = (this._element || this).type\n    return type === 'radialGradient'\n      ? this.attr('r', new SVGNumber(x))\n      : this.rx(x).ry(y)\n  }\n})\n\nregisterMethods('Path', {\n  // Get path length\n  length: function () {\n    return this.node.getTotalLength()\n  },\n  // Get point at length\n  pointAt: function (length) {\n    return new Point(this.node.getPointAtLength(length))\n  }\n})\n\nregisterMethods(['Element', 'Runner'], {\n  // Set font\n  font: function (a, v) {\n    if (typeof a === 'object') {\n      for (v in a) this.font(v, a[v])\n      return this\n    }\n\n    return a === 'leading'\n      ? this.leading(v)\n      : a === 'anchor'\n        ? this.attr('text-anchor', v)\n        : a === 'size' ||\n            a === 'family' ||\n            a === 'weight' ||\n            a === 'stretch' ||\n            a === 'variant' ||\n            a === 'style'\n          ? this.attr('font-' + a, v)\n          : this.attr(a, v)\n  }\n})\n\n// Add events to elements\nconst sugar_methods = [\n  'click',\n  'dblclick',\n  'mousedown',\n  'mouseup',\n  'mouseover',\n  'mouseout',\n  'mousemove',\n  'mouseenter',\n  'mouseleave',\n  'touchstart',\n  'touchmove',\n  'touchleave',\n  'touchend',\n  'touchcancel',\n  'contextmenu',\n  'wheel',\n  'pointerdown',\n  'pointermove',\n  'pointerup',\n  'pointerleave',\n  'pointercancel'\n].reduce(function (last, event) {\n  // add event to Element\n  const fn = function (f) {\n    if (f === null) {\n      this.off(event)\n    } else {\n      this.on(event, f)\n    }\n    return this\n  }\n\n  last[event] = fn\n  return last\n}, {})\n\nregisterMethods('Element', sugar_methods)\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/optional/transform.js\n\n\n\n\n\n// Reset all transformations\nfunction untransform() {\n  return this.attr('transform', null)\n}\n\n// merge the whole transformation chain into one matrix and returns it\nfunction matrixify() {\n  const matrix = (this.attr('transform') || '')\n    // split transformations\n    .split(transforms)\n    .slice(0, -1)\n    .map(function (str) {\n      // generate key => value pairs\n      const kv = str.trim().split('(')\n      return [\n        kv[0],\n        kv[1].split(delimiter).map(function (str) {\n          return parseFloat(str)\n        })\n      ]\n    })\n    .reverse()\n    // merge every transformation into one matrix\n    .reduce(function (matrix, transform) {\n      if (transform[0] === 'matrix') {\n        return matrix.lmultiply(Matrix.fromArray(transform[1]))\n      }\n      return matrix[transform[0]].apply(matrix, transform[1])\n    }, new Matrix())\n\n  return matrix\n}\n\n// add an element to another parent without changing the visual representation on the screen\nfunction toParent(parent, i) {\n  if (this === parent) return this\n\n  if (isDescriptive(this.node)) return this.addTo(parent, i)\n\n  const ctm = this.screenCTM()\n  const pCtm = parent.screenCTM().inverse()\n\n  this.addTo(parent, i).untransform().transform(pCtm.multiply(ctm))\n\n  return this\n}\n\n// same as above with parent equals root-svg\nfunction toRoot(i) {\n  return this.toParent(this.root(), i)\n}\n\n// Add transformations\nfunction transform(o, relative) {\n  // Act as a getter if no object was passed\n  if (o == null || typeof o === 'string') {\n    const decomposed = new Matrix(this).decompose()\n    return o == null ? decomposed : decomposed[o]\n  }\n\n  if (!Matrix.isMatrixLike(o)) {\n    // Set the origin according to the defined transform\n    o = { ...o, origin: getOrigin(o, this) }\n  }\n\n  // The user can pass a boolean, an Element or an Matrix or nothing\n  const cleanRelative = relative === true ? this : relative || false\n  const result = new Matrix(cleanRelative).transform(o)\n  return this.attr('transform', result)\n}\n\nregisterMethods('Element', {\n  untransform,\n  matrixify,\n  toParent,\n  toRoot,\n  transform\n})\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Container.js\n\n\n\nclass Container extends Element {\n  flatten() {\n    this.each(function () {\n      if (this instanceof Container) {\n        return this.flatten().ungroup()\n      }\n    })\n\n    return this\n  }\n\n  ungroup(parent = this.parent(), index = parent.index(this)) {\n    // when parent != this, we want append all elements to the end\n    index = index === -1 ? parent.children().length : index\n\n    this.each(function (i, children) {\n      // reverse each\n      return children[children.length - i - 1].toParent(parent, index)\n    })\n\n    return this.remove()\n  }\n}\n\nregister(Container, 'Container')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Defs.js\n\n\n\nclass Defs extends Container {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('defs', node), attrs)\n  }\n\n  flatten() {\n    return this\n  }\n\n  ungroup() {\n    return this\n  }\n}\n\nregister(Defs, 'Defs')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Shape.js\n\n\n\nclass Shape extends Element {}\n\nregister(Shape, 'Shape')\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/circled.js\n\n\n// Radius x value\nfunction rx(rx) {\n  return this.attr('rx', rx)\n}\n\n// Radius y value\nfunction ry(ry) {\n  return this.attr('ry', ry)\n}\n\n// Move over x-axis\nfunction x(x) {\n  return x == null ? this.cx() - this.rx() : this.cx(x + this.rx())\n}\n\n// Move over y-axis\nfunction y(y) {\n  return y == null ? this.cy() - this.ry() : this.cy(y + this.ry())\n}\n\n// Move by center over x-axis\nfunction cx(x) {\n  return this.attr('cx', x)\n}\n\n// Move by center over y-axis\nfunction cy(y) {\n  return this.attr('cy', y)\n}\n\n// Set width of element\nfunction width(width) {\n  return width == null ? this.rx() * 2 : this.rx(new SVGNumber(width).divide(2))\n}\n\n// Set height of element\nfunction height(height) {\n  return height == null\n    ? this.ry() * 2\n    : this.ry(new SVGNumber(height).divide(2))\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Ellipse.js\n\n\n\n\n\n\n\nclass Ellipse extends Shape {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('ellipse', node), attrs)\n  }\n\n  size(width, height) {\n    const p = proportionalSize(this, width, height)\n\n    return this.rx(new SVGNumber(p.width).divide(2)).ry(\n      new SVGNumber(p.height).divide(2)\n    )\n  }\n}\n\nextend(Ellipse, circled_namespaceObject)\n\nregisterMethods('Container', {\n  // Create an ellipse\n  ellipse: wrapWithAttrCheck(function (width = 0, height = width) {\n    return this.put(new Ellipse()).size(width, height).move(0, 0)\n  })\n})\n\nregister(Ellipse, 'Ellipse')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Fragment.js\n\n\n\n\nclass Fragment extends Dom {\n  constructor(node = globals.document.createDocumentFragment()) {\n    super(node)\n  }\n\n  // Import / Export raw xml\n  xml(xmlOrFn, outerXML, ns) {\n    if (typeof xmlOrFn === 'boolean') {\n      ns = outerXML\n      outerXML = xmlOrFn\n      xmlOrFn = null\n    }\n\n    // because this is a fragment we have to put all elements into a wrapper first\n    // before we can get the innerXML from it\n    if (xmlOrFn == null || typeof xmlOrFn === 'function') {\n      const wrapper = new Dom(create('wrapper', ns))\n      wrapper.add(this.node.cloneNode(true))\n\n      return wrapper.xml(false, ns)\n    }\n\n    // Act as setter if we got a string\n    return super.xml(xmlOrFn, false, ns)\n  }\n}\n\nregister(Fragment, 'Fragment')\n\n/* harmony default export */ const elements_Fragment = (Fragment);\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/gradiented.js\n\n\nfunction from(x, y) {\n  return (this._element || this).type === 'radialGradient'\n    ? this.attr({ fx: new SVGNumber(x), fy: new SVGNumber(y) })\n    : this.attr({ x1: new SVGNumber(x), y1: new SVGNumber(y) })\n}\n\nfunction to(x, y) {\n  return (this._element || this).type === 'radialGradient'\n    ? this.attr({ cx: new SVGNumber(x), cy: new SVGNumber(y) })\n    : this.attr({ x2: new SVGNumber(x), y2: new SVGNumber(y) })\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Gradient.js\n\n\n\n\n\n\n\nclass Gradient extends Container {\n  constructor(type, attrs) {\n    super(\n      nodeOrNew(type + 'Gradient', typeof type === 'string' ? null : type),\n      attrs\n    )\n  }\n\n  // custom attr to handle transform\n  attr(a, b, c) {\n    if (a === 'transform') a = 'gradientTransform'\n    return super.attr(a, b, c)\n  }\n\n  bbox() {\n    return new Box()\n  }\n\n  targets() {\n    return baseFind('svg [fill*=' + this.id() + ']')\n  }\n\n  // Alias string conversion to fill\n  toString() {\n    return this.url()\n  }\n\n  // Update gradient\n  update(block) {\n    // remove all stops\n    this.clear()\n\n    // invoke passed block\n    if (typeof block === 'function') {\n      block.call(this, this)\n    }\n\n    return this\n  }\n\n  // Return the fill id\n  url() {\n    return 'url(#' + this.id() + ')'\n  }\n}\n\nextend(Gradient, gradiented_namespaceObject)\n\nregisterMethods({\n  Container: {\n    // Create gradient element in defs\n    gradient(...args) {\n      return this.defs().gradient(...args)\n    }\n  },\n  // define gradient\n  Defs: {\n    gradient: wrapWithAttrCheck(function (type, block) {\n      return this.put(new Gradient(type)).update(block)\n    })\n  }\n})\n\nregister(Gradient, 'Gradient')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Pattern.js\n\n\n\n\n\n\nclass Pattern extends Container {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('pattern', node), attrs)\n  }\n\n  // custom attr to handle transform\n  attr(a, b, c) {\n    if (a === 'transform') a = 'patternTransform'\n    return super.attr(a, b, c)\n  }\n\n  bbox() {\n    return new Box()\n  }\n\n  targets() {\n    return baseFind('svg [fill*=' + this.id() + ']')\n  }\n\n  // Alias string conversion to fill\n  toString() {\n    return this.url()\n  }\n\n  // Update pattern by rebuilding\n  update(block) {\n    // remove content\n    this.clear()\n\n    // invoke passed block\n    if (typeof block === 'function') {\n      block.call(this, this)\n    }\n\n    return this\n  }\n\n  // Return the fill id\n  url() {\n    return 'url(#' + this.id() + ')'\n  }\n}\n\nregisterMethods({\n  Container: {\n    // Create pattern element in defs\n    pattern(...args) {\n      return this.defs().pattern(...args)\n    }\n  },\n  Defs: {\n    pattern: wrapWithAttrCheck(function (width, height, block) {\n      return this.put(new Pattern()).update(block).attr({\n        x: 0,\n        y: 0,\n        width: width,\n        height: height,\n        patternUnits: 'userSpaceOnUse'\n      })\n    })\n  }\n})\n\nregister(Pattern, 'Pattern')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Image.js\n\n\n\n\n\n\n\n\n\n\nclass Image extends Shape {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('image', node), attrs)\n  }\n\n  // (re)load image\n  load(url, callback) {\n    if (!url) return this\n\n    const img = new globals.window.Image()\n\n    on(\n      img,\n      'load',\n      function (e) {\n        const p = this.parent(Pattern)\n\n        // ensure image size\n        if (this.width() === 0 && this.height() === 0) {\n          this.size(img.width, img.height)\n        }\n\n        if (p instanceof Pattern) {\n          // ensure pattern size if not set\n          if (p.width() === 0 && p.height() === 0) {\n            p.size(this.width(), this.height())\n          }\n        }\n\n        if (typeof callback === 'function') {\n          callback.call(this, e)\n        }\n      },\n      this\n    )\n\n    on(img, 'load error', function () {\n      // dont forget to unbind memory leaking events\n      off(img)\n    })\n\n    return this.attr('href', (img.src = url), xlink)\n  }\n}\n\nregisterAttrHook(function (attr, val, _this) {\n  // convert image fill and stroke to patterns\n  if (attr === 'fill' || attr === 'stroke') {\n    if (isImage.test(val)) {\n      val = _this.root().defs().image(val)\n    }\n  }\n\n  if (val instanceof Image) {\n    val = _this\n      .root()\n      .defs()\n      .pattern(0, 0, (pattern) => {\n        pattern.add(val)\n      })\n  }\n\n  return val\n})\n\nregisterMethods({\n  Container: {\n    // create image element, load image and set its size\n    image: wrapWithAttrCheck(function (source, callback) {\n      return this.put(new Image()).size(0, 0).load(source, callback)\n    })\n  }\n})\n\nregister(Image, 'Image')\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/PointArray.js\n\n\n\n\n\nclass PointArray extends SVGArray {\n  // Get bounding box of points\n  bbox() {\n    let maxX = -Infinity\n    let maxY = -Infinity\n    let minX = Infinity\n    let minY = Infinity\n    this.forEach(function (el) {\n      maxX = Math.max(el[0], maxX)\n      maxY = Math.max(el[1], maxY)\n      minX = Math.min(el[0], minX)\n      minY = Math.min(el[1], minY)\n    })\n    return new Box(minX, minY, maxX - minX, maxY - minY)\n  }\n\n  // Move point string\n  move(x, y) {\n    const box = this.bbox()\n\n    // get relative offset\n    x -= box.x\n    y -= box.y\n\n    // move every point\n    if (!isNaN(x) && !isNaN(y)) {\n      for (let i = this.length - 1; i >= 0; i--) {\n        this[i] = [this[i][0] + x, this[i][1] + y]\n      }\n    }\n\n    return this\n  }\n\n  // Parse point string and flat array\n  parse(array = [0, 0]) {\n    const points = []\n\n    // if it is an array, we flatten it and therefore clone it to 1 depths\n    if (array instanceof Array) {\n      array = Array.prototype.concat.apply([], array)\n    } else {\n      // Else, it is considered as a string\n      // parse points\n      array = array.trim().split(delimiter).map(parseFloat)\n    }\n\n    // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints\n    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.\n    if (array.length % 2 !== 0) array.pop()\n\n    // wrap points in two-tuples\n    for (let i = 0, len = array.length; i < len; i = i + 2) {\n      points.push([array[i], array[i + 1]])\n    }\n\n    return points\n  }\n\n  // Resize poly string\n  size(width, height) {\n    let i\n    const box = this.bbox()\n\n    // recalculate position of all points according to new size\n    for (i = this.length - 1; i >= 0; i--) {\n      if (box.width)\n        this[i][0] = ((this[i][0] - box.x) * width) / box.width + box.x\n      if (box.height)\n        this[i][1] = ((this[i][1] - box.y) * height) / box.height + box.y\n    }\n\n    return this\n  }\n\n  // Convert array to line object\n  toLine() {\n    return {\n      x1: this[0][0],\n      y1: this[0][1],\n      x2: this[1][0],\n      y2: this[1][1]\n    }\n  }\n\n  // Convert array to string\n  toString() {\n    const array = []\n    // convert to a poly point string\n    for (let i = 0, il = this.length; i < il; i++) {\n      array.push(this[i].join(','))\n    }\n\n    return array.join(' ')\n  }\n\n  transform(m) {\n    return this.clone().transformO(m)\n  }\n\n  // transform points with matrix (similar to Point.transform)\n  transformO(m) {\n    if (!Matrix.isMatrixLike(m)) {\n      m = new Matrix(m)\n    }\n\n    for (let i = this.length; i--; ) {\n      // Perform the matrix multiplication\n      const [x, y] = this[i]\n      this[i][0] = m.a * x + m.c * y + m.e\n      this[i][1] = m.b * x + m.d * y + m.f\n    }\n\n    return this\n  }\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/pointed.js\n\n\nconst MorphArray = PointArray\n\n// Move by left top corner over x-axis\nfunction pointed_x(x) {\n  return x == null ? this.bbox().x : this.move(x, this.bbox().y)\n}\n\n// Move by left top corner over y-axis\nfunction pointed_y(y) {\n  return y == null ? this.bbox().y : this.move(this.bbox().x, y)\n}\n\n// Set width of element\nfunction pointed_width(width) {\n  const b = this.bbox()\n  return width == null ? b.width : this.size(width, b.height)\n}\n\n// Set height of element\nfunction pointed_height(height) {\n  const b = this.bbox()\n  return height == null ? b.height : this.size(b.width, height)\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Line.js\n\n\n\n\n\n\n\nclass Line extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('line', node), attrs)\n  }\n\n  // Get array\n  array() {\n    return new PointArray([\n      [this.attr('x1'), this.attr('y1')],\n      [this.attr('x2'), this.attr('y2')]\n    ])\n  }\n\n  // Move by left top corner\n  move(x, y) {\n    return this.attr(this.array().move(x, y).toLine())\n  }\n\n  // Overwrite native plot() method\n  plot(x1, y1, x2, y2) {\n    if (x1 == null) {\n      return this.array()\n    } else if (typeof y1 !== 'undefined') {\n      x1 = { x1, y1, x2, y2 }\n    } else {\n      x1 = new PointArray(x1).toLine()\n    }\n\n    return this.attr(x1)\n  }\n\n  // Set element size to given width and height\n  size(width, height) {\n    const p = proportionalSize(this, width, height)\n    return this.attr(this.array().size(p.width, p.height).toLine())\n  }\n}\n\nextend(Line, pointed_namespaceObject)\n\nregisterMethods({\n  Container: {\n    // Create a line element\n    line: wrapWithAttrCheck(function (...args) {\n      // make sure plot is called as a setter\n      // x1 is not necessarily a number, it can also be an array, a string and a PointArray\n      return Line.prototype.plot.apply(\n        this.put(new Line()),\n        args[0] != null ? args : [0, 0, 0, 0]\n      )\n    })\n  }\n})\n\nregister(Line, 'Line')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Marker.js\n\n\n\n\nclass Marker extends Container {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('marker', node), attrs)\n  }\n\n  // Set height of element\n  height(height) {\n    return this.attr('markerHeight', height)\n  }\n\n  orient(orient) {\n    return this.attr('orient', orient)\n  }\n\n  // Set marker refX and refY\n  ref(x, y) {\n    return this.attr('refX', x).attr('refY', y)\n  }\n\n  // Return the fill id\n  toString() {\n    return 'url(#' + this.id() + ')'\n  }\n\n  // Update marker\n  update(block) {\n    // remove all content\n    this.clear()\n\n    // invoke passed block\n    if (typeof block === 'function') {\n      block.call(this, this)\n    }\n\n    return this\n  }\n\n  // Set width of element\n  width(width) {\n    return this.attr('markerWidth', width)\n  }\n}\n\nregisterMethods({\n  Container: {\n    marker(...args) {\n      // Create marker element in defs\n      return this.defs().marker(...args)\n    }\n  },\n  Defs: {\n    // Create marker\n    marker: wrapWithAttrCheck(function (width, height, block) {\n      // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto\n      return this.put(new Marker())\n        .size(width, height)\n        .ref(width / 2, height / 2)\n        .viewbox(0, 0, width, height)\n        .attr('orient', 'auto')\n        .update(block)\n    })\n  },\n  marker: {\n    // Create and attach markers\n    marker(marker, width, height, block) {\n      let attr = ['marker']\n\n      // Build attribute name\n      if (marker !== 'all') attr.push(marker)\n      attr = attr.join('-')\n\n      // Set marker attribute\n      marker =\n        arguments[1] instanceof Marker\n          ? arguments[1]\n          : this.defs().marker(width, height, block)\n\n      return this.attr(attr, marker)\n    }\n  }\n})\n\nregister(Marker, 'Marker')\n\n;// ./node_modules/@svgdotjs/svg.js/src/animation/Controller.js\n\n\n\n/***\nBase Class\n==========\nThe base stepper class that will be\n***/\n\nfunction makeSetterGetter(k, f) {\n  return function (v) {\n    if (v == null) return this[k]\n    this[k] = v\n    if (f) f.call(this)\n    return this\n  }\n}\n\nconst easing = {\n  '-': function (pos) {\n    return pos\n  },\n  '<>': function (pos) {\n    return -Math.cos(pos * Math.PI) / 2 + 0.5\n  },\n  '>': function (pos) {\n    return Math.sin((pos * Math.PI) / 2)\n  },\n  '<': function (pos) {\n    return -Math.cos((pos * Math.PI) / 2) + 1\n  },\n  bezier: function (x1, y1, x2, y2) {\n    // see https://www.w3.org/TR/css-easing-1/#cubic-bezier-algo\n    return function (t) {\n      if (t < 0) {\n        if (x1 > 0) {\n          return (y1 / x1) * t\n        } else if (x2 > 0) {\n          return (y2 / x2) * t\n        } else {\n          return 0\n        }\n      } else if (t > 1) {\n        if (x2 < 1) {\n          return ((1 - y2) / (1 - x2)) * t + (y2 - x2) / (1 - x2)\n        } else if (x1 < 1) {\n          return ((1 - y1) / (1 - x1)) * t + (y1 - x1) / (1 - x1)\n        } else {\n          return 1\n        }\n      } else {\n        return 3 * t * (1 - t) ** 2 * y1 + 3 * t ** 2 * (1 - t) * y2 + t ** 3\n      }\n    }\n  },\n  // see https://www.w3.org/TR/css-easing-1/#step-timing-function-algo\n  steps: function (steps, stepPosition = 'end') {\n    // deal with \"jump-\" prefix\n    stepPosition = stepPosition.split('-').reverse()[0]\n\n    let jumps = steps\n    if (stepPosition === 'none') {\n      --jumps\n    } else if (stepPosition === 'both') {\n      ++jumps\n    }\n\n    // The beforeFlag is essentially useless\n    return (t, beforeFlag = false) => {\n      // Step is called currentStep in referenced url\n      let step = Math.floor(t * steps)\n      const jumping = (t * step) % 1 === 0\n\n      if (stepPosition === 'start' || stepPosition === 'both') {\n        ++step\n      }\n\n      if (beforeFlag && jumping) {\n        --step\n      }\n\n      if (t >= 0 && step < 0) {\n        step = 0\n      }\n\n      if (t <= 1 && step > jumps) {\n        step = jumps\n      }\n\n      return step / jumps\n    }\n  }\n}\n\nclass Stepper {\n  done() {\n    return false\n  }\n}\n\n/***\nEasing Functions\n================\n***/\n\nclass Ease extends Stepper {\n  constructor(fn = timeline.ease) {\n    super()\n    this.ease = easing[fn] || fn\n  }\n\n  step(from, to, pos) {\n    if (typeof from !== 'number') {\n      return pos < 1 ? from : to\n    }\n    return from + (to - from) * this.ease(pos)\n  }\n}\n\n/***\nController Types\n================\n***/\n\nclass Controller extends Stepper {\n  constructor(fn) {\n    super()\n    this.stepper = fn\n  }\n\n  done(c) {\n    return c.done\n  }\n\n  step(current, target, dt, c) {\n    return this.stepper(current, target, dt, c)\n  }\n}\n\nfunction recalculate() {\n  // Apply the default parameters\n  const duration = (this._duration || 500) / 1000\n  const overshoot = this._overshoot || 0\n\n  // Calculate the PID natural response\n  const eps = 1e-10\n  const pi = Math.PI\n  const os = Math.log(overshoot / 100 + eps)\n  const zeta = -os / Math.sqrt(pi * pi + os * os)\n  const wn = 3.9 / (zeta * duration)\n\n  // Calculate the Spring values\n  this.d = 2 * zeta * wn\n  this.k = wn * wn\n}\n\nclass Spring extends Controller {\n  constructor(duration = 500, overshoot = 0) {\n    super()\n    this.duration(duration).overshoot(overshoot)\n  }\n\n  step(current, target, dt, c) {\n    if (typeof current === 'string') return current\n    c.done = dt === Infinity\n    if (dt === Infinity) return target\n    if (dt === 0) return current\n\n    if (dt > 100) dt = 16\n\n    dt /= 1000\n\n    // Get the previous velocity\n    const velocity = c.velocity || 0\n\n    // Apply the control to get the new position and store it\n    const acceleration = -this.d * velocity - this.k * (current - target)\n    const newPosition = current + velocity * dt + (acceleration * dt * dt) / 2\n\n    // Store the velocity\n    c.velocity = velocity + acceleration * dt\n\n    // Figure out if we have converged, and if so, pass the value\n    c.done = Math.abs(target - newPosition) + Math.abs(velocity) < 0.002\n    return c.done ? target : newPosition\n  }\n}\n\nextend(Spring, {\n  duration: makeSetterGetter('_duration', recalculate),\n  overshoot: makeSetterGetter('_overshoot', recalculate)\n})\n\nclass PID extends Controller {\n  constructor(p = 0.1, i = 0.01, d = 0, windup = 1000) {\n    super()\n    this.p(p).i(i).d(d).windup(windup)\n  }\n\n  step(current, target, dt, c) {\n    if (typeof current === 'string') return current\n    c.done = dt === Infinity\n\n    if (dt === Infinity) return target\n    if (dt === 0) return current\n\n    const p = target - current\n    let i = (c.integral || 0) + p * dt\n    const d = (p - (c.error || 0)) / dt\n    const windup = this._windup\n\n    // antiwindup\n    if (windup !== false) {\n      i = Math.max(-windup, Math.min(i, windup))\n    }\n\n    c.error = p\n    c.integral = i\n\n    c.done = Math.abs(p) < 0.001\n\n    return c.done ? target : current + (this.P * p + this.I * i + this.D * d)\n  }\n}\n\nextend(PID, {\n  windup: makeSetterGetter('_windup'),\n  p: makeSetterGetter('P'),\n  i: makeSetterGetter('I'),\n  d: makeSetterGetter('D')\n})\n\n;// ./node_modules/@svgdotjs/svg.js/src/utils/pathParser.js\n\n\n\nconst segmentParameters = {\n  M: 2,\n  L: 2,\n  H: 1,\n  V: 1,\n  C: 6,\n  S: 4,\n  Q: 4,\n  T: 2,\n  A: 7,\n  Z: 0\n}\n\nconst pathHandlers = {\n  M: function (c, p, p0) {\n    p.x = p0.x = c[0]\n    p.y = p0.y = c[1]\n\n    return ['M', p.x, p.y]\n  },\n  L: function (c, p) {\n    p.x = c[0]\n    p.y = c[1]\n    return ['L', c[0], c[1]]\n  },\n  H: function (c, p) {\n    p.x = c[0]\n    return ['H', c[0]]\n  },\n  V: function (c, p) {\n    p.y = c[0]\n    return ['V', c[0]]\n  },\n  C: function (c, p) {\n    p.x = c[4]\n    p.y = c[5]\n    return ['C', c[0], c[1], c[2], c[3], c[4], c[5]]\n  },\n  S: function (c, p) {\n    p.x = c[2]\n    p.y = c[3]\n    return ['S', c[0], c[1], c[2], c[3]]\n  },\n  Q: function (c, p) {\n    p.x = c[2]\n    p.y = c[3]\n    return ['Q', c[0], c[1], c[2], c[3]]\n  },\n  T: function (c, p) {\n    p.x = c[0]\n    p.y = c[1]\n    return ['T', c[0], c[1]]\n  },\n  Z: function (c, p, p0) {\n    p.x = p0.x\n    p.y = p0.y\n    return ['Z']\n  },\n  A: function (c, p) {\n    p.x = c[5]\n    p.y = c[6]\n    return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]]\n  }\n}\n\nconst mlhvqtcsaz = 'mlhvqtcsaz'.split('')\n\nfor (let i = 0, il = mlhvqtcsaz.length; i < il; ++i) {\n  pathHandlers[mlhvqtcsaz[i]] = (function (i) {\n    return function (c, p, p0) {\n      if (i === 'H') c[0] = c[0] + p.x\n      else if (i === 'V') c[0] = c[0] + p.y\n      else if (i === 'A') {\n        c[5] = c[5] + p.x\n        c[6] = c[6] + p.y\n      } else {\n        for (let j = 0, jl = c.length; j < jl; ++j) {\n          c[j] = c[j] + (j % 2 ? p.y : p.x)\n        }\n      }\n\n      return pathHandlers[i](c, p, p0)\n    }\n  })(mlhvqtcsaz[i].toUpperCase())\n}\n\nfunction makeAbsolut(parser) {\n  const command = parser.segment[0]\n  return pathHandlers[command](parser.segment.slice(1), parser.p, parser.p0)\n}\n\nfunction segmentComplete(parser) {\n  return (\n    parser.segment.length &&\n    parser.segment.length - 1 ===\n      segmentParameters[parser.segment[0].toUpperCase()]\n  )\n}\n\nfunction startNewSegment(parser, token) {\n  parser.inNumber && finalizeNumber(parser, false)\n  const pathLetter = isPathLetter.test(token)\n\n  if (pathLetter) {\n    parser.segment = [token]\n  } else {\n    const lastCommand = parser.lastCommand\n    const small = lastCommand.toLowerCase()\n    const isSmall = lastCommand === small\n    parser.segment = [small === 'm' ? (isSmall ? 'l' : 'L') : lastCommand]\n  }\n\n  parser.inSegment = true\n  parser.lastCommand = parser.segment[0]\n\n  return pathLetter\n}\n\nfunction finalizeNumber(parser, inNumber) {\n  if (!parser.inNumber) throw new Error('Parser Error')\n  parser.number && parser.segment.push(parseFloat(parser.number))\n  parser.inNumber = inNumber\n  parser.number = ''\n  parser.pointSeen = false\n  parser.hasExponent = false\n\n  if (segmentComplete(parser)) {\n    finalizeSegment(parser)\n  }\n}\n\nfunction finalizeSegment(parser) {\n  parser.inSegment = false\n  if (parser.absolute) {\n    parser.segment = makeAbsolut(parser)\n  }\n  parser.segments.push(parser.segment)\n}\n\nfunction isArcFlag(parser) {\n  if (!parser.segment.length) return false\n  const isArc = parser.segment[0].toUpperCase() === 'A'\n  const length = parser.segment.length\n\n  return isArc && (length === 4 || length === 5)\n}\n\nfunction isExponential(parser) {\n  return parser.lastToken.toUpperCase() === 'E'\n}\n\nconst pathDelimiters = new Set([' ', ',', '\\t', '\\n', '\\r', '\\f'])\nfunction pathParser(d, toAbsolute = true) {\n  let index = 0\n  let token = ''\n  const parser = {\n    segment: [],\n    inNumber: false,\n    number: '',\n    lastToken: '',\n    inSegment: false,\n    segments: [],\n    pointSeen: false,\n    hasExponent: false,\n    absolute: toAbsolute,\n    p0: new Point(),\n    p: new Point()\n  }\n\n  while (((parser.lastToken = token), (token = d.charAt(index++)))) {\n    if (!parser.inSegment) {\n      if (startNewSegment(parser, token)) {\n        continue\n      }\n    }\n\n    if (token === '.') {\n      if (parser.pointSeen || parser.hasExponent) {\n        finalizeNumber(parser, false)\n        --index\n        continue\n      }\n      parser.inNumber = true\n      parser.pointSeen = true\n      parser.number += token\n      continue\n    }\n\n    if (!isNaN(parseInt(token))) {\n      if (parser.number === '0' || isArcFlag(parser)) {\n        parser.inNumber = true\n        parser.number = token\n        finalizeNumber(parser, true)\n        continue\n      }\n\n      parser.inNumber = true\n      parser.number += token\n      continue\n    }\n\n    if (pathDelimiters.has(token)) {\n      if (parser.inNumber) {\n        finalizeNumber(parser, false)\n      }\n      continue\n    }\n\n    if (token === '-' || token === '+') {\n      if (parser.inNumber && !isExponential(parser)) {\n        finalizeNumber(parser, false)\n        --index\n        continue\n      }\n      parser.number += token\n      parser.inNumber = true\n      continue\n    }\n\n    if (token.toUpperCase() === 'E') {\n      parser.number += token\n      parser.hasExponent = true\n      continue\n    }\n\n    if (isPathLetter.test(token)) {\n      if (parser.inNumber) {\n        finalizeNumber(parser, false)\n      } else if (!segmentComplete(parser)) {\n        throw new Error('parser Error')\n      } else {\n        finalizeSegment(parser)\n      }\n      --index\n    }\n  }\n\n  if (parser.inNumber) {\n    finalizeNumber(parser, false)\n  }\n\n  if (parser.inSegment && segmentComplete(parser)) {\n    finalizeSegment(parser)\n  }\n\n  return parser.segments\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/types/PathArray.js\n\n\n\n\n\nfunction arrayToString(a) {\n  let s = ''\n  for (let i = 0, il = a.length; i < il; i++) {\n    s += a[i][0]\n\n    if (a[i][1] != null) {\n      s += a[i][1]\n\n      if (a[i][2] != null) {\n        s += ' '\n        s += a[i][2]\n\n        if (a[i][3] != null) {\n          s += ' '\n          s += a[i][3]\n          s += ' '\n          s += a[i][4]\n\n          if (a[i][5] != null) {\n            s += ' '\n            s += a[i][5]\n            s += ' '\n            s += a[i][6]\n\n            if (a[i][7] != null) {\n              s += ' '\n              s += a[i][7]\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return s + ' '\n}\n\nclass PathArray extends SVGArray {\n  // Get bounding box of path\n  bbox() {\n    parser().path.setAttribute('d', this.toString())\n    return new Box(parser.nodes.path.getBBox())\n  }\n\n  // Move path string\n  move(x, y) {\n    // get bounding box of current situation\n    const box = this.bbox()\n\n    // get relative offset\n    x -= box.x\n    y -= box.y\n\n    if (!isNaN(x) && !isNaN(y)) {\n      // move every point\n      for (let l, i = this.length - 1; i >= 0; i--) {\n        l = this[i][0]\n\n        if (l === 'M' || l === 'L' || l === 'T') {\n          this[i][1] += x\n          this[i][2] += y\n        } else if (l === 'H') {\n          this[i][1] += x\n        } else if (l === 'V') {\n          this[i][1] += y\n        } else if (l === 'C' || l === 'S' || l === 'Q') {\n          this[i][1] += x\n          this[i][2] += y\n          this[i][3] += x\n          this[i][4] += y\n\n          if (l === 'C') {\n            this[i][5] += x\n            this[i][6] += y\n          }\n        } else if (l === 'A') {\n          this[i][6] += x\n          this[i][7] += y\n        }\n      }\n    }\n\n    return this\n  }\n\n  // Absolutize and parse path to array\n  parse(d = 'M0 0') {\n    if (Array.isArray(d)) {\n      d = Array.prototype.concat.apply([], d).toString()\n    }\n\n    return pathParser(d)\n  }\n\n  // Resize path string\n  size(width, height) {\n    // get bounding box of current situation\n    const box = this.bbox()\n    let i, l\n\n    // If the box width or height is 0 then we ignore\n    // transformations on the respective axis\n    box.width = box.width === 0 ? 1 : box.width\n    box.height = box.height === 0 ? 1 : box.height\n\n    // recalculate position of all points according to new size\n    for (i = this.length - 1; i >= 0; i--) {\n      l = this[i][0]\n\n      if (l === 'M' || l === 'L' || l === 'T') {\n        this[i][1] = ((this[i][1] - box.x) * width) / box.width + box.x\n        this[i][2] = ((this[i][2] - box.y) * height) / box.height + box.y\n      } else if (l === 'H') {\n        this[i][1] = ((this[i][1] - box.x) * width) / box.width + box.x\n      } else if (l === 'V') {\n        this[i][1] = ((this[i][1] - box.y) * height) / box.height + box.y\n      } else if (l === 'C' || l === 'S' || l === 'Q') {\n        this[i][1] = ((this[i][1] - box.x) * width) / box.width + box.x\n        this[i][2] = ((this[i][2] - box.y) * height) / box.height + box.y\n        this[i][3] = ((this[i][3] - box.x) * width) / box.width + box.x\n        this[i][4] = ((this[i][4] - box.y) * height) / box.height + box.y\n\n        if (l === 'C') {\n          this[i][5] = ((this[i][5] - box.x) * width) / box.width + box.x\n          this[i][6] = ((this[i][6] - box.y) * height) / box.height + box.y\n        }\n      } else if (l === 'A') {\n        // resize radii\n        this[i][1] = (this[i][1] * width) / box.width\n        this[i][2] = (this[i][2] * height) / box.height\n\n        // move position values\n        this[i][6] = ((this[i][6] - box.x) * width) / box.width + box.x\n        this[i][7] = ((this[i][7] - box.y) * height) / box.height + box.y\n      }\n    }\n\n    return this\n  }\n\n  // Convert array to string\n  toString() {\n    return arrayToString(this)\n  }\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/animation/Morphable.js\n\n\n\n\n\n\n\n\nconst getClassForType = (value) => {\n  const type = typeof value\n\n  if (type === 'number') {\n    return SVGNumber\n  } else if (type === 'string') {\n    if (Color.isColor(value)) {\n      return Color\n    } else if (delimiter.test(value)) {\n      return isPathLetter.test(value) ? PathArray : SVGArray\n    } else if (numberAndUnit.test(value)) {\n      return SVGNumber\n    } else {\n      return NonMorphable\n    }\n  } else if (morphableTypes.indexOf(value.constructor) > -1) {\n    return value.constructor\n  } else if (Array.isArray(value)) {\n    return SVGArray\n  } else if (type === 'object') {\n    return ObjectBag\n  } else {\n    return NonMorphable\n  }\n}\n\nclass Morphable {\n  constructor(stepper) {\n    this._stepper = stepper || new Ease('-')\n\n    this._from = null\n    this._to = null\n    this._type = null\n    this._context = null\n    this._morphObj = null\n  }\n\n  at(pos) {\n    return this._morphObj.morph(\n      this._from,\n      this._to,\n      pos,\n      this._stepper,\n      this._context\n    )\n  }\n\n  done() {\n    const complete = this._context.map(this._stepper.done).reduce(function (\n      last,\n      curr\n    ) {\n      return last && curr\n    }, true)\n    return complete\n  }\n\n  from(val) {\n    if (val == null) {\n      return this._from\n    }\n\n    this._from = this._set(val)\n    return this\n  }\n\n  stepper(stepper) {\n    if (stepper == null) return this._stepper\n    this._stepper = stepper\n    return this\n  }\n\n  to(val) {\n    if (val == null) {\n      return this._to\n    }\n\n    this._to = this._set(val)\n    return this\n  }\n\n  type(type) {\n    // getter\n    if (type == null) {\n      return this._type\n    }\n\n    // setter\n    this._type = type\n    return this\n  }\n\n  _set(value) {\n    if (!this._type) {\n      this.type(getClassForType(value))\n    }\n\n    let result = new this._type(value)\n    if (this._type === Color) {\n      result = this._to\n        ? result[this._to[4]]()\n        : this._from\n          ? result[this._from[4]]()\n          : result\n    }\n\n    if (this._type === ObjectBag) {\n      result = this._to\n        ? result.align(this._to)\n        : this._from\n          ? result.align(this._from)\n          : result\n    }\n\n    result = result.toConsumable()\n\n    this._morphObj = this._morphObj || new this._type()\n    this._context =\n      this._context ||\n      Array.apply(null, Array(result.length))\n        .map(Object)\n        .map(function (o) {\n          o.done = true\n          return o\n        })\n    return result\n  }\n}\n\nclass NonMorphable {\n  constructor(...args) {\n    this.init(...args)\n  }\n\n  init(val) {\n    val = Array.isArray(val) ? val[0] : val\n    this.value = val\n    return this\n  }\n\n  toArray() {\n    return [this.value]\n  }\n\n  valueOf() {\n    return this.value\n  }\n}\n\nclass TransformBag {\n  constructor(...args) {\n    this.init(...args)\n  }\n\n  init(obj) {\n    if (Array.isArray(obj)) {\n      obj = {\n        scaleX: obj[0],\n        scaleY: obj[1],\n        shear: obj[2],\n        rotate: obj[3],\n        translateX: obj[4],\n        translateY: obj[5],\n        originX: obj[6],\n        originY: obj[7]\n      }\n    }\n\n    Object.assign(this, TransformBag.defaults, obj)\n    return this\n  }\n\n  toArray() {\n    const v = this\n\n    return [\n      v.scaleX,\n      v.scaleY,\n      v.shear,\n      v.rotate,\n      v.translateX,\n      v.translateY,\n      v.originX,\n      v.originY\n    ]\n  }\n}\n\nTransformBag.defaults = {\n  scaleX: 1,\n  scaleY: 1,\n  shear: 0,\n  rotate: 0,\n  translateX: 0,\n  translateY: 0,\n  originX: 0,\n  originY: 0\n}\n\nconst sortByKey = (a, b) => {\n  return a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0\n}\n\nclass ObjectBag {\n  constructor(...args) {\n    this.init(...args)\n  }\n\n  align(other) {\n    const values = this.values\n    for (let i = 0, il = values.length; i < il; ++i) {\n      // If the type is the same we only need to check if the color is in the correct format\n      if (values[i + 1] === other[i + 1]) {\n        if (values[i + 1] === Color && other[i + 7] !== values[i + 7]) {\n          const space = other[i + 7]\n          const color = new Color(this.values.splice(i + 3, 5))\n            [space]()\n            .toArray()\n          this.values.splice(i + 3, 0, ...color)\n        }\n\n        i += values[i + 2] + 2\n        continue\n      }\n\n      if (!other[i + 1]) {\n        return this\n      }\n\n      // The types differ, so we overwrite the new type with the old one\n      // And initialize it with the types default (e.g. black for color or 0 for number)\n      const defaultObject = new other[i + 1]().toArray()\n\n      // Than we fix the values array\n      const toDelete = values[i + 2] + 3\n\n      values.splice(\n        i,\n        toDelete,\n        other[i],\n        other[i + 1],\n        other[i + 2],\n        ...defaultObject\n      )\n\n      i += values[i + 2] + 2\n    }\n    return this\n  }\n\n  init(objOrArr) {\n    this.values = []\n\n    if (Array.isArray(objOrArr)) {\n      this.values = objOrArr.slice()\n      return\n    }\n\n    objOrArr = objOrArr || {}\n    const entries = []\n\n    for (const i in objOrArr) {\n      const Type = getClassForType(objOrArr[i])\n      const val = new Type(objOrArr[i]).toArray()\n      entries.push([i, Type, val.length, ...val])\n    }\n\n    entries.sort(sortByKey)\n\n    this.values = entries.reduce((last, curr) => last.concat(curr), [])\n    return this\n  }\n\n  toArray() {\n    return this.values\n  }\n\n  valueOf() {\n    const obj = {}\n    const arr = this.values\n\n    // for (var i = 0, len = arr.length; i < len; i += 2) {\n    while (arr.length) {\n      const key = arr.shift()\n      const Type = arr.shift()\n      const num = arr.shift()\n      const values = arr.splice(0, num)\n      obj[key] = new Type(values) // .valueOf()\n    }\n\n    return obj\n  }\n}\n\nconst morphableTypes = [NonMorphable, TransformBag, ObjectBag]\n\nfunction registerMorphableType(type = []) {\n  morphableTypes.push(...[].concat(type))\n}\n\nfunction makeMorphable() {\n  extend(morphableTypes, {\n    to(val) {\n      return new Morphable()\n        .type(this.constructor)\n        .from(this.toArray()) // this.valueOf())\n        .to(val)\n    },\n    fromArray(arr) {\n      this.init(arr)\n      return this\n    },\n    toConsumable() {\n      return this.toArray()\n    },\n    morph(from, to, pos, stepper, context) {\n      const mapper = function (i, index) {\n        return stepper.step(i, to[index], pos, context[index], context)\n      }\n\n      return this.fromArray(from.map(mapper))\n    }\n  })\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Path.js\n\n\n\n\n\n\nclass Path extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('path', node), attrs)\n  }\n\n  // Get array\n  array() {\n    return this._array || (this._array = new PathArray(this.attr('d')))\n  }\n\n  // Clear array cache\n  clear() {\n    delete this._array\n    return this\n  }\n\n  // Set height of element\n  height(height) {\n    return height == null\n      ? this.bbox().height\n      : this.size(this.bbox().width, height)\n  }\n\n  // Move by left top corner\n  move(x, y) {\n    return this.attr('d', this.array().move(x, y))\n  }\n\n  // Plot new path\n  plot(d) {\n    return d == null\n      ? this.array()\n      : this.clear().attr(\n          'd',\n          typeof d === 'string' ? d : (this._array = new PathArray(d))\n        )\n  }\n\n  // Set element size to given width and height\n  size(width, height) {\n    const p = proportionalSize(this, width, height)\n    return this.attr('d', this.array().size(p.width, p.height))\n  }\n\n  // Set width of element\n  width(width) {\n    return width == null\n      ? this.bbox().width\n      : this.size(width, this.bbox().height)\n  }\n\n  // Move by left top corner over x-axis\n  x(x) {\n    return x == null ? this.bbox().x : this.move(x, this.bbox().y)\n  }\n\n  // Move by left top corner over y-axis\n  y(y) {\n    return y == null ? this.bbox().y : this.move(this.bbox().x, y)\n  }\n}\n\n// Define morphable array\nPath.prototype.MorphArray = PathArray\n\n// Add parent method\nregisterMethods({\n  Container: {\n    // Create a wrapped path element\n    path: wrapWithAttrCheck(function (d) {\n      // make sure plot is called as a setter\n      return this.put(new Path()).plot(d || new PathArray())\n    })\n  }\n})\n\nregister(Path, 'Path')\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/poly.js\n\n\n\n// Get array\nfunction array() {\n  return this._array || (this._array = new PointArray(this.attr('points')))\n}\n\n// Clear array cache\nfunction clear() {\n  delete this._array\n  return this\n}\n\n// Move by left top corner\nfunction move(x, y) {\n  return this.attr('points', this.array().move(x, y))\n}\n\n// Plot new path\nfunction plot(p) {\n  return p == null\n    ? this.array()\n    : this.clear().attr(\n        'points',\n        typeof p === 'string' ? p : (this._array = new PointArray(p))\n      )\n}\n\n// Set element size to given width and height\nfunction size(width, height) {\n  const p = proportionalSize(this, width, height)\n  return this.attr('points', this.array().size(p.width, p.height))\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Polygon.js\n\n\n\n\n\n\n\nclass Polygon extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('polygon', node), attrs)\n  }\n}\n\nregisterMethods({\n  Container: {\n    // Create a wrapped polygon element\n    polygon: wrapWithAttrCheck(function (p) {\n      // make sure plot is called as a setter\n      return this.put(new Polygon()).plot(p || new PointArray())\n    })\n  }\n})\n\nextend(Polygon, pointed_namespaceObject)\nextend(Polygon, poly_namespaceObject)\nregister(Polygon, 'Polygon')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Polyline.js\n\n\n\n\n\n\n\nclass Polyline extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('polyline', node), attrs)\n  }\n}\n\nregisterMethods({\n  Container: {\n    // Create a wrapped polygon element\n    polyline: wrapWithAttrCheck(function (p) {\n      // make sure plot is called as a setter\n      return this.put(new Polyline()).plot(p || new PointArray())\n    })\n  }\n})\n\nextend(Polyline, pointed_namespaceObject)\nextend(Polyline, poly_namespaceObject)\nregister(Polyline, 'Polyline')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Rect.js\n\n\n\n\n\nclass Rect extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('rect', node), attrs)\n  }\n}\n\nextend(Rect, { rx: rx, ry: ry })\n\nregisterMethods({\n  Container: {\n    // Create a rect element\n    rect: wrapWithAttrCheck(function (width, height) {\n      return this.put(new Rect()).size(width, height)\n    })\n  }\n})\n\nregister(Rect, 'Rect')\n\n;// ./node_modules/@svgdotjs/svg.js/src/animation/Queue.js\nclass Queue {\n  constructor() {\n    this._first = null\n    this._last = null\n  }\n\n  // Shows us the first item in the list\n  first() {\n    return this._first && this._first.value\n  }\n\n  // Shows us the last item in the list\n  last() {\n    return this._last && this._last.value\n  }\n\n  push(value) {\n    // An item stores an id and the provided value\n    const item =\n      typeof value.next !== 'undefined'\n        ? value\n        : { value: value, next: null, prev: null }\n\n    // Deal with the queue being empty or populated\n    if (this._last) {\n      item.prev = this._last\n      this._last.next = item\n      this._last = item\n    } else {\n      this._last = item\n      this._first = item\n    }\n\n    // Return the current item\n    return item\n  }\n\n  // Removes the item that was returned from the push\n  remove(item) {\n    // Relink the previous item\n    if (item.prev) item.prev.next = item.next\n    if (item.next) item.next.prev = item.prev\n    if (item === this._last) this._last = item.prev\n    if (item === this._first) this._first = item.next\n\n    // Invalidate item\n    item.prev = null\n    item.next = null\n  }\n\n  shift() {\n    // Check if we have a value\n    const remove = this._first\n    if (!remove) return null\n\n    // If we do, remove it and relink things\n    this._first = remove.next\n    if (this._first) this._first.prev = null\n    this._last = this._first ? this._last : null\n    return remove.value\n  }\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/animation/Animator.js\n\n\n\nconst Animator = {\n  nextDraw: null,\n  frames: new Queue(),\n  timeouts: new Queue(),\n  immediates: new Queue(),\n  timer: () => globals.window.performance || globals.window.Date,\n  transforms: [],\n\n  frame(fn) {\n    // Store the node\n    const node = Animator.frames.push({ run: fn })\n\n    // Request an animation frame if we don't have one\n    if (Animator.nextDraw === null) {\n      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw)\n    }\n\n    // Return the node so we can remove it easily\n    return node\n  },\n\n  timeout(fn, delay) {\n    delay = delay || 0\n\n    // Work out when the event should fire\n    const time = Animator.timer().now() + delay\n\n    // Add the timeout to the end of the queue\n    const node = Animator.timeouts.push({ run: fn, time: time })\n\n    // Request another animation frame if we need one\n    if (Animator.nextDraw === null) {\n      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw)\n    }\n\n    return node\n  },\n\n  immediate(fn) {\n    // Add the immediate fn to the end of the queue\n    const node = Animator.immediates.push(fn)\n    // Request another animation frame if we need one\n    if (Animator.nextDraw === null) {\n      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw)\n    }\n\n    return node\n  },\n\n  cancelFrame(node) {\n    node != null && Animator.frames.remove(node)\n  },\n\n  clearTimeout(node) {\n    node != null && Animator.timeouts.remove(node)\n  },\n\n  cancelImmediate(node) {\n    node != null && Animator.immediates.remove(node)\n  },\n\n  _draw(now) {\n    // Run all the timeouts we can run, if they are not ready yet, add them\n    // to the end of the queue immediately! (bad timeouts!!! [sarcasm])\n    let nextTimeout = null\n    const lastTimeout = Animator.timeouts.last()\n    while ((nextTimeout = Animator.timeouts.shift())) {\n      // Run the timeout if its time, or push it to the end\n      if (now >= nextTimeout.time) {\n        nextTimeout.run()\n      } else {\n        Animator.timeouts.push(nextTimeout)\n      }\n\n      // If we hit the last item, we should stop shifting out more items\n      if (nextTimeout === lastTimeout) break\n    }\n\n    // Run all of the animation frames\n    let nextFrame = null\n    const lastFrame = Animator.frames.last()\n    while (nextFrame !== lastFrame && (nextFrame = Animator.frames.shift())) {\n      nextFrame.run(now)\n    }\n\n    let nextImmediate = null\n    while ((nextImmediate = Animator.immediates.shift())) {\n      nextImmediate()\n    }\n\n    // If we have remaining timeouts or frames, draw until we don't anymore\n    Animator.nextDraw =\n      Animator.timeouts.first() || Animator.frames.first()\n        ? globals.window.requestAnimationFrame(Animator._draw)\n        : null\n  }\n}\n\n/* harmony default export */ const animation_Animator = (Animator);\n\n;// ./node_modules/@svgdotjs/svg.js/src/animation/Timeline.js\n\n\n\n\n\nconst makeSchedule = function (runnerInfo) {\n  const start = runnerInfo.start\n  const duration = runnerInfo.runner.duration()\n  const end = start + duration\n  return {\n    start: start,\n    duration: duration,\n    end: end,\n    runner: runnerInfo.runner\n  }\n}\n\nconst defaultSource = function () {\n  const w = globals.window\n  return (w.performance || w.Date).now()\n}\n\nclass Timeline extends EventTarget {\n  // Construct a new timeline on the given element\n  constructor(timeSource = defaultSource) {\n    super()\n\n    this._timeSource = timeSource\n\n    // terminate resets all variables to their initial state\n    this.terminate()\n  }\n\n  active() {\n    return !!this._nextFrame\n  }\n\n  finish() {\n    // Go to end and pause\n    this.time(this.getEndTimeOfTimeline() + 1)\n    return this.pause()\n  }\n\n  // Calculates the end of the timeline\n  getEndTime() {\n    const lastRunnerInfo = this.getLastRunnerInfo()\n    const lastDuration = lastRunnerInfo ? lastRunnerInfo.runner.duration() : 0\n    const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time\n    return lastStartTime + lastDuration\n  }\n\n  getEndTimeOfTimeline() {\n    const endTimes = this._runners.map((i) => i.start + i.runner.duration())\n    return Math.max(0, ...endTimes)\n  }\n\n  getLastRunnerInfo() {\n    return this.getRunnerInfoById(this._lastRunnerId)\n  }\n\n  getRunnerInfoById(id) {\n    return this._runners[this._runnerIds.indexOf(id)] || null\n  }\n\n  pause() {\n    this._paused = true\n    return this._continue()\n  }\n\n  persist(dtOrForever) {\n    if (dtOrForever == null) return this._persist\n    this._persist = dtOrForever\n    return this\n  }\n\n  play() {\n    // Now make sure we are not paused and continue the animation\n    this._paused = false\n    return this.updateTime()._continue()\n  }\n\n  reverse(yes) {\n    const currentSpeed = this.speed()\n    if (yes == null) return this.speed(-currentSpeed)\n\n    const positive = Math.abs(currentSpeed)\n    return this.speed(yes ? -positive : positive)\n  }\n\n  // schedules a runner on the timeline\n  schedule(runner, delay, when) {\n    if (runner == null) {\n      return this._runners.map(makeSchedule)\n    }\n\n    // The start time for the next animation can either be given explicitly,\n    // derived from the current timeline time or it can be relative to the\n    // last start time to chain animations directly\n\n    let absoluteStartTime = 0\n    const endTime = this.getEndTime()\n    delay = delay || 0\n\n    // Work out when to start the animation\n    if (when == null || when === 'last' || when === 'after') {\n      // Take the last time and increment\n      absoluteStartTime = endTime\n    } else if (when === 'absolute' || when === 'start') {\n      absoluteStartTime = delay\n      delay = 0\n    } else if (when === 'now') {\n      absoluteStartTime = this._time\n    } else if (when === 'relative') {\n      const runnerInfo = this.getRunnerInfoById(runner.id)\n      if (runnerInfo) {\n        absoluteStartTime = runnerInfo.start + delay\n        delay = 0\n      }\n    } else if (when === 'with-last') {\n      const lastRunnerInfo = this.getLastRunnerInfo()\n      const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time\n      absoluteStartTime = lastStartTime\n    } else {\n      throw new Error('Invalid value for the \"when\" parameter')\n    }\n\n    // Manage runner\n    runner.unschedule()\n    runner.timeline(this)\n\n    const persist = runner.persist()\n    const runnerInfo = {\n      persist: persist === null ? this._persist : persist,\n      start: absoluteStartTime + delay,\n      runner\n    }\n\n    this._lastRunnerId = runner.id\n\n    this._runners.push(runnerInfo)\n    this._runners.sort((a, b) => a.start - b.start)\n    this._runnerIds = this._runners.map((info) => info.runner.id)\n\n    this.updateTime()._continue()\n    return this\n  }\n\n  seek(dt) {\n    return this.time(this._time + dt)\n  }\n\n  source(fn) {\n    if (fn == null) return this._timeSource\n    this._timeSource = fn\n    return this\n  }\n\n  speed(speed) {\n    if (speed == null) return this._speed\n    this._speed = speed\n    return this\n  }\n\n  stop() {\n    // Go to start and pause\n    this.time(0)\n    return this.pause()\n  }\n\n  time(time) {\n    if (time == null) return this._time\n    this._time = time\n    return this._continue(true)\n  }\n\n  // Remove the runner from this timeline\n  unschedule(runner) {\n    const index = this._runnerIds.indexOf(runner.id)\n    if (index < 0) return this\n\n    this._runners.splice(index, 1)\n    this._runnerIds.splice(index, 1)\n\n    runner.timeline(null)\n    return this\n  }\n\n  // Makes sure, that after pausing the time doesn't jump\n  updateTime() {\n    if (!this.active()) {\n      this._lastSourceTime = this._timeSource()\n    }\n    return this\n  }\n\n  // Checks if we are running and continues the animation\n  _continue(immediateStep = false) {\n    animation_Animator.cancelFrame(this._nextFrame)\n    this._nextFrame = null\n\n    if (immediateStep) return this._stepImmediate()\n    if (this._paused) return this\n\n    this._nextFrame = animation_Animator.frame(this._step)\n    return this\n  }\n\n  _stepFn(immediateStep = false) {\n    // Get the time delta from the last time and update the time\n    const time = this._timeSource()\n    let dtSource = time - this._lastSourceTime\n\n    if (immediateStep) dtSource = 0\n\n    const dtTime = this._speed * dtSource + (this._time - this._lastStepTime)\n    this._lastSourceTime = time\n\n    // Only update the time if we use the timeSource.\n    // Otherwise use the current time\n    if (!immediateStep) {\n      // Update the time\n      this._time += dtTime\n      this._time = this._time < 0 ? 0 : this._time\n    }\n    this._lastStepTime = this._time\n    this.fire('time', this._time)\n\n    // This is for the case that the timeline was seeked so that the time\n    // is now before the startTime of the runner. That is why we need to set\n    // the runner to position 0\n\n    // FIXME:\n    // However, resetting in insertion order leads to bugs. Considering the case,\n    // where 2 runners change the same attribute but in different times,\n    // resetting both of them will lead to the case where the later defined\n    // runner always wins the reset even if the other runner started earlier\n    // and therefore should win the attribute battle\n    // this can be solved by resetting them backwards\n    for (let k = this._runners.length; k--; ) {\n      // Get and run the current runner and ignore it if its inactive\n      const runnerInfo = this._runners[k]\n      const runner = runnerInfo.runner\n\n      // Make sure that we give the actual difference\n      // between runner start time and now\n      const dtToStart = this._time - runnerInfo.start\n\n      // Dont run runner if not started yet\n      // and try to reset it\n      if (dtToStart <= 0) {\n        runner.reset()\n      }\n    }\n\n    // Run all of the runners directly\n    let runnersLeft = false\n    for (let i = 0, len = this._runners.length; i < len; i++) {\n      // Get and run the current runner and ignore it if its inactive\n      const runnerInfo = this._runners[i]\n      const runner = runnerInfo.runner\n      let dt = dtTime\n\n      // Make sure that we give the actual difference\n      // between runner start time and now\n      const dtToStart = this._time - runnerInfo.start\n\n      // Dont run runner if not started yet\n      if (dtToStart <= 0) {\n        runnersLeft = true\n        continue\n      } else if (dtToStart < dt) {\n        // Adjust dt to make sure that animation is on point\n        dt = dtToStart\n      }\n\n      if (!runner.active()) continue\n\n      // If this runner is still going, signal that we need another animation\n      // frame, otherwise, remove the completed runner\n      const finished = runner.step(dt).done\n      if (!finished) {\n        runnersLeft = true\n        // continue\n      } else if (runnerInfo.persist !== true) {\n        // runner is finished. And runner might get removed\n        const endTime = runner.duration() - runner.time() + this._time\n\n        if (endTime + runnerInfo.persist < this._time) {\n          // Delete runner and correct index\n          runner.unschedule()\n          --i\n          --len\n        }\n      }\n    }\n\n    // Basically: we continue when there are runners right from us in time\n    // when --\x3e, and when runners are left from us when <--\n    if (\n      (runnersLeft && !(this._speed < 0 && this._time === 0)) ||\n      (this._runnerIds.length && this._speed < 0 && this._time > 0)\n    ) {\n      this._continue()\n    } else {\n      this.pause()\n      this.fire('finished')\n    }\n\n    return this\n  }\n\n  terminate() {\n    // cleanup memory\n\n    // Store the timing variables\n    this._startTime = 0\n    this._speed = 1.0\n\n    // Determines how long a runner is hold in memory. Can be a dt or true/false\n    this._persist = 0\n\n    // Keep track of the running animations and their starting parameters\n    this._nextFrame = null\n    this._paused = true\n    this._runners = []\n    this._runnerIds = []\n    this._lastRunnerId = -1\n    this._time = 0\n    this._lastSourceTime = 0\n    this._lastStepTime = 0\n\n    // Make sure that step is always called in class context\n    this._step = this._stepFn.bind(this, false)\n    this._stepImmediate = this._stepFn.bind(this, true)\n  }\n}\n\nregisterMethods({\n  Element: {\n    timeline: function (timeline) {\n      if (timeline == null) {\n        this._timeline = this._timeline || new Timeline()\n        return this._timeline\n      } else {\n        this._timeline = timeline\n        return this\n      }\n    }\n  }\n})\n\n;// ./node_modules/@svgdotjs/svg.js/src/animation/Runner.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Runner extends EventTarget {\n  constructor(options) {\n    super()\n\n    // Store a unique id on the runner, so that we can identify it later\n    this.id = Runner.id++\n\n    // Ensure a default value\n    options = options == null ? timeline.duration : options\n\n    // Ensure that we get a controller\n    options = typeof options === 'function' ? new Controller(options) : options\n\n    // Declare all of the variables\n    this._element = null\n    this._timeline = null\n    this.done = false\n    this._queue = []\n\n    // Work out the stepper and the duration\n    this._duration = typeof options === 'number' && options\n    this._isDeclarative = options instanceof Controller\n    this._stepper = this._isDeclarative ? options : new Ease()\n\n    // We copy the current values from the timeline because they can change\n    this._history = {}\n\n    // Store the state of the runner\n    this.enabled = true\n    this._time = 0\n    this._lastTime = 0\n\n    // At creation, the runner is in reset state\n    this._reseted = true\n\n    // Save transforms applied to this runner\n    this.transforms = new Matrix()\n    this.transformId = 1\n\n    // Looping variables\n    this._haveReversed = false\n    this._reverse = false\n    this._loopsDone = 0\n    this._swing = false\n    this._wait = 0\n    this._times = 1\n\n    this._frameId = null\n\n    // Stores how long a runner is stored after being done\n    this._persist = this._isDeclarative ? true : null\n  }\n\n  static sanitise(duration, delay, when) {\n    // Initialise the default parameters\n    let times = 1\n    let swing = false\n    let wait = 0\n    duration = duration ?? timeline.duration\n    delay = delay ?? timeline.delay\n    when = when || 'last'\n\n    // If we have an object, unpack the values\n    if (typeof duration === 'object' && !(duration instanceof Stepper)) {\n      delay = duration.delay ?? delay\n      when = duration.when ?? when\n      swing = duration.swing || swing\n      times = duration.times ?? times\n      wait = duration.wait ?? wait\n      duration = duration.duration ?? timeline.duration\n    }\n\n    return {\n      duration: duration,\n      delay: delay,\n      swing: swing,\n      times: times,\n      wait: wait,\n      when: when\n    }\n  }\n\n  active(enabled) {\n    if (enabled == null) return this.enabled\n    this.enabled = enabled\n    return this\n  }\n\n  /*\n  Private Methods\n  ===============\n  Methods that shouldn't be used externally\n  */\n  addTransform(transform) {\n    this.transforms.lmultiplyO(transform)\n    return this\n  }\n\n  after(fn) {\n    return this.on('finished', fn)\n  }\n\n  animate(duration, delay, when) {\n    const o = Runner.sanitise(duration, delay, when)\n    const runner = new Runner(o.duration)\n    if (this._timeline) runner.timeline(this._timeline)\n    if (this._element) runner.element(this._element)\n    return runner.loop(o).schedule(o.delay, o.when)\n  }\n\n  clearTransform() {\n    this.transforms = new Matrix()\n    return this\n  }\n\n  // TODO: Keep track of all transformations so that deletion is faster\n  clearTransformsFromQueue() {\n    if (\n      !this.done ||\n      !this._timeline ||\n      !this._timeline._runnerIds.includes(this.id)\n    ) {\n      this._queue = this._queue.filter((item) => {\n        return !item.isTransform\n      })\n    }\n  }\n\n  delay(delay) {\n    return this.animate(0, delay)\n  }\n\n  duration() {\n    return this._times * (this._wait + this._duration) - this._wait\n  }\n\n  during(fn) {\n    return this.queue(null, fn)\n  }\n\n  ease(fn) {\n    this._stepper = new Ease(fn)\n    return this\n  }\n  /*\n  Runner Definitions\n  ==================\n  These methods help us define the runtime behaviour of the Runner or they\n  help us make new runners from the current runner\n  */\n\n  element(element) {\n    if (element == null) return this._element\n    this._element = element\n    element._prepareRunner()\n    return this\n  }\n\n  finish() {\n    return this.step(Infinity)\n  }\n\n  loop(times, swing, wait) {\n    // Deal with the user passing in an object\n    if (typeof times === 'object') {\n      swing = times.swing\n      wait = times.wait\n      times = times.times\n    }\n\n    // Sanitise the values and store them\n    this._times = times || Infinity\n    this._swing = swing || false\n    this._wait = wait || 0\n\n    // Allow true to be passed\n    if (this._times === true) {\n      this._times = Infinity\n    }\n\n    return this\n  }\n\n  loops(p) {\n    const loopDuration = this._duration + this._wait\n    if (p == null) {\n      const loopsDone = Math.floor(this._time / loopDuration)\n      const relativeTime = this._time - loopsDone * loopDuration\n      const position = relativeTime / this._duration\n      return Math.min(loopsDone + position, this._times)\n    }\n    const whole = Math.floor(p)\n    const partial = p % 1\n    const time = loopDuration * whole + this._duration * partial\n    return this.time(time)\n  }\n\n  persist(dtOrForever) {\n    if (dtOrForever == null) return this._persist\n    this._persist = dtOrForever\n    return this\n  }\n\n  position(p) {\n    // Get all of the variables we need\n    const x = this._time\n    const d = this._duration\n    const w = this._wait\n    const t = this._times\n    const s = this._swing\n    const r = this._reverse\n    let position\n\n    if (p == null) {\n      /*\n      This function converts a time to a position in the range [0, 1]\n      The full explanation can be found in this desmos demonstration\n        https://www.desmos.com/calculator/u4fbavgche\n      The logic is slightly simplified here because we can use booleans\n      */\n\n      // Figure out the value without thinking about the start or end time\n      const f = function (x) {\n        const swinging = s * Math.floor((x % (2 * (w + d))) / (w + d))\n        const backwards = (swinging && !r) || (!swinging && r)\n        const uncliped =\n          (Math.pow(-1, backwards) * (x % (w + d))) / d + backwards\n        const clipped = Math.max(Math.min(uncliped, 1), 0)\n        return clipped\n      }\n\n      // Figure out the value by incorporating the start time\n      const endTime = t * (w + d) - w\n      position =\n        x <= 0\n          ? Math.round(f(1e-5))\n          : x < endTime\n            ? f(x)\n            : Math.round(f(endTime - 1e-5))\n      return position\n    }\n\n    // Work out the loops done and add the position to the loops done\n    const loopsDone = Math.floor(this.loops())\n    const swingForward = s && loopsDone % 2 === 0\n    const forwards = (swingForward && !r) || (r && swingForward)\n    position = loopsDone + (forwards ? p : 1 - p)\n    return this.loops(position)\n  }\n\n  progress(p) {\n    if (p == null) {\n      return Math.min(1, this._time / this.duration())\n    }\n    return this.time(p * this.duration())\n  }\n\n  /*\n  Basic Functionality\n  ===================\n  These methods allow us to attach basic functions to the runner directly\n  */\n  queue(initFn, runFn, retargetFn, isTransform) {\n    this._queue.push({\n      initialiser: initFn || noop,\n      runner: runFn || noop,\n      retarget: retargetFn,\n      isTransform: isTransform,\n      initialised: false,\n      finished: false\n    })\n    const timeline = this.timeline()\n    timeline && this.timeline()._continue()\n    return this\n  }\n\n  reset() {\n    if (this._reseted) return this\n    this.time(0)\n    this._reseted = true\n    return this\n  }\n\n  reverse(reverse) {\n    this._reverse = reverse == null ? !this._reverse : reverse\n    return this\n  }\n\n  schedule(timeline, delay, when) {\n    // The user doesn't need to pass a timeline if we already have one\n    if (!(timeline instanceof Timeline)) {\n      when = delay\n      delay = timeline\n      timeline = this.timeline()\n    }\n\n    // If there is no timeline, yell at the user...\n    if (!timeline) {\n      throw Error('Runner cannot be scheduled without timeline')\n    }\n\n    // Schedule the runner on the timeline provided\n    timeline.schedule(this, delay, when)\n    return this\n  }\n\n  step(dt) {\n    // If we are inactive, this stepper just gets skipped\n    if (!this.enabled) return this\n\n    // Update the time and get the new position\n    dt = dt == null ? 16 : dt\n    this._time += dt\n    const position = this.position()\n\n    // Figure out if we need to run the stepper in this frame\n    const running = this._lastPosition !== position && this._time >= 0\n    this._lastPosition = position\n\n    // Figure out if we just started\n    const duration = this.duration()\n    const justStarted = this._lastTime <= 0 && this._time > 0\n    const justFinished = this._lastTime < duration && this._time >= duration\n\n    this._lastTime = this._time\n    if (justStarted) {\n      this.fire('start', this)\n    }\n\n    // Work out if the runner is finished set the done flag here so animations\n    // know, that they are running in the last step (this is good for\n    // transformations which can be merged)\n    const declarative = this._isDeclarative\n    this.done = !declarative && !justFinished && this._time >= duration\n\n    // Runner is running. So its not in reset state anymore\n    this._reseted = false\n\n    let converged = false\n    // Call initialise and the run function\n    if (running || declarative) {\n      this._initialise(running)\n\n      // clear the transforms on this runner so they dont get added again and again\n      this.transforms = new Matrix()\n      converged = this._run(declarative ? dt : position)\n\n      this.fire('step', this)\n    }\n    // correct the done flag here\n    // declarative animations itself know when they converged\n    this.done = this.done || (converged && declarative)\n    if (justFinished) {\n      this.fire('finished', this)\n    }\n    return this\n  }\n\n  /*\n  Runner animation methods\n  ========================\n  Control how the animation plays\n  */\n  time(time) {\n    if (time == null) {\n      return this._time\n    }\n    const dt = time - this._time\n    this.step(dt)\n    return this\n  }\n\n  timeline(timeline) {\n    // check explicitly for undefined so we can set the timeline to null\n    if (typeof timeline === 'undefined') return this._timeline\n    this._timeline = timeline\n    return this\n  }\n\n  unschedule() {\n    const timeline = this.timeline()\n    timeline && timeline.unschedule(this)\n    return this\n  }\n\n  // Run each initialise function in the runner if required\n  _initialise(running) {\n    // If we aren't running, we shouldn't initialise when not declarative\n    if (!running && !this._isDeclarative) return\n\n    // Loop through all of the initialisers\n    for (let i = 0, len = this._queue.length; i < len; ++i) {\n      // Get the current initialiser\n      const current = this._queue[i]\n\n      // Determine whether we need to initialise\n      const needsIt = this._isDeclarative || (!current.initialised && running)\n      running = !current.finished\n\n      // Call the initialiser if we need to\n      if (needsIt && running) {\n        current.initialiser.call(this)\n        current.initialised = true\n      }\n    }\n  }\n\n  // Save a morpher to the morpher list so that we can retarget it later\n  _rememberMorpher(method, morpher) {\n    this._history[method] = {\n      morpher: morpher,\n      caller: this._queue[this._queue.length - 1]\n    }\n\n    // We have to resume the timeline in case a controller\n    // is already done without being ever run\n    // This can happen when e.g. this is done:\n    //    anim = el.animate(new SVG.Spring)\n    // and later\n    //    anim.move(...)\n    if (this._isDeclarative) {\n      const timeline = this.timeline()\n      timeline && timeline.play()\n    }\n  }\n\n  // Try to set the target for a morpher if the morpher exists, otherwise\n  // Run each run function for the position or dt given\n  _run(positionOrDt) {\n    // Run all of the _queue directly\n    let allfinished = true\n    for (let i = 0, len = this._queue.length; i < len; ++i) {\n      // Get the current function to run\n      const current = this._queue[i]\n\n      // Run the function if its not finished, we keep track of the finished\n      // flag for the sake of declarative _queue\n      const converged = current.runner.call(this, positionOrDt)\n      current.finished = current.finished || converged === true\n      allfinished = allfinished && current.finished\n    }\n\n    // We report when all of the constructors are finished\n    return allfinished\n  }\n\n  // do nothing and return false\n  _tryRetarget(method, target, extra) {\n    if (this._history[method]) {\n      // if the last method wasn't even initialised, throw it away\n      if (!this._history[method].caller.initialised) {\n        const index = this._queue.indexOf(this._history[method].caller)\n        this._queue.splice(index, 1)\n        return false\n      }\n\n      // for the case of transformations, we use the special retarget function\n      // which has access to the outer scope\n      if (this._history[method].caller.retarget) {\n        this._history[method].caller.retarget.call(this, target, extra)\n        // for everything else a simple morpher change is sufficient\n      } else {\n        this._history[method].morpher.to(target)\n      }\n\n      this._history[method].caller.finished = false\n      const timeline = this.timeline()\n      timeline && timeline.play()\n      return true\n    }\n    return false\n  }\n}\n\nRunner.id = 0\n\nclass FakeRunner {\n  constructor(transforms = new Matrix(), id = -1, done = true) {\n    this.transforms = transforms\n    this.id = id\n    this.done = done\n  }\n\n  clearTransformsFromQueue() {}\n}\n\nextend([Runner, FakeRunner], {\n  mergeWith(runner) {\n    return new FakeRunner(\n      runner.transforms.lmultiply(this.transforms),\n      runner.id\n    )\n  }\n})\n\n// FakeRunner.emptyRunner = new FakeRunner()\n\nconst lmultiply = (last, curr) => last.lmultiplyO(curr)\nconst getRunnerTransform = (runner) => runner.transforms\n\nfunction mergeTransforms() {\n  // Find the matrix to apply to the element and apply it\n  const runners = this._transformationRunners.runners\n  const netTransform = runners\n    .map(getRunnerTransform)\n    .reduce(lmultiply, new Matrix())\n\n  this.transform(netTransform)\n\n  this._transformationRunners.merge()\n\n  if (this._transformationRunners.length() === 1) {\n    this._frameId = null\n  }\n}\n\nclass RunnerArray {\n  constructor() {\n    this.runners = []\n    this.ids = []\n  }\n\n  add(runner) {\n    if (this.runners.includes(runner)) return\n    const id = runner.id + 1\n\n    this.runners.push(runner)\n    this.ids.push(id)\n\n    return this\n  }\n\n  clearBefore(id) {\n    const deleteCnt = this.ids.indexOf(id + 1) || 1\n    this.ids.splice(0, deleteCnt, 0)\n    this.runners\n      .splice(0, deleteCnt, new FakeRunner())\n      .forEach((r) => r.clearTransformsFromQueue())\n    return this\n  }\n\n  edit(id, newRunner) {\n    const index = this.ids.indexOf(id + 1)\n    this.ids.splice(index, 1, id + 1)\n    this.runners.splice(index, 1, newRunner)\n    return this\n  }\n\n  getByID(id) {\n    return this.runners[this.ids.indexOf(id + 1)]\n  }\n\n  length() {\n    return this.ids.length\n  }\n\n  merge() {\n    let lastRunner = null\n    for (let i = 0; i < this.runners.length; ++i) {\n      const runner = this.runners[i]\n\n      const condition =\n        lastRunner &&\n        runner.done &&\n        lastRunner.done &&\n        // don't merge runner when persisted on timeline\n        (!runner._timeline ||\n          !runner._timeline._runnerIds.includes(runner.id)) &&\n        (!lastRunner._timeline ||\n          !lastRunner._timeline._runnerIds.includes(lastRunner.id))\n\n      if (condition) {\n        // the +1 happens in the function\n        this.remove(runner.id)\n        const newRunner = runner.mergeWith(lastRunner)\n        this.edit(lastRunner.id, newRunner)\n        lastRunner = newRunner\n        --i\n      } else {\n        lastRunner = runner\n      }\n    }\n\n    return this\n  }\n\n  remove(id) {\n    const index = this.ids.indexOf(id + 1)\n    this.ids.splice(index, 1)\n    this.runners.splice(index, 1)\n    return this\n  }\n}\n\nregisterMethods({\n  Element: {\n    animate(duration, delay, when) {\n      const o = Runner.sanitise(duration, delay, when)\n      const timeline = this.timeline()\n      return new Runner(o.duration)\n        .loop(o)\n        .element(this)\n        .timeline(timeline.play())\n        .schedule(o.delay, o.when)\n    },\n\n    delay(by, when) {\n      return this.animate(0, by, when)\n    },\n\n    // this function searches for all runners on the element and deletes the ones\n    // which run before the current one. This is because absolute transformations\n    // overwrite anything anyway so there is no need to waste time computing\n    // other runners\n    _clearTransformRunnersBefore(currentRunner) {\n      this._transformationRunners.clearBefore(currentRunner.id)\n    },\n\n    _currentTransform(current) {\n      return (\n        this._transformationRunners.runners\n          // we need the equal sign here to make sure, that also transformations\n          // on the same runner which execute before the current transformation are\n          // taken into account\n          .filter((runner) => runner.id <= current.id)\n          .map(getRunnerTransform)\n          .reduce(lmultiply, new Matrix())\n      )\n    },\n\n    _addRunner(runner) {\n      this._transformationRunners.add(runner)\n\n      // Make sure that the runner merge is executed at the very end of\n      // all Animator functions. That is why we use immediate here to execute\n      // the merge right after all frames are run\n      animation_Animator.cancelImmediate(this._frameId)\n      this._frameId = animation_Animator.immediate(mergeTransforms.bind(this))\n    },\n\n    _prepareRunner() {\n      if (this._frameId == null) {\n        this._transformationRunners = new RunnerArray().add(\n          new FakeRunner(new Matrix(this))\n        )\n      }\n    }\n  }\n})\n\n// Will output the elements from array A that are not in the array B\nconst difference = (a, b) => a.filter((x) => !b.includes(x))\n\nextend(Runner, {\n  attr(a, v) {\n    return this.styleAttr('attr', a, v)\n  },\n\n  // Add animatable styles\n  css(s, v) {\n    return this.styleAttr('css', s, v)\n  },\n\n  styleAttr(type, nameOrAttrs, val) {\n    if (typeof nameOrAttrs === 'string') {\n      return this.styleAttr(type, { [nameOrAttrs]: val })\n    }\n\n    let attrs = nameOrAttrs\n    if (this._tryRetarget(type, attrs)) return this\n\n    let morpher = new Morphable(this._stepper).to(attrs)\n    let keys = Object.keys(attrs)\n\n    this.queue(\n      function () {\n        morpher = morpher.from(this.element()[type](keys))\n      },\n      function (pos) {\n        this.element()[type](morpher.at(pos).valueOf())\n        return morpher.done()\n      },\n      function (newToAttrs) {\n        // Check if any new keys were added\n        const newKeys = Object.keys(newToAttrs)\n        const differences = difference(newKeys, keys)\n\n        // If their are new keys, initialize them and add them to morpher\n        if (differences.length) {\n          // Get the values\n          const addedFromAttrs = this.element()[type](differences)\n\n          // Get the already initialized values\n          const oldFromAttrs = new ObjectBag(morpher.from()).valueOf()\n\n          // Merge old and new\n          Object.assign(oldFromAttrs, addedFromAttrs)\n          morpher.from(oldFromAttrs)\n        }\n\n        // Get the object from the morpher\n        const oldToAttrs = new ObjectBag(morpher.to()).valueOf()\n\n        // Merge in new attributes\n        Object.assign(oldToAttrs, newToAttrs)\n\n        // Change morpher target\n        morpher.to(oldToAttrs)\n\n        // Make sure that we save the work we did so we don't need it to do again\n        keys = newKeys\n        attrs = newToAttrs\n      }\n    )\n\n    this._rememberMorpher(type, morpher)\n    return this\n  },\n\n  zoom(level, point) {\n    if (this._tryRetarget('zoom', level, point)) return this\n\n    let morpher = new Morphable(this._stepper).to(new SVGNumber(level))\n\n    this.queue(\n      function () {\n        morpher = morpher.from(this.element().zoom())\n      },\n      function (pos) {\n        this.element().zoom(morpher.at(pos), point)\n        return morpher.done()\n      },\n      function (newLevel, newPoint) {\n        point = newPoint\n        morpher.to(newLevel)\n      }\n    )\n\n    this._rememberMorpher('zoom', morpher)\n    return this\n  },\n\n  /**\n   ** absolute transformations\n   **/\n\n  //\n  // M v -----|-----(D M v = F v)------|-----\x3e  T v\n  //\n  // 1. define the final state (T) and decompose it (once)\n  //    t = [tx, ty, the, lam, sy, sx]\n  // 2. on every frame: pull the current state of all previous transforms\n  //    (M - m can change)\n  //   and then write this as m = [tx0, ty0, the0, lam0, sy0, sx0]\n  // 3. Find the interpolated matrix F(pos) = m + pos * (t - m)\n  //   - Note F(0) = M\n  //   - Note F(1) = T\n  // 4. Now you get the delta matrix as a result: D = F * inv(M)\n\n  transform(transforms, relative, affine) {\n    // If we have a declarative function, we should retarget it if possible\n    relative = transforms.relative || relative\n    if (\n      this._isDeclarative &&\n      !relative &&\n      this._tryRetarget('transform', transforms)\n    ) {\n      return this\n    }\n\n    // Parse the parameters\n    const isMatrix = Matrix.isMatrixLike(transforms)\n    affine =\n      transforms.affine != null\n        ? transforms.affine\n        : affine != null\n          ? affine\n          : !isMatrix\n\n    // Create a morpher and set its type\n    const morpher = new Morphable(this._stepper).type(\n      affine ? TransformBag : Matrix\n    )\n\n    let origin\n    let element\n    let current\n    let currentAngle\n    let startTransform\n\n    function setup() {\n      // make sure element and origin is defined\n      element = element || this.element()\n      origin = origin || getOrigin(transforms, element)\n\n      startTransform = new Matrix(relative ? undefined : element)\n\n      // add the runner to the element so it can merge transformations\n      element._addRunner(this)\n\n      // Deactivate all transforms that have run so far if we are absolute\n      if (!relative) {\n        element._clearTransformRunnersBefore(this)\n      }\n    }\n\n    function run(pos) {\n      // clear all other transforms before this in case something is saved\n      // on this runner. We are absolute. We dont need these!\n      if (!relative) this.clearTransform()\n\n      const { x, y } = new Point(origin).transform(\n        element._currentTransform(this)\n      )\n\n      let target = new Matrix({ ...transforms, origin: [x, y] })\n      let start = this._isDeclarative && current ? current : startTransform\n\n      if (affine) {\n        target = target.decompose(x, y)\n        start = start.decompose(x, y)\n\n        // Get the current and target angle as it was set\n        const rTarget = target.rotate\n        const rCurrent = start.rotate\n\n        // Figure out the shortest path to rotate directly\n        const possibilities = [rTarget - 360, rTarget, rTarget + 360]\n        const distances = possibilities.map((a) => Math.abs(a - rCurrent))\n        const shortest = Math.min(...distances)\n        const index = distances.indexOf(shortest)\n        target.rotate = possibilities[index]\n      }\n\n      if (relative) {\n        // we have to be careful here not to overwrite the rotation\n        // with the rotate method of Matrix\n        if (!isMatrix) {\n          target.rotate = transforms.rotate || 0\n        }\n        if (this._isDeclarative && currentAngle) {\n          start.rotate = currentAngle\n        }\n      }\n\n      morpher.from(start)\n      morpher.to(target)\n\n      const affineParameters = morpher.at(pos)\n      currentAngle = affineParameters.rotate\n      current = new Matrix(affineParameters)\n\n      this.addTransform(current)\n      element._addRunner(this)\n      return morpher.done()\n    }\n\n    function retarget(newTransforms) {\n      // only get a new origin if it changed since the last call\n      if (\n        (newTransforms.origin || 'center').toString() !==\n        (transforms.origin || 'center').toString()\n      ) {\n        origin = getOrigin(newTransforms, element)\n      }\n\n      // overwrite the old transformations with the new ones\n      transforms = { ...newTransforms, origin }\n    }\n\n    this.queue(setup, run, retarget, true)\n    this._isDeclarative && this._rememberMorpher('transform', morpher)\n    return this\n  },\n\n  // Animatable x-axis\n  x(x) {\n    return this._queueNumber('x', x)\n  },\n\n  // Animatable y-axis\n  y(y) {\n    return this._queueNumber('y', y)\n  },\n\n  ax(x) {\n    return this._queueNumber('ax', x)\n  },\n\n  ay(y) {\n    return this._queueNumber('ay', y)\n  },\n\n  dx(x = 0) {\n    return this._queueNumberDelta('x', x)\n  },\n\n  dy(y = 0) {\n    return this._queueNumberDelta('y', y)\n  },\n\n  dmove(x, y) {\n    return this.dx(x).dy(y)\n  },\n\n  _queueNumberDelta(method, to) {\n    to = new SVGNumber(to)\n\n    // Try to change the target if we have this method already registered\n    if (this._tryRetarget(method, to)) return this\n\n    // Make a morpher and queue the animation\n    const morpher = new Morphable(this._stepper).to(to)\n    let from = null\n    this.queue(\n      function () {\n        from = this.element()[method]()\n        morpher.from(from)\n        morpher.to(from + to)\n      },\n      function (pos) {\n        this.element()[method](morpher.at(pos))\n        return morpher.done()\n      },\n      function (newTo) {\n        morpher.to(from + new SVGNumber(newTo))\n      }\n    )\n\n    // Register the morpher so that if it is changed again, we can retarget it\n    this._rememberMorpher(method, morpher)\n    return this\n  },\n\n  _queueObject(method, to) {\n    // Try to change the target if we have this method already registered\n    if (this._tryRetarget(method, to)) return this\n\n    // Make a morpher and queue the animation\n    const morpher = new Morphable(this._stepper).to(to)\n    this.queue(\n      function () {\n        morpher.from(this.element()[method]())\n      },\n      function (pos) {\n        this.element()[method](morpher.at(pos))\n        return morpher.done()\n      }\n    )\n\n    // Register the morpher so that if it is changed again, we can retarget it\n    this._rememberMorpher(method, morpher)\n    return this\n  },\n\n  _queueNumber(method, value) {\n    return this._queueObject(method, new SVGNumber(value))\n  },\n\n  // Animatable center x-axis\n  cx(x) {\n    return this._queueNumber('cx', x)\n  },\n\n  // Animatable center y-axis\n  cy(y) {\n    return this._queueNumber('cy', y)\n  },\n\n  // Add animatable move\n  move(x, y) {\n    return this.x(x).y(y)\n  },\n\n  amove(x, y) {\n    return this.ax(x).ay(y)\n  },\n\n  // Add animatable center\n  center(x, y) {\n    return this.cx(x).cy(y)\n  },\n\n  // Add animatable size\n  size(width, height) {\n    // animate bbox based size for all other elements\n    let box\n\n    if (!width || !height) {\n      box = this._element.bbox()\n    }\n\n    if (!width) {\n      width = (box.width / box.height) * height\n    }\n\n    if (!height) {\n      height = (box.height / box.width) * width\n    }\n\n    return this.width(width).height(height)\n  },\n\n  // Add animatable width\n  width(width) {\n    return this._queueNumber('width', width)\n  },\n\n  // Add animatable height\n  height(height) {\n    return this._queueNumber('height', height)\n  },\n\n  // Add animatable plot\n  plot(a, b, c, d) {\n    // Lines can be plotted with 4 arguments\n    if (arguments.length === 4) {\n      return this.plot([a, b, c, d])\n    }\n\n    if (this._tryRetarget('plot', a)) return this\n\n    const morpher = new Morphable(this._stepper)\n      .type(this._element.MorphArray)\n      .to(a)\n\n    this.queue(\n      function () {\n        morpher.from(this._element.array())\n      },\n      function (pos) {\n        this._element.plot(morpher.at(pos))\n        return morpher.done()\n      }\n    )\n\n    this._rememberMorpher('plot', morpher)\n    return this\n  },\n\n  // Add leading method\n  leading(value) {\n    return this._queueNumber('leading', value)\n  },\n\n  // Add animatable viewbox\n  viewbox(x, y, width, height) {\n    return this._queueObject('viewbox', new Box(x, y, width, height))\n  },\n\n  update(o) {\n    if (typeof o !== 'object') {\n      return this.update({\n        offset: arguments[0],\n        color: arguments[1],\n        opacity: arguments[2]\n      })\n    }\n\n    if (o.opacity != null) this.attr('stop-opacity', o.opacity)\n    if (o.color != null) this.attr('stop-color', o.color)\n    if (o.offset != null) this.attr('offset', o.offset)\n\n    return this\n  }\n})\n\nextend(Runner, { rx: rx, ry: ry, from: from, to: to })\nregister(Runner, 'Runner')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Svg.js\n\n\n\n\n\n\n\nclass Svg extends Container {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('svg', node), attrs)\n    this.namespace()\n  }\n\n  // Creates and returns defs element\n  defs() {\n    if (!this.isRoot()) return this.root().defs()\n\n    return adopt(this.node.querySelector('defs')) || this.put(new Defs())\n  }\n\n  isRoot() {\n    return (\n      !this.node.parentNode ||\n      (!(this.node.parentNode instanceof globals.window.SVGElement) &&\n        this.node.parentNode.nodeName !== '#document-fragment')\n    )\n  }\n\n  // Add namespaces\n  namespace() {\n    if (!this.isRoot()) return this.root().namespace()\n    return this.attr({ xmlns: svg, version: '1.1' }).attr(\n      'xmlns:xlink',\n      xlink,\n      xmlns\n    )\n  }\n\n  removeNamespace() {\n    return this.attr({ xmlns: null, version: null })\n      .attr('xmlns:xlink', null, xmlns)\n      .attr('xmlns:svgjs', null, xmlns)\n  }\n\n  // Check if this is a root svg\n  // If not, call root() from this element\n  root() {\n    if (this.isRoot()) return this\n    return super.root()\n  }\n}\n\nregisterMethods({\n  Container: {\n    // Create nested svg document\n    nested: wrapWithAttrCheck(function () {\n      return this.put(new Svg())\n    })\n  }\n})\n\nregister(Svg, 'Svg', true)\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Symbol.js\n\n\n\n\nclass Symbol_Symbol extends Container {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('symbol', node), attrs)\n  }\n}\n\nregisterMethods({\n  Container: {\n    symbol: wrapWithAttrCheck(function () {\n      return this.put(new Symbol_Symbol())\n    })\n  }\n})\n\nregister(Symbol_Symbol, 'Symbol')\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/textable.js\n\n\n// Create plain text node\nfunction plain(text) {\n  // clear if build mode is disabled\n  if (this._build === false) {\n    this.clear()\n  }\n\n  // create text node\n  this.node.appendChild(globals.document.createTextNode(text))\n\n  return this\n}\n\n// Get length of text element\nfunction textable_length() {\n  return this.node.getComputedTextLength()\n}\n\n// Move over x-axis\n// Text is moved by its bounding box\n// text-anchor does NOT matter\nfunction textable_x(x, box = this.bbox()) {\n  if (x == null) {\n    return box.x\n  }\n\n  return this.attr('x', this.attr('x') + x - box.x)\n}\n\n// Move over y-axis\nfunction textable_y(y, box = this.bbox()) {\n  if (y == null) {\n    return box.y\n  }\n\n  return this.attr('y', this.attr('y') + y - box.y)\n}\n\nfunction textable_move(x, y, box = this.bbox()) {\n  return this.x(x, box).y(y, box)\n}\n\n// Move center over x-axis\nfunction textable_cx(x, box = this.bbox()) {\n  if (x == null) {\n    return box.cx\n  }\n\n  return this.attr('x', this.attr('x') + x - box.cx)\n}\n\n// Move center over y-axis\nfunction textable_cy(y, box = this.bbox()) {\n  if (y == null) {\n    return box.cy\n  }\n\n  return this.attr('y', this.attr('y') + y - box.cy)\n}\n\nfunction center(x, y, box = this.bbox()) {\n  return this.cx(x, box).cy(y, box)\n}\n\nfunction ax(x) {\n  return this.attr('x', x)\n}\n\nfunction ay(y) {\n  return this.attr('y', y)\n}\n\nfunction amove(x, y) {\n  return this.ax(x).ay(y)\n}\n\n// Enable / disable build mode\nfunction build(build) {\n  this._build = !!build\n  return this\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Text.js\n\n\n\n\n\n\n\n\nclass Text extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('text', node), attrs)\n\n    this.dom.leading = this.dom.leading ?? new SVGNumber(1.3) // store leading value for rebuilding\n    this._rebuild = true // enable automatic updating of dy values\n    this._build = false // disable build mode for adding multiple lines\n  }\n\n  // Set / get leading\n  leading(value) {\n    // act as getter\n    if (value == null) {\n      return this.dom.leading\n    }\n\n    // act as setter\n    this.dom.leading = new SVGNumber(value)\n\n    return this.rebuild()\n  }\n\n  // Rebuild appearance type\n  rebuild(rebuild) {\n    // store new rebuild flag if given\n    if (typeof rebuild === 'boolean') {\n      this._rebuild = rebuild\n    }\n\n    // define position of all lines\n    if (this._rebuild) {\n      const self = this\n      let blankLineOffset = 0\n      const leading = this.dom.leading\n\n      this.each(function (i) {\n        if (isDescriptive(this.node)) return\n\n        const fontSize = globals.window\n          .getComputedStyle(this.node)\n          .getPropertyValue('font-size')\n\n        const dy = leading * new SVGNumber(fontSize)\n\n        if (this.dom.newLined) {\n          this.attr('x', self.attr('x'))\n\n          if (this.text() === '\\n') {\n            blankLineOffset += dy\n          } else {\n            this.attr('dy', i ? dy + blankLineOffset : 0)\n            blankLineOffset = 0\n          }\n        }\n      })\n\n      this.fire('rebuild')\n    }\n\n    return this\n  }\n\n  // overwrite method from parent to set data properly\n  setData(o) {\n    this.dom = o\n    this.dom.leading = new SVGNumber(o.leading || 1.3)\n    return this\n  }\n\n  writeDataToDom() {\n    writeDataToDom(this, this.dom, { leading: 1.3 })\n    return this\n  }\n\n  // Set the text content\n  text(text) {\n    // act as getter\n    if (text === undefined) {\n      const children = this.node.childNodes\n      let firstLine = 0\n      text = ''\n\n      for (let i = 0, len = children.length; i < len; ++i) {\n        // skip textPaths - they are no lines\n        if (children[i].nodeName === 'textPath' || isDescriptive(children[i])) {\n          if (i === 0) firstLine = i + 1\n          continue\n        }\n\n        // add newline if its not the first child and newLined is set to true\n        if (\n          i !== firstLine &&\n          children[i].nodeType !== 3 &&\n          adopt(children[i]).dom.newLined === true\n        ) {\n          text += '\\n'\n        }\n\n        // add content of this node\n        text += children[i].textContent\n      }\n\n      return text\n    }\n\n    // remove existing content\n    this.clear().build(true)\n\n    if (typeof text === 'function') {\n      // call block\n      text.call(this, this)\n    } else {\n      // store text and make sure text is not blank\n      text = (text + '').split('\\n')\n\n      // build new lines\n      for (let j = 0, jl = text.length; j < jl; j++) {\n        this.newLine(text[j])\n      }\n    }\n\n    // disable build mode and rebuild lines\n    return this.build(false).rebuild()\n  }\n}\n\nextend(Text, textable_namespaceObject)\n\nregisterMethods({\n  Container: {\n    // Create text element\n    text: wrapWithAttrCheck(function (text = '') {\n      return this.put(new Text()).text(text)\n    }),\n\n    // Create plain text element\n    plain: wrapWithAttrCheck(function (text = '') {\n      return this.put(new Text()).plain(text)\n    })\n  }\n})\n\nregister(Text, 'Text')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Tspan.js\n\n\n\n\n\n\n\n\nclass Tspan extends Shape {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('tspan', node), attrs)\n    this._build = false // disable build mode for adding multiple lines\n  }\n\n  // Shortcut dx\n  dx(dx) {\n    return this.attr('dx', dx)\n  }\n\n  // Shortcut dy\n  dy(dy) {\n    return this.attr('dy', dy)\n  }\n\n  // Create new line\n  newLine() {\n    // mark new line\n    this.dom.newLined = true\n\n    // fetch parent\n    const text = this.parent()\n\n    // early return in case we are not in a text element\n    if (!(text instanceof Text)) {\n      return this\n    }\n\n    const i = text.index(this)\n\n    const fontSize = globals.window\n      .getComputedStyle(this.node)\n      .getPropertyValue('font-size')\n    const dy = text.dom.leading * new SVGNumber(fontSize)\n\n    // apply new position\n    return this.dy(i ? dy : 0).attr('x', text.x())\n  }\n\n  // Set text content\n  text(text) {\n    if (text == null)\n      return this.node.textContent + (this.dom.newLined ? '\\n' : '')\n\n    if (typeof text === 'function') {\n      this.clear().build(true)\n      text.call(this, this)\n      this.build(false)\n    } else {\n      this.plain(text)\n    }\n\n    return this\n  }\n}\n\nextend(Tspan, textable_namespaceObject)\n\nregisterMethods({\n  Tspan: {\n    tspan: wrapWithAttrCheck(function (text = '') {\n      const tspan = new Tspan()\n\n      // clear if build mode is disabled\n      if (!this._build) {\n        this.clear()\n      }\n\n      // add new tspan\n      return this.put(tspan).text(text)\n    })\n  },\n  Text: {\n    newLine: function (text = '') {\n      return this.tspan(text).newLine()\n    }\n  }\n})\n\nregister(Tspan, 'Tspan')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Circle.js\n\n\n\n\n\n\nclass Circle extends Shape {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('circle', node), attrs)\n  }\n\n  radius(r) {\n    return this.attr('r', r)\n  }\n\n  // Radius x value\n  rx(rx) {\n    return this.attr('r', rx)\n  }\n\n  // Alias radius x value\n  ry(ry) {\n    return this.rx(ry)\n  }\n\n  size(size) {\n    return this.radius(new SVGNumber(size).divide(2))\n  }\n}\n\nextend(Circle, { x: x, y: y, cx: cx, cy: cy, width: width, height: height })\n\nregisterMethods({\n  Container: {\n    // Create circle element\n    circle: wrapWithAttrCheck(function (size = 0) {\n      return this.put(new Circle()).size(size).move(0, 0)\n    })\n  }\n})\n\nregister(Circle, 'Circle')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/ClipPath.js\n\n\n\n\n\nclass ClipPath extends Container {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('clipPath', node), attrs)\n  }\n\n  // Unclip all clipped elements and remove itself\n  remove() {\n    // unclip all targets\n    this.targets().forEach(function (el) {\n      el.unclip()\n    })\n\n    // remove clipPath from parent\n    return super.remove()\n  }\n\n  targets() {\n    return baseFind('svg [clip-path*=' + this.id() + ']')\n  }\n}\n\nregisterMethods({\n  Container: {\n    // Create clipping element\n    clip: wrapWithAttrCheck(function () {\n      return this.defs().put(new ClipPath())\n    })\n  },\n  Element: {\n    // Distribute clipPath to svg element\n    clipper() {\n      return this.reference('clip-path')\n    },\n\n    clipWith(element) {\n      // use given clip or create a new one\n      const clipper =\n        element instanceof ClipPath\n          ? element\n          : this.parent().clip().add(element)\n\n      // apply mask\n      return this.attr('clip-path', 'url(#' + clipper.id() + ')')\n    },\n\n    // Unclip element\n    unclip() {\n      return this.attr('clip-path', null)\n    }\n  }\n})\n\nregister(ClipPath, 'ClipPath')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/ForeignObject.js\n\n\n\n\nclass ForeignObject extends Element {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('foreignObject', node), attrs)\n  }\n}\n\nregisterMethods({\n  Container: {\n    foreignObject: wrapWithAttrCheck(function (width, height) {\n      return this.put(new ForeignObject()).size(width, height)\n    })\n  }\n})\n\nregister(ForeignObject, 'ForeignObject')\n\n;// ./node_modules/@svgdotjs/svg.js/src/modules/core/containerGeometry.js\n\n\n\n\n\n\nfunction dmove(dx, dy) {\n  this.children().forEach((child) => {\n    let bbox\n\n    // We have to wrap this for elements that dont have a bbox\n    // e.g. title and other descriptive elements\n    try {\n      // Get the childs bbox\n      // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1905039\n      // Because bbox for nested svgs returns the contents bbox in the coordinate space of the svg itself (weird!), we cant use bbox for svgs\n      // Therefore we have to use getBoundingClientRect. But THAT is broken (as explained in the bug).\n      // Funnily enough the broken behavior would work for us but that breaks it in chrome\n      // So we have to replicate the broken behavior of FF by just reading the attributes of the svg itself\n      bbox =\n        child.node instanceof getWindow().SVGSVGElement\n          ? new Box(child.attr(['x', 'y', 'width', 'height']))\n          : child.bbox()\n    } catch (e) {\n      return\n    }\n\n    // Get childs matrix\n    const m = new Matrix(child)\n    // Translate childs matrix by amount and\n    // transform it back into parents space\n    const matrix = m.translate(dx, dy).transform(m.inverse())\n    // Calculate new x and y from old box\n    const p = new Point(bbox.x, bbox.y).transform(matrix)\n    // Move element\n    child.move(p.x, p.y)\n  })\n\n  return this\n}\n\nfunction dx(dx) {\n  return this.dmove(dx, 0)\n}\n\nfunction dy(dy) {\n  return this.dmove(0, dy)\n}\n\nfunction containerGeometry_height(height, box = this.bbox()) {\n  if (height == null) return box.height\n  return this.size(box.width, height, box)\n}\n\nfunction containerGeometry_move(x = 0, y = 0, box = this.bbox()) {\n  const dx = x - box.x\n  const dy = y - box.y\n\n  return this.dmove(dx, dy)\n}\n\nfunction containerGeometry_size(width, height, box = this.bbox()) {\n  const p = proportionalSize(this, width, height, box)\n  const scaleX = p.width / box.width\n  const scaleY = p.height / box.height\n\n  this.children().forEach((child) => {\n    const o = new Point(box).transform(new Matrix(child).inverse())\n    child.scale(scaleX, scaleY, o.x, o.y)\n  })\n\n  return this\n}\n\nfunction containerGeometry_width(width, box = this.bbox()) {\n  if (width == null) return box.width\n  return this.size(width, box.height, box)\n}\n\nfunction containerGeometry_x(x, box = this.bbox()) {\n  if (x == null) return box.x\n  return this.move(x, box.y, box)\n}\n\nfunction containerGeometry_y(y, box = this.bbox()) {\n  if (y == null) return box.y\n  return this.move(box.x, y, box)\n}\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/G.js\n\n\n\n\n\nclass G extends Container {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('g', node), attrs)\n  }\n}\n\nextend(G, containerGeometry_namespaceObject)\n\nregisterMethods({\n  Container: {\n    // Create a group element\n    group: wrapWithAttrCheck(function () {\n      return this.put(new G())\n    })\n  }\n})\n\nregister(G, 'G')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/A.js\n\n\n\n\n\n\nclass A extends Container {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('a', node), attrs)\n  }\n\n  // Link target attribute\n  target(target) {\n    return this.attr('target', target)\n  }\n\n  // Link url\n  to(url) {\n    return this.attr('href', url, xlink)\n  }\n}\n\nextend(A, containerGeometry_namespaceObject)\n\nregisterMethods({\n  Container: {\n    // Create a hyperlink element\n    link: wrapWithAttrCheck(function (url) {\n      return this.put(new A()).to(url)\n    })\n  },\n  Element: {\n    unlink() {\n      const link = this.linker()\n\n      if (!link) return this\n\n      const parent = link.parent()\n\n      if (!parent) {\n        return this.remove()\n      }\n\n      const index = parent.index(link)\n      parent.add(this, index)\n\n      link.remove()\n      return this\n    },\n    linkTo(url) {\n      // reuse old link if possible\n      let link = this.linker()\n\n      if (!link) {\n        link = new A()\n        this.wrap(link)\n      }\n\n      if (typeof url === 'function') {\n        url.call(link, link)\n      } else {\n        link.to(url)\n      }\n\n      return this\n    },\n    linker() {\n      const link = this.parent()\n      if (link && link.node.nodeName.toLowerCase() === 'a') {\n        return link\n      }\n\n      return null\n    }\n  }\n})\n\nregister(A, 'A')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Mask.js\n\n\n\n\n\nclass Mask extends Container {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('mask', node), attrs)\n  }\n\n  // Unmask all masked elements and remove itself\n  remove() {\n    // unmask all targets\n    this.targets().forEach(function (el) {\n      el.unmask()\n    })\n\n    // remove mask from parent\n    return super.remove()\n  }\n\n  targets() {\n    return baseFind('svg [mask*=' + this.id() + ']')\n  }\n}\n\nregisterMethods({\n  Container: {\n    mask: wrapWithAttrCheck(function () {\n      return this.defs().put(new Mask())\n    })\n  },\n  Element: {\n    // Distribute mask to svg element\n    masker() {\n      return this.reference('mask')\n    },\n\n    maskWith(element) {\n      // use given mask or create a new one\n      const masker =\n        element instanceof Mask ? element : this.parent().mask().add(element)\n\n      // apply mask\n      return this.attr('mask', 'url(#' + masker.id() + ')')\n    },\n\n    // Unmask element\n    unmask() {\n      return this.attr('mask', null)\n    }\n  }\n})\n\nregister(Mask, 'Mask')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Stop.js\n\n\n\n\n\nclass Stop extends Element {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('stop', node), attrs)\n  }\n\n  // add color stops\n  update(o) {\n    if (typeof o === 'number' || o instanceof SVGNumber) {\n      o = {\n        offset: arguments[0],\n        color: arguments[1],\n        opacity: arguments[2]\n      }\n    }\n\n    // set attributes\n    if (o.opacity != null) this.attr('stop-opacity', o.opacity)\n    if (o.color != null) this.attr('stop-color', o.color)\n    if (o.offset != null) this.attr('offset', new SVGNumber(o.offset))\n\n    return this\n  }\n}\n\nregisterMethods({\n  Gradient: {\n    // Add a color stop\n    stop: function (offset, color, opacity) {\n      return this.put(new Stop()).update(offset, color, opacity)\n    }\n  }\n})\n\nregister(Stop, 'Stop')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Style.js\n\n\n\n\n\nfunction cssRule(selector, rule) {\n  if (!selector) return ''\n  if (!rule) return selector\n\n  let ret = selector + '{'\n\n  for (const i in rule) {\n    ret += unCamelCase(i) + ':' + rule[i] + ';'\n  }\n\n  ret += '}'\n\n  return ret\n}\n\nclass Style extends Element {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('style', node), attrs)\n  }\n\n  addText(w = '') {\n    this.node.textContent += w\n    return this\n  }\n\n  font(name, src, params = {}) {\n    return this.rule('@font-face', {\n      fontFamily: name,\n      src: src,\n      ...params\n    })\n  }\n\n  rule(selector, obj) {\n    return this.addText(cssRule(selector, obj))\n  }\n}\n\nregisterMethods('Dom', {\n  style(selector, obj) {\n    return this.put(new Style()).rule(selector, obj)\n  },\n  fontface(name, src, params) {\n    return this.put(new Style()).font(name, src, params)\n  }\n})\n\nregister(Style, 'Style')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/TextPath.js\n\n\n\n\n\n\n\n\nclass TextPath extends Text {\n  // Initialize node\n  constructor(node, attrs = node) {\n    super(nodeOrNew('textPath', node), attrs)\n  }\n\n  // return the array of the path track element\n  array() {\n    const track = this.track()\n\n    return track ? track.array() : null\n  }\n\n  // Plot path if any\n  plot(d) {\n    const track = this.track()\n    let pathArray = null\n\n    if (track) {\n      pathArray = track.plot(d)\n    }\n\n    return d == null ? pathArray : this\n  }\n\n  // Get the path element\n  track() {\n    return this.reference('href')\n  }\n}\n\nregisterMethods({\n  Container: {\n    textPath: wrapWithAttrCheck(function (text, path) {\n      // Convert text to instance if needed\n      if (!(text instanceof Text)) {\n        text = this.text(text)\n      }\n\n      return text.path(path)\n    })\n  },\n  Text: {\n    // Create path for text to run on\n    path: wrapWithAttrCheck(function (track, importNodes = true) {\n      const textPath = new TextPath()\n\n      // if track is a path, reuse it\n      if (!(track instanceof Path)) {\n        // create path element\n        track = this.defs().path(track)\n      }\n\n      // link textPath to path and add content\n      textPath.attr('href', '#' + track, xlink)\n\n      // Transplant all nodes from text to textPath\n      let node\n      if (importNodes) {\n        while ((node = this.node.firstChild)) {\n          textPath.node.appendChild(node)\n        }\n      }\n\n      // add textPath element as child node and return textPath\n      return this.put(textPath)\n    }),\n\n    // Get the textPath children\n    textPath() {\n      return this.findOne('textPath')\n    }\n  },\n  Path: {\n    // creates a textPath from this path\n    text: wrapWithAttrCheck(function (text) {\n      // Convert text to instance if needed\n      if (!(text instanceof Text)) {\n        text = new Text().addTo(this.parent()).text(text)\n      }\n\n      // Create textPath from text and path and return\n      return text.path(this)\n    }),\n\n    targets() {\n      return baseFind('svg textPath').filter((node) => {\n        return (node.attr('href') || '').includes(this.id())\n      })\n\n      // Does not work in IE11. Use when IE support is dropped\n      // return baseFind('svg textPath[*|href*=' + this.id() + ']')\n    }\n  }\n})\n\nTextPath.prototype.MorphArray = PathArray\nregister(TextPath, 'TextPath')\n\n;// ./node_modules/@svgdotjs/svg.js/src/elements/Use.js\n\n\n\n\n\nclass Use extends Shape {\n  constructor(node, attrs = node) {\n    super(nodeOrNew('use', node), attrs)\n  }\n\n  // Use element as a reference\n  use(element, file) {\n    // Set lined element\n    return this.attr('href', (file || '') + '#' + element, xlink)\n  }\n}\n\nregisterMethods({\n  Container: {\n    // Create a use element\n    use: wrapWithAttrCheck(function (element, file) {\n      return this.put(new Use()).use(element, file)\n    })\n  }\n})\n\nregister(Use, 'Use')\n\n;// ./node_modules/@svgdotjs/svg.js/src/main.js\n/* Optional Modules */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst SVG = (/* unused pure expression or super */ null && (makeInstance))\n\n\n\n\n\n\n/* Animation Modules */\n\n\n\n\n\n\n/* Types */\n\n\n\n\n\n\n\n\n\n\n\n/* Elements */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nextend([Svg, Symbol_Symbol, Image, Pattern, Marker], getMethodsFor('viewbox'))\n\nextend([Line, Polyline, Polygon, Path], getMethodsFor('marker'))\n\nextend(Text, getMethodsFor('Text'))\nextend(Path, getMethodsFor('Path'))\n\nextend(Defs, getMethodsFor('Defs'))\n\nextend([Text, Tspan], getMethodsFor('Tspan'))\n\nextend([Rect, Ellipse, Gradient, Runner], getMethodsFor('radius'))\n\nextend(EventTarget, getMethodsFor('EventTarget'))\nextend(Dom, getMethodsFor('Dom'))\nextend(Element, getMethodsFor('Element'))\nextend(Shape, getMethodsFor('Shape'))\nextend([Container, elements_Fragment], getMethodsFor('Container'))\nextend(Gradient, getMethodsFor('Gradient'))\n\nextend(Runner, getMethodsFor('Runner'))\n\ntypes_List.extend(getMethodNames())\n\nregisterMorphableType([\n  SVGNumber,\n  Color,\n  Box,\n  Matrix,\n  SVGArray,\n  PointArray,\n  PathArray,\n  Point\n])\n\nmakeMorphable()\n\n;// ./src/objects/text-circle.ts\n\n\nclass TextCircle extends G {\n    constructor() {\n        super(...arguments);\n        this.$circle = null;\n        this.$text = null;\n    }\n    init(text, x, y, size, strokeWidth) {\n        this.$circle = this.circle(size)\n            .stroke({ width: strokeWidth })\n            .center(0, 0);\n        this.$text = this.text(text).center(0, 0);\n        if (x && y)\n            this.center(x, y);\n        return this;\n    }\n    getText() {\n        var _a;\n        return ((_a = this.$text) === null || _a === void 0 ? void 0 : _a.text()) || \"\";\n    }\n    setText(text) {\n        var _a;\n        if (text == null)\n            text = \"\";\n        text = `${text}`;\n        if (text === \"\")\n            text = NBSP;\n        (_a = this.$text) === null || _a === void 0 ? void 0 : _a.text(text);\n        return this;\n    }\n    getSize() {\n        const r = this.attr(\"r\");\n        if (typeof r === \"number\")\n            return r * 2;\n        if (typeof r === \"string\" && !isNaN(Number(r)))\n            return Number(r) * 2;\n        return 0;\n    }\n    setSize(diameter, animationDuration = 0) {\n        this.animate(animationDuration).attr(\"r\", String(diameter / 2));\n        return this;\n    }\n    toString() {\n        return this.getText();\n    }\n}\n\n;// ./src/objects/graph-node.ts\n\n\nclass GraphNode extends TextCircle {\n    constructor() {\n        super(...arguments);\n        this.$incoming = {};\n        this.$outgoing = {};\n        this.$nullary = {};\n    }\n    init(text, x, y, size, strokeWidth) {\n        const bgSize = 3 * size;\n        this.rect(bgSize, bgSize).center(0, 0).addClass(\"invisible\");\n        return super.init(text, x, y, size, strokeWidth);\n    }\n    getBend(key) {\n        return 0;\n    }\n    getDirected(key) {\n        return true;\n    }\n    getIncoming(inKey) {\n        return this.$incoming[inKey];\n    }\n    getOutgoing(outKey) {\n        return this.$outgoing[outKey];\n    }\n    getIncomingEdges() {\n        return Object.values(this.$incoming).filter((e) => e !== null);\n    }\n    getOutgoingEdges() {\n        return Object.values(this.$outgoing).filter((e) => e !== null);\n    }\n    getPredecessors() {\n        return Object.values(this.$incoming)\n            .map((e) => e === null || e === void 0 ? void 0 : e.getStart())\n            .filter((e) => e !== undefined && e !== null);\n    }\n    getSuccessors() {\n        return Object.values(this.$outgoing)\n            .map((e) => e === null || e === void 0 ? void 0 : e.getEnd())\n            .filter((e) => e !== undefined && e !== null);\n    }\n    getPredecessor(inKey) {\n        var _a;\n        return ((_a = this.$incoming[inKey]) === null || _a === void 0 ? void 0 : _a.getStart()) || null;\n    }\n    getSuccessor(outKey) {\n        var _a;\n        return ((_a = this.$outgoing[outKey]) === null || _a === void 0 ? void 0 : _a.getEnd()) || null;\n    }\n    setPredecessor(inKey, outKey, predecessor, strokeWidth) {\n        predecessor.setSuccessor(outKey, inKey, this, strokeWidth);\n        return this;\n    }\n    setSuccessor(outKey, inKey, successor, strokeWidth) {\n        const outEdge = this.$outgoing[outKey];\n        if (outEdge) {\n            const oldSuccessor = outEdge.getEnd();\n            const oldIncoming = oldSuccessor === null || oldSuccessor === void 0 ? void 0 : oldSuccessor.$incoming;\n            for (const k in oldIncoming) {\n                if (oldIncoming[k] === outEdge)\n                    delete oldIncoming[k];\n            }\n            outEdge.remove();\n        }\n        if (successor) {\n            const inEdge = successor.$incoming[inKey];\n            if (inEdge) {\n                const oldPredecessor = inEdge.getStart();\n                const oldOutgoing = oldPredecessor === null || oldPredecessor === void 0 ? void 0 : oldPredecessor.$outgoing;\n                for (const k in oldOutgoing) {\n                    if (oldOutgoing[k] === inEdge)\n                        delete oldOutgoing[k];\n                }\n                inEdge.remove();\n            }\n            const edge = this.root().connection(this, successor, strokeWidth, this.getBend(outKey), this.getDirected(outKey));\n            this.$outgoing[outKey] = edge;\n            successor.$incoming[inKey] = edge;\n        }\n        else {\n            delete this.$outgoing[outKey];\n        }\n        this._updateNullary();\n        return this;\n    }\n    _updateNullary() {\n        var _a, _b;\n        for (const node of baseFind(\"g\")) {\n            if (node instanceof GraphNode) {\n                for (const c in node.$nullary) {\n                    const show = !node.$outgoing[c];\n                    if (show)\n                        (_a = node.$nullary[c]) === null || _a === void 0 ? void 0 : _a.removeClass(\"invisible\");\n                    else\n                        (_b = node.$nullary[c]) === null || _b === void 0 ? void 0 : _b.addClass(\"invisible\");\n                }\n            }\n        }\n    }\n    setIncomingHighlight(inKey, high) {\n        var _a;\n        this.setHighlight(high);\n        (_a = this.getIncoming(inKey)) === null || _a === void 0 ? void 0 : _a.setHighlight(high);\n        return this;\n    }\n    getHighlight() {\n        return this.hasClass(\"highlight\");\n    }\n    setOutgoingHighlight(outKey, high) {\n        var _a;\n        this.setHighlight(high);\n        (_a = this.getOutgoing(outKey)) === null || _a === void 0 ? void 0 : _a.setHighlight(high);\n        return this;\n    }\n    remove() {\n        for (const outKey in this.$outgoing) {\n            const outEdge = this.$outgoing[outKey];\n            if (!outEdge)\n                continue;\n            const end = outEdge.getEnd();\n            const incoming = end === null || end === void 0 ? void 0 : end.$incoming;\n            for (const inKey in incoming) {\n                if (outEdge === incoming[inKey]) {\n                    delete incoming[inKey];\n                }\n                outEdge.remove();\n            }\n        }\n        for (const inKey in this.$incoming) {\n            const inEdge = this.$incoming[inKey];\n            if (!inEdge)\n                continue;\n            const start = inEdge.getStart();\n            const outgoing = start === null || start === void 0 ? void 0 : start.$outgoing;\n            for (const outKey in outgoing) {\n                if (inEdge === outgoing[outKey]) {\n                    delete outgoing[outKey];\n                }\n                inEdge.remove();\n            }\n        }\n        super.remove();\n        this._updateNullary();\n        return this;\n    }\n    setCenter(x, y, animationDuration = 0) {\n        super.setCenter(x, y, animationDuration);\n        for (const edge of this.getOutgoingEdges()) {\n            edge.update({ x1: x, y1: y }, animationDuration);\n        }\n        for (const edge of this.getIncomingEdges()) {\n            edge.update({ x2: x, y2: y }, animationDuration);\n        }\n        return this;\n    }\n    setSize(size, animationDuration = 0) {\n        super.setSize(size, animationDuration);\n        for (const edge of this.getIncomingEdges()) {\n            edge.update({ r2: size / 2 }, animationDuration);\n        }\n        return this;\n    }\n}\n\n;// ./src/objects/binary-node.ts\n\nclass BinaryNode extends GraphNode {\n    constructor() {\n        super(...arguments);\n        this.$incoming = {\n            parent: null,\n        };\n        this.$outgoing = {\n            left: null,\n            right: null,\n        };\n        this.$nullary = {\n            left: null,\n            right: null,\n        };\n        this.$edgebends = { left: 0.1, right: -0.1 };\n        this.$leftWidth = 0;\n        this.$rightWidth = 0;\n        this.$width = 0;\n    }\n    init(text, x, y, size, strokeWidth) {\n        const d = size;\n        const nX = 0.5 * d, nY = 0.8 * d, nR = 2 * strokeWidth;\n        const nullpath = (s) => `M 0,0 L ${s * nX},${nY} m ${nR},0 a ${nR},${nR} 0 1,0 ${-2 * nR},0 a ${nR},${nR} 0 1,0 ${2 * nR},0`;\n        this.$nullary.left = this.path(nullpath(-1))\n            .stroke({ width: strokeWidth })\n            .addClass(\"nullnode\");\n        this.$nullary.right = this.path(nullpath(1))\n            .stroke({ width: strokeWidth })\n            .addClass(\"nullnode\");\n        return super.init(text, x, y, size, strokeWidth);\n    }\n    getBend(c) {\n        return this.$edgebends[c];\n    }\n    getParent() {\n        var _a;\n        return ((_a = this.$incoming.parent) === null || _a === void 0 ? void 0 : _a.getStart()) || null;\n    }\n    getLeft() {\n        var _a;\n        return ((_a = this.$outgoing.left) === null || _a === void 0 ? void 0 : _a.getEnd()) || null;\n    }\n    getRight() {\n        var _a;\n        return ((_a = this.$outgoing.right) === null || _a === void 0 ? void 0 : _a.getEnd()) || null;\n    }\n    getChild(c) {\n        var _a;\n        return ((_a = this.$outgoing[c]) === null || _a === void 0 ? void 0 : _a.getEnd()) || null;\n    }\n    getSibling() {\n        const parent = this.getParent();\n        if (!parent)\n            return null;\n        return this === parent.getLeft() ? parent.getRight() : parent.getLeft();\n    }\n    getParentEdge() {\n        return this.$incoming.parent;\n    }\n    getLeftEdge() {\n        return this.$outgoing.left;\n    }\n    getRightEdge() {\n        return this.$outgoing.right;\n    }\n    getChildEdge(c) {\n        return this.$outgoing[c];\n    }\n    isLeaf() {\n        return !(this.getLeft() || this.getRight());\n    }\n    isLeftChild() {\n        var _a;\n        return this === ((_a = this.getParent()) === null || _a === void 0 ? void 0 : _a.getLeft());\n    }\n    isRightChild() {\n        var _a;\n        return this === ((_a = this.getParent()) === null || _a === void 0 ? void 0 : _a.getRight());\n    }\n    isChild(c) {\n        var _a;\n        return this === ((_a = this.getParent()) === null || _a === void 0 ? void 0 : _a.getChild(c));\n    }\n    setLeft(child, strokeWidth) {\n        return this.setChild(\"left\", child, strokeWidth);\n    }\n    setRight(child, strokeWidth) {\n        return this.setChild(\"right\", child, strokeWidth);\n    }\n    setChild(c, child, strokeWidth) {\n        return this.setSuccessor(c, \"parent\", child, strokeWidth);\n    }\n    setParentLeft(parent, strokeWidth) {\n        return this.setParent(\"left\", parent, strokeWidth);\n    }\n    setParentRight(parent, strokeWidth) {\n        return this.setParent(\"right\", parent, strokeWidth);\n    }\n    setParent(c, parent, strokeWidth) {\n        parent.setChild(c, this, strokeWidth);\n        return this;\n    }\n    setParentHighlight(high) {\n        return this.setIncomingHighlight(\"parent\", high);\n    }\n    setRightHighlight(high) {\n        return this.setChildHighlight(\"right\", high);\n    }\n    setLeftHighlight(high) {\n        return this.setChildHighlight(\"left\", high);\n    }\n    setChildHighlight(c, high) {\n        return this.setOutgoingHighlight(c, high);\n    }\n    deepString() {\n        var _a, _b;\n        let s = \"\";\n        if (this.getLeft())\n            s += `(${(_a = this.getLeft()) === null || _a === void 0 ? void 0 : _a.deepString()}) `;\n        s += this.getText();\n        if (this.getRight())\n            s += ` (${(_b = this.getRight()) === null || _b === void 0 ? void 0 : _b.deepString()})`;\n        return s;\n    }\n    resize(startX, startY, svgMargin, nodeSpacing, animationDuration = 0) {\n        this._resizeWidths(nodeSpacing);\n        const svgWidth = this.root().viewbox().width;\n        if (startX + this.$rightWidth > svgWidth - svgMargin)\n            startX = svgWidth - this.$rightWidth - svgMargin;\n        if (startX - this.$leftWidth < svgMargin)\n            startX = this.$leftWidth + svgMargin;\n        this._setNewPositions(startX, startY, nodeSpacing, animationDuration);\n        return this;\n    }\n    _resizeWidths(nodeSpacing) {\n        let width = nodeSpacing;\n        const left = this.getLeft();\n        if (left)\n            width += left._resizeWidths(nodeSpacing);\n        const right = this.getRight();\n        if (right)\n            width += right._resizeWidths(nodeSpacing);\n        width = Math.max(this.getSize(), width);\n        const leftWidth = (left === null || left === void 0 ? void 0 : left.$leftWidth) || 0;\n        const rightWidth = (right === null || right === void 0 ? void 0 : right.$rightWidth) || 0;\n        const mid = width - leftWidth - rightWidth;\n        this.$leftWidth = mid / 2 + leftWidth;\n        this.$rightWidth = mid / 2 + rightWidth;\n        this.$width = width;\n        return width;\n    }\n    _setNewPositions(x, y, nodeSpacing, animationDuration = 0) {\n        this.setCenter(x, y, animationDuration);\n        const ySpacing = nodeSpacing;\n        const nextY = y + this.getSize() + ySpacing;\n        const left = this.getLeft();\n        if (left)\n            left._setNewPositions(x - this.$leftWidth + left.$leftWidth, nextY, nodeSpacing, animationDuration);\n        const right = this.getRight();\n        if (right)\n            right._setNewPositions(x + this.$rightWidth - right.$rightWidth, nextY, nodeSpacing, animationDuration);\n    }\n    validate() {\n        var _a, _b, _c, _d;\n        const parent = (_a = this.$incoming.parent) === null || _a === void 0 ? void 0 : _a.getStart();\n        if (parent) {\n            parent.$incoming;\n            const c = this.isLeftChild() ? \"left\" : \"right\";\n            if (((_b = parent.$outgoing[c]) === null || _b === void 0 ? void 0 : _b.getEnd()) !== this)\n                console.error(\"Parent mismatch\");\n            let n = 0;\n            for (const edge of this.getEdges()) {\n                if (edge.getStart() === parent) {\n                    n++;\n                    if (edge.getEnd() !== this)\n                        console.error(\"Parent edge mismatch\");\n                }\n            }\n            if (n !== 1)\n                console.error(`Wrong n:o parent edges, ${n}`);\n        }\n        for (const c of [\"left\", \"right\"]) {\n            const child = (_c = this.$outgoing[c]) === null || _c === void 0 ? void 0 : _c.getEnd();\n            if (((_d = child === null || child === void 0 ? void 0 : child.$incoming.parent) === null || _d === void 0 ? void 0 : _d.getStart()) !== this)\n                console.error(`${c} child mismatch`);\n            let n = 0;\n            for (const edge of this.getEdges()) {\n                if (edge.getEnd() === child) {\n                    n++;\n                    if (edge.getStart() !== this)\n                        console.error(`${c} child edge mismatch`);\n                }\n            }\n            if (n !== 1)\n                console.error(`Wrong n:o ${c} child edges, ${n}`);\n        }\n    }\n}\n\n;// ./src/objects/avl-node.ts\n\nclass AVLNode extends BinaryNode {\n    constructor() {\n        super(...arguments);\n        this.$height = null;\n    }\n    init(text, x, y, size, strokeWidth) {\n        const d = size;\n        this.$height = this.text(\"1\")\n            .center(-0.6 * d, -0.5 * d)\n            .addClass(\"avlheight\");\n        return super.init(text, x, y, size, strokeWidth);\n    }\n    getHeight() {\n        if (this.$height)\n            return parseInt(this.$height.text());\n        return 1;\n    }\n    setHeight(height) {\n        var _a;\n        (_a = this.$height) === null || _a === void 0 ? void 0 : _a.text(String(height));\n        return this;\n    }\n    updateHeightPosition() {\n        if (!this.$height)\n            return this;\n        const hx = this.$height.cx();\n        const cx = this.cx();\n        if (this.isRightChild() && hx - cx < 0)\n            this.$height.cx(2 * cx - hx);\n        if (this.isLeftChild() && hx - cx > 0)\n            this.$height.cx(2 * cx - hx);\n        return this;\n    }\n    getHeightHighlight() {\n        var _a;\n        return ((_a = this.$height) === null || _a === void 0 ? void 0 : _a.getHighlight()) || false;\n    }\n    setHeightHighlight(high) {\n        var _a;\n        (_a = this.$height) === null || _a === void 0 ? void 0 : _a.setHighlight(high);\n        return this;\n    }\n}\n\n;// ./src/objects/connection.ts\n\nclass Connection extends Path {\n    constructor() {\n        super(...arguments);\n        this.$coords = {\n            r2: 0,\n            x1: 0,\n            x2: 0,\n            y1: 0,\n            y2: 0,\n        };\n        this.$start = null;\n        this.$end = null;\n        this.$bend = 0;\n    }\n    init(start, end, strokeWidth, bend = 0, directed = false) {\n        this.$start = start;\n        this.$end = end;\n        Object.assign(this.$coords, {\n            x1: start.cx(),\n            y1: start.cy(),\n            x2: end.cx(),\n            y2: end.cy(),\n            r2: end.getSize() / 2,\n        });\n        this.stroke({ width: strokeWidth });\n        this.back();\n        this.setBend(bend);\n        if (directed)\n            this._createArrow();\n        this.update(this.$coords);\n        return this;\n    }\n    getBend() {\n        return this.$bend;\n    }\n    setBend(bend) {\n        this.$bend = bend;\n        return this;\n    }\n    isDirected() {\n        return Boolean(this.reference(\"marker-end\"));\n    }\n    update(newCoords, animationDuration = 0) {\n        Object.assign(this.$coords, newCoords);\n        this.engine().animate(this, animationDuration > 0).plot(this._getPath());\n        if (this.isDirected())\n            this._redrawArrow(animationDuration);\n        return this;\n    }\n    _createArrow() {\n        this.marker(\"end\", 5, 4, function (add) {\n            add.polygon([0, 0, 5, 2, 0, 4]).addClass(\"filled\");\n        });\n    }\n    _redrawArrow(animationDuration = 0) {\n        const marker = this.reference(\"marker-end\");\n        const radius = this.$coords.r2;\n        const stroke = this.attr(\"stroke-width\");\n        this.engine()\n            .animate(marker, animationDuration > 0)\n            .attr({ refX: radius / stroke + 5 });\n    }\n    toString() {\n        return `${this.getStart()} --\x3e ${this.getEnd()}`;\n    }\n    getStart() {\n        return this.$start;\n    }\n    getEnd() {\n        return this.$end;\n    }\n    setStart(start, animationDuration = 0) {\n        if (start === this.$start)\n            return this;\n        this.$start = start;\n        if (start)\n            this.update({ x1: start.cx(), y1: start.cy() }, animationDuration);\n        return this;\n    }\n    setEnd(end, animationDuration = 0) {\n        if (end === this.$end)\n            return this;\n        this.$end = end;\n        if (end)\n            this.update({ x2: end.cx(), y2: end.cy() }, animationDuration);\n        return this;\n    }\n    setHighlight(high) {\n        super.setHighlight(high);\n        const marker = this.reference(\"marker-end\");\n        if (marker)\n            marker.setHighlight(high);\n        return this;\n    }\n    _getPath() {\n        const C = this.$coords;\n        const xControl = (C.x1 + C.x2) / 2 + (C.y1 - C.y2) * this.getBend();\n        const yControl = (C.y1 + C.y2) / 2 + (C.x2 - C.x1) * this.getBend();\n        return `M ${C.x1} ${C.y1} Q ${xControl} ${yControl} ${C.x2} ${C.y2}`;\n    }\n}\n\n;// ./src/objects/btree-connection.ts\n\nclass BTreeConnection extends Connection {\n    constructor() {\n        super(...arguments);\n        this.$maxBend = 0.1;\n        this.$coords = {\n            x1: 0,\n            x2: 0,\n            y1: 0,\n            y2: 0,\n            r2: 0,\n            n: 0,\n            i: 0,\n        };\n    }\n    init(start, end, child, numChildren, strokeWidth) {\n        Object.assign(this.$coords, { i: child, n: numChildren });\n        return super.init(start, end, strokeWidth);\n    }\n    getBend() {\n        if (this.$coords.n <= 1)\n            return 0;\n        return this.$maxBend * (1 - (2 * this.$coords.i) / (this.$coords.n - 1));\n    }\n    _getPath() {\n        const C = this.$coords;\n        let x1 = C.x1 + (2 * C.i - C.n + 1) * C.r2;\n        const y1 = C.y1 + C.r2;\n        if (C.i === 0)\n            x1 += C.r2 / 4;\n        if (C.i === C.n - 1)\n            x1 -= C.r2 / 4;\n        const xControl = (x1 + C.x2) / 2 + (y1 - C.y2) * this.getBend();\n        const yControl = (y1 + C.y2) / 2 + (C.x2 - x1) * this.getBend();\n        return `M ${x1} ${y1} Q ${xControl} ${yControl} ${C.x2} ${C.y2}`;\n    }\n}\n\n;// ./src/objects/btree-node.ts\n\n\nclass BTreeNode extends G {\n    constructor() {\n        super(...arguments);\n        this.$parent = null;\n        this.$children = null;\n        this.$rect = null;\n        this.$values = [];\n        this.$lines = [];\n        this.$rightWidth = 0;\n        this.$leftWidth = 0;\n        this.$childWidths = 0;\n        this.$width = 0;\n    }\n    init(leaf, nvalues, x, y, objectSize, strokeWidth) {\n        if (nvalues < 1)\n            throw new Error(\"BTreeNode: must have at least one value\");\n        this.$children = leaf ? null : Array(nvalues + 1);\n        this.setNumValues(nvalues, objectSize, strokeWidth);\n        if (x && y)\n            this.center(x, y);\n        return this;\n    }\n    toString() {\n        return `[${this.getTexts().join(\" | \")}]`;\n    }\n    numValues() {\n        return this.$values.length;\n    }\n    numChildren() {\n        var _a;\n        return ((_a = this.$children) === null || _a === void 0 ? void 0 : _a.length) || 0;\n    }\n    isLeaf() {\n        return this.$children === null;\n    }\n    setLeaf(leaf, strokeWidth) {\n        if (leaf && this.$children) {\n            for (let i = 0; i < this.$children.length; i++) {\n                this.setChild(i, null, strokeWidth);\n            }\n            this.$children = null;\n        }\n        else {\n            this.$children = Array(this.numValues() + 1);\n        }\n        return this;\n    }\n    insertValue(i, text, objectSize, strokeWidth, leftChildInsert = false) {\n        var _a;\n        if (i < this.numValues()) {\n            const dx = (i / Math.max(1, this.numValues()) - 1) * objectSize;\n            this.dmoveCenter(dx, 0);\n        }\n        this.$values.splice(i, 0);\n        this.$lines.splice(i, 0);\n        if (!this.isLeaf()) {\n            const j = leftChildInsert ? i : i + 1;\n            (_a = this.$children) === null || _a === void 0 ? void 0 : _a.splice(j, 0);\n        }\n        this.setNumValues(this.numValues(), objectSize, strokeWidth);\n        this.setText(i, text);\n        return this;\n    }\n    deleteValue(i, objectSize, strokeWidth, leftChildDelete = true) {\n        var _a;\n        this.$values[i].remove();\n        this.$values.splice(i, 1);\n        const l = Math.max(i, 1);\n        this.$lines[l].remove();\n        this.$lines.splice(l, 1);\n        if (!this.isLeaf()) {\n            const j = leftChildDelete ? i : i + 1;\n            this.setChild(j, null, strokeWidth);\n            (_a = this.$children) === null || _a === void 0 ? void 0 : _a.splice(j, 1);\n        }\n        this.setNumValues(this.numValues(), objectSize, strokeWidth);\n        return this;\n    }\n    setNumValues(nvalues, objectSize, strokeWidth) {\n        var _a, _b, _c, _d, _e;\n        while (nvalues < this.numValues()) {\n            if (!this.isLeaf()) {\n                this.setChild(((_a = this.$children) === null || _a === void 0 ? void 0 : _a.length) || 0 - 1, null, strokeWidth);\n                (_b = this.$children) === null || _b === void 0 ? void 0 : _b.pop();\n            }\n            (_c = this.$values.pop()) === null || _c === void 0 ? void 0 : _c.remove();\n            (_d = this.$lines.pop()) === null || _d === void 0 ? void 0 : _d.remove();\n        }\n        const w0 = objectSize, h = objectSize, stroke = strokeWidth;\n        if (!this.$rect)\n            this.$rect = this.rect(w0 * nvalues, h)\n                .stroke({ width: stroke })\n                .center(0, 0);\n        this.$rect.width(w0 * Math.max(0.5, nvalues)).radius(h / 4);\n        const cx = this.$rect.cx(), cy = this.$rect.cy();\n        for (let i = 0; i < nvalues; i++) {\n            if (!this.$values[i])\n                this.$values[i] = this.text(NBSP);\n            this.$values[i].center(cx + w0 * (i - nvalues / 2 + 0.5), cy);\n            if (i > 0) {\n                const dx = w0 * (i - nvalues / 2), dy = h / 2;\n                if (!this.$lines[i])\n                    this.$lines[i] = this.line(0, cy - dy, 0, cy + dy).stroke({\n                        width: stroke,\n                    });\n                this.$lines[i].cx(cx + dx);\n            }\n        }\n        if (!this.isLeaf() && this.$children) {\n            const n = (this.$children.length = nvalues + 1);\n            for (let i = 0; i < n; i++) {\n                (_e = this.$children[i]) === null || _e === void 0 ? void 0 : _e.update({ i: i, n: n });\n            }\n        }\n        return this;\n    }\n    getCX(i, objectSize) {\n        return this.cx() + objectSize * (i - this.numValues() / 2 + 0.5);\n    }\n    getWidth() {\n        var _a;\n        return Number((_a = this.$rect) === null || _a === void 0 ? void 0 : _a.width()) || 0;\n    }\n    getHeight() {\n        var _a;\n        return Number((_a = this.$rect) === null || _a === void 0 ? void 0 : _a.height()) || 0;\n    }\n    getSize() {\n        return this.getHeight();\n    }\n    getTexts() {\n        return this.$values.map((t) => t.text());\n    }\n    setTexts(texts) {\n        if (texts.length !== this.numValues())\n            throw new Error(`Wrong number of texts: ${texts.length} != ${this.numValues()}`);\n        for (let i = 0; i < texts.length; i++) {\n            this.setText(i, texts[i]);\n        }\n        return this;\n    }\n    getText(c) {\n        return this.$values[c].text();\n    }\n    setText(i, text) {\n        if (text == null)\n            text = \"\";\n        text = `${text}`;\n        if (text === \"\")\n            text = NBSP;\n        this.$values[i].text(text);\n        return this;\n    }\n    getParent() {\n        var _a;\n        return ((_a = this.$parent) === null || _a === void 0 ? void 0 : _a.getStart()) || null;\n    }\n    getChildren() {\n        var _a;\n        return (((_a = this.$children) === null || _a === void 0 ? void 0 : _a.map((e) => e === null || e === void 0 ? void 0 : e.getEnd()).filter((e) => e !== null && e !== undefined)) || []);\n    }\n    getChild(i) {\n        var _a, _b;\n        return ((_b = (_a = this.$children) === null || _a === void 0 ? void 0 : _a[i]) === null || _b === void 0 ? void 0 : _b.getEnd()) || null;\n    }\n    getLeft() {\n        return this.getChild(0);\n    }\n    getRight() {\n        return this.getChild(this.numChildren() - 1);\n    }\n    isChild(c) {\n        var _a;\n        return this === ((_a = this.getParent()) === null || _a === void 0 ? void 0 : _a.getChild(c));\n    }\n    getParentIndex() {\n        const parent = this.getParent();\n        if (!parent)\n            return null;\n        for (let i = 0; i < parent.numChildren(); i++) {\n            if (this === parent.getChild(i))\n                return i;\n        }\n        return null;\n    }\n    getParentEdge() {\n        return this.$parent;\n    }\n    getChildEdge(i) {\n        var _a;\n        return ((_a = this.$children) === null || _a === void 0 ? void 0 : _a[i]) || null;\n    }\n    setChild(i, child, strokeWidth) {\n        var _a, _b, _c, _d;\n        if ((_a = this.$children) === null || _a === void 0 ? void 0 : _a[i]) {\n            const oldChild = this.$children[i].getEnd();\n            oldChild.$parent = null;\n            this.$children[i].remove();\n        }\n        if (!child) {\n            if ((_b = this.$children) === null || _b === void 0 ? void 0 : _b[i])\n                this.$children[i] = null;\n        }\n        else {\n            if (child.$parent) {\n                const oldParent = child.$parent.getStart();\n                (_c = oldParent === null || oldParent === void 0 ? void 0 : oldParent.$children) === null || _c === void 0 ? void 0 : _c.forEach((oldParentChild) => {\n                    if (child.$parent === oldParentChild) {\n                        oldParentChild = null;\n                    }\n                });\n                child.$parent.remove();\n            }\n            const edge = this.root().bTreeConnection(this, child, i, this.numChildren(), strokeWidth);\n            if ((_d = this.$children) === null || _d === void 0 ? void 0 : _d[i])\n                this.$children[i] = edge;\n            child.$parent = edge;\n        }\n        return this;\n    }\n    setParent(c, parent, strokeWidth) {\n        parent.setChild(c, this, strokeWidth);\n        return this;\n    }\n    setParentHighlight(high) {\n        var _a;\n        this.setHighlight(high);\n        (_a = this.getParent()) === null || _a === void 0 ? void 0 : _a.setHighlight(high);\n        return this;\n    }\n    setChildHighlight(i, high) {\n        var _a;\n        this.setHighlight(high);\n        (_a = this.getChild(i)) === null || _a === void 0 ? void 0 : _a.setHighlight(high);\n        return this;\n    }\n    remove() {\n        var _a, _b, _c;\n        if (!this.isLeaf()) {\n            (_a = this.$children) === null || _a === void 0 ? void 0 : _a.forEach((child) => {\n                if (!child)\n                    return;\n                child.remove();\n                child = null;\n            });\n        }\n        if (this.$parent) {\n            const i = this.getParentIndex();\n            if (i && ((_c = (_b = this.$parent.getStart()) === null || _b === void 0 ? void 0 : _b.$children) === null || _c === void 0 ? void 0 : _c[i]))\n                this.$parent.getStart().$children[i] = null;\n            this.$parent.remove();\n            this.$parent = null;\n        }\n        super.remove();\n        return this;\n    }\n    setCenter(x, y, animationDuration = 0) {\n        var _a, _b;\n        super.setCenter(x, y, animationDuration);\n        (_a = this.$children) === null || _a === void 0 ? void 0 : _a.forEach((child) => {\n            child === null || child === void 0 ? void 0 : child.update({ x1: x, y1: y }, animationDuration);\n        });\n        (_b = this.$parent) === null || _b === void 0 ? void 0 : _b.update({ x2: x, y2: y }, animationDuration);\n        return this;\n    }\n    resize(startX, startY, svgMargin, nodeSpacing, animationDuration = 0) {\n        this._resizeWidths(nodeSpacing);\n        const svgWidth = this.root().viewbox().width;\n        if (startX + this.$rightWidth > svgWidth - svgMargin)\n            startX = svgWidth - this.$rightWidth - svgMargin;\n        if (startX - this.$leftWidth < svgMargin)\n            startX = this.$leftWidth + svgMargin;\n        this._setNewPositions(startX, startY, animationDuration);\n        return this;\n    }\n    _resizeWidths(nodeSpacing) {\n        var _a, _b;\n        let left = 0, right = 0;\n        this.$childWidths = 0;\n        this.$width = this.getWidth();\n        if (!this.isLeaf()) {\n            for (const child of this.getChildren()) {\n                this.$childWidths += (child === null || child === void 0 ? void 0 : child._resizeWidths(nodeSpacing)) || 0;\n            }\n            const xSpacing = nodeSpacing;\n            this.$width = Math.max(this.$width, this.$childWidths + this.numValues() * xSpacing);\n            left = ((_a = this.getLeft()) === null || _a === void 0 ? void 0 : _a.$leftWidth) || 0;\n            right = ((_b = this.getRight()) === null || _b === void 0 ? void 0 : _b.$rightWidth) || 0;\n        }\n        const mid = this.$width - left - right;\n        this.$leftWidth = mid / 2 + left;\n        this.$rightWidth = mid / 2 + right;\n        return this.$width;\n    }\n    _setNewPositions(x, y, nodeSpacing, animationDuration = 0) {\n        this.setCenter(x, y, animationDuration);\n        if (this.isLeaf())\n            return;\n        x -= this.$leftWidth;\n        const xSpacing = (this.$width - this.$childWidths) / this.numValues();\n        const ySpacing = nodeSpacing;\n        const nextY = y + this.getHeight() + ySpacing;\n        for (const child of this.getChildren()) {\n            child === null || child === void 0 ? void 0 : child._setNewPositions(x + child.$leftWidth, nextY, animationDuration);\n            x += ((child === null || child === void 0 ? void 0 : child.$width) || 0) + xSpacing;\n        }\n    }\n}\n\n;// ./src/objects/highlight-circle.ts\n\nclass HighlightCircle extends Circle {\n    init(x, y, radius, strokeWidth) {\n        return this.radius(radius)\n            .stroke({ width: strokeWidth })\n            .center(x, y)\n            .addClass(\"highlight-circle\");\n    }\n    getSize() {\n        const r = this.attr(\"r\");\n        if (typeof r === \"number\")\n            return r * 2;\n        if (typeof r === \"string\" && !isNaN(Number(r)))\n            return Number(r) * 2;\n        return 0;\n    }\n    setSize(diameter, animationDuration) {\n        this.engine()\n            .animate(this, animationDuration > 0)\n            .attr(\"r\", String(diameter / 2));\n        return this;\n    }\n}\n\n;// ./src/objects/index.ts\n\n\n\n\n\n\n\n\n\nextend(Element, {\n    getHighlight() {\n        return this.hasClass(\"highlight\");\n    },\n    setHighlight(high) {\n        if (high == null)\n            this.toggleClass(\"highlight\");\n        else if (high)\n            this.addClass(\"highlight\");\n        else\n            this.removeClass(\"highlight\");\n        return this;\n    },\n    getCenter() {\n        return [this.cx(), this.cy()];\n    },\n    setCenter(x, y, animationDuration = 0) {\n        return this\n            .engine()\n            .animate(this, animationDuration > 0)\n            .center(x, y);\n    },\n    dmoveCenter(dx, dy, animationDuration = 0) {\n        this.setCenter(this.cx() + dx, this.cy() + dy, animationDuration);\n        return this;\n    },\n    engine() {\n        return this.root().$engine;\n    },\n});\nextend(Container, {\n    highlightCircle(x, y, radius, strokeWidth) {\n        return this\n            .put(new HighlightCircle())\n            .init(x, y, radius, strokeWidth);\n    },\n    textCircle(text, x, y, size, strokeWidth) {\n        return this\n            .put(new TextCircle())\n            .init(text, x, y, size, strokeWidth);\n    },\n    graphNode(text, x, y, size, strokeWidth) {\n        return this\n            .put(new GraphNode())\n            .init(text, x, y, size, strokeWidth);\n    },\n    binaryNode(text, x, y, size, strokeWidth) {\n        return this\n            .put(new BinaryNode())\n            .init(text, x, y, size, strokeWidth);\n    },\n    avlNode(text, x, y, size, strokeWidth) {\n        return this\n            .put(new AVLNode())\n            .init(text, x, y, size, strokeWidth);\n    },\n    connection(start, end, strokeWidth, bend, directed) {\n        return this\n            .put(new Connection())\n            .init(start, end, strokeWidth, bend, directed);\n    },\n    bTreeNode(leaf, nvalues, x, y, objectSize, strokeWidth) {\n        return this\n            .put(new BTreeNode())\n            .init(leaf, nvalues, x, y, objectSize, strokeWidth);\n    },\n    bTreeConnection(start, end, child, numChildren, strokeWidth) {\n        return this\n            .put(new BTreeConnection())\n            .init(start, end, child, numChildren, strokeWidth);\n    },\n});\n\n\n;// ./src/engine.ts\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nclass Engine {\n    getAnimationSpeed() {\n        var _a;\n        if (this.toolbar.animationSpeed)\n            return parseInt((_a = this.toolbar.animationSpeed) === null || _a === void 0 ? void 0 : _a.value);\n        return this.$Svg.animationSpeed;\n    }\n    getObjectSize() {\n        var _a;\n        if (this.toolbar.objectSize)\n            return parseInt((_a = this.toolbar.objectSize) === null || _a === void 0 ? void 0 : _a.value);\n        return this.$Svg.objectSize;\n    }\n    getNodeSpacing() {\n        return this.getObjectSize();\n    }\n    getStrokeWidth() {\n        return this.getObjectSize() / 12;\n    }\n    getNodeStart() {\n        return [this.$Svg.margin + this.getObjectSize() / 2, this.$Svg.margin * 4];\n    }\n    getTreeRoot() {\n        return [\n            this.Svg.viewbox().width / 2,\n            2 * this.$Svg.margin + this.getObjectSize() / 2,\n        ];\n    }\n    constructor(containerSelector, defaults = {}) {\n        this.$Svg = {\n            width: 1000,\n            height: 600,\n            margin: 30,\n            objectSize: 40,\n            animationSpeed: 1000,\n        };\n        this.$CookieExpireDays = 30;\n        this.$Cookies = {\n            animationSpeed: {\n                getCookie: (value) => {\n                    if (this.toolbar.animationSpeed)\n                        this.toolbar.animationSpeed.value = value;\n                },\n                setCookie: () => this.getAnimationSpeed(),\n            },\n            objectSize: {\n                getCookie: (value) => {\n                    if (this.toolbar.objectSize)\n                        this.toolbar.objectSize.value = value;\n                },\n                setCookie: () => this.getObjectSize(),\n            },\n        };\n        this.actions = [];\n        this.CurrentAction = 0;\n        this.CurrentStep = 0;\n        this.DEBUG = true;\n        this.State = {\n            resetting: false,\n            animating: false,\n        };\n        this.Info = {\n            title: undefined,\n            body: undefined,\n            printer: undefined,\n            status: undefined,\n        };\n        this.EventListeners = {\n            stepForward: {},\n            stepBackward: {},\n            fastForward: {},\n            fastBackward: {},\n            toggleRunner: {},\n        };\n        this.$IdleListeners = {\n            stepBackward: {\n                type: \"click\",\n                condition: () => this.actions.length > 0,\n                handler: () => {\n                    this.setRunning(false);\n                    const action = this.actions.pop();\n                    this.execute(action.oper, action.args, action.nsteps - 1);\n                },\n            },\n            fastBackward: {\n                type: \"click\",\n                condition: () => this.actions.length > 0,\n                handler: () => {\n                    this.actions.pop();\n                    if (this.actions.length > 0) {\n                        const action = this.actions.pop();\n                        this.execute(action.oper, action.args, action.nsteps);\n                    }\n                    else {\n                        this.reset();\n                    }\n                },\n            },\n            objectSize: {\n                type: \"change\",\n                condition: () => true,\n                handler: () => {\n                    if (this.actions.length > 0) {\n                        const action = this.actions.pop();\n                        this.execute(action.oper, action.args, action.nsteps);\n                    }\n                    else {\n                        this.reset();\n                    }\n                },\n            },\n        };\n        this.$AsyncListeners = {\n            stepForward: {\n                type: \"click\",\n                handler: (resolve, reject) => {\n                    this.setRunning(false);\n                    this.stepForward(resolve, reject);\n                },\n            },\n            fastForward: {\n                type: \"click\",\n                handler: (resolve, reject) => {\n                    this.actions[this.CurrentAction].nsteps = Number.MAX_SAFE_INTEGER;\n                    this.fastForward(resolve, reject);\n                },\n            },\n            toggleRunner: {\n                type: \"click\",\n                handler: (resolve, reject) => {\n                    this.toggleRunner();\n                    if (this.isRunning()) {\n                        this.stepForward(resolve, reject);\n                    }\n                    else {\n                        this.CurrentStep++;\n                        resolve(undefined);\n                    }\n                },\n            },\n            stepBackward: {\n                type: \"click\",\n                handler: (resolve, reject) => reject({ until: this.CurrentStep - 1, running: false }),\n            },\n            fastBackward: {\n                type: \"click\",\n                handler: (resolve, reject) => reject({ until: 0 }),\n            },\n            objectSize: {\n                type: \"change\",\n                handler: (resolve, reject) => reject({ until: this.CurrentStep }),\n            },\n        };\n        for (const key in defaults) {\n            if (!key.startsWith(\"$\"))\n                throw new TypeError(`Invalid default key: ${key}`);\n        }\n        updateDefault(this, defaults, true);\n        const container = document.querySelector(containerSelector);\n        if (!container)\n            throw new Error(\"No container found\");\n        this.container = container;\n        this.toolbar = this.getToolbar();\n        const svgContainer = this.container.querySelector(\"svg\");\n        if (!svgContainer)\n            throw new Error(\"No svg element found\");\n        this.Svg = new Svg(svgContainer);\n        this.Svg.viewbox(0, 0, this.$Svg.width, this.$Svg.height);\n        this.Svg.$engine = this;\n        const debugParam = new URLSearchParams(window.location.href).get(\"debug\");\n        this.DEBUG = Boolean(debugParam || false);\n        if (this.DEBUG)\n            this.Svg.addClass(\"debug\");\n    }\n    getToolbar() {\n        const generalControls = this.container.querySelector(\"fieldset.generalControls\");\n        const algorithmControls = this.container.querySelector(\"fieldset.algorithmControls\");\n        const stepForward = this.container.querySelector(\"button.stepForward\");\n        const stepBackward = this.container.querySelector(\"button.stepBackward\");\n        const toggleRunner = this.container.querySelector(\"button.toggleRunner\");\n        const fastForward = this.container.querySelector(\"button.fastForward\");\n        const fastBackward = this.container.querySelector(\"button.fastBackward\");\n        const objectSize = this.container.querySelector(\"select.objectSize\");\n        const animationSpeed = this.container.querySelector(\"select.animationSpeed\");\n        if (!generalControls)\n            throw new Error(\"Missing general controls fieldset\");\n        if (!algorithmControls)\n            throw new Error(\"Missing algorithm controls fieldset\");\n        if (!stepForward)\n            throw new Error(\"Missing step forward button\");\n        if (!stepBackward)\n            throw new Error(\"Missing step backward button\");\n        if (!toggleRunner)\n            throw new Error(\"Missing toggle runner button\");\n        if (!fastForward)\n            throw new Error(\"Missing fast forward button\");\n        if (!fastBackward)\n            throw new Error(\"Missing fast backward button\");\n        if (!objectSize)\n            throw new Error(\"Missing object size select\");\n        if (!animationSpeed)\n            throw new Error(\"Missing animation speed select\");\n        return {\n            generalControls,\n            algorithmControls,\n            stepForward,\n            stepBackward,\n            toggleRunner,\n            fastForward,\n            fastBackward,\n            objectSize,\n            animationSpeed,\n        };\n    }\n    initialise() {\n        this.initToolbar();\n        this.resetAll();\n        this.setRunning(true);\n    }\n    initToolbar() {\n        this.toolbar.animationSpeed.addEventListener(\"change\", () => this.saveCookies());\n    }\n    resetAll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.actions = [];\n            this.loadCookies();\n            yield this.reset();\n        });\n    }\n    confirmResetAll() {\n        if (confirm(\"This clears the canvas and your history!\")) {\n            this.resetAll();\n            return true;\n        }\n        return false;\n    }\n    reset() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.clearCanvas();\n            yield this.resetAlgorithm();\n            this.resetListeners(false);\n        });\n    }\n    resetAlgorithm() {\n        return __awaiter(this, void 0, void 0, function* () { });\n    }\n    clearCanvas() {\n        this.Svg.clear();\n        const w = this.Svg.viewbox().width;\n        const h = this.Svg.viewbox().height;\n        if (this.DEBUG) {\n            for (let x = 1; x < w / 100; x++)\n                this.Svg.line(x * 100, 0, x * 100, h).addClass(\"gridline\");\n            for (let y = 1; y < h / 100; y++)\n                this.Svg.line(0, y * 100, w, y * 100).addClass(\"gridline\");\n        }\n        const margin = this.$Svg.margin;\n        this.Info.title = this.Svg.text(NBSP).addClass(\"title\").x(margin).y(margin);\n        this.Info.body = this.Svg.text(NBSP)\n            .addClass(\"message\")\n            .x(margin)\n            .y(2 * margin);\n        this.Info.printer = this.Svg.text(NBSP)\n            .addClass(\"printer\")\n            .x(margin)\n            .cy(h - 2 * margin);\n        this.Info.status = this.Svg.text(NBSP)\n            .addClass(\"status-report\")\n            .x(margin)\n            .cy(h - margin);\n        this.updateCSSVariables();\n    }\n    updateCSSVariables() {\n        const relativeSize = Math.round((100 * this.getObjectSize()) / this.$Svg.objectSize);\n        document.documentElement.style.setProperty(\"--node-font-size\", `${relativeSize}%`);\n    }\n    setStatus(status, timeout = 10) {\n        const currentStatus = this.Info.status;\n        if (currentStatus === undefined)\n            return;\n        setTimeout(() => {\n            if (status === \"running\") {\n                currentStatus\n                    .text(\"Animating\")\n                    .removeClass(\"paused\")\n                    .addClass(\"running\");\n            }\n            else if (status === \"paused\") {\n                currentStatus.text(\"Paused\").addClass(\"paused\").removeClass(\"running\");\n            }\n            else {\n                currentStatus.text(\"Idle\").removeClass(\"paused\").removeClass(\"running\");\n            }\n        }, timeout);\n    }\n    setIdleTitle() {\n        if (this.Info.title !== undefined)\n            this.Info.title.text(\"Select an action from the menu above\");\n        if (this.Info.body !== undefined)\n            this.Info.body.text(NBSP);\n    }\n    disableWhenRunning(disabled) {\n        for (const elem of this.container.querySelectorAll(\".disableWhenRunning\"))\n            elem.disabled = disabled;\n    }\n    resetListeners(isRunning) {\n        this.saveCookies();\n        this.removeAllListeners();\n        if (this.constructor === Engine) {\n            this.disableWhenRunning(true);\n            return;\n        }\n        this.addListener(\"toggleRunner\", \"click\", () => this.toggleRunner());\n        if (isRunning) {\n            this.disableWhenRunning(true);\n            this.setStatus(\"paused\");\n            return;\n        }\n        this.disableWhenRunning(false);\n        this.setIdleTitle();\n        this.setStatus(\"inactive\");\n        for (const id in this.$IdleListeners) {\n            const listener = this.$IdleListeners[id];\n            if (listener.condition()) {\n                if (this.DEBUG)\n                    this.addListener(id, listener.type, () => {\n                        console.log(`${id} ${listener.type}: ${JSON.stringify(this.actions)}`);\n                        listener.handler();\n                    });\n                else\n                    this.addListener(id, listener.type, listener.handler);\n            }\n        }\n    }\n    addListener(id, type, handler) {\n        const listeners = this.EventListeners;\n        if (!listeners[id])\n            listeners[id] = {};\n        const elem = this.toolbar[id];\n        if (!elem)\n            throw new Error(\"Could not find element to add listener to\");\n        const oldHandler = listeners[id][type];\n        if (oldHandler)\n            elem.removeEventListener(type, oldHandler);\n        listeners[id][type] = handler;\n        elem.addEventListener(type, handler);\n        elem.disabled = false;\n    }\n    removeAllListeners() {\n        const listeners = this.EventListeners;\n        for (const id in listeners) {\n            const elem = this.toolbar[id];\n            if (!elem)\n                throw new Error(\"Could not find element to remove listener from\");\n            elem.disabled = true;\n            for (const type in listeners[id])\n                elem.removeEventListener(type, listeners[id][type]);\n            listeners[id] = {};\n        }\n    }\n    submit(method, field) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const rawValue = field.value;\n                field.value = \"\";\n                const values = parseValues(rawValue);\n                if (values)\n                    yield this.execute(method, values);\n                return true;\n            }\n            catch (error) {\n                console.error(error);\n            }\n            return false;\n        });\n    }\n    execute(operation_1) {\n        return __awaiter(this, arguments, void 0, function* (operation, args = [], until = 0) {\n            yield this.reset();\n            this.actions.push({ oper: operation, args: args, nsteps: until });\n            if (this.DEBUG)\n                console.log(`EXEC ${until}: ${operation} ${args.join(\", \")}, ${JSON.stringify(this.actions)}`);\n            try {\n                yield this.runActionsLoop();\n                this.actions[this.actions.length - 1].nsteps = this.CurrentStep || 0;\n                if (this.DEBUG)\n                    console.log(`DONE / ${this.CurrentStep}: ${JSON.stringify(this.actions)}`);\n                this.resetListeners(false);\n            }\n            catch (reason) {\n                if (typeof reason !== \"object\" ||\n                    reason === null ||\n                    \"until\" in reason === false ||\n                    typeof reason.until !== \"number\") {\n                    console.error(reason);\n                    this.resetListeners(false);\n                    return;\n                }\n                this.actions.pop();\n                if (\"running\" in reason && typeof reason.running === \"boolean\")\n                    this.setRunning(reason.running);\n                until = reason.until;\n                if (this.DEBUG)\n                    console.log(`RERUN ${until} / ${this.CurrentStep}: ${JSON.stringify(this.actions)}`);\n                if (until <= 0 && this.actions.length > 0) {\n                    const action = this.actions.pop();\n                    (operation = action.oper),\n                        (args = action.args),\n                        (until = action.nsteps);\n                }\n                if (until > 0) {\n                    this.execute(operation, args, until);\n                }\n                else {\n                    this.reset();\n                }\n            }\n        });\n    }\n    runActionsLoop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            for (let nAction = 0; nAction < this.actions.length; nAction++) {\n                this.resetListeners(true);\n                const action = this.actions[nAction];\n                this.CurrentAction = nAction;\n                this.CurrentStep = 0;\n                const messageArr = action.oper.match(/[A-Za-z][a-z]*/g) || [];\n                let message = messageArr.join(\" \");\n                message = `${message.charAt(0).toUpperCase() + message.substring(1)} ${action.args.join(\", \")}`;\n                if (this.DEBUG)\n                    console.log(`CALL ${nAction}: ${message}, ${JSON.stringify(this.actions)}`);\n                (_a = this.Info.title) === null || _a === void 0 ? void 0 : _a.text(message);\n                yield this.pause(\"\");\n                if (!(action.oper in this &&\n                    typeof this[action.oper] === \"function\"))\n                    throw new Error(\"Cannot call action that does not exist\");\n                yield this[action.oper](...action.args);\n            }\n        });\n    }\n    pause(message, ...args) {\n        const title = this.getMessage(message, ...args);\n        if (this.DEBUG)\n            console.log(`${this.CurrentStep}. Doing: ${title} (running: ${this.isRunning()}), ${JSON.stringify(this.actions)}`);\n        if (this.State.resetting)\n            return null;\n        if (title !== null && this.Info.body !== undefined) {\n            this.Info.body.text(title);\n        }\n        return new Promise((resolve, reject) => {\n            const action = this.actions[this.CurrentAction];\n            if (action.nsteps != null && this.CurrentStep < action.nsteps) {\n                this.fastForward(resolve, reject);\n            }\n            else {\n                let runnerTimer = undefined;\n                for (const id in this.$AsyncListeners) {\n                    const listener = this.$AsyncListeners[id];\n                    this.addListener(id, listener.type, () => {\n                        clearTimeout(runnerTimer);\n                        listener.handler(resolve, reject);\n                    });\n                }\n                if (this.isRunning()) {\n                    this.setStatus(\"running\");\n                    runnerTimer = setTimeout(() => this.stepForward(resolve, reject), this.getAnimationSpeed() * 1.1);\n                }\n            }\n        });\n    }\n    getMessage(message, ...args) {\n        if (Array.isArray(message))\n            [message, ...args] = [...message, ...args];\n        if (typeof message !== \"string\") {\n            if (args.length > 0)\n                console.error(\"Unknown message:\", message, ...args);\n            return message;\n        }\n        if (!message)\n            return args.join(\"\\n\");\n        let title = this.messages || this.constructor.messages || {};\n        const keys = message.split(\".\");\n        if (!(keys[0] in title))\n            return [message, ...args].join(\"\\n\");\n        for (const key of keys) {\n            if (!(typeof title === \"object\" && key in title)) {\n                console.error(\"Unknown message:\", message, ...args);\n                return [message, ...args].join(\"\\n\");\n            }\n            title = title[key];\n        }\n        if (typeof title === \"function\")\n            title = title(...args);\n        if (Array.isArray(title))\n            title = title.join(\"\\n\");\n        if (typeof title === \"object\") {\n            console.error(\"Unknown message:\", message, ...args);\n            return [message, ...args].join(\"\\n\");\n        }\n        if (title === \"\")\n            title = NBSP;\n        return title;\n    }\n    stepForward(resolve, reject) {\n        this.CurrentStep++;\n        this.State.animating = true;\n        resolve(undefined);\n    }\n    fastForward(resolve, reject) {\n        const action = this.actions[this.CurrentAction];\n        if (this.CurrentStep >= action.nsteps) {\n            action.nsteps = this.CurrentStep;\n        }\n        this.CurrentStep++;\n        this.State.animating = false;\n        if (this.DEBUG)\n            setTimeout(resolve, 10);\n        else\n            resolve(undefined);\n    }\n    isRunning() {\n        var _a;\n        return ((_a = this.toolbar.toggleRunner) === null || _a === void 0 ? void 0 : _a.classList.contains(\"selected\")) || false;\n    }\n    setRunning(running) {\n        var _a;\n        const classes = (_a = this.toolbar.toggleRunner) === null || _a === void 0 ? void 0 : _a.classList;\n        if (classes === undefined)\n            throw new Error(\"Can not access toggleRunner\");\n        if (running)\n            classes.add(\"selected\");\n        else\n            classes.remove(\"selected\");\n        return this;\n    }\n    toggleRunner() {\n        return this.setRunning(!this.isRunning());\n    }\n    loadCookies() {\n        if (this.DEBUG)\n            console.log(\"Loading cookies\", document.cookie);\n        const allCookies = document.cookie.split(\";\");\n        for (const cookieName in this.$Cookies) {\n            for (const cookie of allCookies) {\n                const [cookieName0, value0] = cookie.split(\"=\", 2);\n                if (cookieName0.trim() === cookieName) {\n                    const value = decodeURIComponent(value0);\n                    this.$Cookies[cookieName].getCookie(value);\n                    break;\n                }\n            }\n        }\n    }\n    saveCookies() {\n        let expires = \"\";\n        if (this.$CookieExpireDays > 0) {\n            const exdate = new Date();\n            exdate.setDate(exdate.getDate() + this.$CookieExpireDays);\n            expires = `;expires=${exdate.toUTCString()}`;\n        }\n        for (const cookieName in this.$Cookies) {\n            const value = encodeURIComponent(this.$Cookies[cookieName].setCookie());\n            document.cookie = `${cookieName}=${value}${expires}`;\n        }\n        if (this.DEBUG)\n            console.log(\"Setting cookies\", document.cookie);\n    }\n    animate(elem, animate = true) {\n        if (this.State.animating && animate) {\n            this.setStatus(\"running\");\n            this.setStatus(\"paused\", this.getAnimationSpeed());\n            return elem.animate(this.getAnimationSpeed(), 0, \"now\");\n        }\n        else {\n            return elem;\n        }\n    }\n}\nfunction normalizeNumber(input) {\n    input = input.trim();\n    return input === \"\" || isNaN(Number(input)) ? input : Number(input);\n}\nfunction parseValues(values) {\n    if (!values)\n        return [];\n    if (typeof values === \"string\") {\n        values = values.trim().split(/\\s+/);\n    }\n    return values.map((v) => normalizeNumber(v));\n}\nfunction addReturnSubmit(field, allowed, action) {\n    allowed =\n        allowed === \"int\"\n            ? \"0-9\"\n            : allowed === \"int+\"\n                ? \"0-9 \"\n                : allowed === \"float\"\n                    ? \"-.0-9\"\n                    : allowed === \"float+\"\n                        ? \"-.0-9 \"\n                        : allowed === \"ALPHA\"\n                            ? \"A-Z\"\n                            : allowed === \"ALPHA+\"\n                                ? \"A-Z \"\n                                : allowed === \"alpha\"\n                                    ? \"a-zA-Z\"\n                                    : allowed === \"alpha+\"\n                                        ? \"a-zA-Z \"\n                                        : allowed === \"ALPHANUM\"\n                                            ? \"A-Z0-9\"\n                                            : allowed === \"ALPHANUM+\"\n                                                ? \"A-Z0-9 \"\n                                                : allowed === \"alphanum\"\n                                                    ? \"a-zA-Z0-9\"\n                                                    : allowed === \"alphanum+\"\n                                                        ? \"a-zA-Z0-9 \"\n                                                        : allowed;\n    const regex = new RegExp(`[^${allowed}]`, \"g\");\n    const transform = allowed === allowed.toUpperCase()\n        ? (s) => s.toUpperCase()\n        : allowed === allowed.toLowerCase()\n            ? (s) => s.toLowerCase()\n            : (s) => s;\n    field.oninput = (event) => {\n        let pos = field.selectionStart || 0;\n        let value = transform(field.value);\n        if (regex.test(value)) {\n            value = value.replace(regex, \"\");\n            pos--;\n        }\n        field.value = value;\n        field.setSelectionRange(pos, pos);\n    };\n    if (action) {\n        field.onkeydown = (event) => {\n            if (event.key === \"Enter\") {\n                event.preventDefault();\n                action();\n            }\n        };\n    }\n}\nfunction updateDefault(obj, defaultObj, override = false) {\n    for (const key in defaultObj) {\n        if (!(key in obj)) {\n            obj[key] = defaultObj[key];\n        }\n        else if (typeof obj[key] === \"object\" &&\n            obj[key] !== null &&\n            typeof defaultObj[key] === \"object\" &&\n            defaultObj[key] !== null) {\n            updateDefault(obj[key], defaultObj[key], override);\n        }\n        else if (override) {\n            obj[key] = defaultObj[key];\n        }\n    }\n}\nfunction modulo(n, d) {\n    const rem = n % d;\n    return rem < 0 ? rem + d : rem;\n}\nconst NBSP = \"\\u00A0\";\nfunction compare(a, b) {\n    if (a === NBSP)\n        a = \"\";\n    if (b === NBSP)\n        b = \"\";\n    if (isNaN(Number(a)) === isNaN(Number(b))) {\n        if (!isNaN(Number(a))) {\n            a = Number(a);\n            b = Number(b);\n        }\n        return a === b ? 0 : a < b ? -1 : 1;\n    }\n    else {\n        return isNaN(Number(a)) ? 1 : -1;\n    }\n}\n\n;// ./src/trees/BST.ts\nvar BST_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nclass BST extends Engine {\n    constructor(containerSelector) {\n        super(containerSelector);\n        this.messages = BSTMessages;\n        this.initialValues = [];\n        this.treeRoot = null;\n        this.toolbar = this.getToolbar();\n    }\n    getToolbar() {\n        const toolbar = super.getToolbar();\n        console.log(\"Inserting new 2\");\n        toolbar.generalControls.insertAdjacentHTML(\"beforeend\", `<span class=\"formgroup\"><label>\r\n        <input class=\"showNullNodes\" type=\"checkbox\"/> Show null nodes\r\n       </label></span>`);\n        const showNullNodes = this.container.querySelector(\"input.showNullNodes\");\n        if (!showNullNodes)\n            throw new Error(\"Could not find show null nodes input\");\n        return Object.assign(Object.assign({}, toolbar), { showNullNodes });\n    }\n    initialise(initialValues = null) {\n        this.initialValues = parseValues(initialValues);\n        super.initialise();\n        return this;\n    }\n    resetAlgorithm() {\n        const _super = Object.create(null, {\n            resetAlgorithm: { get: () => super.resetAlgorithm }\n        });\n        return BST_awaiter(this, void 0, void 0, function* () {\n            yield _super.resetAlgorithm.call(this);\n            this.treeRoot = null;\n            if (this.initialValues) {\n                this.State.resetting = true;\n                yield this.insert(...this.initialValues);\n                this.State.resetting = false;\n            }\n        });\n    }\n    initToolbar() {\n        super.initToolbar();\n        this.toolbar.showNullNodes.addEventListener(\"change\", () => this.toggleNullNodes(null));\n        this.toggleNullNodes(true);\n    }\n    toggleNullNodes(show) {\n        if (show == null)\n            show = this.toolbar.showNullNodes.checked;\n        this.toolbar.showNullNodes.checked = show;\n        if (show)\n            this.Svg.addClass(\"shownullnodes\");\n        else\n            this.Svg.removeClass(\"shownullnodes\");\n        return this;\n    }\n    newNode(text) {\n        return this.Svg.binaryNode(text, ...this.getNodeStart(), this.getObjectSize(), this.getStrokeWidth());\n    }\n    resizeTree() {\n        var _a;\n        const animate = !this.State.resetting;\n        (_a = this.treeRoot) === null || _a === void 0 ? void 0 : _a.resize(...this.getTreeRoot(), this.$Svg.margin, this.getNodeSpacing(), animate ? this.$Svg.animationSpeed : 0);\n        return this;\n    }\n    insert(...values) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            for (const val of values)\n                yield this.insertOne(val);\n        });\n    }\n    find(value) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            if (!this.treeRoot) {\n                yield this.pause(\"general.empty\");\n                return { success: false, node: null };\n            }\n            yield this.pause(\"find.start\", value);\n            const found = yield this.findHelper(value);\n            (_a = found.node) === null || _a === void 0 ? void 0 : _a.setHighlight(true);\n            const path = found.success ? \"find.found\" : \"find.notfound\";\n            yield this.pause(path, value);\n            (_b = found.node) === null || _b === void 0 ? void 0 : _b.setHighlight(false);\n            return found;\n        });\n    }\n    findHelper(value) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            let parent = null;\n            let node = this.treeRoot;\n            const pointer = this.Svg.highlightCircle((node === null || node === void 0 ? void 0 : node.cx()) || 0, (node === null || node === void 0 ? void 0 : node.cy()) || 0, this.getObjectSize(), this.getStrokeWidth());\n            while (node) {\n                node.setHighlight(true);\n                const cmp = compare(value, node.getText());\n                if (cmp === 0) {\n                    pointer.remove();\n                    node.setHighlight(false);\n                    return { success: true, node: node };\n                }\n                const direction = cmp < 0 ? \"left\" : \"right\";\n                node.setChildHighlight(direction, true);\n                parent = node;\n                node = parent.getChild(direction);\n                if (node)\n                    pointer.setCenter(node.cx(), node.cy(), this.getAnimationSpeed());\n                yield this.pause(\"find.look\", direction);\n                parent.setChildHighlight(direction, false);\n            }\n            pointer.remove();\n            return { success: false, node: parent };\n        });\n    }\n    insertOne(value) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d, _e, _f;\n            if (!this.treeRoot) {\n                this.treeRoot = this.newNode(value);\n                yield this.pause(\"insert.newroot\", value);\n                this.resizeTree();\n                yield this.pause(undefined);\n                return { success: true, node: this.treeRoot };\n            }\n            yield this.pause(\"insert.search\", value);\n            const found = yield this.findHelper(value);\n            if (found.success) {\n                (_a = found.node) === null || _a === void 0 ? void 0 : _a.setHighlight(true);\n                yield this.pause(\"insert.exists\", found.node);\n                (_b = found.node) === null || _b === void 0 ? void 0 : _b.setHighlight(false);\n                return { success: false, node: found.node };\n            }\n            const child = this.newNode(value);\n            const cmp = compare(value, ((_c = found.node) === null || _c === void 0 ? void 0 : _c.getText()) || \"\");\n            const direction = cmp < 0 ? \"left\" : \"right\";\n            (_d = found.node) === null || _d === void 0 ? void 0 : _d.setChild(direction, child, this.getStrokeWidth());\n            child.setHighlight(true);\n            (_e = found.node) === null || _e === void 0 ? void 0 : _e.setChildHighlight(direction, true);\n            yield this.pause(\"insert.child\", value, direction);\n            (_f = found.node) === null || _f === void 0 ? void 0 : _f.setChildHighlight(direction, false);\n            child.setHighlight(false);\n            this.resizeTree();\n            yield this.pause(undefined);\n            return { success: true, node: child };\n        });\n    }\n    delete(value) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d;\n            if (!this.treeRoot) {\n                yield this.pause(\"general.empty\");\n                return null;\n            }\n            yield this.pause(\"delete.search\", value);\n            const found = yield this.findHelper(value);\n            if (!found.success) {\n                (_a = found.node) === null || _a === void 0 ? void 0 : _a.setHighlight(true);\n                yield this.pause(\"delete.notexists\", value);\n                (_b = found.node) === null || _b === void 0 ? void 0 : _b.setHighlight(false);\n                const direction = compare(value, ((_c = found.node) === null || _c === void 0 ? void 0 : _c.getText()) || \"\") < 0 ? \"left\" : \"right\";\n                return { success: false, direction: direction, parent: found.node };\n            }\n            (_d = found.node) === null || _d === void 0 ? void 0 : _d.setHighlight(true);\n            yield this.pause(\"delete.found\", value);\n            return yield this.deleteHelper(found.node);\n        });\n    }\n    deleteHelper(node) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            if (!((node === null || node === void 0 ? void 0 : node.getLeft()) && (node === null || node === void 0 ? void 0 : node.getRight()))) {\n                return yield this.deleteNode(node);\n            }\n            const pointer = this.Svg.highlightCircle(node.cx(), node.cy(), this.getObjectSize(), this.getStrokeWidth());\n            node.setHighlight(false);\n            node.addClass(\"marked\");\n            yield this.pause(\"delete.predecessor.search\", node);\n            let predecessor = node.getLeft();\n            while (true) {\n                predecessor === null || predecessor === void 0 ? void 0 : predecessor.setParentHighlight(true);\n                pointer.setCenter((predecessor === null || predecessor === void 0 ? void 0 : predecessor.cx()) || 0, (predecessor === null || predecessor === void 0 ? void 0 : predecessor.cy()) || 0, this.getAnimationSpeed());\n                yield this.pause(undefined);\n                predecessor === null || predecessor === void 0 ? void 0 : predecessor.setParentHighlight(false);\n                if (!(predecessor === null || predecessor === void 0 ? void 0 : predecessor.getRight()))\n                    break;\n                predecessor = predecessor.getRight();\n            }\n            predecessor === null || predecessor === void 0 ? void 0 : predecessor.setHighlight(true);\n            pointer.remove();\n            const newText = predecessor === null || predecessor === void 0 ? void 0 : predecessor.getText();\n            const moving = this.Svg.textCircle(newText || \"\", (predecessor === null || predecessor === void 0 ? void 0 : predecessor.cx()) || 0, (predecessor === null || predecessor === void 0 ? void 0 : predecessor.cy()) || 0, this.getObjectSize(), this.getStrokeWidth());\n            moving.addClass(\"unfilled\");\n            moving.setHighlight(true);\n            yield this.pause(\"delete.predecessor.replace\", node, predecessor);\n            moving.setCenter(node.cx(), node.cy(), this.getAnimationSpeed());\n            node.setText(\"\");\n            yield this.pause(undefined);\n            node.setText(newText || \"\");\n            moving.remove();\n            node.removeClass(\"marked\");\n            yield this.pause(\"delete.predecessor.delete\", predecessor);\n            return yield this.deleteNode(predecessor);\n        });\n    }\n    deleteNode(node) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            const child = (node === null || node === void 0 ? void 0 : node.getLeft()) || (node === null || node === void 0 ? void 0 : node.getRight());\n            const parent = node === null || node === void 0 ? void 0 : node.getParent();\n            if (!parent) {\n                if (!child) {\n                    this.treeRoot = null;\n                    yield this.pause(\"delete.root.singleton\", node);\n                }\n                else {\n                    this.treeRoot = child;\n                    yield this.pause(\"delete.root.onechild\", child, node);\n                }\n                node === null || node === void 0 ? void 0 : node.remove();\n                this.resizeTree();\n                yield this.pause(undefined);\n                return { success: true, direction: null, parent: null };\n            }\n            const direction = parent.getLeft() === node ? \"left\" : \"right\";\n            if (child) {\n                node === null || node === void 0 ? void 0 : node.setHighlight(false);\n                if (child === ((_a = parent.getLeft()) === null || _a === void 0 ? void 0 : _a.getLeft()))\n                    node === null || node === void 0 ? void 0 : node.dmoveCenter(-node.getSize(), -node.getSize() / 2, this.getAnimationSpeed());\n                if (child === ((_b = parent.getRight()) === null || _b === void 0 ? void 0 : _b.getRight()))\n                    node === null || node === void 0 ? void 0 : node.dmoveCenter(node.getSize(), -node.getSize() / 2, this.getAnimationSpeed());\n                parent.setChild(direction, child, this.getStrokeWidth());\n                child.setHighlight(true);\n                parent.setChildHighlight(direction, true);\n                yield this.pause(\"delete.redirect\", parent, child);\n                parent.setChildHighlight(direction, false);\n                child.setHighlight(false);\n                node === null || node === void 0 ? void 0 : node.setHighlight(true);\n                yield this.pause(\"delete.node\", node);\n            }\n            else {\n                yield this.pause(\"delete.leaf\", node);\n            }\n            node === null || node === void 0 ? void 0 : node.remove();\n            this.resizeTree();\n            yield this.pause(undefined);\n            return { success: true, direction: direction, parent: parent };\n        });\n    }\n    print() {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            var _a;\n            if (!this.treeRoot) {\n                yield this.pause(\"general.empty\");\n                return;\n            }\n            const { x, y } = ((_a = this.Info.printer) === null || _a === void 0 ? void 0 : _a.bbox()) || { x: 0, y: 0 };\n            const printed = [\n                this.Svg.text(\"Printed nodes: \").addClass(\"printer\").x(x).y(y),\n            ];\n            const pointer = this.Svg.highlightCircle(...this.getNodeStart(), this.getObjectSize(), this.getStrokeWidth());\n            yield this.printHelper(this.treeRoot, pointer, printed);\n            pointer.remove();\n            yield this.pause(undefined);\n            for (const lbl of printed)\n                lbl.remove();\n        });\n    }\n    printHelper(node, pointer, printed) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            pointer.setCenter(node.cx(), node.cy(), this.getAnimationSpeed());\n            yield this.pause(undefined);\n            if (node.getLeft()) {\n                yield this.printHelper(node.getLeft(), pointer, printed);\n                pointer.setCenter(node.cx(), node.cy(), this.getAnimationSpeed());\n                yield this.pause(undefined);\n            }\n            const lbl = this.Svg.text(node.getText()).center(node.cx(), node.cy());\n            yield this.pause(undefined);\n            const last = printed[printed.length - 1];\n            const spacing = this.getNodeSpacing() / 2;\n            this.animate(lbl)\n                .cy(last.cy())\n                .x(last.bbox().x2 + spacing);\n            printed.push(lbl);\n            yield this.pause(undefined);\n            if (node.getRight()) {\n                yield this.printHelper(node.getRight(), pointer, printed);\n                this.animate(pointer);\n                pointer.setCenter(node.cx(), node.cy(), this.getAnimationSpeed());\n                yield this.pause(undefined);\n            }\n        });\n    }\n    resetHeight(node) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n        });\n    }\n    doubleRotate(firstDir, node) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            const secondDir = firstDir === \"left\" ? \"right\" : \"left\";\n            const child = node.getChild(secondDir);\n            if (child === undefined || child === null)\n                throw new Error(\"Invalid B node in singleRotate\");\n            yield this.pause(\"rotate.zigzag\", child, secondDir, node, firstDir);\n            yield this.singleRotate(secondDir, child);\n            return yield this.singleRotate(firstDir, node);\n        });\n    }\n    singleRotate(firstDir, node) {\n        return BST_awaiter(this, void 0, void 0, function* () {\n            const secondDir = firstDir === \"left\" ? \"right\" : \"left\";\n            const A = node;\n            const B = A.getChild(secondDir);\n            if (B === undefined || B === null)\n                throw new Error(\"Invalid B node in singleRotate\");\n            const C = B.getChild(firstDir);\n            A.setChildHighlight(secondDir, true);\n            B === null || B === void 0 ? void 0 : B.setHighlight(true);\n            yield this.pause(\"rotate.single\", A, firstDir);\n            const parent = A.getParent();\n            if (parent) {\n                const direction = parent.getLeft() === A ? \"left\" : \"right\";\n                B === null || B === void 0 ? void 0 : B.setParent(direction, parent, this.getStrokeWidth());\n            }\n            else {\n                this.treeRoot = B;\n            }\n            A.setChild(secondDir, C, this.getStrokeWidth());\n            B.setChild(firstDir, A, this.getStrokeWidth());\n            B.setChildHighlight(firstDir, true);\n            A.setHighlight(true);\n            yield this.pause(undefined);\n            this.resizeTree();\n            yield this.pause(undefined);\n            B.setChildHighlight(firstDir, false);\n            A.setHighlight(false);\n            yield this.resetHeight(A);\n            yield this.resetHeight(B);\n            return B;\n        });\n    }\n}\nconst BSTMessages = {\n    general: {\n        empty: \"Tree is empty\",\n    },\n    find: {\n        start: (value) => `Searching for ${value}`,\n        found: (value) => `Found ${value}`,\n        notfound: (value) => `Did not find ${value}`,\n        look: (direction) => `Look into ${direction} child`,\n    },\n    insert: {\n        newroot: (value) => `Create a new tree root ${value}`,\n        search: (value) => `Searching for node to insert ${value}`,\n        exists: (node) => `There is already a node ${node}`,\n        child: (value, direction) => `Insert ${value} as ${direction} child`,\n    },\n    delete: {\n        search: (value) => `Searching for node to delete ${value}`,\n        notexists: (value) => `There is no node ${value}`,\n        found: (value) => `Found node ${value} to delete`,\n        predecessor: {\n            search: (node) => `Finding the predecessor node of ${node}`,\n            replace: (node, predecessor) => `Replace the value of ${node} with ${predecessor}`,\n            delete: (predecessor) => `Now delete the predecessor ${predecessor}`,\n        },\n        redirect: (parent, child) => `Redirect parent ${parent} to child ${child}`,\n        root: {\n            singleton: (root) => `Remove the root node ${root}`,\n            onechild: (child, root) => [\n                `Make the child ${child} the new root,`,\n                `and remove node ${root}`,\n            ],\n        },\n        node: (node) => `Remove node ${node}`,\n        leaf: (node) => `Remove leaf node ${node}`,\n    },\n    rotate: {\n        single: (node, dir) => `Rotate ${node} ${dir}`,\n        zigzag: (child, dir1, node, dir2) => `Zig-zag: Rotate ${child} ${dir1}, then rotate ${node} ${dir2}`,\n    },\n};\n\n;// ./src/trees/AVL.ts\nvar AVL_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nclass AVL extends BST {\n    constructor() {\n        super(...arguments);\n        this.messages = updateDefault(AVLmessages, BSTMessages);\n        this.treeRoot = null;\n        this.pointer = null;\n    }\n    newNode(text) {\n        return this.Svg.avlNode(text, ...this.getNodeStart(), this.getObjectSize(), this.getStrokeWidth());\n    }\n    getHeight(node) {\n        return node ? node.getHeight() : 0;\n    }\n    insertOne(value) {\n        const _super = Object.create(null, {\n            insertOne: { get: () => super.insertOne }\n        });\n        return AVL_awaiter(this, void 0, void 0, function* () {\n            const result = yield _super.insertOne.call(this, value);\n            if (result.success && result.node) {\n                result.node.updateHeightPosition();\n                yield this.updateHeights(result.node, undefined);\n                yield this.updateHeightPositions();\n            }\n            return result;\n        });\n    }\n    delete(value) {\n        const _super = Object.create(null, {\n            delete: { get: () => super.delete }\n        });\n        return AVL_awaiter(this, void 0, void 0, function* () {\n            const result = yield _super.delete.call(this, value);\n            if (result === null || result === void 0 ? void 0 : result.success) {\n                if (result.parent) {\n                    yield this.updateHeights(result.parent, result.direction);\n                }\n                yield this.updateHeightPositions();\n            }\n            return result;\n        });\n    }\n    updateHeightPositions() {\n        return AVL_awaiter(this, void 0, void 0, function* () {\n            this.Svg.find(\"g\").forEach((node) => {\n                if (node instanceof AVLNode)\n                    node.updateHeightPosition();\n            });\n        });\n    }\n    updateHeights(node, fromchild) {\n        return AVL_awaiter(this, void 0, void 0, function* () {\n            const child = (fromchild && node.getChild(fromchild)) || node;\n            this.pointer = this.Svg.highlightCircle(child.cx(), child.cy(), this.getObjectSize(), this.getStrokeWidth());\n            while (node) {\n                this.pointer.setCenter(node.cx(), node.cy(), this.getAnimationSpeed());\n                yield this.pause(\"node.updateHeight\");\n                const leftHeight = this.getHeight(node.getLeft()), rightHeight = this.getHeight(node.getRight());\n                const height = 1 + Math.max(leftHeight, rightHeight);\n                if (height !== this.getHeight(node)) {\n                    node.setHeightHighlight(true);\n                    node.setHeight(height);\n                    yield this.pause(undefined);\n                    node.setHeightHighlight(false);\n                }\n                node = yield this.rebalance(node);\n                node = node.getParent();\n            }\n            this.pointer.remove();\n        });\n    }\n    rebalance(node) {\n        return AVL_awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const leftHeight = this.getHeight(node.getLeft()), rightHeight = this.getHeight(node.getRight());\n            if (Math.abs(leftHeight - rightHeight) <= 1)\n                return node;\n            yield this.pause(\"node.unbalanced\");\n            const left = leftHeight < rightHeight ? \"left\" : \"right\";\n            const right = left === \"left\" ? \"right\" : \"left\";\n            const child = node.getChild(right);\n            const childLeft = this.getHeight(child === null || child === void 0 ? void 0 : child.getChild(left)), childRight = this.getHeight(child === null || child === void 0 ? void 0 : child.getChild(right));\n            (_a = this.pointer) === null || _a === void 0 ? void 0 : _a.hide();\n            if (childLeft <= childRight) {\n                node = (yield this.singleRotate(left, node));\n            }\n            else {\n                node = (yield this.doubleRotate(left, node));\n            }\n            this.pointer = this.Svg.highlightCircle(node.cx(), node.cy(), this.getObjectSize(), this.getStrokeWidth());\n            yield this.pause(\"node.balanced\");\n            return node;\n        });\n    }\n    resetHeight(node) {\n        return AVL_awaiter(this, void 0, void 0, function* () {\n            const height = 1 +\n                Math.max(this.getHeight(node.getLeft()), this.getHeight(node.getRight()));\n            if (height !== this.getHeight(node)) {\n                node.setHeight(height);\n            }\n        });\n    }\n}\nconst AVLmessages = {\n    node: {\n        updateHeight: \"Update node heights\",\n        unbalanced: \"Node is unbalanced!\",\n        balanced: \"Node is now balanced\",\n    },\n};\n\n;// ./src/trees/BTree.ts\nvar BTree_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nclass BTree extends Engine {\n    constructor(containerSelector) {\n        super(containerSelector);\n        this.initialValues = [];\n        this.treeRoot = null;\n        this.messages = Object.assign(Object.assign(Object.assign({}, BSTMessages), BTreeMessages), { find: Object.assign(Object.assign({}, BSTMessages.find), BTreeMessages.find), insert: Object.assign(Object.assign({}, BSTMessages.insert), BTreeMessages.insert), delete: Object.assign(Object.assign({}, BSTMessages.delete), BTreeMessages.delete) });\n        this.toolbar = this.getToolbar();\n    }\n    getToolbar() {\n        const toolbar = super.getToolbar();\n        toolbar.algorithmControls.insertAdjacentHTML(\"beforeend\", `<span class=\"formgroup\"><label>\r\n        Max degree:\r\n        <select class=\"maxDegree disableWhenRunning\">\r\n          <option value=\"3\">2/3-tree</option>\r\n          <option value=\"4\">2/3/4-tree</option>\r\n          <option value=\"5\">Max degree 5</option>\r\n          <option value=\"6\">Max degree 6</option>\r\n        </select>\r\n      </label></span>`);\n        const maxDegree = this.container.querySelector(\"select.maxDegree\");\n        if (!maxDegree)\n            throw new Error(\"Could not find max degree select element\");\n        return Object.assign(Object.assign({}, toolbar), { maxDegree });\n    }\n    initialise(initialValues = null) {\n        this.initialValues = parseValues(initialValues);\n        super.initialise();\n    }\n    resetAlgorithm() {\n        const _super = Object.create(null, {\n            resetAlgorithm: { get: () => super.resetAlgorithm }\n        });\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            yield _super.resetAlgorithm.call(this);\n            this.treeRoot = null;\n            if (this.initialValues) {\n                this.State.resetting = true;\n                yield this.insert(...this.initialValues);\n                this.State.resetting = false;\n            }\n        });\n    }\n    initToolbar() {\n        var _a;\n        super.initToolbar();\n        (_a = this.toolbar.maxDegree) === null || _a === void 0 ? void 0 : _a.addEventListener(\"change\", () => this.confirmResetAll());\n    }\n    getMaxDegree() {\n        var _a;\n        return parseInt(((_a = this.toolbar.maxDegree) === null || _a === void 0 ? void 0 : _a.value) || \"0\");\n    }\n    getMaxKeys() {\n        return this.getMaxDegree() - 1;\n    }\n    getMinKeys() {\n        return Math.floor((this.getMaxDegree() + 1) / 2) - 1;\n    }\n    getSplitIndex() {\n        return Math.floor((this.getMaxDegree() - 1) / 2);\n    }\n    resizeTree(svgMargin, nodeSpacing) {\n        var _a;\n        const animate = !this.State.resetting;\n        (_a = this.treeRoot) === null || _a === void 0 ? void 0 : _a.resize(...this.getTreeRoot(), svgMargin, nodeSpacing, animate ? this.getAnimationSpeed() : 0);\n    }\n    insert(...values) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            for (const val of values)\n                yield this.insertOne(val);\n        });\n    }\n    find(value) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            if (!this.treeRoot) {\n                yield this.pause(\"general.empty\");\n                return;\n            }\n            yield this.pause(\"find.start\", value);\n            const found = yield this.findHelper(value);\n            (_a = found.node) === null || _a === void 0 ? void 0 : _a.setHighlight(true);\n            const path = found.success ? \"find.found\" : \"find.notfound\";\n            yield this.pause(path, value);\n            (_b = found.node) === null || _b === void 0 ? void 0 : _b.setHighlight(false);\n        });\n    }\n    findHelper(value_1) {\n        return BTree_awaiter(this, arguments, void 0, function* (value, findLeaf = false) {\n            let parent = null;\n            let node = this.treeRoot;\n            const pointer = this.Svg.highlightCircle(...this.getNodeStart(), this.getObjectSize(), this.getStrokeWidth());\n            while (node) {\n                pointer.setCenter(node.getCX(0, this.getObjectSize()), node.cy(), this.getAnimationSpeed());\n                node.setHighlight(true);\n                yield this.pause(undefined);\n                let i = 0;\n                let cmpStr = String(value);\n                while (i < node.numValues()) {\n                    const txt = node.getText(i);\n                    const cmp = compare(value, txt);\n                    if (cmp === 0) {\n                        cmpStr = `${txt} = ${value}`;\n                        break;\n                    }\n                    else if (cmp < 0) {\n                        cmpStr = `${cmpStr} < ${txt}`;\n                        break;\n                    }\n                    cmpStr = `${txt} < ${value}`;\n                    i++;\n                }\n                const found = i < node.numValues() && compare(value, node.getText(i)) === 0;\n                pointer.setCenter(node.getCX(i - (found ? 0 : 0.5), this.getObjectSize()), node.cy(), this.getAnimationSpeed());\n                if (node.isLeaf() || (found && !findLeaf)) {\n                    yield this.pause(cmpStr);\n                    pointer.remove();\n                    node.setHighlight(false);\n                    return { success: found, node: node, i: i };\n                }\n                if (found)\n                    i++;\n                yield this.pause(`${cmpStr}: ${this.getMessage(\"node.lookNthChild\", this.getOrdinal(i, node.numChildren()))}`);\n                node.setHighlight(false);\n                parent = node;\n                node = parent.getChild(i);\n            }\n            pointer.remove();\n            return { success: false, node: parent, i: null };\n        });\n    }\n    insertOne(value) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            if (this.treeRoot) {\n                yield this.insertBottomup(value);\n            }\n            else {\n                this.treeRoot = this.Svg.bTreeNode(true, 1, ...this.getNodeStart(), this.getObjectSize(), this.getStrokeWidth());\n                this.treeRoot.setText(0, String(value));\n                yield this.pause(\"insert.newroot\", value);\n                this.resizeTree(this.$Svg.margin, this.getNodeSpacing());\n                yield this.pause(undefined);\n            }\n        });\n    }\n    insertBottomup(value) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            yield this.pause(\"insert.search\", value);\n            const found = yield this.findHelper(value);\n            const node = found.node;\n            if (!node)\n                return;\n            node.setHighlight(true);\n            if (found.success) {\n                yield this.pause(\"insert.exists\", found.node);\n                node.setHighlight(false);\n            }\n            else {\n                node.insertValue(found.i || 0, String(value), this.getObjectSize(), this.getStrokeWidth());\n                this.resizeTree(this.$Svg.margin, this.getNodeSpacing());\n                yield this.pause(\"insert.nth\", value, this.getOrdinal(found.i || 0, node === null || node === void 0 ? void 0 : node.numValues()));\n                node === null || node === void 0 ? void 0 : node.setHighlight(false);\n                yield this.insertRepair(node);\n                yield this.pause(undefined);\n            }\n        });\n    }\n    insertRepair(node) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            if (node.numValues() > this.getMaxKeys()) {\n                if (!node.getParent()) {\n                    this.treeRoot = yield this.split(node);\n                }\n                else {\n                    const newNode = yield this.split(node);\n                    yield this.insertRepair(newNode);\n                }\n            }\n        });\n    }\n    split(node) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            node.setHighlight(true);\n            yield this.pause(\"node.split\", node);\n            const parent = node.getParent();\n            const parentIndex = node.getParentIndex();\n            const risingValue = node.getText(this.getSplitIndex());\n            const rightSplit = this.getSplitIndex() + 1;\n            const risingX = node.getCX(rightSplit - 1, this.getObjectSize());\n            const risingNode = this.Svg.bTreeNode(false, 1, risingX, node.cy(), this.getObjectSize(), this.getStrokeWidth());\n            risingNode.setHighlight(true);\n            risingNode.setText(0, risingValue);\n            const rightValues = node.numValues() - rightSplit;\n            const rightX = node.getCX(rightSplit + rightValues / 2 - 0.5, this.getObjectSize());\n            const rightNode = this.Svg.bTreeNode(node.isLeaf(), rightValues, rightX, node.cy(), this.getObjectSize(), this.getStrokeWidth());\n            rightNode.setHighlight(true);\n            for (let i = rightSplit; i < node.numValues(); i++) {\n                const j = i - rightSplit;\n                rightNode.setText(j, node.getText(i));\n            }\n            if (!node.isLeaf()) {\n                for (let i = rightSplit; i < node.numChildren(); i++) {\n                    const j = i - rightSplit;\n                    rightNode.setChild(j, node.getChild(i), this.getStrokeWidth());\n                }\n            }\n            node.setNumValues(this.getSplitIndex(), this.getObjectSize(), this.getStrokeWidth());\n            risingNode.setChild(0, node, this.getStrokeWidth());\n            risingNode.setChild(1, rightNode, this.getStrokeWidth());\n            if (parent && parentIndex !== null) {\n                parent.setChild(parentIndex, risingNode, this.getStrokeWidth());\n                yield this.pause(undefined);\n                risingNode.setCenter(parent.getCX(parentIndex - 0.5, this.getObjectSize()), parent.cy(), this.getAnimationSpeed());\n                node.setHighlight(false);\n                rightNode.setHighlight(false);\n                yield this.pause(undefined);\n                parent.insertValue(parentIndex, risingValue, this.getObjectSize(), this.getStrokeWidth());\n                parent.setChild(parentIndex, node, this.getStrokeWidth());\n                parent.setChild(parentIndex + 1, rightNode, this.getStrokeWidth());\n                risingNode.remove();\n                this.resizeTree(this.$Svg.margin, this.getNodeSpacing());\n                return parent;\n            }\n            this.treeRoot = risingNode;\n            this.resizeTree(this.$Svg.margin, this.getNodeSpacing());\n            this.treeRoot.setHighlight(false);\n            node.setHighlight(false);\n            rightNode.setHighlight(false);\n            return this.treeRoot;\n        });\n    }\n    getOrdinal(i, n) {\n        if (n === 1) {\n            return \"only\";\n        }\n        else if (n <= 3) {\n            return i === 0 ? \"left\" : i === n - 1 ? \"right\" : \"middle\";\n        }\n        else {\n            return i === 0\n                ? \"first\"\n                : i === 1\n                    ? \"second\"\n                    : i === n - 1\n                        ? \"last\"\n                        : `${i}rd`;\n        }\n    }\n    print() {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            if (!this.treeRoot) {\n                yield this.pause(\"general.empty\");\n                return;\n            }\n            if (!this.Info.printer)\n                throw new Error(\"No info printer\");\n            const { x, y } = this.Info.printer.bbox();\n            const printed = [\n                this.Svg.text(\"Printed nodes: \").addClass(\"printer\").x(x).y(y),\n            ];\n            const pointer = this.Svg.highlightCircle(...this.getNodeStart(), this.getObjectSize(), this.getStrokeWidth());\n            yield this.printHelper(this.treeRoot, pointer, printed);\n            pointer.remove();\n            yield this.pause(undefined);\n            for (const lbl of printed)\n                lbl.remove();\n        });\n    }\n    printHelper(node, pointer, printed) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            if (node.isLeaf()) {\n                for (let i = 0; i < node.numValues(); i++) {\n                    pointer.setCenter(node.getCX(i, this.getObjectSize()), node.cy(), this.getAnimationSpeed());\n                    yield this.printOneLabel(node, i, printed);\n                }\n            }\n            else {\n                for (let i = 0; i < node.numChildren(); i++) {\n                    pointer.setCenter(node.getCX(i - 0.5, this.getObjectSize()), Number(node.y()) + Number(node.height()), this.getAnimationSpeed());\n                    yield this.pause(undefined);\n                    yield this.printHelper(node.getChild(i), pointer, printed);\n                    if (i < node.numValues()) {\n                        pointer.setCenter(node.getCX(i, this.getObjectSize()), node.cy(), this.getAnimationSpeed());\n                        yield this.printOneLabel(node, i, printed);\n                    }\n                    else {\n                        pointer.setCenter(node.getCX(i - 0.5, this.getObjectSize()), node.cy(), this.getAnimationSpeed());\n                        yield this.pause(undefined);\n                    }\n                }\n            }\n        });\n    }\n    printOneLabel(node, i, printed) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            const lbl = this.Svg.text(node.getText(i)).center(node.getCX(i, this.getObjectSize()), node.cy());\n            yield this.pause(undefined);\n            const last = printed[printed.length - 1];\n            const spacing = this.getNodeSpacing() / 2;\n            this.animate(lbl)\n                .cy(last.cy())\n                .x(last.bbox().x2 + spacing);\n            printed.push(lbl);\n            yield this.pause(undefined);\n        });\n    }\n    delete(value) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d, _e;\n            if (!this.treeRoot) {\n                yield this.pause(\"general.empty\");\n                return;\n            }\n            yield this.pause(\"delete.search\", value);\n            const found = yield this.findHelper(value);\n            if (!found.success) {\n                (_a = found.node) === null || _a === void 0 ? void 0 : _a.setHighlight(true);\n                yield this.pause(\"delete.notexists\", value);\n                (_b = found.node) === null || _b === void 0 ? void 0 : _b.setHighlight(false);\n                return;\n            }\n            (_c = found.node) === null || _c === void 0 ? void 0 : _c.setHighlight(true);\n            yield this.pause(\"delete.found\", value);\n            (_d = found.node) === null || _d === void 0 ? void 0 : _d.setHighlight(false);\n            if ((_e = found.node) === null || _e === void 0 ? void 0 : _e.isLeaf()) {\n                yield this.deleteLeaf(found.node, found.i || 0);\n            }\n            else {\n                yield this.deleteNonleaf(found.node, found.i || 0);\n            }\n            if (this.treeRoot.numValues() === 0) {\n                this.treeRoot.setHighlight(true);\n                yield this.pause(\"delete.root.empty\");\n                const newRoot = this.treeRoot.isLeaf() ? null : this.treeRoot.getLeft();\n                this.treeRoot.remove();\n                this.treeRoot = newRoot;\n                this.resizeTree(this.$Svg.margin, this.getNodeSpacing());\n            }\n        });\n    }\n    deleteLeaf(node, i) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            node.setHighlight(true);\n            yield this.pause(\"delete.leaf.nth\", node, this.getOrdinal(i, node.numValues()));\n            node.deleteValue(i, this.getObjectSize(), this.getStrokeWidth());\n            this.resizeTree(this.$Svg.margin, this.getNodeSpacing());\n            node.setHighlight(false);\n            yield this.repairAfterDelete(node);\n        });\n    }\n    deleteNonleaf(node, i) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            node.addClass(\"marked\");\n            const pointer = this.Svg.highlightCircle(node.getCX(i, this.getObjectSize()), node.cy(), this.getObjectSize(), this.getStrokeWidth());\n            yield this.pause(\"find.predecessor\", node.getText(i));\n            let maxNode = node.getChild(i);\n            let j;\n            while (true) {\n                j = ((maxNode === null || maxNode === void 0 ? void 0 : maxNode.numValues()) || 0) - 1;\n                pointer.setCenter((maxNode === null || maxNode === void 0 ? void 0 : maxNode.getCX(j, this.getObjectSize())) || 0, (maxNode === null || maxNode === void 0 ? void 0 : maxNode.cy()) || 0, this.getAnimationSpeed());\n                yield this.pause(undefined);\n                if (maxNode === null || maxNode === void 0 ? void 0 : maxNode.isLeaf())\n                    break;\n                maxNode = (maxNode === null || maxNode === void 0 ? void 0 : maxNode.getRight()) || null;\n            }\n            const maxValue = maxNode.getText(j);\n            const risingNode = this.Svg.bTreeNode(false, 1, maxNode.getCX(j, this.getObjectSize()), maxNode.cy(), this.getObjectSize(), this.getStrokeWidth());\n            risingNode.setHighlight(true);\n            risingNode.setText(0, maxValue);\n            yield this.pause(\"delete.replace\", node.getText(i), maxValue);\n            pointer.remove();\n            risingNode.setCenter(node.getCX(i, this.getObjectSize()), node.cy(), this.getAnimationSpeed());\n            node.setText(i, \"\");\n            yield this.pause(undefined);\n            node.setText(i, maxValue);\n            risingNode.remove();\n            node.removeClass(\"marked\");\n            maxNode.setHighlight(true);\n            yield this.pause(\"delete.leaf.value\", maxValue, maxNode);\n            yield this.deleteLeaf(maxNode, j);\n        });\n    }\n    repairAfterDelete(node) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            if (node.numValues() >= this.getMinKeys())\n                return;\n            const parent = node.getParent();\n            if (!parent)\n                return;\n            node.setHighlight(true);\n            yield this.pause(\"node.tooFew\", node);\n            const i = node.getParentIndex() || 0;\n            if (i > 0 &&\n                parent.getChild(i - 1) !== null &&\n                parent.getChild(i - 1).numValues() > this.getMinKeys()) {\n                yield this.stealFromLeft(node, i);\n            }\n            else if (i < parent.numValues() &&\n                parent.getChild(i + 1) !== null &&\n                parent.getChild(i + 1).numValues() > this.getMinKeys()) {\n                yield this.stealFromRight(node, i);\n            }\n            else if (i < parent.numChildren() - 1) {\n                const nextNode = yield this.mergeRight(node);\n                yield this.repairAfterDelete(nextNode.getParent());\n            }\n            else {\n                const nextNode = yield this.mergeRight(parent.getChild(i - 1));\n                yield this.repairAfterDelete(nextNode.getParent());\n            }\n        });\n    }\n    mergeRight(node) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            const parent = node.getParent();\n            const parentIndex = node.getParentIndex();\n            if (!parent || parentIndex === null)\n                throw new Error(\"Invalid parent\");\n            const parentValue = parent === null || parent === void 0 ? void 0 : parent.getText(parentIndex);\n            const rightSib = parent.getChild(parentIndex + 1);\n            node.setHighlight(true);\n            parent.setHighlight(true);\n            rightSib === null || rightSib === void 0 ? void 0 : rightSib.setHighlight(true);\n            yield this.pause(\"node.mergeRight\", node, parentValue, rightSib);\n            const sinkingNode = this.Svg.bTreeNode(false, 1, parent.getCX(parentIndex, this.getObjectSize()), parent.cy(), this.getObjectSize(), this.getStrokeWidth());\n            sinkingNode.setHighlight(true);\n            sinkingNode.setText(0, parentValue);\n            parent.setText(parentIndex, \"\");\n            const sinkingX = (Number(node.x()) + Number(node.width()) + Number(rightSib === null || rightSib === void 0 ? void 0 : rightSib.x())) / 2;\n            sinkingNode.setCenter(sinkingX, node.cy(), this.getAnimationSpeed());\n            node.setCenter(sinkingX - (this.getObjectSize() + Number(node.width())) / 2, node.cy(), this.getAnimationSpeed());\n            rightSib === null || rightSib === void 0 ? void 0 : rightSib.setCenter(sinkingX + (this.getObjectSize() + Number(rightSib.width())) / 2, node.cy(), this.getAnimationSpeed());\n            yield this.pause(undefined);\n            const nodeSize = node.numValues();\n            const textsToInsert = [parentValue].concat((rightSib === null || rightSib === void 0 ? void 0 : rightSib.getTexts()) || []);\n            node.setNumValues(nodeSize + textsToInsert.length, this.getObjectSize(), this.getStrokeWidth());\n            for (let i = 0; i < textsToInsert.length; i++) {\n                node.setText(nodeSize + i, textsToInsert[i]);\n                if (!node.isLeaf()) {\n                    node.setChild(nodeSize + i + 1, rightSib === null || rightSib === void 0 ? void 0 : rightSib.getChild(i), this.getStrokeWidth());\n                }\n            }\n            parent.deleteValue(parentIndex, this.getObjectSize(), this.getStrokeWidth(), false);\n            sinkingNode.remove();\n            rightSib === null || rightSib === void 0 ? void 0 : rightSib.remove();\n            this.resizeTree(this.$Svg.margin, this.getNodeSpacing());\n            yield this.pause(undefined);\n            node.setHighlight(false);\n            parent.setHighlight(false);\n            return node;\n        });\n    }\n    stealFromRight(node, parentIndex) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            const parent = node.getParent();\n            const rightSib = parent === null || parent === void 0 ? void 0 : parent.getChild(parentIndex + 1);\n            if (!parent || !rightSib)\n                throw new Error(\"Can not steal from right, missing parent or right sibling\");\n            node.setHighlight(true);\n            parent.setHighlight(true);\n            rightSib.setHighlight(true);\n            const leftValue = parent.getText(parentIndex);\n            const rightValue = rightSib.getText(0);\n            yield this.pause(\"node.steal.right\", node, leftValue, rightValue);\n            const leftNode = this.Svg.bTreeNode(false, 1, parent === null || parent === void 0 ? void 0 : parent.getCX(parentIndex, this.getObjectSize()), parent === null || parent === void 0 ? void 0 : parent.cy(), this.getObjectSize(), this.getStrokeWidth());\n            leftNode.setText(0, leftValue || \"\");\n            leftNode.setHighlight(true);\n            const rightNode = this.Svg.bTreeNode(false, 1, rightSib === null || rightSib === void 0 ? void 0 : rightSib.getCX(0, this.getObjectSize()), rightSib === null || rightSib === void 0 ? void 0 : rightSib.cy(), this.getObjectSize(), this.getStrokeWidth());\n            rightNode.setText(0, rightValue || \"\");\n            rightNode.setHighlight(true);\n            node.insertValue(node.numValues(), \"\", this.getObjectSize(), this.getStrokeWidth());\n            parent.setText(parentIndex, \"\");\n            rightSib.setText(0, \"\");\n            leftNode.setCenter(node.getCX(node.numValues() - 1, this.getObjectSize()), node.cy(), this.getAnimationSpeed());\n            rightNode.setCenter(parent.getCX(parentIndex, this.getObjectSize()), parent.cy(), this.getAnimationSpeed());\n            if (!node.isLeaf())\n                node.setChild(node.numChildren() - 1, rightSib.getChild(0), this.getStrokeWidth());\n            yield this.pause(undefined);\n            leftNode.remove();\n            rightNode.remove();\n            rightSib.deleteValue(0, this.getObjectSize(), this.getStrokeWidth());\n            parent.setText(parentIndex, rightValue);\n            node.setText(node.numValues() - 1, leftValue);\n            this.resizeTree(this.$Svg.margin, this.getNodeSpacing());\n            yield this.pause(undefined);\n            node.setHighlight(false);\n            parent.setHighlight(false);\n            rightSib.setHighlight(false);\n            return node;\n        });\n    }\n    stealFromLeft(node, parentIndex) {\n        return BTree_awaiter(this, void 0, void 0, function* () {\n            parentIndex--;\n            const parent = node.getParent();\n            const leftSib = parent === null || parent === void 0 ? void 0 : parent.getChild(parentIndex);\n            if (!parent || !leftSib)\n                throw new Error(\"Can not steal from left, missing parent or left sibling\");\n            node.setHighlight(true);\n            parent.setHighlight(true);\n            leftSib.setHighlight(true);\n            const rightValue = parent.getText(parentIndex);\n            const leftValue = leftSib.getText(leftSib.numValues() - 1);\n            yield this.pause(\"node.steal.left\", node, leftValue, rightValue);\n            const rightNode = this.Svg.bTreeNode(false, 1, parent.getCX(parentIndex, this.getObjectSize()), parent.cy(), this.getObjectSize(), this.getStrokeWidth());\n            rightNode.setText(0, rightValue);\n            rightNode.setHighlight(true);\n            const leftNode = this.Svg.bTreeNode(false, 1, leftSib.getCX(leftSib.numValues() - 1, this.getObjectSize()), leftSib.cy(), this.getObjectSize(), this.getStrokeWidth());\n            leftNode.setText(0, leftValue);\n            leftNode.setHighlight(true);\n            node.insertValue(0, \"\", this.getObjectSize(), this.getStrokeWidth(), true);\n            parent.setText(parentIndex, \"\");\n            leftSib.setText(leftSib.numValues() - 1, \"\");\n            rightNode.setCenter(node.getCX(0, this.getObjectSize()), node.cy(), this.getAnimationSpeed());\n            leftNode.setCenter(parent.getCX(parentIndex, this.getObjectSize()), parent.cy(), this.getAnimationSpeed());\n            if (!node.isLeaf())\n                node.setChild(0, leftSib.getChild(leftSib.numChildren() - 1), this.getStrokeWidth());\n            yield this.pause(undefined);\n            rightNode.remove();\n            leftNode.remove();\n            leftSib.deleteValue(leftSib.numValues() - 1, this.getObjectSize(), this.getStrokeWidth(), false);\n            parent.setText(parentIndex, leftValue);\n            node.setText(0, rightValue);\n            this.resizeTree(this.$Svg.margin, this.getNodeSpacing());\n            yield this.pause(undefined);\n            node.setHighlight(false);\n            parent.setHighlight(false);\n            leftSib.setHighlight(false);\n            return node;\n        });\n    }\n}\nconst BTreeMessages = {\n    find: {\n        predecessor: (val) => `Find the predecessor value of ${val}`,\n    },\n    insert: {\n        nth: (val, nth) => `Insert ${val} as ${nth} value in the node`,\n    },\n    delete: {\n        root: {\n            empty: \"Remove empty tree root\",\n        },\n        leaf: {\n            nth: (leaf, nth) => `Delete the ${nth} value in leaf ${leaf}`,\n            value: (val, leaf) => `Now delete ${val} in the leaf node ${leaf}`,\n        },\n        replace: (val, newVal) => `Replace the value ${val} with ${newVal}`,\n    },\n    node: {\n        lookNthChild: (nth) => `Look into ${nth} child`,\n        split: (node) => `Splitting node ${node}`,\n        tooFew: (node) => `Node ${node} has too few values`,\n        mergeRight: (node, parent, rightSib) => [\n            \"Merging nodes:\",\n            `${node} + [${parent}] + ${rightSib}`,\n        ],\n        steal: {\n            right: (node, left, right) => [\n                \"Stealing from right sibling:\",\n                `${node}  [${left}]  [${right}]`,\n            ],\n            left: (node, left, right) => [\n                \"Stealing from left sibling:\",\n                `[${left}]  [${right}]  ${node}`,\n            ],\n        },\n    },\n};\n\n;// ./src/trees/RedBlack.ts\nvar RedBlack_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nclass RedBlack extends BST {\n    constructor() {\n        super(...arguments);\n        this.messages = Object.assign(Object.assign(Object.assign({}, BSTMessages), RedBlackMessages), { rotate: Object.assign(Object.assign({}, BSTMessages.rotate), RedBlackMessages.rotate) });\n    }\n    newNode(text) {\n        return super.newNode(text).addClass(\"red\");\n    }\n    insertOne(value) {\n        const _super = Object.create(null, {\n            insertOne: { get: () => super.insertOne }\n        });\n        return RedBlack_awaiter(this, void 0, void 0, function* () {\n            const result = yield _super.insertOne.call(this, value);\n            if ((result === null || result === void 0 ? void 0 : result.success) && result.node) {\n                yield this.fixDoubleRed(result.node);\n                if (this.treeRoot && this.isRed(this.treeRoot)) {\n                    yield this.pause(\"color.redRootBlack\");\n                    this.colorBlack(this.treeRoot);\n                }\n            }\n            return result;\n        });\n    }\n    fixDoubleRed(node) {\n        return RedBlack_awaiter(this, void 0, void 0, function* () {\n            let parent = node.getParent();\n            if (!parent)\n                return;\n            if (!this.isRed(parent))\n                return;\n            let grandparent = parent.getParent();\n            if (!grandparent)\n                return;\n            const pibling = parent.getSibling();\n            if (pibling && this.isRed(pibling)) {\n                node.setHighlight(true);\n                parent.setHighlight(true);\n                pibling.setHighlight(true);\n                yield this.pause(\"color.pushDownBlack\", node, parent, pibling);\n                node.setHighlight(false);\n                parent.setHighlight(false);\n                pibling.setHighlight(false);\n                this.colorBlack(pibling);\n                this.colorBlack(parent);\n                this.colorRed(grandparent);\n                yield this.pause(undefined);\n                yield this.fixDoubleRed(grandparent);\n                return;\n            }\n            let side = node.isLeftChild() ? \"left\" : \"right\";\n            let rotate = parent.isLeftChild() ? \"left\" : \"right\";\n            if (side !== rotate) {\n                node.setHighlight(true);\n                parent.setHighlight(true);\n                grandparent.setHighlight(true);\n                yield this.pause(\"rotate.parent\", node, side, rotate, parent),\n                    node.setHighlight(false);\n                parent.setHighlight(false);\n                grandparent.setHighlight(false);\n                node = (yield this.singleRotate(rotate, parent)).getChild(rotate);\n            }\n            side = node.isLeftChild() ? \"left\" : \"right\";\n            rotate = side === \"left\" ? \"right\" : \"left\";\n            parent = node.getParent();\n            grandparent = (parent === null || parent === void 0 ? void 0 : parent.getParent()) || null;\n            if (!parent || !grandparent)\n                throw new Error(\"Missing parent or grandparent\");\n            node.setHighlight(true);\n            parent.setHighlight(true);\n            grandparent === null || grandparent === void 0 ? void 0 : grandparent.setHighlight(true);\n            yield this.pause(\"rotate.grandparent\", node, side, grandparent, rotate);\n            node.setHighlight(false);\n            parent.setHighlight(false);\n            grandparent === null || grandparent === void 0 ? void 0 : grandparent.setHighlight(false);\n            this.colorBlack(parent);\n            this.colorRed(grandparent);\n            yield this.singleRotate(rotate, grandparent);\n        });\n    }\n    delete(value) {\n        const _super = Object.create(null, {\n            delete: { get: () => super.delete }\n        });\n        return RedBlack_awaiter(this, void 0, void 0, function* () {\n            const result = yield _super.delete.call(this, value);\n            if (result === null || result === void 0 ? void 0 : result.success) {\n                if (result.parent && result.direction) {\n                    yield this.fixDeleteImbalance(result.parent, result.direction);\n                }\n                if (this.treeRoot && this.isRed(this.treeRoot)) {\n                    this.colorBlack(this.treeRoot);\n                    yield this.pause(\"color.rootBlack\");\n                }\n            }\n            return result;\n        });\n    }\n    fixDeleteImbalance(parent, dir) {\n        return RedBlack_awaiter(this, void 0, void 0, function* () {\n            const child = parent.getChild(dir);\n            if (child && this.isRed(child)) {\n                this.colorBlack(child);\n                child.setHighlight(true);\n                yield this.pause(\"color.nodeBlack\", child);\n                child.setHighlight(false);\n            }\n            else if (!parent.isLeaf()) {\n                yield this.fixDoubleBlack(parent, dir);\n            }\n        });\n    }\n    fixDoubleBlack(parent, left) {\n        return RedBlack_awaiter(this, void 0, void 0, function* () {\n            const right = left === \"left\" ? \"right\" : \"left\";\n            const rightChild = parent.getChild(right);\n            const rightGrandchild = rightChild === null || rightChild === void 0 ? void 0 : rightChild.getChild(right);\n            const leftGrandchild = rightChild === null || rightChild === void 0 ? void 0 : rightChild.getChild(left);\n            parent.setHighlight(true);\n            yield this.pause(\"balancing.parentImbalanced\", parent);\n            if (rightChild && this.isRed(rightChild)) {\n                parent.setChildHighlight(right, true);\n                rightChild.setHighlight(true);\n                yield this.pause(\"rotate.redSibling\", parent, right, rightChild, left);\n                parent.setChildHighlight(right, false);\n                rightChild.setHighlight(false);\n                this.colorBlack(rightChild);\n                this.colorRed(parent);\n                yield this.singleRotate(left, parent);\n                yield this.fixDoubleBlack(parent, left);\n                return;\n            }\n            if (rightGrandchild && this.isRed(rightGrandchild)) {\n                parent.setChildHighlight(right, true);\n                rightChild === null || rightChild === void 0 ? void 0 : rightChild.setChildHighlight(right, true);\n                rightGrandchild.setHighlight(true);\n                yield this.pause(\"rotate.redDistantChild\", right, rightChild, left);\n                parent.setChildHighlight(right, false);\n                rightChild === null || rightChild === void 0 ? void 0 : rightChild.setChildHighlight(right, false);\n                rightGrandchild.setHighlight(false);\n                if (this.isBlack(parent))\n                    this.colorBlack(rightChild);\n                else\n                    this.colorRed(rightChild);\n                this.colorBlack(parent);\n                this.colorBlack(rightGrandchild);\n                yield this.singleRotate(left, parent);\n                return;\n            }\n            if (rightChild && leftGrandchild && this.isRed(leftGrandchild)) {\n                parent.setChildHighlight(right, true);\n                rightChild.setChildHighlight(left, true);\n                leftGrandchild.setHighlight(true);\n                yield this.pause(\"rotate.redCloseChild\", right, rightChild, left);\n                parent.setChildHighlight(right, false);\n                rightChild.setChildHighlight(left, false);\n                leftGrandchild.setHighlight(false);\n                this.colorRed(rightChild);\n                this.colorBlack(leftGrandchild);\n                yield this.singleRotate(right, rightChild);\n                yield this.fixDoubleBlack(parent, left);\n                return;\n            }\n            if (this.isRed(parent)) {\n                parent.setChildHighlight(right, true);\n                rightChild === null || rightChild === void 0 ? void 0 : rightChild.setHighlight(true);\n                yield this.pause(\"color.switch\", parent, right, rightChild);\n                parent.setChildHighlight(right, false);\n                rightChild === null || rightChild === void 0 ? void 0 : rightChild.setHighlight(false);\n                this.colorBlack(parent);\n                this.colorRed(rightChild);\n                return;\n            }\n            parent.setChildHighlight(right, true);\n            rightChild === null || rightChild === void 0 ? void 0 : rightChild.setHighlight(true);\n            yield this.pause(\"color.childRed\", parent, right, rightChild);\n            parent.setChildHighlight(right, false);\n            rightChild === null || rightChild === void 0 ? void 0 : rightChild.setHighlight(false);\n            this.colorRed(rightChild);\n            const grandparent = parent.getParent();\n            if (grandparent) {\n                const direction = parent === grandparent.getLeft() ? \"left\" : \"right\";\n                yield this.fixDoubleBlack(grandparent, direction);\n            }\n        });\n    }\n    isBlack(node) {\n        return !node || node.hasClass(\"black\");\n    }\n    isRed(node) {\n        return !this.isBlack(node);\n    }\n    colorBlack(node) {\n        node.addClass(\"black\");\n    }\n    colorRed(node) {\n        node.removeClass(\"black\");\n    }\n}\nconst RedBlackMessages = {\n    color: {\n        redRootBlack: \"Tree root is red: Color it black\",\n        rootBlack: \"Color the root black\",\n        nodeBlack: (n) => `Color node ${n} black`,\n        pushDownBlack: (node, parent, pibling) => [\n            `Node ${node}, parent ${parent} and parent's sibling ${pibling} are all red`,\n            \"Push blackness down from grandparent\",\n        ],\n        switch: (parent, dir, dirChild) => [\n            `Parent ${parent} is red,`,\n            `${dir} child ${dirChild} and its children are black:`,\n            \"Switch colors\",\n        ],\n        childRed: (parent, dir, dirChild) => [\n            `Parent ${parent}, ${dir} child ${dirChild} and its children are black:`,\n            `Color ${dir} child red`,\n        ],\n    },\n    balancing: {\n        parentImbalanced: (parent) => `Parent ${parent} is imbalanced`,\n    },\n    rotate: {\n        parent: (node, side, rotate, parent) => [\n            `Node ${node} is a red ${side} child of a red ${rotate} child`,\n            `Rotate parent ${parent} ${rotate}`,\n        ],\n        grandparent: (node, side, grandparent, rotate) => [\n            `Node ${node} is a red ${side} child of a red ${side} child`,\n            `Switch colors and rotate grandparent ${grandparent} ${rotate}`,\n        ],\n        redSibling: (parent, right, rightChild, left) => [\n            `Parent ${parent} is black, and its ${right} child ${rightChild} is red:`,\n            `Switch colors and rotate ${left}`,\n        ],\n        redDistantChild: (right, rightChild, left) => [\n            `${right} child ${rightChild} is black, its ${right} child is red:`,\n            `Switch colors and rotate ${left}`,\n        ],\n        redCloseChild: (right, rightChild, left) => [\n            `${right} child ${rightChild} is black, its ${left} child is red:`,\n            `Switch colors and rotate child ${right}`,\n        ],\n    },\n};\n\n;// ./src/trees/SplayTree.ts\nvar SplayTree_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nclass SplayTree extends BST {\n    constructor() {\n        super(...arguments);\n        this.messages = Object.assign(Object.assign(Object.assign({}, BSTMessages), SplayTreeMessages), { rotate: Object.assign(Object.assign({}, BSTMessages.rotate), SplayTreeMessages.rotate), delete: Object.assign(Object.assign({}, BSTMessages.delete), SplayTreeMessages.delete) });\n    }\n    find(value) {\n        const _super = Object.create(null, {\n            find: { get: () => super.find }\n        });\n        return SplayTree_awaiter(this, void 0, void 0, function* () {\n            const found = yield _super.find.call(this, value);\n            if (found === null || found === void 0 ? void 0 : found.node) {\n                yield this.splayUp(found.node);\n            }\n            return found;\n        });\n    }\n    insertOne(value) {\n        const _super = Object.create(null, {\n            insertOne: { get: () => super.insertOne }\n        });\n        return SplayTree_awaiter(this, void 0, void 0, function* () {\n            const result = yield _super.insertOne.call(this, value);\n            if (result === null || result === void 0 ? void 0 : result.node) {\n                if (!result.success)\n                    yield this.pause(\"insert.exists\", result.node);\n                yield this.splayUp(result.node);\n            }\n            return result;\n        });\n    }\n    delete(value) {\n        return SplayTree_awaiter(this, void 0, void 0, function* () {\n            var _a;\n            if (!this.treeRoot)\n                return { success: false, direction: null, parent: null };\n            yield this.find(value);\n            if (compare(value, (_a = this.treeRoot) === null || _a === void 0 ? void 0 : _a.getText()) !== 0) {\n                yield this.pause(\"delete.notexists\", value);\n                return { success: false, parent: null, direction: null };\n            }\n            this.treeRoot.setHighlight(true);\n            yield this.pause(\"delete.root\");\n            if (!(this.treeRoot.getLeft() && this.treeRoot.getRight())) {\n                const left = this.treeRoot.getLeft() ? \"left\" : \"right\";\n                const right = left === \"left\" ? \"right\" : \"left\";\n                const child = this.treeRoot.getLeft() || this.treeRoot.getRight();\n                const newRoot = child.setHighlight(true);\n                yield this.pause(\"delete.singleChild\", right, left);\n                this.treeRoot.remove();\n                this.treeRoot = newRoot;\n                this.resizeTree();\n                yield this.pause(undefined);\n                return { success: true, parent: this.treeRoot, direction: left };\n            }\n            const right = this.treeRoot.getRight();\n            const left = this.treeRoot.getLeft();\n            this.treeRoot.remove();\n            yield this.pause(\"delete.splayLargest\");\n            let largestLeft = left;\n            largestLeft.setHighlight(true);\n            yield this.pause(undefined);\n            if (largestLeft.getRight()) {\n                while (largestLeft.getRight()) {\n                    largestLeft.setHighlight(false);\n                    largestLeft = largestLeft.getRight();\n                    largestLeft.setHighlight(true);\n                    yield this.pause(undefined);\n                }\n            }\n            largestLeft.setHighlight(false);\n            yield this.splayUp(largestLeft);\n            yield this.pause(\"delete.connectLeftRight\");\n            largestLeft.setHighlight(true);\n            yield this.pause(undefined);\n            largestLeft.setHighlight(false);\n            largestLeft.setRight(right, this.getStrokeWidth());\n            this.treeRoot = largestLeft;\n            this.resizeTree();\n            yield this.pause(undefined);\n            return { success: true, parent: this.treeRoot, direction: null };\n        });\n    }\n    splayUp(node) {\n        return SplayTree_awaiter(this, void 0, void 0, function* () {\n            if (node === this.treeRoot)\n                return;\n            node.setHighlight(true);\n            yield this.pause(\"rotate.splayUp\", node);\n            node.setHighlight(false);\n            while (node.getParent()) {\n                const parent = node.getParent();\n                const left = node.isLeftChild() ? \"left\" : \"right\";\n                const right = left === \"left\" ? \"right\" : \"left\";\n                if (!parent.getParent()) {\n                    node = yield this.singleRotate(right, parent);\n                }\n                else if (parent.isChild(right)) {\n                    node = yield this.doubleRotate(left, parent.getParent());\n                }\n                else {\n                    node = yield this.zigZig(right, parent.getParent());\n                }\n            }\n        });\n    }\n    splayHelper(node) {\n        return SplayTree_awaiter(this, void 0, void 0, function* () {\n            const parent = node.getParent();\n            if (!parent)\n                return;\n            const left = node.isLeftChild() ? \"left\" : \"right\";\n            const right = left === \"left\" ? \"right\" : \"left\";\n            if (!(parent === null || parent === void 0 ? void 0 : parent.getParent())) {\n                this.singleRotate(left, parent);\n            }\n            else if (parent.isChild(right)) {\n                this.doubleRotate(left, parent.getParent());\n                this.splayHelper(node);\n            }\n            else {\n                this.zigZig(right, parent.getParent());\n                this.splayHelper(node);\n            }\n        });\n    }\n    zigZig(left, node) {\n        return SplayTree_awaiter(this, void 0, void 0, function* () {\n            const right = left === \"left\" ? \"right\" : \"left\";\n            const child = node.getChild(right);\n            if (!child)\n                return node;\n            yield this.pause(\"rotate.zigzig\", node, left, child);\n            yield this.singleRotate(left, node);\n            return yield this.singleRotate(left, child);\n        });\n    }\n}\nconst SplayTreeMessages = {\n    delete: {\n        root: \"Remove root, leaving left and right trees\",\n        singleChild: (right, left) => `No ${right} tree, make ${left} tree the root`,\n        splayLargest: \"Splay largest element in left tree to root\",\n        connectLeftRight: \"Left tree now has no right subtree, connect left and right trees\",\n    },\n    rotate: {\n        splayUp: (node) => `Now splaying ${node} up to the root`,\n        zigzig: (node, left, child) => `Zig-zig: Rotate ${node} ${left}, then rotate ${child} ${left}`,\n    },\n};\n\n;// ./src/collections.ts\n\n\n\n\n\n\nconst COLLECTIONS = {\n    BST: BST,\n    AVL: AVL,\n    RedBlack: RedBlack,\n    SplayTree: SplayTree,\n    BTree: BTree,\n};\ninitialiseCollections(\"#collectionsContainer\");\nfunction initialiseCollections(containerID) {\n    const algoSelector = document.querySelector(`${containerID} select.algorithmSelector`);\n    if (!algoSelector)\n        throw new Error(\"Could not find algo selector\");\n    algoSelector.addEventListener(\"change\", () => {\n        const searchParams = new URLSearchParams();\n        if (algoSelector.value in COLLECTIONS)\n            searchParams.set(\"algorithm\", algoSelector.value);\n        else\n            searchParams.delete(\"algorithm\");\n        if (CollectionEngine.DEBUG)\n            searchParams.set(\"debug\", \"true\");\n        else\n            searchParams.delete(\"debug\");\n        const url = `${window.location.pathname}?${searchParams}`;\n        window.history.replaceState(\"\", \"\", url);\n        window.location.reload();\n    });\n    let algo = new URL(window.location.href).searchParams.get(\"algorithm\");\n    if (!(algo && /^[\\w.]+$/.test(algo) && algo in COLLECTIONS)) {\n        algo = \"\";\n    }\n    const algoClass = algo;\n    algoSelector.value = algo;\n    const Collection = algoClass ? COLLECTIONS[algoClass] : Engine;\n    const CollectionEngine = new Collection(containerID);\n    CollectionEngine.initialise();\n    const toolbar = getCollectionsToolbar(CollectionEngine.container);\n    toolbar.insertSelect.addEventListener(\"change\", () => {\n        toolbar.insertField.value = toolbar.insertSelect.value;\n        toolbar.insertSelect.value = \"\";\n    });\n    addReturnSubmit(toolbar.insertField, \"ALPHANUM+\", () => CollectionEngine.submit(\"insert\", toolbar.insertField));\n    toolbar.insertSubmit.addEventListener(\"click\", () => {\n        CollectionEngine.submit(\"insert\", toolbar.insertField);\n    });\n    addReturnSubmit(toolbar.findField, \"ALPHANUM\", () => CollectionEngine.submit(\"find\", toolbar.findField));\n    toolbar.findSubmit.addEventListener(\"click\", () => CollectionEngine.submit(\"find\", toolbar.findField));\n    addReturnSubmit(toolbar.deleteField, \"ALPHANUM\", () => CollectionEngine.submit(\"delete\", toolbar.deleteField));\n    toolbar.deleteSubmit.addEventListener(\"click\", () => CollectionEngine.submit(\"delete\", toolbar.deleteField));\n    toolbar.printSubmit.addEventListener(\"click\", () => CollectionEngine.submit(\"print\", toolbar.printSubmit));\n    toolbar.clearSubmit.addEventListener(\"click\", () => CollectionEngine.confirmResetAll());\n}\nfunction getCollectionsToolbar(container) {\n    const insertSelect = container.querySelector(\"select.insertSelect\");\n    const insertField = container.querySelector(\"input.insertField\");\n    const insertSubmit = container.querySelector(\"input.insertSubmit\");\n    const findField = container.querySelector(\"input.findField\");\n    const findSubmit = container.querySelector(\"input.findSubmit\");\n    const deleteField = container.querySelector(\"input.deleteField\");\n    const deleteSubmit = container.querySelector(\"input.deleteSubmit\");\n    const printSubmit = container.querySelector(\"input.printSubmit\");\n    const clearSubmit = container.querySelector(\"input.clearSubmit\");\n    if (!insertSelect)\n        throw new Error(\"Missing insert select\");\n    if (!insertField)\n        throw new Error(\"Missing insert field\");\n    if (!insertSubmit)\n        throw new Error(\"Missing insert submit\");\n    if (!findField)\n        throw new Error(\"Missing find field\");\n    if (!findSubmit)\n        throw new Error(\"Missing find submit\");\n    if (!deleteField)\n        throw new Error(\"Missing delete field\");\n    if (!deleteSubmit)\n        throw new Error(\"Missing delete submit\");\n    if (!printSubmit)\n        throw new Error(\"Missing print submit\");\n    if (!clearSubmit)\n        throw new Error(\"Missing clear submit\");\n    return {\n        insertSelect,\n        insertField,\n        insertSubmit,\n        findField,\n        findSubmit,\n        deleteField,\n        deleteSubmit,\n        printSubmit,\n        clearSubmit,\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsT0FBTzs7QUFFZjtBQUNBOztBQUVBLFlBQVksbUJBQW1COztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLG1CQUFtQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksbUJBQW1COztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsT0FBTztBQUNmLFFBQVEsT0FBTzs7QUFFZjtBQUNBOztBQUVBLFlBQVksbUJBQW1COztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUN0T3NEO0FBQ2xCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixZQUFZOztBQUVqQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakIsV0FBVyxLQUFLO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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O0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkM7QUFDQSw0QkFBNEIsS0FBSztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQLEVBQUUsTUFBTTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxrQkFBUTtBQUNaOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLGtCQUFRO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEtBQUs7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUM3VjBEO0FBQ0w7QUFDRTtBQUNYO0FBQ2U7QUFDUDtBQUNGO0FBQ2Y7QUFDSDtBQUNnQjtBQUNWO0FBQzRCO0FBQzlCO0FBQ1E7QUFDVDs7QUFFckIscUJBQXFCLFdBQVc7QUFDL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLFFBQVE7O0FBRXhDO0FBQ0Esa0RBQWtELFVBQVU7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QyxVQUFVO0FBQ3ZELHdEQUF3RCxJQUFJOztBQUU1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DLHFCQUFxQixRQUFRO0FBQzdCOztBQUVBO0FBQ0EsOERBQThELE9BQU87QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLElBQUk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixJQUFJO0FBQ2pDLHVCQUF1QixJQUFJO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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TSxXQUFXLEdBQ2YsU0FBUyxDQUFDLGFBQWEsQ0FBbUIsbUJBQW1CLENBQUMsQ0FBQztJQUVqRSxJQUFJLENBQUMsWUFBWTtRQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLENBQUMsQ0FBQztJQUM1RCxJQUFJLENBQUMsV0FBVztRQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsc0JBQXNCLENBQUMsQ0FBQztJQUMxRCxJQUFJLENBQUMsWUFBWTtRQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLENBQUMsQ0FBQztJQUM1RCxJQUFJLENBQUMsU0FBUztRQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsb0JBQW9CLENBQUMsQ0FBQztJQUN0RCxJQUFJLENBQUMsVUFBVTtRQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQztJQUN4RCxJQUFJLENBQUMsV0FBVztRQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsc0JBQXNCLENBQUMsQ0FBQztJQUMxRCxJQUFJLENBQUMsWUFBWTtRQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLENBQUMsQ0FBQztJQUM1RCxJQUFJLENBQUMsV0FBVztRQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsc0JBQXNCLENBQUMsQ0FBQztJQUMxRCxJQUFJLENBQUMsV0FBVztRQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsc0JBQXNCLENBQUMsQ0FBQztJQUUxRCxPQUFPO1FBQ0wsWUFBWTtRQUNaLFdBQVc7UUFDWCxZQUFZO1FBQ1osU0FBUztRQUNULFVBQVU7UUFDVixXQUFXO1FBQ1gsWUFBWTtRQUNaLFdBQVc7UUFDWCxXQUFXO0tBQ1osQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy91dGlscy9tZXRob2RzLmpzPzRmMTUiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvdXRpbHMvdXRpbHMuanM/MjA5ZCIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL2NvcmUvbmFtZXNwYWNlcy5qcz8yNTU3Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3V0aWxzL3dpbmRvdy5qcz9iMWQyIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3R5cGVzL0Jhc2UuanM/NmU0MiIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy91dGlscy9hZG9wdGVyLmpzPzAwZmUiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9vcHRpb25hbC9hcnJhbmdlLmpzP2FhYzgiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9jb3JlL3JlZ2V4LmpzP2JjZDYiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9vcHRpb25hbC9jbGFzcy5qcz9iYWMyIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvb3B0aW9uYWwvY3NzLmpzPzk2MWYiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9vcHRpb25hbC9kYXRhLmpzP2ZjMGEiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9vcHRpb25hbC9tZW1vcnkuanM/Y2FmNCIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy90eXBlcy9Db2xvci5qcz8wMzIwIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3R5cGVzL1BvaW50LmpzP2RkNTQiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvdHlwZXMvTWF0cml4LmpzP2ZlZTYiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9jb3JlL3BhcnNlci5qcz82YzllIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3R5cGVzL0JveC5qcz83OGRlIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3R5cGVzL0xpc3QuanM/ZTY1MyIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL2NvcmUvc2VsZWN0b3IuanM/ZjY0NiIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL2NvcmUvZXZlbnQuanM/MTJhOSIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy90eXBlcy9FdmVudFRhcmdldC5qcz9hMmZhIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvY29yZS9kZWZhdWx0cy5qcz9jZTMxIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3R5cGVzL1NWR0FycmF5LmpzP2RjYTciLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvdHlwZXMvU1ZHTnVtYmVyLmpzPzU1MGEiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9jb3JlL2F0dHIuanM/ZTMzYSIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9Eb20uanM/YjY4YyIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9FbGVtZW50LmpzPzM5ZjIiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9vcHRpb25hbC9zdWdhci5qcz82NzQ1Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvb3B0aW9uYWwvdHJhbnNmb3JtLmpzPzk0NTYiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvQ29udGFpbmVyLmpzP2RmMjQiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvRGVmcy5qcz9iN2Q5Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1NoYXBlLmpzPzdmZjkiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9jb3JlL2NpcmNsZWQuanM/NWQyMyIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9FbGxpcHNlLmpzP2YzMDYiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvRnJhZ21lbnQuanM/NWRjMSIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL2NvcmUvZ3JhZGllbnRlZC5qcz9mYThmIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0dyYWRpZW50LmpzPzI1YmMiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvUGF0dGVybi5qcz9mZjUzIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0ltYWdlLmpzPzBiZTciLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvdHlwZXMvUG9pbnRBcnJheS5qcz8yZDFiIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvY29yZS9wb2ludGVkLmpzP2Y3MTYiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvTGluZS5qcz9mODliIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL01hcmtlci5qcz9iM2E4Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2FuaW1hdGlvbi9Db250cm9sbGVyLmpzP2YzOTYiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvdXRpbHMvcGF0aFBhcnNlci5qcz80YzU4Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3R5cGVzL1BhdGhBcnJheS5qcz8xZmNhIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2FuaW1hdGlvbi9Nb3JwaGFibGUuanM/NzcwMSIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9QYXRoLmpzPzIyMDQiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9jb3JlL3BvbHkuanM/ZmY5NSIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9Qb2x5Z29uLmpzP2VlODkiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvUG9seWxpbmUuanM/MTY0NiIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9SZWN0LmpzPzc1NzAiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvYW5pbWF0aW9uL1F1ZXVlLmpzPzk3NjAiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvYW5pbWF0aW9uL0FuaW1hdG9yLmpzPzIzN2MiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvYW5pbWF0aW9uL1RpbWVsaW5lLmpzP2Q4M2QiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvYW5pbWF0aW9uL1J1bm5lci5qcz80NWExIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1N2Zy5qcz8zNjFjIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1N5bWJvbC5qcz9iN2RlIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvY29yZS90ZXh0YWJsZS5qcz9iYjA0Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1RleHQuanM/N2Y0OSIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9Uc3Bhbi5qcz83N2Q3Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0NpcmNsZS5qcz84ODgzIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0NsaXBQYXRoLmpzPzA1MWMiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvRm9yZWlnbk9iamVjdC5qcz9jYzNlIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvY29yZS9jb250YWluZXJHZW9tZXRyeS5qcz85ODYyIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0cuanM/NDU0MiIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9BLmpzP2Y3OWMiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvTWFzay5qcz81M2U2Iiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1N0b3AuanM/MTY1NiIsIndlYnBhY2s6Ly9kc3Zpcy8uL25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9TdHlsZS5qcz9kMjgzIiwid2VicGFjazovL2RzdmlzLy4vbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1RleHRQYXRoLmpzPzllMTYiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvVXNlLmpzPzUzNjciLCJ3ZWJwYWNrOi8vZHN2aXMvLi9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbWFpbi5qcz8xMzYyIiwid2VicGFjazovL2RzdmlzLy4vc3JjL29iamVjdHMvdGV4dC1jaXJjbGUudHM/ZGFkMCIsIndlYnBhY2s6Ly9kc3Zpcy8uL3NyYy9vYmplY3RzL2dyYXBoLW5vZGUudHM/Y2Q4YSIsIndlYnBhY2s6Ly9kc3Zpcy8uL3NyYy9vYmplY3RzL2JpbmFyeS1ub2RlLnRzPzE3ZTAiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9zcmMvb2JqZWN0cy9hdmwtbm9kZS50cz9lZGZlIiwid2VicGFjazovL2RzdmlzLy4vc3JjL29iamVjdHMvY29ubmVjdGlvbi50cz9kOTIyIiwid2VicGFjazovL2RzdmlzLy4vc3JjL29iamVjdHMvYnRyZWUtY29ubmVjdGlvbi50cz8wNGJkIiwid2VicGFjazovL2RzdmlzLy4vc3JjL29iamVjdHMvYnRyZWUtbm9kZS50cz9mOTdmIiwid2VicGFjazovL2RzdmlzLy4vc3JjL29iamVjdHMvaGlnaGxpZ2h0LWNpcmNsZS50cz81MDJiIiwid2VicGFjazovL2RzdmlzLy4vc3JjL29iamVjdHMvaW5kZXgudHM/NDRlMyIsIndlYnBhY2s6Ly9kc3Zpcy8uL3NyYy9lbmdpbmUudHM/MjJlYyIsIndlYnBhY2s6Ly9kc3Zpcy8uL3NyYy90cmVlcy9CU1QudHM/YjlhMiIsIndlYnBhY2s6Ly9kc3Zpcy8uL3NyYy90cmVlcy9BVkwudHM/OWE3ZiIsIndlYnBhY2s6Ly9kc3Zpcy8uL3NyYy90cmVlcy9CVHJlZS50cz80NjE4Iiwid2VicGFjazovL2RzdmlzLy4vc3JjL3RyZWVzL1JlZEJsYWNrLnRzP2U0ZTQiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9zcmMvdHJlZXMvU3BsYXlUcmVlLnRzPzQ1N2UiLCJ3ZWJwYWNrOi8vZHN2aXMvLi9zcmMvY29sbGVjdGlvbnMudHM/YjU5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBtZXRob2RzID0ge31cbmNvbnN0IG5hbWVzID0gW11cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyTWV0aG9kcyhuYW1lLCBtKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XG4gICAgZm9yIChjb25zdCBfbmFtZSBvZiBuYW1lKSB7XG4gICAgICByZWdpc3Rlck1ldGhvZHMoX25hbWUsIG0pXG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAoY29uc3QgX25hbWUgaW4gbmFtZSkge1xuICAgICAgcmVnaXN0ZXJNZXRob2RzKF9uYW1lLCBuYW1lW19uYW1lXSlcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICBhZGRNZXRob2ROYW1lcyhPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtKSlcbiAgbWV0aG9kc1tuYW1lXSA9IE9iamVjdC5hc3NpZ24obWV0aG9kc1tuYW1lXSB8fCB7fSwgbSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1ldGhvZHNGb3IobmFtZSkge1xuICByZXR1cm4gbWV0aG9kc1tuYW1lXSB8fCB7fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWV0aG9kTmFtZXMoKSB7XG4gIHJldHVybiBbLi4ubmV3IFNldChuYW1lcyldXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRNZXRob2ROYW1lcyhfbmFtZXMpIHtcbiAgbmFtZXMucHVzaCguLi5fbmFtZXMpXG59XG4iLCIvLyBNYXAgZnVuY3Rpb25cbmV4cG9ydCBmdW5jdGlvbiBtYXAoYXJyYXksIGJsb2NrKSB7XG4gIGxldCBpXG4gIGNvbnN0IGlsID0gYXJyYXkubGVuZ3RoXG4gIGNvbnN0IHJlc3VsdCA9IFtdXG5cbiAgZm9yIChpID0gMDsgaSA8IGlsOyBpKyspIHtcbiAgICByZXN1bHQucHVzaChibG9jayhhcnJheVtpXSkpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIEZpbHRlciBmdW5jdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlcihhcnJheSwgYmxvY2spIHtcbiAgbGV0IGlcbiAgY29uc3QgaWwgPSBhcnJheS5sZW5ndGhcbiAgY29uc3QgcmVzdWx0ID0gW11cblxuICBmb3IgKGkgPSAwOyBpIDwgaWw7IGkrKykge1xuICAgIGlmIChibG9jayhhcnJheVtpXSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gRGVncmVlcyB0byByYWRpYW5zXG5leHBvcnQgZnVuY3Rpb24gcmFkaWFucyhkKSB7XG4gIHJldHVybiAoKGQgJSAzNjApICogTWF0aC5QSSkgLyAxODBcbn1cblxuLy8gUmFkaWFucyB0byBkZWdyZWVzXG5leHBvcnQgZnVuY3Rpb24gZGVncmVlcyhyKSB7XG4gIHJldHVybiAoKHIgKiAxODApIC8gTWF0aC5QSSkgJSAzNjBcbn1cblxuLy8gQ29udmVydCBjYW1lbCBjYXNlZCBzdHJpbmcgdG8gZGFzaCBzZXBhcmF0ZWRcbmV4cG9ydCBmdW5jdGlvbiB1bkNhbWVsQ2FzZShzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoLyhbQS1aXSkvZywgZnVuY3Rpb24gKG0sIGcpIHtcbiAgICByZXR1cm4gJy0nICsgZy50b0xvd2VyQ2FzZSgpXG4gIH0pXG59XG5cbi8vIENhcGl0YWxpemUgZmlyc3QgbGV0dGVyIG9mIGEgc3RyaW5nXG5leHBvcnQgZnVuY3Rpb24gY2FwaXRhbGl6ZShzKSB7XG4gIHJldHVybiBzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKVxufVxuXG4vLyBDYWxjdWxhdGUgcHJvcG9ydGlvbmFsIHdpZHRoIGFuZCBoZWlnaHQgdmFsdWVzIHdoZW4gbmVjZXNzYXJ5XG5leHBvcnQgZnVuY3Rpb24gcHJvcG9ydGlvbmFsU2l6ZShlbGVtZW50LCB3aWR0aCwgaGVpZ2h0LCBib3gpIHtcbiAgaWYgKHdpZHRoID09IG51bGwgfHwgaGVpZ2h0ID09IG51bGwpIHtcbiAgICBib3ggPSBib3ggfHwgZWxlbWVudC5iYm94KClcblxuICAgIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgICB3aWR0aCA9IChib3gud2lkdGggLyBib3guaGVpZ2h0KSAqIGhlaWdodFxuICAgIH0gZWxzZSBpZiAoaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgIGhlaWdodCA9IChib3guaGVpZ2h0IC8gYm94LndpZHRoKSAqIHdpZHRoXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWRkcyBzdXBwb3J0IGZvciBzdHJpbmcgb3JpZ2lucy5cbiAqIEl0IHNlYXJjaGVzIGZvciBhbiBvcmlnaW4gaW4gby5vcmlnaW4gby5veCBhbmQgby5vcmlnaW5YLlxuICogVGhpcyB3YXksIG9yaWdpbjoge3g6ICdjZW50ZXInLCB5OiA1MH0gY2FuIGJlIHBhc3NlZCBhcyB3ZWxsIGFzIG94OiAnY2VudGVyJywgb3k6IDUwXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3JpZ2luKG8sIGVsZW1lbnQpIHtcbiAgY29uc3Qgb3JpZ2luID0gby5vcmlnaW5cbiAgLy8gRmlyc3QgY2hlY2sgaWYgb3JpZ2luIGlzIGluIG94IG9yIG9yaWdpblhcbiAgbGV0IG94ID0gby5veCAhPSBudWxsID8gby5veCA6IG8ub3JpZ2luWCAhPSBudWxsID8gby5vcmlnaW5YIDogJ2NlbnRlcidcbiAgbGV0IG95ID0gby5veSAhPSBudWxsID8gby5veSA6IG8ub3JpZ2luWSAhPSBudWxsID8gby5vcmlnaW5ZIDogJ2NlbnRlcidcblxuICAvLyBUaGVuIGNoZWNrIGlmIG9yaWdpbiB3YXMgdXNlZCBhbmQgb3ZlcndyaXRlIGluIHRoYXQgY2FzZVxuICBpZiAob3JpZ2luICE9IG51bGwpIHtcbiAgICA7W294LCBveV0gPSBBcnJheS5pc0FycmF5KG9yaWdpbilcbiAgICAgID8gb3JpZ2luXG4gICAgICA6IHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnXG4gICAgICAgID8gW29yaWdpbi54LCBvcmlnaW4ueV1cbiAgICAgICAgOiBbb3JpZ2luLCBvcmlnaW5dXG4gIH1cblxuICAvLyBNYWtlIHN1cmUgdG8gb25seSBjYWxsIGJib3ggd2hlbiBhY3R1YWxseSBuZWVkZWRcbiAgY29uc3QgY29uZFggPSB0eXBlb2Ygb3ggPT09ICdzdHJpbmcnXG4gIGNvbnN0IGNvbmRZID0gdHlwZW9mIG95ID09PSAnc3RyaW5nJ1xuICBpZiAoY29uZFggfHwgY29uZFkpIHtcbiAgICBjb25zdCB7IGhlaWdodCwgd2lkdGgsIHgsIHkgfSA9IGVsZW1lbnQuYmJveCgpXG5cbiAgICAvLyBBbmQgb25seSBvdmVyd3JpdGUgaWYgc3RyaW5nIHdhcyBwYXNzZWQgZm9yIHRoaXMgc3BlY2lmaWMgYXhpc1xuICAgIGlmIChjb25kWCkge1xuICAgICAgb3ggPSBveC5pbmNsdWRlcygnbGVmdCcpXG4gICAgICAgID8geFxuICAgICAgICA6IG94LmluY2x1ZGVzKCdyaWdodCcpXG4gICAgICAgICAgPyB4ICsgd2lkdGhcbiAgICAgICAgICA6IHggKyB3aWR0aCAvIDJcbiAgICB9XG5cbiAgICBpZiAoY29uZFkpIHtcbiAgICAgIG95ID0gb3kuaW5jbHVkZXMoJ3RvcCcpXG4gICAgICAgID8geVxuICAgICAgICA6IG95LmluY2x1ZGVzKCdib3R0b20nKVxuICAgICAgICAgID8geSArIGhlaWdodFxuICAgICAgICAgIDogeSArIGhlaWdodCAvIDJcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIG9yaWdpbiBhcyBpdCBpcyBpZiBpdCB3YXNuJ3QgYSBzdHJpbmdcbiAgcmV0dXJuIFtveCwgb3ldXG59XG5cbmNvbnN0IGRlc2NyaXB0aXZlRWxlbWVudHMgPSBuZXcgU2V0KFsnZGVzYycsICdtZXRhZGF0YScsICd0aXRsZSddKVxuZXhwb3J0IGNvbnN0IGlzRGVzY3JpcHRpdmUgPSAoZWxlbWVudCkgPT5cbiAgZGVzY3JpcHRpdmVFbGVtZW50cy5oYXMoZWxlbWVudC5ub2RlTmFtZSlcblxuZXhwb3J0IGNvbnN0IHdyaXRlRGF0YVRvRG9tID0gKGVsZW1lbnQsIGRhdGEsIGRlZmF1bHRzID0ge30pID0+IHtcbiAgY29uc3QgY2xvbmVkID0geyAuLi5kYXRhIH1cblxuICBmb3IgKGNvbnN0IGtleSBpbiBjbG9uZWQpIHtcbiAgICBpZiAoY2xvbmVkW2tleV0udmFsdWVPZigpID09PSBkZWZhdWx0c1trZXldKSB7XG4gICAgICBkZWxldGUgY2xvbmVkW2tleV1cbiAgICB9XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMoY2xvbmVkKS5sZW5ndGgpIHtcbiAgICBlbGVtZW50Lm5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLXN2Z2pzJywgSlNPTi5zdHJpbmdpZnkoY2xvbmVkKSkgLy8gc2VlICM0MjhcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50Lm5vZGUucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXN2Z2pzJylcbiAgICBlbGVtZW50Lm5vZGUucmVtb3ZlQXR0cmlidXRlKCdzdmdqczpkYXRhJylcbiAgfVxufVxuIiwiLy8gRGVmYXVsdCBuYW1lc3BhY2VzXG5leHBvcnQgY29uc3Qgc3ZnID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xuZXhwb3J0IGNvbnN0IGh0bWwgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCdcbmV4cG9ydCBjb25zdCB4bWxucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLydcbmV4cG9ydCBjb25zdCB4bGluayA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJ1xuIiwiZXhwb3J0IGNvbnN0IGdsb2JhbHMgPSB7XG4gIHdpbmRvdzogdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93LFxuICBkb2N1bWVudDogdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBkb2N1bWVudFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJXaW5kb3cod2luID0gbnVsbCwgZG9jID0gbnVsbCkge1xuICBnbG9iYWxzLndpbmRvdyA9IHdpblxuICBnbG9iYWxzLmRvY3VtZW50ID0gZG9jXG59XG5cbmNvbnN0IHNhdmUgPSB7fVxuXG5leHBvcnQgZnVuY3Rpb24gc2F2ZVdpbmRvdygpIHtcbiAgc2F2ZS53aW5kb3cgPSBnbG9iYWxzLndpbmRvd1xuICBzYXZlLmRvY3VtZW50ID0gZ2xvYmFscy5kb2N1bWVudFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZVdpbmRvdygpIHtcbiAgZ2xvYmFscy53aW5kb3cgPSBzYXZlLndpbmRvd1xuICBnbG9iYWxzLmRvY3VtZW50ID0gc2F2ZS5kb2N1bWVudFxufVxuXG5leHBvcnQgZnVuY3Rpb24gd2l0aFdpbmRvdyh3aW4sIGZuKSB7XG4gIHNhdmVXaW5kb3coKVxuICByZWdpc3RlcldpbmRvdyh3aW4sIHdpbi5kb2N1bWVudClcbiAgZm4od2luLCB3aW4uZG9jdW1lbnQpXG4gIHJlc3RvcmVXaW5kb3coKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2luZG93KCkge1xuICByZXR1cm4gZ2xvYmFscy53aW5kb3dcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2Uge1xuICAvLyBjb25zdHJ1Y3RvciAobm9kZS8qLCB7ZXh0ZW5zaW9ucyA9IFtdfSAqLykge1xuICAvLyAgIC8vIHRoaXMudGFncyA9IFtdXG4gIC8vICAgLy9cbiAgLy8gICAvLyBmb3IgKGxldCBleHRlbnNpb24gb2YgZXh0ZW5zaW9ucykge1xuICAvLyAgIC8vICAgZXh0ZW5zaW9uLnNldHVwLmNhbGwodGhpcywgbm9kZSlcbiAgLy8gICAvLyAgIHRoaXMudGFncy5wdXNoKGV4dGVuc2lvbi5uYW1lKVxuICAvLyAgIC8vIH1cbiAgLy8gfVxufVxuIiwiaW1wb3J0IHsgYWRkTWV0aG9kTmFtZXMgfSBmcm9tICcuL21ldGhvZHMuanMnXG5pbXBvcnQgeyBjYXBpdGFsaXplIH0gZnJvbSAnLi91dGlscy5qcydcbmltcG9ydCB7IHN2ZyB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9uYW1lc3BhY2VzLmpzJ1xuaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4uL3V0aWxzL3dpbmRvdy5qcydcbmltcG9ydCBCYXNlIGZyb20gJy4uL3R5cGVzL0Jhc2UuanMnXG5cbmNvbnN0IGVsZW1lbnRzID0ge31cbmV4cG9ydCBjb25zdCByb290ID0gJ19fX1NZTUJPTF9fX1JPT1RfX18nXG5cbi8vIE1ldGhvZCBmb3IgZWxlbWVudCBjcmVhdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBucyA9IHN2Zykge1xuICAvLyBjcmVhdGUgZWxlbWVudFxuICByZXR1cm4gZ2xvYmFscy5kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIG5hbWUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlSW5zdGFuY2UoZWxlbWVudCwgaXNIVE1MID0gZmFsc2UpIHtcbiAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBCYXNlKSByZXR1cm4gZWxlbWVudFxuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gYWRvcHRlcihlbGVtZW50KVxuICB9XG5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgZWxlbWVudHNbcm9vdF0oKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyAmJiBlbGVtZW50LmNoYXJBdCgwKSAhPT0gJzwnKSB7XG4gICAgcmV0dXJuIGFkb3B0ZXIoZ2xvYmFscy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsZW1lbnQpKVxuICB9XG5cbiAgLy8gTWFrZSBzdXJlLCB0aGF0IEhUTUwgZWxlbWVudHMgYXJlIGNyZWF0ZWQgd2l0aCB0aGUgY29ycmVjdCBuYW1lc3BhY2VcbiAgY29uc3Qgd3JhcHBlciA9IGlzSFRNTCA/IGdsb2JhbHMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgOiBjcmVhdGUoJ3N2ZycpXG4gIHdyYXBwZXIuaW5uZXJIVE1MID0gZWxlbWVudFxuXG4gIC8vIFdlIGNhbiB1c2UgZmlyc3RDaGlsZCBoZXJlIGJlY2F1c2Ugd2Uga25vdyxcbiAgLy8gdGhhdCB0aGUgZmlyc3QgY2hhciBpcyA8IGFuZCB0aHVzIGFuIGVsZW1lbnRcbiAgZWxlbWVudCA9IGFkb3B0ZXIod3JhcHBlci5maXJzdENoaWxkKVxuXG4gIC8vIG1ha2Ugc3VyZSwgdGhhdCBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBpdHMgd3JhcHBlciBhdHRhY2hlZFxuICB3cmFwcGVyLnJlbW92ZUNoaWxkKHdyYXBwZXIuZmlyc3RDaGlsZClcbiAgcmV0dXJuIGVsZW1lbnRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVPck5ldyhuYW1lLCBub2RlKSB7XG4gIHJldHVybiBub2RlICYmXG4gICAgKG5vZGUgaW5zdGFuY2VvZiBnbG9iYWxzLndpbmRvdy5Ob2RlIHx8XG4gICAgICAobm9kZS5vd25lckRvY3VtZW50ICYmXG4gICAgICAgIG5vZGUgaW5zdGFuY2VvZiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuTm9kZSkpXG4gICAgPyBub2RlXG4gICAgOiBjcmVhdGUobmFtZSlcbn1cblxuLy8gQWRvcHQgZXhpc3Rpbmcgc3ZnIGVsZW1lbnRzXG5leHBvcnQgZnVuY3Rpb24gYWRvcHQobm9kZSkge1xuICAvLyBjaGVjayBmb3IgcHJlc2VuY2Ugb2Ygbm9kZVxuICBpZiAoIW5vZGUpIHJldHVybiBudWxsXG5cbiAgLy8gbWFrZSBzdXJlIGEgbm9kZSBpc24ndCBhbHJlYWR5IGFkb3B0ZWRcbiAgaWYgKG5vZGUuaW5zdGFuY2UgaW5zdGFuY2VvZiBCYXNlKSByZXR1cm4gbm9kZS5pbnN0YW5jZVxuXG4gIGlmIChub2RlLm5vZGVOYW1lID09PSAnI2RvY3VtZW50LWZyYWdtZW50Jykge1xuICAgIHJldHVybiBuZXcgZWxlbWVudHMuRnJhZ21lbnQobm9kZSlcbiAgfVxuXG4gIC8vIGluaXRpYWxpemUgdmFyaWFibGVzXG4gIGxldCBjbGFzc05hbWUgPSBjYXBpdGFsaXplKG5vZGUubm9kZU5hbWUgfHwgJ0RvbScpXG5cbiAgLy8gTWFrZSBzdXJlIHRoYXQgZ3JhZGllbnRzIGFyZSBhZG9wdGVkIGNvcnJlY3RseVxuICBpZiAoY2xhc3NOYW1lID09PSAnTGluZWFyR3JhZGllbnQnIHx8IGNsYXNzTmFtZSA9PT0gJ1JhZGlhbEdyYWRpZW50Jykge1xuICAgIGNsYXNzTmFtZSA9ICdHcmFkaWVudCdcblxuICAgIC8vIEZhbGxiYWNrIHRvIERvbSBpZiBlbGVtZW50IGlzIG5vdCBrbm93blxuICB9IGVsc2UgaWYgKCFlbGVtZW50c1tjbGFzc05hbWVdKSB7XG4gICAgY2xhc3NOYW1lID0gJ0RvbSdcbiAgfVxuXG4gIHJldHVybiBuZXcgZWxlbWVudHNbY2xhc3NOYW1lXShub2RlKVxufVxuXG5sZXQgYWRvcHRlciA9IGFkb3B0XG5cbmV4cG9ydCBmdW5jdGlvbiBtb2NrQWRvcHQobW9jayA9IGFkb3B0KSB7XG4gIGFkb3B0ZXIgPSBtb2NrXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlcihlbGVtZW50LCBuYW1lID0gZWxlbWVudC5uYW1lLCBhc1Jvb3QgPSBmYWxzZSkge1xuICBlbGVtZW50c1tuYW1lXSA9IGVsZW1lbnRcbiAgaWYgKGFzUm9vdCkgZWxlbWVudHNbcm9vdF0gPSBlbGVtZW50XG5cbiAgYWRkTWV0aG9kTmFtZXMoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZWxlbWVudC5wcm90b3R5cGUpKVxuXG4gIHJldHVybiBlbGVtZW50XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGFzcyhuYW1lKSB7XG4gIHJldHVybiBlbGVtZW50c1tuYW1lXVxufVxuXG4vLyBFbGVtZW50IGlkIHNlcXVlbmNlXG5sZXQgZGlkID0gMTAwMFxuXG4vLyBHZXQgbmV4dCBuYW1lZCBlbGVtZW50IGlkXG5leHBvcnQgZnVuY3Rpb24gZWlkKG5hbWUpIHtcbiAgcmV0dXJuICdTdmdqcycgKyBjYXBpdGFsaXplKG5hbWUpICsgZGlkKytcbn1cblxuLy8gRGVlcCBuZXcgaWQgYXNzaWdubWVudFxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbk5ld0lkKG5vZGUpIHtcbiAgLy8gZG8gdGhlIHNhbWUgZm9yIFNWRyBjaGlsZCBub2RlcyBhcyB3ZWxsXG4gIGZvciAobGV0IGkgPSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgYXNzaWduTmV3SWQobm9kZS5jaGlsZHJlbltpXSlcbiAgfVxuXG4gIGlmIChub2RlLmlkKSB7XG4gICAgbm9kZS5pZCA9IGVpZChub2RlLm5vZGVOYW1lKVxuICAgIHJldHVybiBub2RlXG4gIH1cblxuICByZXR1cm4gbm9kZVxufVxuXG4vLyBNZXRob2QgZm9yIGV4dGVuZGluZyBvYmplY3RzXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKG1vZHVsZXMsIG1ldGhvZHMpIHtcbiAgbGV0IGtleSwgaVxuXG4gIG1vZHVsZXMgPSBBcnJheS5pc0FycmF5KG1vZHVsZXMpID8gbW9kdWxlcyA6IFttb2R1bGVzXVxuXG4gIGZvciAoaSA9IG1vZHVsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBtb2R1bGVzW2ldLnByb3RvdHlwZVtrZXldID0gbWV0aG9kc1trZXldXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwV2l0aEF0dHJDaGVjayhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBvID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdXG5cbiAgICBpZiAobyAmJiBvLmNvbnN0cnVjdG9yID09PSBPYmplY3QgJiYgIShvIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncy5zbGljZSgwLCAtMSkpLmF0dHIobylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBtYWtlSW5zdGFuY2UgfSBmcm9tICcuLi8uLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vLi4vdXRpbHMvbWV0aG9kcy5qcydcblxuLy8gR2V0IGFsbCBzaWJsaW5ncywgaW5jbHVkaW5nIG15c2VsZlxuZXhwb3J0IGZ1bmN0aW9uIHNpYmxpbmdzKCkge1xuICByZXR1cm4gdGhpcy5wYXJlbnQoKS5jaGlsZHJlbigpXG59XG5cbi8vIEdldCB0aGUgY3VycmVudCBwb3NpdGlvbiBzaWJsaW5nc1xuZXhwb3J0IGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xuICByZXR1cm4gdGhpcy5wYXJlbnQoKS5pbmRleCh0aGlzKVxufVxuXG4vLyBHZXQgdGhlIG5leHQgZWxlbWVudCAod2lsbCByZXR1cm4gbnVsbCBpZiB0aGVyZSBpcyBub25lKVxuZXhwb3J0IGZ1bmN0aW9uIG5leHQoKSB7XG4gIHJldHVybiB0aGlzLnNpYmxpbmdzKClbdGhpcy5wb3NpdGlvbigpICsgMV1cbn1cblxuLy8gR2V0IHRoZSBuZXh0IGVsZW1lbnQgKHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlcmUgaXMgbm9uZSlcbmV4cG9ydCBmdW5jdGlvbiBwcmV2KCkge1xuICByZXR1cm4gdGhpcy5zaWJsaW5ncygpW3RoaXMucG9zaXRpb24oKSAtIDFdXG59XG5cbi8vIFNlbmQgZ2l2ZW4gZWxlbWVudCBvbmUgc3RlcCBmb3J3YXJkXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZCgpIHtcbiAgY29uc3QgaSA9IHRoaXMucG9zaXRpb24oKVxuICBjb25zdCBwID0gdGhpcy5wYXJlbnQoKVxuXG4gIC8vIG1vdmUgbm9kZSBvbmUgc3RlcCBmb3J3YXJkXG4gIHAuYWRkKHRoaXMucmVtb3ZlKCksIGkgKyAxKVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIFNlbmQgZ2l2ZW4gZWxlbWVudCBvbmUgc3RlcCBiYWNrd2FyZFxuZXhwb3J0IGZ1bmN0aW9uIGJhY2t3YXJkKCkge1xuICBjb25zdCBpID0gdGhpcy5wb3NpdGlvbigpXG4gIGNvbnN0IHAgPSB0aGlzLnBhcmVudCgpXG5cbiAgcC5hZGQodGhpcy5yZW1vdmUoKSwgaSA/IGkgLSAxIDogMClcblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBTZW5kIGdpdmVuIGVsZW1lbnQgYWxsIHRoZSB3YXkgdG8gdGhlIGZyb250XG5leHBvcnQgZnVuY3Rpb24gZnJvbnQoKSB7XG4gIGNvbnN0IHAgPSB0aGlzLnBhcmVudCgpXG5cbiAgLy8gTW92ZSBub2RlIGZvcndhcmRcbiAgcC5hZGQodGhpcy5yZW1vdmUoKSlcblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBTZW5kIGdpdmVuIGVsZW1lbnQgYWxsIHRoZSB3YXkgdG8gdGhlIGJhY2tcbmV4cG9ydCBmdW5jdGlvbiBiYWNrKCkge1xuICBjb25zdCBwID0gdGhpcy5wYXJlbnQoKVxuXG4gIC8vIE1vdmUgbm9kZSBiYWNrXG4gIHAuYWRkKHRoaXMucmVtb3ZlKCksIDApXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSW5zZXJ0cyBhIGdpdmVuIGVsZW1lbnQgYmVmb3JlIHRoZSB0YXJnZXRlZCBlbGVtZW50XG5leHBvcnQgZnVuY3Rpb24gYmVmb3JlKGVsZW1lbnQpIHtcbiAgZWxlbWVudCA9IG1ha2VJbnN0YW5jZShlbGVtZW50KVxuICBlbGVtZW50LnJlbW92ZSgpXG5cbiAgY29uc3QgaSA9IHRoaXMucG9zaXRpb24oKVxuXG4gIHRoaXMucGFyZW50KCkuYWRkKGVsZW1lbnQsIGkpXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSW5zZXJ0cyBhIGdpdmVuIGVsZW1lbnQgYWZ0ZXIgdGhlIHRhcmdldGVkIGVsZW1lbnRcbmV4cG9ydCBmdW5jdGlvbiBhZnRlcihlbGVtZW50KSB7XG4gIGVsZW1lbnQgPSBtYWtlSW5zdGFuY2UoZWxlbWVudClcbiAgZWxlbWVudC5yZW1vdmUoKVxuXG4gIGNvbnN0IGkgPSB0aGlzLnBvc2l0aW9uKClcblxuICB0aGlzLnBhcmVudCgpLmFkZChlbGVtZW50LCBpICsgMSlcblxuICByZXR1cm4gdGhpc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKGVsZW1lbnQpIHtcbiAgZWxlbWVudCA9IG1ha2VJbnN0YW5jZShlbGVtZW50KVxuICBlbGVtZW50LmJlZm9yZSh0aGlzKVxuICByZXR1cm4gdGhpc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIoZWxlbWVudCkge1xuICBlbGVtZW50ID0gbWFrZUluc3RhbmNlKGVsZW1lbnQpXG4gIGVsZW1lbnQuYWZ0ZXIodGhpcylcbiAgcmV0dXJuIHRoaXNcbn1cblxucmVnaXN0ZXJNZXRob2RzKCdEb20nLCB7XG4gIHNpYmxpbmdzLFxuICBwb3NpdGlvbixcbiAgbmV4dCxcbiAgcHJldixcbiAgZm9yd2FyZCxcbiAgYmFja3dhcmQsXG4gIGZyb250LFxuICBiYWNrLFxuICBiZWZvcmUsXG4gIGFmdGVyLFxuICBpbnNlcnRCZWZvcmUsXG4gIGluc2VydEFmdGVyXG59KVxuIiwiLy8gUGFyc2UgdW5pdCB2YWx1ZVxuZXhwb3J0IGNvbnN0IG51bWJlckFuZFVuaXQgPVxuICAvXihbKy1dPyhcXGQrKFxcLlxcZCopP3xcXC5cXGQrKShlWystXT9cXGQrKT8pKFthLXolXSopJC9pXG5cbi8vIFBhcnNlIGhleCB2YWx1ZVxuZXhwb3J0IGNvbnN0IGhleCA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2lcblxuLy8gUGFyc2UgcmdiIHZhbHVlXG5leHBvcnQgY29uc3QgcmdiID0gL3JnYlxcKChcXGQrKSwoXFxkKyksKFxcZCspXFwpL1xuXG4vLyBQYXJzZSByZWZlcmVuY2UgaWRcbmV4cG9ydCBjb25zdCByZWZlcmVuY2UgPSAvKCNbYS16X11bYS16MC05XFwtX10qKS9pXG5cbi8vIHNwbGl0cyBhIHRyYW5zZm9ybWF0aW9uIGNoYWluXG5leHBvcnQgY29uc3QgdHJhbnNmb3JtcyA9IC9cXClcXHMqLD9cXHMqL1xuXG4vLyBXaGl0ZXNwYWNlXG5leHBvcnQgY29uc3Qgd2hpdGVzcGFjZSA9IC9cXHMvZ1xuXG4vLyBUZXN0IGhleCB2YWx1ZVxuZXhwb3J0IGNvbnN0IGlzSGV4ID0gL14jW2EtZjAtOV17M30kfF4jW2EtZjAtOV17Nn0kL2lcblxuLy8gVGVzdCByZ2IgdmFsdWVcbmV4cG9ydCBjb25zdCBpc1JnYiA9IC9ecmdiXFwoL1xuXG4vLyBUZXN0IGZvciBibGFuayBzdHJpbmdcbmV4cG9ydCBjb25zdCBpc0JsYW5rID0gL14oXFxzKyk/JC9cblxuLy8gVGVzdCBmb3IgbnVtZXJpYyBzdHJpbmdcbmV4cG9ydCBjb25zdCBpc051bWJlciA9IC9eWystXT8oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/JC9pXG5cbi8vIFRlc3QgZm9yIGltYWdlIHVybFxuZXhwb3J0IGNvbnN0IGlzSW1hZ2UgPSAvXFwuKGpwZ3xqcGVnfHBuZ3xnaWZ8c3ZnKShcXD9bXj1dKy4qKT8vaVxuXG4vLyBzcGxpdCBhdCB3aGl0ZXNwYWNlIGFuZCBjb21tYVxuZXhwb3J0IGNvbnN0IGRlbGltaXRlciA9IC9bXFxzLF0rL1xuXG4vLyBUZXN0IGZvciBwYXRoIGxldHRlclxuZXhwb3J0IGNvbnN0IGlzUGF0aExldHRlciA9IC9bTUxIVkNTUVRBWl0vaVxuIiwiaW1wb3J0IHsgZGVsaW1pdGVyIH0gZnJvbSAnLi4vY29yZS9yZWdleC5qcydcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uLy4uL3V0aWxzL21ldGhvZHMuanMnXG5cbi8vIFJldHVybiBhcnJheSBvZiBjbGFzc2VzIG9uIHRoZSBub2RlXG5leHBvcnQgZnVuY3Rpb24gY2xhc3NlcygpIHtcbiAgY29uc3QgYXR0ciA9IHRoaXMuYXR0cignY2xhc3MnKVxuICByZXR1cm4gYXR0ciA9PSBudWxsID8gW10gOiBhdHRyLnRyaW0oKS5zcGxpdChkZWxpbWl0ZXIpXG59XG5cbi8vIFJldHVybiB0cnVlIGlmIGNsYXNzIGV4aXN0cyBvbiB0aGUgbm9kZSwgZmFsc2Ugb3RoZXJ3aXNlXG5leHBvcnQgZnVuY3Rpb24gaGFzQ2xhc3MobmFtZSkge1xuICByZXR1cm4gdGhpcy5jbGFzc2VzKCkuaW5kZXhPZihuYW1lKSAhPT0gLTFcbn1cblxuLy8gQWRkIGNsYXNzIHRvIHRoZSBub2RlXG5leHBvcnQgZnVuY3Rpb24gYWRkQ2xhc3MobmFtZSkge1xuICBpZiAoIXRoaXMuaGFzQ2xhc3MobmFtZSkpIHtcbiAgICBjb25zdCBhcnJheSA9IHRoaXMuY2xhc3NlcygpXG4gICAgYXJyYXkucHVzaChuYW1lKVxuICAgIHRoaXMuYXR0cignY2xhc3MnLCBhcnJheS5qb2luKCcgJykpXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBSZW1vdmUgY2xhc3MgZnJvbSB0aGUgbm9kZVxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKG5hbWUpIHtcbiAgaWYgKHRoaXMuaGFzQ2xhc3MobmFtZSkpIHtcbiAgICB0aGlzLmF0dHIoXG4gICAgICAnY2xhc3MnLFxuICAgICAgdGhpcy5jbGFzc2VzKClcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICAgIHJldHVybiBjICE9PSBuYW1lXG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcgJylcbiAgICApXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBUb2dnbGUgdGhlIHByZXNlbmNlIG9mIGEgY2xhc3Mgb24gdGhlIG5vZGVcbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVDbGFzcyhuYW1lKSB7XG4gIHJldHVybiB0aGlzLmhhc0NsYXNzKG5hbWUpID8gdGhpcy5yZW1vdmVDbGFzcyhuYW1lKSA6IHRoaXMuYWRkQ2xhc3MobmFtZSlcbn1cblxucmVnaXN0ZXJNZXRob2RzKCdEb20nLCB7XG4gIGNsYXNzZXMsXG4gIGhhc0NsYXNzLFxuICBhZGRDbGFzcyxcbiAgcmVtb3ZlQ2xhc3MsXG4gIHRvZ2dsZUNsYXNzXG59KVxuIiwiaW1wb3J0IHsgaXNCbGFuayB9IGZyb20gJy4uL2NvcmUvcmVnZXguanMnXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi8uLi91dGlscy9tZXRob2RzLmpzJ1xuXG4vLyBEeW5hbWljIHN0eWxlIGdlbmVyYXRvclxuZXhwb3J0IGZ1bmN0aW9uIGNzcyhzdHlsZSwgdmFsKSB7XG4gIGNvbnN0IHJldCA9IHt9XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gZ2V0IGZ1bGwgc3R5bGUgYXMgb2JqZWN0XG4gICAgdGhpcy5ub2RlLnN0eWxlLmNzc1RleHRcbiAgICAgIC5zcGxpdCgvXFxzKjtcXHMqLylcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiAhIWVsLmxlbmd0aFxuICAgICAgfSlcbiAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBjb25zdCB0ID0gZWwuc3BsaXQoL1xccyo6XFxzKi8pXG4gICAgICAgIHJldFt0WzBdXSA9IHRbMV1cbiAgICAgIH0pXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgLy8gZ2V0IHN0eWxlIHByb3BlcnRpZXMgYXMgYXJyYXlcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZSkpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBzdHlsZSkge1xuICAgICAgICBjb25zdCBjYXNlZCA9IG5hbWVcbiAgICAgICAgcmV0W25hbWVdID0gdGhpcy5ub2RlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoY2FzZWQpXG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0XG4gICAgfVxuXG4gICAgLy8gZ2V0IHN0eWxlIGZvciBwcm9wZXJ0eVxuICAgIGlmICh0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoc3R5bGUpXG4gICAgfVxuXG4gICAgLy8gc2V0IHN0eWxlcyBpbiBvYmplY3RcbiAgICBpZiAodHlwZW9mIHN0eWxlID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHN0eWxlKSB7XG4gICAgICAgIC8vIHNldCBlbXB0eSBzdHJpbmcgaWYgbnVsbC91bmRlZmluZWQvJycgd2FzIGdpdmVuXG4gICAgICAgIHRoaXMubm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHN0eWxlW25hbWVdID09IG51bGwgfHwgaXNCbGFuay50ZXN0KHN0eWxlW25hbWVdKSA/ICcnIDogc3R5bGVbbmFtZV1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzdHlsZSBmb3IgcHJvcGVydHlcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB0aGlzLm5vZGUuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICBzdHlsZSxcbiAgICAgIHZhbCA9PSBudWxsIHx8IGlzQmxhbmsudGVzdCh2YWwpID8gJycgOiB2YWxcbiAgICApXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBTaG93IGVsZW1lbnRcbmV4cG9ydCBmdW5jdGlvbiBzaG93KCkge1xuICByZXR1cm4gdGhpcy5jc3MoJ2Rpc3BsYXknLCAnJylcbn1cblxuLy8gSGlkZSBlbGVtZW50XG5leHBvcnQgZnVuY3Rpb24gaGlkZSgpIHtcbiAgcmV0dXJuIHRoaXMuY3NzKCdkaXNwbGF5JywgJ25vbmUnKVxufVxuXG4vLyBJcyBlbGVtZW50IHZpc2libGU/XG5leHBvcnQgZnVuY3Rpb24gdmlzaWJsZSgpIHtcbiAgcmV0dXJuIHRoaXMuY3NzKCdkaXNwbGF5JykgIT09ICdub25lJ1xufVxuXG5yZWdpc3Rlck1ldGhvZHMoJ0RvbScsIHtcbiAgY3NzLFxuICBzaG93LFxuICBoaWRlLFxuICB2aXNpYmxlXG59KVxuIiwiaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vLi4vdXRpbHMvbWV0aG9kcy5qcydcbmltcG9ydCB7IGZpbHRlciwgbWFwIH0gZnJvbSAnLi4vLi4vdXRpbHMvdXRpbHMuanMnXG5cbi8vIFN0b3JlIGRhdGEgdmFsdWVzIG9uIHN2ZyBub2Rlc1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGEoYSwgdiwgcikge1xuICBpZiAoYSA9PSBudWxsKSB7XG4gICAgLy8gZ2V0IGFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzXG4gICAgcmV0dXJuIHRoaXMuZGF0YShcbiAgICAgIG1hcChcbiAgICAgICAgZmlsdGVyKFxuICAgICAgICAgIHRoaXMubm9kZS5hdHRyaWJ1dGVzLFxuICAgICAgICAgIChlbCkgPT4gZWwubm9kZU5hbWUuaW5kZXhPZignZGF0YS0nKSA9PT0gMFxuICAgICAgICApLFxuICAgICAgICAoZWwpID0+IGVsLm5vZGVOYW1lLnNsaWNlKDUpXG4gICAgICApXG4gICAgKVxuICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGNvbnN0IGRhdGEgPSB7fVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGEpIHtcbiAgICAgIGRhdGFba2V5XSA9IHRoaXMuZGF0YShrZXkpXG4gICAgfVxuICAgIHJldHVybiBkYXRhXG4gIH0gZWxzZSBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yICh2IGluIGEpIHtcbiAgICAgIHRoaXMuZGF0YSh2LCBhW3ZdKVxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmF0dHIoJ2RhdGEtJyArIGEpKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2RhdGEtJyArIGEpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuYXR0cihcbiAgICAgICdkYXRhLScgKyBhLFxuICAgICAgdiA9PT0gbnVsbFxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiByID09PSB0cnVlIHx8IHR5cGVvZiB2ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdiA9PT0gJ251bWJlcidcbiAgICAgICAgICA/IHZcbiAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHYpXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxucmVnaXN0ZXJNZXRob2RzKCdEb20nLCB7IGRhdGEgfSlcbiIsImltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uLy4uL3V0aWxzL21ldGhvZHMuanMnXG5cbi8vIFJlbWVtYmVyIGFyYml0cmFyeSBkYXRhXG5leHBvcnQgZnVuY3Rpb24gcmVtZW1iZXIoaywgdikge1xuICAvLyByZW1lbWJlciBldmVyeSBpdGVtIGluIGFuIG9iamVjdCBpbmRpdmlkdWFsbHlcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaykge1xuICAgICAgdGhpcy5yZW1lbWJlcihrZXksIGtba2V5XSlcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIHJldHJpZXZlIG1lbW9yeVxuICAgIHJldHVybiB0aGlzLm1lbW9yeSgpW2tdXG4gIH0gZWxzZSB7XG4gICAgLy8gc3RvcmUgbWVtb3J5XG4gICAgdGhpcy5tZW1vcnkoKVtrXSA9IHZcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEVyYXNlIGEgZ2l2ZW4gbWVtb3J5XG5leHBvcnQgZnVuY3Rpb24gZm9yZ2V0KCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuX21lbW9yeSA9IHt9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgZGVsZXRlIHRoaXMubWVtb3J5KClbYXJndW1lbnRzW2ldXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBUaGlzIHRyaWdnZXJzIGNyZWF0aW9uIG9mIGEgbmV3IGhpZGRlbiBjbGFzcyB3aGljaCBpcyBub3QgcGVyZm9ybWFudFxuLy8gSG93ZXZlciwgdGhpcyBmdW5jdGlvbiBpcyBub3QgcmFyZWx5IHVzZWQgc28gaXQgd2lsbCBub3QgaGFwcGVuIGZyZXF1ZW50bHlcbi8vIFJldHVybiBsb2NhbCBtZW1vcnkgb2JqZWN0XG5leHBvcnQgZnVuY3Rpb24gbWVtb3J5KCkge1xuICByZXR1cm4gKHRoaXMuX21lbW9yeSA9IHRoaXMuX21lbW9yeSB8fCB7fSlcbn1cblxucmVnaXN0ZXJNZXRob2RzKCdEb20nLCB7IHJlbWVtYmVyLCBmb3JnZXQsIG1lbW9yeSB9KVxuIiwiaW1wb3J0IHsgaGV4LCBpc0hleCwgaXNSZ2IsIHJnYiwgd2hpdGVzcGFjZSB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9yZWdleC5qcydcblxuZnVuY3Rpb24gc2l4RGlnaXRIZXgoaGV4KSB7XG4gIHJldHVybiBoZXgubGVuZ3RoID09PSA0XG4gICAgPyBbXG4gICAgICAgICcjJyxcbiAgICAgICAgaGV4LnN1YnN0cmluZygxLCAyKSxcbiAgICAgICAgaGV4LnN1YnN0cmluZygxLCAyKSxcbiAgICAgICAgaGV4LnN1YnN0cmluZygyLCAzKSxcbiAgICAgICAgaGV4LnN1YnN0cmluZygyLCAzKSxcbiAgICAgICAgaGV4LnN1YnN0cmluZygzLCA0KSxcbiAgICAgICAgaGV4LnN1YnN0cmluZygzLCA0KVxuICAgICAgXS5qb2luKCcnKVxuICAgIDogaGV4XG59XG5cbmZ1bmN0aW9uIGNvbXBvbmVudEhleChjb21wb25lbnQpIHtcbiAgY29uc3QgaW50ZWdlciA9IE1hdGgucm91bmQoY29tcG9uZW50KVxuICBjb25zdCBib3VuZGVkID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBpbnRlZ2VyKSlcbiAgY29uc3QgaGV4ID0gYm91bmRlZC50b1N0cmluZygxNilcbiAgcmV0dXJuIGhleC5sZW5ndGggPT09IDEgPyAnMCcgKyBoZXggOiBoZXhcbn1cblxuZnVuY3Rpb24gaXMob2JqZWN0LCBzcGFjZSkge1xuICBmb3IgKGxldCBpID0gc3BhY2UubGVuZ3RoOyBpLS07ICkge1xuICAgIGlmIChvYmplY3Rbc3BhY2VbaV1dID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZXRQYXJhbWV0ZXJzKGEsIGIpIHtcbiAgY29uc3QgcGFyYW1zID0gaXMoYSwgJ3JnYicpXG4gICAgPyB7IF9hOiBhLnIsIF9iOiBhLmcsIF9jOiBhLmIsIF9kOiAwLCBzcGFjZTogJ3JnYicgfVxuICAgIDogaXMoYSwgJ3h5eicpXG4gICAgICA/IHsgX2E6IGEueCwgX2I6IGEueSwgX2M6IGEueiwgX2Q6IDAsIHNwYWNlOiAneHl6JyB9XG4gICAgICA6IGlzKGEsICdoc2wnKVxuICAgICAgICA/IHsgX2E6IGEuaCwgX2I6IGEucywgX2M6IGEubCwgX2Q6IDAsIHNwYWNlOiAnaHNsJyB9XG4gICAgICAgIDogaXMoYSwgJ2xhYicpXG4gICAgICAgICAgPyB7IF9hOiBhLmwsIF9iOiBhLmEsIF9jOiBhLmIsIF9kOiAwLCBzcGFjZTogJ2xhYicgfVxuICAgICAgICAgIDogaXMoYSwgJ2xjaCcpXG4gICAgICAgICAgICA/IHsgX2E6IGEubCwgX2I6IGEuYywgX2M6IGEuaCwgX2Q6IDAsIHNwYWNlOiAnbGNoJyB9XG4gICAgICAgICAgICA6IGlzKGEsICdjbXlrJylcbiAgICAgICAgICAgICAgPyB7IF9hOiBhLmMsIF9iOiBhLm0sIF9jOiBhLnksIF9kOiBhLmssIHNwYWNlOiAnY215aycgfVxuICAgICAgICAgICAgICA6IHsgX2E6IDAsIF9iOiAwLCBfYzogMCwgc3BhY2U6ICdyZ2InIH1cblxuICBwYXJhbXMuc3BhY2UgPSBiIHx8IHBhcmFtcy5zcGFjZVxuICByZXR1cm4gcGFyYW1zXG59XG5cbmZ1bmN0aW9uIGNpZVNwYWNlKHNwYWNlKSB7XG4gIGlmIChzcGFjZSA9PT0gJ2xhYicgfHwgc3BhY2UgPT09ICd4eXonIHx8IHNwYWNlID09PSAnbGNoJykge1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gaHVlVG9SZ2IocCwgcSwgdCkge1xuICBpZiAodCA8IDApIHQgKz0gMVxuICBpZiAodCA+IDEpIHQgLT0gMVxuICBpZiAodCA8IDEgLyA2KSByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdFxuICBpZiAodCA8IDEgLyAyKSByZXR1cm4gcVxuICBpZiAodCA8IDIgLyAzKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDZcbiAgcmV0dXJuIHBcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sb3Ige1xuICBjb25zdHJ1Y3RvciguLi5pbnB1dHMpIHtcbiAgICB0aGlzLmluaXQoLi4uaW5wdXRzKVxuICB9XG5cbiAgLy8gVGVzdCBpZiBnaXZlbiB2YWx1ZSBpcyBhIGNvbG9yXG4gIHN0YXRpYyBpc0NvbG9yKGNvbG9yKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGNvbG9yICYmIChjb2xvciBpbnN0YW5jZW9mIENvbG9yIHx8IHRoaXMuaXNSZ2IoY29sb3IpIHx8IHRoaXMudGVzdChjb2xvcikpXG4gICAgKVxuICB9XG5cbiAgLy8gVGVzdCBpZiBnaXZlbiB2YWx1ZSBpcyBhbiByZ2Igb2JqZWN0XG4gIHN0YXRpYyBpc1JnYihjb2xvcikge1xuICAgIHJldHVybiAoXG4gICAgICBjb2xvciAmJlxuICAgICAgdHlwZW9mIGNvbG9yLnIgPT09ICdudW1iZXInICYmXG4gICAgICB0eXBlb2YgY29sb3IuZyA9PT0gJ251bWJlcicgJiZcbiAgICAgIHR5cGVvZiBjb2xvci5iID09PSAnbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIC8qXG4gIEdlbmVyYXRpbmcgcmFuZG9tIGNvbG9yc1xuICAqL1xuICBzdGF0aWMgcmFuZG9tKG1vZGUgPSAndmlicmFudCcsIHQpIHtcbiAgICAvLyBHZXQgdGhlIG1hdGggbW9kdWxlc1xuICAgIGNvbnN0IHsgcmFuZG9tLCByb3VuZCwgc2luLCBQSTogcGkgfSA9IE1hdGhcblxuICAgIC8vIFJ1biB0aGUgY29ycmVjdCBnZW5lcmF0b3JcbiAgICBpZiAobW9kZSA9PT0gJ3ZpYnJhbnQnKSB7XG4gICAgICBjb25zdCBsID0gKDgxIC0gNTcpICogcmFuZG9tKCkgKyA1N1xuICAgICAgY29uc3QgYyA9ICg4MyAtIDQ1KSAqIHJhbmRvbSgpICsgNDVcbiAgICAgIGNvbnN0IGggPSAzNjAgKiByYW5kb20oKVxuICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IobCwgYywgaCwgJ2xjaCcpXG4gICAgICByZXR1cm4gY29sb3JcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdzaW5lJykge1xuICAgICAgdCA9IHQgPT0gbnVsbCA/IHJhbmRvbSgpIDogdFxuICAgICAgY29uc3QgciA9IHJvdW5kKDgwICogc2luKCgyICogcGkgKiB0KSAvIDAuNSArIDAuMDEpICsgMTUwKVxuICAgICAgY29uc3QgZyA9IHJvdW5kKDUwICogc2luKCgyICogcGkgKiB0KSAvIDAuNSArIDQuNikgKyAyMDApXG4gICAgICBjb25zdCBiID0gcm91bmQoMTAwICogc2luKCgyICogcGkgKiB0KSAvIDAuNSArIDIuMykgKyAxNTApXG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihyLCBnLCBiKVxuICAgICAgcmV0dXJuIGNvbG9yXG4gICAgfSBlbHNlIGlmIChtb2RlID09PSAncGFzdGVsJykge1xuICAgICAgY29uc3QgbCA9ICg5NCAtIDg2KSAqIHJhbmRvbSgpICsgODZcbiAgICAgIGNvbnN0IGMgPSAoMjYgLSA5KSAqIHJhbmRvbSgpICsgOVxuICAgICAgY29uc3QgaCA9IDM2MCAqIHJhbmRvbSgpXG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihsLCBjLCBoLCAnbGNoJylcbiAgICAgIHJldHVybiBjb2xvclxuICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2RhcmsnKSB7XG4gICAgICBjb25zdCBsID0gMTAgKyAxMCAqIHJhbmRvbSgpXG4gICAgICBjb25zdCBjID0gKDEyNSAtIDc1KSAqIHJhbmRvbSgpICsgODZcbiAgICAgIGNvbnN0IGggPSAzNjAgKiByYW5kb20oKVxuICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IobCwgYywgaCwgJ2xjaCcpXG4gICAgICByZXR1cm4gY29sb3JcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdyZ2InKSB7XG4gICAgICBjb25zdCByID0gMjU1ICogcmFuZG9tKClcbiAgICAgIGNvbnN0IGcgPSAyNTUgKiByYW5kb20oKVxuICAgICAgY29uc3QgYiA9IDI1NSAqIHJhbmRvbSgpXG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihyLCBnLCBiKVxuICAgICAgcmV0dXJuIGNvbG9yXG4gICAgfSBlbHNlIGlmIChtb2RlID09PSAnbGFiJykge1xuICAgICAgY29uc3QgbCA9IDEwMCAqIHJhbmRvbSgpXG4gICAgICBjb25zdCBhID0gMjU2ICogcmFuZG9tKCkgLSAxMjhcbiAgICAgIGNvbnN0IGIgPSAyNTYgKiByYW5kb20oKSAtIDEyOFxuICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IobCwgYSwgYiwgJ2xhYicpXG4gICAgICByZXR1cm4gY29sb3JcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdncmV5Jykge1xuICAgICAgY29uc3QgZ3JleSA9IDI1NSAqIHJhbmRvbSgpXG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihncmV5LCBncmV5LCBncmV5KVxuICAgICAgcmV0dXJuIGNvbG9yXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcmFuZG9tIGNvbG9yIG1vZGUnKVxuICAgIH1cbiAgfVxuXG4gIC8vIFRlc3QgaWYgZ2l2ZW4gdmFsdWUgaXMgYSBjb2xvciBzdHJpbmdcbiAgc3RhdGljIHRlc3QoY29sb3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJyAmJiAoaXNIZXgudGVzdChjb2xvcikgfHwgaXNSZ2IudGVzdChjb2xvcikpXG4gIH1cblxuICBjbXlrKCkge1xuICAgIC8vIEdldCB0aGUgcmdiIHZhbHVlcyBmb3IgdGhlIGN1cnJlbnQgY29sb3JcbiAgICBjb25zdCB7IF9hLCBfYiwgX2MgfSA9IHRoaXMucmdiKClcbiAgICBjb25zdCBbciwgZywgYl0gPSBbX2EsIF9iLCBfY10ubWFwKCh2KSA9PiB2IC8gMjU1KVxuXG4gICAgLy8gR2V0IHRoZSBjbXlrIHZhbHVlcyBpbiBhbiB1bmJvdW5kZWQgZm9ybWF0XG4gICAgY29uc3QgayA9IE1hdGgubWluKDEgLSByLCAxIC0gZywgMSAtIGIpXG5cbiAgICBpZiAoayA9PT0gMSkge1xuICAgICAgLy8gQ2F0Y2ggdGhlIGJsYWNrIGNhc2VcbiAgICAgIHJldHVybiBuZXcgQ29sb3IoMCwgMCwgMCwgMSwgJ2NteWsnKVxuICAgIH1cblxuICAgIGNvbnN0IGMgPSAoMSAtIHIgLSBrKSAvICgxIC0gaylcbiAgICBjb25zdCBtID0gKDEgLSBnIC0gaykgLyAoMSAtIGspXG4gICAgY29uc3QgeSA9ICgxIC0gYiAtIGspIC8gKDEgLSBrKVxuXG4gICAgLy8gQ29uc3RydWN0IHRoZSBuZXcgY29sb3JcbiAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihjLCBtLCB5LCBrLCAnY215aycpXG4gICAgcmV0dXJuIGNvbG9yXG4gIH1cblxuICBoc2woKSB7XG4gICAgLy8gR2V0IHRoZSByZ2IgdmFsdWVzXG4gICAgY29uc3QgeyBfYSwgX2IsIF9jIH0gPSB0aGlzLnJnYigpXG4gICAgY29uc3QgW3IsIGcsIGJdID0gW19hLCBfYiwgX2NdLm1hcCgodikgPT4gdiAvIDI1NSlcblxuICAgIC8vIEZpbmQgdGhlIG1heGltdW0gYW5kIG1pbmltdW0gdmFsdWVzIHRvIGdldCB0aGUgbGlnaHRuZXNzXG4gICAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYilcbiAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKVxuICAgIGNvbnN0IGwgPSAobWF4ICsgbWluKSAvIDJcblxuICAgIC8vIElmIHRoZSByLCBnLCB2IHZhbHVlcyBhcmUgaWRlbnRpY2FsIHRoZW4gd2UgYXJlIGdyZXlcbiAgICBjb25zdCBpc0dyZXkgPSBtYXggPT09IG1pblxuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBodWUgYW5kIHNhdHVyYXRpb25cbiAgICBjb25zdCBkZWx0YSA9IG1heCAtIG1pblxuICAgIGNvbnN0IHMgPSBpc0dyZXlcbiAgICAgID8gMFxuICAgICAgOiBsID4gMC41XG4gICAgICAgID8gZGVsdGEgLyAoMiAtIG1heCAtIG1pbilcbiAgICAgICAgOiBkZWx0YSAvIChtYXggKyBtaW4pXG4gICAgY29uc3QgaCA9IGlzR3JleVxuICAgICAgPyAwXG4gICAgICA6IG1heCA9PT0gclxuICAgICAgICA/ICgoZyAtIGIpIC8gZGVsdGEgKyAoZyA8IGIgPyA2IDogMCkpIC8gNlxuICAgICAgICA6IG1heCA9PT0gZ1xuICAgICAgICAgID8gKChiIC0gcikgLyBkZWx0YSArIDIpIC8gNlxuICAgICAgICAgIDogbWF4ID09PSBiXG4gICAgICAgICAgICA/ICgociAtIGcpIC8gZGVsdGEgKyA0KSAvIDZcbiAgICAgICAgICAgIDogMFxuXG4gICAgLy8gQ29uc3RydWN0IGFuZCByZXR1cm4gdGhlIG5ldyBjb2xvclxuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKDM2MCAqIGgsIDEwMCAqIHMsIDEwMCAqIGwsICdoc2wnKVxuICAgIHJldHVybiBjb2xvclxuICB9XG5cbiAgaW5pdChhID0gMCwgYiA9IDAsIGMgPSAwLCBkID0gMCwgc3BhY2UgPSAncmdiJykge1xuICAgIC8vIFRoaXMgY2F0Y2hlcyB0aGUgY2FzZSB3aGVuIGEgZmFsc3kgdmFsdWUgaXMgcGFzc2VkIGxpa2UgJydcbiAgICBhID0gIWEgPyAwIDogYVxuXG4gICAgLy8gUmVzZXQgYWxsIHZhbHVlcyBpbiBjYXNlIHRoZSBpbml0IGZ1bmN0aW9uIGlzIHJlcnVuIHdpdGggbmV3IGNvbG9yIHNwYWNlXG4gICAgaWYgKHRoaXMuc3BhY2UpIHtcbiAgICAgIGZvciAoY29uc3QgY29tcG9uZW50IGluIHRoaXMuc3BhY2UpIHtcbiAgICAgICAgZGVsZXRlIHRoaXNbdGhpcy5zcGFjZVtjb21wb25lbnRdXVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIEFsbG93IGZvciB0aGUgY2FzZSB0aGF0IHdlIGRvbid0IG5lZWQgZC4uLlxuICAgICAgc3BhY2UgPSB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyBkIDogc3BhY2VcbiAgICAgIGQgPSB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyAwIDogZFxuXG4gICAgICAvLyBBc3NpZ24gdGhlIHZhbHVlcyBzdHJhaWdodCB0byB0aGUgY29sb3JcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBfYTogYSwgX2I6IGIsIF9jOiBjLCBfZDogZCwgc3BhY2UgfSlcbiAgICAgIC8vIElmIHRoZSB1c2VyIGdhdmUgdXMgYW4gYXJyYXksIG1ha2UgdGhlIGNvbG9yIGZyb20gaXRcbiAgICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgdGhpcy5zcGFjZSA9IGIgfHwgKHR5cGVvZiBhWzNdID09PSAnc3RyaW5nJyA/IGFbM10gOiBhWzRdKSB8fCAncmdiJ1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IF9hOiBhWzBdLCBfYjogYVsxXSwgX2M6IGFbMl0sIF9kOiBhWzNdIHx8IDAgfSlcbiAgICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIC8vIFNldCB0aGUgb2JqZWN0IHVwIGFuZCBhc3NpZ24gaXRzIHZhbHVlcyBkaXJlY3RseVxuICAgICAgY29uc3QgdmFsdWVzID0gZ2V0UGFyYW1ldGVycyhhLCBiKVxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB2YWx1ZXMpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChpc1JnYi50ZXN0KGEpKSB7XG4gICAgICAgIGNvbnN0IG5vV2hpdGVzcGFjZSA9IGEucmVwbGFjZSh3aGl0ZXNwYWNlLCAnJylcbiAgICAgICAgY29uc3QgW19hLCBfYiwgX2NdID0gcmdiXG4gICAgICAgICAgLmV4ZWMobm9XaGl0ZXNwYWNlKVxuICAgICAgICAgIC5zbGljZSgxLCA0KVxuICAgICAgICAgIC5tYXAoKHYpID0+IHBhcnNlSW50KHYpKVxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgX2EsIF9iLCBfYywgX2Q6IDAsIHNwYWNlOiAncmdiJyB9KVxuICAgICAgfSBlbHNlIGlmIChpc0hleC50ZXN0KGEpKSB7XG4gICAgICAgIGNvbnN0IGhleFBhcnNlID0gKHYpID0+IHBhcnNlSW50KHYsIDE2KVxuICAgICAgICBjb25zdCBbLCBfYSwgX2IsIF9jXSA9IGhleC5leGVjKHNpeERpZ2l0SGV4KGEpKS5tYXAoaGV4UGFyc2UpXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBfYSwgX2IsIF9jLCBfZDogMCwgc3BhY2U6ICdyZ2InIH0pXG4gICAgICB9IGVsc2UgdGhyb3cgRXJyb3IoXCJVbnN1cHBvcnRlZCBzdHJpbmcgZm9ybWF0LCBjYW4ndCBjb25zdHJ1Y3QgQ29sb3JcIilcbiAgICB9XG5cbiAgICAvLyBOb3cgYWRkIHRoZSBjb21wb25lbnRzIGFzIGEgY29udmVuaWVuY2VcbiAgICBjb25zdCB7IF9hLCBfYiwgX2MsIF9kIH0gPSB0aGlzXG4gICAgY29uc3QgY29tcG9uZW50cyA9XG4gICAgICB0aGlzLnNwYWNlID09PSAncmdiJ1xuICAgICAgICA/IHsgcjogX2EsIGc6IF9iLCBiOiBfYyB9XG4gICAgICAgIDogdGhpcy5zcGFjZSA9PT0gJ3h5eidcbiAgICAgICAgICA/IHsgeDogX2EsIHk6IF9iLCB6OiBfYyB9XG4gICAgICAgICAgOiB0aGlzLnNwYWNlID09PSAnaHNsJ1xuICAgICAgICAgICAgPyB7IGg6IF9hLCBzOiBfYiwgbDogX2MgfVxuICAgICAgICAgICAgOiB0aGlzLnNwYWNlID09PSAnbGFiJ1xuICAgICAgICAgICAgICA/IHsgbDogX2EsIGE6IF9iLCBiOiBfYyB9XG4gICAgICAgICAgICAgIDogdGhpcy5zcGFjZSA9PT0gJ2xjaCdcbiAgICAgICAgICAgICAgICA/IHsgbDogX2EsIGM6IF9iLCBoOiBfYyB9XG4gICAgICAgICAgICAgICAgOiB0aGlzLnNwYWNlID09PSAnY215aydcbiAgICAgICAgICAgICAgICAgID8geyBjOiBfYSwgbTogX2IsIHk6IF9jLCBrOiBfZCB9XG4gICAgICAgICAgICAgICAgICA6IHt9XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjb21wb25lbnRzKVxuICB9XG5cbiAgbGFiKCkge1xuICAgIC8vIEdldCB0aGUgeHl6IGNvbG9yXG4gICAgY29uc3QgeyB4LCB5LCB6IH0gPSB0aGlzLnh5eigpXG5cbiAgICAvLyBHZXQgdGhlIGxhYiBjb21wb25lbnRzXG4gICAgY29uc3QgbCA9IDExNiAqIHkgLSAxNlxuICAgIGNvbnN0IGEgPSA1MDAgKiAoeCAtIHkpXG4gICAgY29uc3QgYiA9IDIwMCAqICh5IC0geilcblxuICAgIC8vIENvbnN0cnVjdCBhbmQgcmV0dXJuIGEgbmV3IGNvbG9yXG4gICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IobCwgYSwgYiwgJ2xhYicpXG4gICAgcmV0dXJuIGNvbG9yXG4gIH1cblxuICBsY2goKSB7XG4gICAgLy8gR2V0IHRoZSBsYWIgY29sb3IgZGlyZWN0bHlcbiAgICBjb25zdCB7IGwsIGEsIGIgfSA9IHRoaXMubGFiKClcblxuICAgIC8vIEdldCB0aGUgY2hyb21hdGljaXR5IGFuZCB0aGUgaHVlIHVzaW5nIHBvbGFyIGNvb3JkaW5hdGVzXG4gICAgY29uc3QgYyA9IE1hdGguc3FydChhICoqIDIgKyBiICoqIDIpXG4gICAgbGV0IGggPSAoMTgwICogTWF0aC5hdGFuMihiLCBhKSkgLyBNYXRoLlBJXG4gICAgaWYgKGggPCAwKSB7XG4gICAgICBoICo9IC0xXG4gICAgICBoID0gMzYwIC0gaFxuICAgIH1cblxuICAgIC8vIE1ha2UgYSBuZXcgY29sb3IgYW5kIHJldHVybiBpdFxuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGwsIGMsIGgsICdsY2gnKVxuICAgIHJldHVybiBjb2xvclxuICB9XG4gIC8qXG4gIENvbnZlcnNpb24gTWV0aG9kc1xuICAqL1xuXG4gIHJnYigpIHtcbiAgICBpZiAodGhpcy5zcGFjZSA9PT0gJ3JnYicpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSBlbHNlIGlmIChjaWVTcGFjZSh0aGlzLnNwYWNlKSkge1xuICAgICAgLy8gQ29udmVydCB0byB0aGUgeHl6IGNvbG9yIHNwYWNlXG4gICAgICBsZXQgeyB4LCB5LCB6IH0gPSB0aGlzXG4gICAgICBpZiAodGhpcy5zcGFjZSA9PT0gJ2xhYicgfHwgdGhpcy5zcGFjZSA9PT0gJ2xjaCcpIHtcbiAgICAgICAgLy8gR2V0IHRoZSB2YWx1ZXMgaW4gdGhlIGxhYiBzcGFjZVxuICAgICAgICBsZXQgeyBsLCBhLCBiIH0gPSB0aGlzXG4gICAgICAgIGlmICh0aGlzLnNwYWNlID09PSAnbGNoJykge1xuICAgICAgICAgIGNvbnN0IHsgYywgaCB9ID0gdGhpc1xuICAgICAgICAgIGNvbnN0IGRUb1IgPSBNYXRoLlBJIC8gMTgwXG4gICAgICAgICAgYSA9IGMgKiBNYXRoLmNvcyhkVG9SICogaClcbiAgICAgICAgICBiID0gYyAqIE1hdGguc2luKGRUb1IgKiBoKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5kbyB0aGUgbm9ubGluZWFyIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHlMID0gKGwgKyAxNikgLyAxMTZcbiAgICAgICAgY29uc3QgeEwgPSBhIC8gNTAwICsgeUxcbiAgICAgICAgY29uc3QgekwgPSB5TCAtIGIgLyAyMDBcblxuICAgICAgICAvLyBHZXQgdGhlIHh5eiB2YWx1ZXNcbiAgICAgICAgY29uc3QgY3QgPSAxNiAvIDExNlxuICAgICAgICBjb25zdCBteCA9IDAuMDA4ODU2XG4gICAgICAgIGNvbnN0IG5tID0gNy43ODdcbiAgICAgICAgeCA9IDAuOTUwNDcgKiAoeEwgKiogMyA+IG14ID8geEwgKiogMyA6ICh4TCAtIGN0KSAvIG5tKVxuICAgICAgICB5ID0gMS4wICogKHlMICoqIDMgPiBteCA/IHlMICoqIDMgOiAoeUwgLSBjdCkgLyBubSlcbiAgICAgICAgeiA9IDEuMDg4ODMgKiAoekwgKiogMyA+IG14ID8gekwgKiogMyA6ICh6TCAtIGN0KSAvIG5tKVxuICAgICAgfVxuXG4gICAgICAvLyBDb252ZXJ0IHh5eiB0byB1bmJvdW5kZWQgcmdiIHZhbHVlc1xuICAgICAgY29uc3QgclUgPSB4ICogMy4yNDA2ICsgeSAqIC0xLjUzNzIgKyB6ICogLTAuNDk4NlxuICAgICAgY29uc3QgZ1UgPSB4ICogLTAuOTY4OSArIHkgKiAxLjg3NTggKyB6ICogMC4wNDE1XG4gICAgICBjb25zdCBiVSA9IHggKiAwLjA1NTcgKyB5ICogLTAuMjA0ICsgeiAqIDEuMDU3XG5cbiAgICAgIC8vIENvbnZlcnQgdGhlIHZhbHVlcyB0byB0cnVlIHJnYiB2YWx1ZXNcbiAgICAgIGNvbnN0IHBvdyA9IE1hdGgucG93XG4gICAgICBjb25zdCBiZCA9IDAuMDAzMTMwOFxuICAgICAgY29uc3QgciA9IHJVID4gYmQgPyAxLjA1NSAqIHBvdyhyVSwgMSAvIDIuNCkgLSAwLjA1NSA6IDEyLjkyICogclVcbiAgICAgIGNvbnN0IGcgPSBnVSA+IGJkID8gMS4wNTUgKiBwb3coZ1UsIDEgLyAyLjQpIC0gMC4wNTUgOiAxMi45MiAqIGdVXG4gICAgICBjb25zdCBiID0gYlUgPiBiZCA/IDEuMDU1ICogcG93KGJVLCAxIC8gMi40KSAtIDAuMDU1IDogMTIuOTIgKiBiVVxuXG4gICAgICAvLyBNYWtlIGFuZCByZXR1cm4gdGhlIGNvbG9yXG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcigyNTUgKiByLCAyNTUgKiBnLCAyNTUgKiBiKVxuICAgICAgcmV0dXJuIGNvbG9yXG4gICAgfSBlbHNlIGlmICh0aGlzLnNwYWNlID09PSAnaHNsJykge1xuICAgICAgLy8gaHR0cHM6Ly9iZ3JpbnMuZ2l0aHViLmlvL1RpbnlDb2xvci9kb2NzL3Rpbnljb2xvci5odG1sXG4gICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgaHNsIHZhbHVlc1xuICAgICAgbGV0IHsgaCwgcywgbCB9ID0gdGhpc1xuICAgICAgaCAvPSAzNjBcbiAgICAgIHMgLz0gMTAwXG4gICAgICBsIC89IDEwMFxuXG4gICAgICAvLyBJZiB3ZSBhcmUgZ3JleSwgdGhlbiBqdXN0IG1ha2UgdGhlIGNvbG9yIGRpcmVjdGx5XG4gICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICBsICo9IDI1NVxuICAgICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihsLCBsLCBsKVxuICAgICAgICByZXR1cm4gY29sb3JcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETyBJIGhhdmUgbm8gaWRlYSB3aGF0IHRoaXMgZG9lcyA6RCBJZiB5b3UgZmlndXJlIGl0IG91dCwgdGVsbCBtZSFcbiAgICAgIGNvbnN0IHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzXG4gICAgICBjb25zdCBwID0gMiAqIGwgLSBxXG5cbiAgICAgIC8vIEdldCB0aGUgcmdiIHZhbHVlc1xuICAgICAgY29uc3QgciA9IDI1NSAqIGh1ZVRvUmdiKHAsIHEsIGggKyAxIC8gMylcbiAgICAgIGNvbnN0IGcgPSAyNTUgKiBodWVUb1JnYihwLCBxLCBoKVxuICAgICAgY29uc3QgYiA9IDI1NSAqIGh1ZVRvUmdiKHAsIHEsIGggLSAxIC8gMylcblxuICAgICAgLy8gTWFrZSBhIG5ldyBjb2xvclxuICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IociwgZywgYilcbiAgICAgIHJldHVybiBjb2xvclxuICAgIH0gZWxzZSBpZiAodGhpcy5zcGFjZSA9PT0gJ2NteWsnKSB7XG4gICAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9mZWxpcGVzYWJpbm8vNTA2NjMzNlxuICAgICAgLy8gR2V0IHRoZSBub3JtYWxpc2VkIGNteWsgdmFsdWVzXG4gICAgICBjb25zdCB7IGMsIG0sIHksIGsgfSA9IHRoaXNcblxuICAgICAgLy8gR2V0IHRoZSByZ2IgdmFsdWVzXG4gICAgICBjb25zdCByID0gMjU1ICogKDEgLSBNYXRoLm1pbigxLCBjICogKDEgLSBrKSArIGspKVxuICAgICAgY29uc3QgZyA9IDI1NSAqICgxIC0gTWF0aC5taW4oMSwgbSAqICgxIC0gaykgKyBrKSlcbiAgICAgIGNvbnN0IGIgPSAyNTUgKiAoMSAtIE1hdGgubWluKDEsIHkgKiAoMSAtIGspICsgaykpXG5cbiAgICAgIC8vIEZvcm0gdGhlIGNvbG9yIGFuZCByZXR1cm4gaXRcbiAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKHIsIGcsIGIpXG4gICAgICByZXR1cm4gY29sb3JcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gIH1cblxuICB0b0FycmF5KCkge1xuICAgIGNvbnN0IHsgX2EsIF9iLCBfYywgX2QsIHNwYWNlIH0gPSB0aGlzXG4gICAgcmV0dXJuIFtfYSwgX2IsIF9jLCBfZCwgc3BhY2VdXG4gIH1cblxuICB0b0hleCgpIHtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLl9jbGFtcGVkKCkubWFwKGNvbXBvbmVudEhleClcbiAgICByZXR1cm4gYCMke3J9JHtnfSR7Yn1gXG4gIH1cblxuICB0b1JnYigpIHtcbiAgICBjb25zdCBbclYsIGdWLCBiVl0gPSB0aGlzLl9jbGFtcGVkKClcbiAgICBjb25zdCBzdHJpbmcgPSBgcmdiKCR7clZ9LCR7Z1Z9LCR7YlZ9KWBcbiAgICByZXR1cm4gc3RyaW5nXG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy50b0hleCgpXG4gIH1cblxuICB4eXooKSB7XG4gICAgLy8gTm9ybWFsaXNlIHRoZSByZWQsIGdyZWVuIGFuZCBibHVlIHZhbHVlc1xuICAgIGNvbnN0IHsgX2E6IHIyNTUsIF9iOiBnMjU1LCBfYzogYjI1NSB9ID0gdGhpcy5yZ2IoKVxuICAgIGNvbnN0IFtyLCBnLCBiXSA9IFtyMjU1LCBnMjU1LCBiMjU1XS5tYXAoKHYpID0+IHYgLyAyNTUpXG5cbiAgICAvLyBDb252ZXJ0IHRvIHRoZSBsYWIgcmdiIHNwYWNlXG4gICAgY29uc3QgckwgPSByID4gMC4wNDA0NSA/IE1hdGgucG93KChyICsgMC4wNTUpIC8gMS4wNTUsIDIuNCkgOiByIC8gMTIuOTJcbiAgICBjb25zdCBnTCA9IGcgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKGcgKyAwLjA1NSkgLyAxLjA1NSwgMi40KSA6IGcgLyAxMi45MlxuICAgIGNvbnN0IGJMID0gYiA+IDAuMDQwNDUgPyBNYXRoLnBvdygoYiArIDAuMDU1KSAvIDEuMDU1LCAyLjQpIDogYiAvIDEyLjkyXG5cbiAgICAvLyBDb252ZXJ0IHRvIHRoZSB4eXogY29sb3Igc3BhY2Ugd2l0aG91dCBib3VuZGluZyB0aGUgdmFsdWVzXG4gICAgY29uc3QgeFUgPSAockwgKiAwLjQxMjQgKyBnTCAqIDAuMzU3NiArIGJMICogMC4xODA1KSAvIDAuOTUwNDdcbiAgICBjb25zdCB5VSA9IChyTCAqIDAuMjEyNiArIGdMICogMC43MTUyICsgYkwgKiAwLjA3MjIpIC8gMS4wXG4gICAgY29uc3QgelUgPSAockwgKiAwLjAxOTMgKyBnTCAqIDAuMTE5MiArIGJMICogMC45NTA1KSAvIDEuMDg4ODNcblxuICAgIC8vIEdldCB0aGUgcHJvcGVyIHh5eiB2YWx1ZXMgYnkgYXBwbHlpbmcgdGhlIGJvdW5kaW5nXG4gICAgY29uc3QgeCA9IHhVID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4VSwgMSAvIDMpIDogNy43ODcgKiB4VSArIDE2IC8gMTE2XG4gICAgY29uc3QgeSA9IHlVID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5VSwgMSAvIDMpIDogNy43ODcgKiB5VSArIDE2IC8gMTE2XG4gICAgY29uc3QgeiA9IHpVID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh6VSwgMSAvIDMpIDogNy43ODcgKiB6VSArIDE2IC8gMTE2XG5cbiAgICAvLyBNYWtlIGFuZCByZXR1cm4gdGhlIGNvbG9yXG4gICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IoeCwgeSwgeiwgJ3h5eicpXG4gICAgcmV0dXJuIGNvbG9yXG4gIH1cblxuICAvKlxuICBJbnB1dCBhbmQgT3V0cHV0IG1ldGhvZHNcbiAgKi9cblxuICBfY2xhbXBlZCgpIHtcbiAgICBjb25zdCB7IF9hLCBfYiwgX2MgfSA9IHRoaXMucmdiKClcbiAgICBjb25zdCB7IG1heCwgbWluLCByb3VuZCB9ID0gTWF0aFxuICAgIGNvbnN0IGZvcm1hdCA9ICh2KSA9PiBtYXgoMCwgbWluKHJvdW5kKHYpLCAyNTUpKVxuICAgIHJldHVybiBbX2EsIF9iLCBfY10ubWFwKGZvcm1hdClcbiAgfVxuXG4gIC8qXG4gIENvbnN0cnVjdGluZyBjb2xvcnNcbiAgKi9cbn1cbiIsImltcG9ydCBNYXRyaXggZnJvbSAnLi9NYXRyaXguanMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50IHtcbiAgLy8gSW5pdGlhbGl6ZVxuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgdGhpcy5pbml0KC4uLmFyZ3MpXG4gIH1cblxuICAvLyBDbG9uZSBwb2ludFxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMpXG4gIH1cblxuICBpbml0KHgsIHkpIHtcbiAgICBjb25zdCBiYXNlID0geyB4OiAwLCB5OiAwIH1cblxuICAgIC8vIGVuc3VyZSBzb3VyY2UgYXMgb2JqZWN0XG4gICAgY29uc3Qgc291cmNlID0gQXJyYXkuaXNBcnJheSh4KVxuICAgICAgPyB7IHg6IHhbMF0sIHk6IHhbMV0gfVxuICAgICAgOiB0eXBlb2YgeCA9PT0gJ29iamVjdCdcbiAgICAgICAgPyB7IHg6IHgueCwgeTogeC55IH1cbiAgICAgICAgOiB7IHg6IHgsIHk6IHkgfVxuXG4gICAgLy8gbWVyZ2Ugc291cmNlXG4gICAgdGhpcy54ID0gc291cmNlLnggPT0gbnVsbCA/IGJhc2UueCA6IHNvdXJjZS54XG4gICAgdGhpcy55ID0gc291cmNlLnkgPT0gbnVsbCA/IGJhc2UueSA6IHNvdXJjZS55XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gW3RoaXMueCwgdGhpcy55XVxuICB9XG5cbiAgdHJhbnNmb3JtKG0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnRyYW5zZm9ybU8obSlcbiAgfVxuXG4gIC8vIFRyYW5zZm9ybSBwb2ludCB3aXRoIG1hdHJpeFxuICB0cmFuc2Zvcm1PKG0pIHtcbiAgICBpZiAoIU1hdHJpeC5pc01hdHJpeExpa2UobSkpIHtcbiAgICAgIG0gPSBuZXcgTWF0cml4KG0pXG4gICAgfVxuXG4gICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzXG5cbiAgICAvLyBQZXJmb3JtIHRoZSBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICB0aGlzLnggPSBtLmEgKiB4ICsgbS5jICogeSArIG0uZVxuICAgIHRoaXMueSA9IG0uYiAqIHggKyBtLmQgKiB5ICsgbS5mXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gIHJldHVybiBuZXcgUG9pbnQoeCwgeSkudHJhbnNmb3JtTyh0aGlzLnNjcmVlbkNUTSgpLmludmVyc2VPKCkpXG59XG4iLCJpbXBvcnQgeyBkZWxpbWl0ZXIgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcmVnZXguanMnXG5pbXBvcnQgeyByYWRpYW5zIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMuanMnXG5pbXBvcnQgeyByZWdpc3RlciB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5pbXBvcnQgRWxlbWVudCBmcm9tICcuLi9lbGVtZW50cy9FbGVtZW50LmpzJ1xuaW1wb3J0IFBvaW50IGZyb20gJy4vUG9pbnQuanMnXG5cbmZ1bmN0aW9uIGNsb3NlRW5vdWdoKGEsIGIsIHRocmVzaG9sZCkge1xuICByZXR1cm4gTWF0aC5hYnMoYiAtIGEpIDwgKHRocmVzaG9sZCB8fCAxZS02KVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXRyaXgge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgdGhpcy5pbml0KC4uLmFyZ3MpXG4gIH1cblxuICBzdGF0aWMgZm9ybWF0VHJhbnNmb3JtcyhvKSB7XG4gICAgLy8gR2V0IGFsbCBvZiB0aGUgcGFyYW1ldGVycyByZXF1aXJlZCB0byBmb3JtIHRoZSBtYXRyaXhcbiAgICBjb25zdCBmbGlwQm90aCA9IG8uZmxpcCA9PT0gJ2JvdGgnIHx8IG8uZmxpcCA9PT0gdHJ1ZVxuICAgIGNvbnN0IGZsaXBYID0gby5mbGlwICYmIChmbGlwQm90aCB8fCBvLmZsaXAgPT09ICd4JykgPyAtMSA6IDFcbiAgICBjb25zdCBmbGlwWSA9IG8uZmxpcCAmJiAoZmxpcEJvdGggfHwgby5mbGlwID09PSAneScpID8gLTEgOiAxXG4gICAgY29uc3Qgc2tld1ggPVxuICAgICAgby5za2V3ICYmIG8uc2tldy5sZW5ndGhcbiAgICAgICAgPyBvLnNrZXdbMF1cbiAgICAgICAgOiBpc0Zpbml0ZShvLnNrZXcpXG4gICAgICAgICAgPyBvLnNrZXdcbiAgICAgICAgICA6IGlzRmluaXRlKG8uc2tld1gpXG4gICAgICAgICAgICA/IG8uc2tld1hcbiAgICAgICAgICAgIDogMFxuICAgIGNvbnN0IHNrZXdZID1cbiAgICAgIG8uc2tldyAmJiBvLnNrZXcubGVuZ3RoXG4gICAgICAgID8gby5za2V3WzFdXG4gICAgICAgIDogaXNGaW5pdGUoby5za2V3KVxuICAgICAgICAgID8gby5za2V3XG4gICAgICAgICAgOiBpc0Zpbml0ZShvLnNrZXdZKVxuICAgICAgICAgICAgPyBvLnNrZXdZXG4gICAgICAgICAgICA6IDBcbiAgICBjb25zdCBzY2FsZVggPVxuICAgICAgby5zY2FsZSAmJiBvLnNjYWxlLmxlbmd0aFxuICAgICAgICA/IG8uc2NhbGVbMF0gKiBmbGlwWFxuICAgICAgICA6IGlzRmluaXRlKG8uc2NhbGUpXG4gICAgICAgICAgPyBvLnNjYWxlICogZmxpcFhcbiAgICAgICAgICA6IGlzRmluaXRlKG8uc2NhbGVYKVxuICAgICAgICAgICAgPyBvLnNjYWxlWCAqIGZsaXBYXG4gICAgICAgICAgICA6IGZsaXBYXG4gICAgY29uc3Qgc2NhbGVZID1cbiAgICAgIG8uc2NhbGUgJiYgby5zY2FsZS5sZW5ndGhcbiAgICAgICAgPyBvLnNjYWxlWzFdICogZmxpcFlcbiAgICAgICAgOiBpc0Zpbml0ZShvLnNjYWxlKVxuICAgICAgICAgID8gby5zY2FsZSAqIGZsaXBZXG4gICAgICAgICAgOiBpc0Zpbml0ZShvLnNjYWxlWSlcbiAgICAgICAgICAgID8gby5zY2FsZVkgKiBmbGlwWVxuICAgICAgICAgICAgOiBmbGlwWVxuICAgIGNvbnN0IHNoZWFyID0gby5zaGVhciB8fCAwXG4gICAgY29uc3QgdGhldGEgPSBvLnJvdGF0ZSB8fCBvLnRoZXRhIHx8IDBcbiAgICBjb25zdCBvcmlnaW4gPSBuZXcgUG9pbnQoXG4gICAgICBvLm9yaWdpbiB8fCBvLmFyb3VuZCB8fCBvLm94IHx8IG8ub3JpZ2luWCxcbiAgICAgIG8ub3kgfHwgby5vcmlnaW5ZXG4gICAgKVxuICAgIGNvbnN0IG94ID0gb3JpZ2luLnhcbiAgICBjb25zdCBveSA9IG9yaWdpbi55XG4gICAgLy8gV2UgbmVlZCBQb2ludCB0byBiZSBpbnZhbGlkIGlmIG5vdGhpbmcgd2FzIHBhc3NlZCBiZWNhdXNlIHdlIGNhbm5vdCBkZWZhdWx0IHRvIDAgaGVyZS4gVGhhdCBpcyB3aHkgTmFOXG4gICAgY29uc3QgcG9zaXRpb24gPSBuZXcgUG9pbnQoXG4gICAgICBvLnBvc2l0aW9uIHx8IG8ucHggfHwgby5wb3NpdGlvblggfHwgTmFOLFxuICAgICAgby5weSB8fCBvLnBvc2l0aW9uWSB8fCBOYU5cbiAgICApXG4gICAgY29uc3QgcHggPSBwb3NpdGlvbi54XG4gICAgY29uc3QgcHkgPSBwb3NpdGlvbi55XG4gICAgY29uc3QgdHJhbnNsYXRlID0gbmV3IFBvaW50KFxuICAgICAgby50cmFuc2xhdGUgfHwgby50eCB8fCBvLnRyYW5zbGF0ZVgsXG4gICAgICBvLnR5IHx8IG8udHJhbnNsYXRlWVxuICAgIClcbiAgICBjb25zdCB0eCA9IHRyYW5zbGF0ZS54XG4gICAgY29uc3QgdHkgPSB0cmFuc2xhdGUueVxuICAgIGNvbnN0IHJlbGF0aXZlID0gbmV3IFBvaW50KFxuICAgICAgby5yZWxhdGl2ZSB8fCBvLnJ4IHx8IG8ucmVsYXRpdmVYLFxuICAgICAgby5yeSB8fCBvLnJlbGF0aXZlWVxuICAgIClcbiAgICBjb25zdCByeCA9IHJlbGF0aXZlLnhcbiAgICBjb25zdCByeSA9IHJlbGF0aXZlLnlcblxuICAgIC8vIFBvcHVsYXRlIGFsbCBvZiB0aGUgdmFsdWVzXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjYWxlWCxcbiAgICAgIHNjYWxlWSxcbiAgICAgIHNrZXdYLFxuICAgICAgc2tld1ksXG4gICAgICBzaGVhcixcbiAgICAgIHRoZXRhLFxuICAgICAgcngsXG4gICAgICByeSxcbiAgICAgIHR4LFxuICAgICAgdHksXG4gICAgICBveCxcbiAgICAgIG95LFxuICAgICAgcHgsXG4gICAgICBweVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBmcm9tQXJyYXkoYSkge1xuICAgIHJldHVybiB7IGE6IGFbMF0sIGI6IGFbMV0sIGM6IGFbMl0sIGQ6IGFbM10sIGU6IGFbNF0sIGY6IGFbNV0gfVxuICB9XG5cbiAgc3RhdGljIGlzTWF0cml4TGlrZShvKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIG8uYSAhPSBudWxsIHx8XG4gICAgICBvLmIgIT0gbnVsbCB8fFxuICAgICAgby5jICE9IG51bGwgfHxcbiAgICAgIG8uZCAhPSBudWxsIHx8XG4gICAgICBvLmUgIT0gbnVsbCB8fFxuICAgICAgby5mICE9IG51bGxcbiAgICApXG4gIH1cblxuICAvLyBsZWZ0IG1hdHJpeCwgcmlnaHQgbWF0cml4LCB0YXJnZXQgbWF0cml4IHdoaWNoIGlzIG92ZXJ3cml0dGVuXG4gIHN0YXRpYyBtYXRyaXhNdWx0aXBseShsLCByLCBvKSB7XG4gICAgLy8gV29yayBvdXQgdGhlIHByb2R1Y3QgZGlyZWN0bHlcbiAgICBjb25zdCBhID0gbC5hICogci5hICsgbC5jICogci5iXG4gICAgY29uc3QgYiA9IGwuYiAqIHIuYSArIGwuZCAqIHIuYlxuICAgIGNvbnN0IGMgPSBsLmEgKiByLmMgKyBsLmMgKiByLmRcbiAgICBjb25zdCBkID0gbC5iICogci5jICsgbC5kICogci5kXG4gICAgY29uc3QgZSA9IGwuZSArIGwuYSAqIHIuZSArIGwuYyAqIHIuZlxuICAgIGNvbnN0IGYgPSBsLmYgKyBsLmIgKiByLmUgKyBsLmQgKiByLmZcblxuICAgIC8vIG1ha2Ugc3VyZSB0byB1c2UgbG9jYWwgdmFyaWFibGVzIGJlY2F1c2UgbC9yIGFuZCBvIGNvdWxkIGJlIHRoZSBzYW1lXG4gICAgby5hID0gYVxuICAgIG8uYiA9IGJcbiAgICBvLmMgPSBjXG4gICAgby5kID0gZFxuICAgIG8uZSA9IGVcbiAgICBvLmYgPSBmXG5cbiAgICByZXR1cm4gb1xuICB9XG5cbiAgYXJvdW5kKGN4LCBjeSwgbWF0cml4KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5hcm91bmRPKGN4LCBjeSwgbWF0cml4KVxuICB9XG5cbiAgLy8gVHJhbnNmb3JtIGFyb3VuZCBhIGNlbnRlciBwb2ludFxuICBhcm91bmRPKGN4LCBjeSwgbWF0cml4KSB7XG4gICAgY29uc3QgZHggPSBjeCB8fCAwXG4gICAgY29uc3QgZHkgPSBjeSB8fCAwXG4gICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlTygtZHgsIC1keSkubG11bHRpcGx5TyhtYXRyaXgpLnRyYW5zbGF0ZU8oZHgsIGR5KVxuICB9XG5cbiAgLy8gQ2xvbmVzIHRoaXMgbWF0cml4XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgTWF0cml4KHRoaXMpXG4gIH1cblxuICAvLyBEZWNvbXBvc2VzIHRoaXMgbWF0cml4IGludG8gaXRzIGFmZmluZSBwYXJhbWV0ZXJzXG4gIGRlY29tcG9zZShjeCA9IDAsIGN5ID0gMCkge1xuICAgIC8vIEdldCB0aGUgcGFyYW1ldGVycyBmcm9tIHRoZSBtYXRyaXhcbiAgICBjb25zdCBhID0gdGhpcy5hXG4gICAgY29uc3QgYiA9IHRoaXMuYlxuICAgIGNvbnN0IGMgPSB0aGlzLmNcbiAgICBjb25zdCBkID0gdGhpcy5kXG4gICAgY29uc3QgZSA9IHRoaXMuZVxuICAgIGNvbnN0IGYgPSB0aGlzLmZcblxuICAgIC8vIEZpZ3VyZSBvdXQgaWYgdGhlIHdpbmRpbmcgZGlyZWN0aW9uIGlzIGNsb2Nrd2lzZSBvciBjb3VudGVyY2xvY2t3aXNlXG4gICAgY29uc3QgZGV0ZXJtaW5hbnQgPSBhICogZCAtIGIgKiBjXG4gICAgY29uc3QgY2N3ID0gZGV0ZXJtaW5hbnQgPiAwID8gMSA6IC0xXG5cbiAgICAvLyBTaW5jZSB3ZSBvbmx5IHNoZWFyIGluIHgsIHdlIGNhbiB1c2UgdGhlIHggYmFzaXMgdG8gZ2V0IHRoZSB4IHNjYWxlXG4gICAgLy8gYW5kIHRoZSByb3RhdGlvbiBvZiB0aGUgcmVzdWx0aW5nIG1hdHJpeFxuICAgIGNvbnN0IHN4ID0gY2N3ICogTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpXG4gICAgY29uc3QgdGhldGFSYWQgPSBNYXRoLmF0YW4yKGNjdyAqIGIsIGNjdyAqIGEpXG4gICAgY29uc3QgdGhldGEgPSAoMTgwIC8gTWF0aC5QSSkgKiB0aGV0YVJhZFxuICAgIGNvbnN0IGN0ID0gTWF0aC5jb3ModGhldGFSYWQpXG4gICAgY29uc3Qgc3QgPSBNYXRoLnNpbih0aGV0YVJhZClcblxuICAgIC8vIFdlIGNhbiB0aGVuIHNvbHZlIHRoZSB5IGJhc2lzIHZlY3RvciBzaW11bHRhbmVvdXNseSB0byBnZXQgdGhlIG90aGVyXG4gICAgLy8gdHdvIGFmZmluZSBwYXJhbWV0ZXJzIGRpcmVjdGx5IGZyb20gdGhlc2UgcGFyYW1ldGVyc1xuICAgIGNvbnN0IGxhbSA9IChhICogYyArIGIgKiBkKSAvIGRldGVybWluYW50XG4gICAgY29uc3Qgc3kgPSAoYyAqIHN4KSAvIChsYW0gKiBhIC0gYikgfHwgKGQgKiBzeCkgLyAobGFtICogYiArIGEpXG5cbiAgICAvLyBVc2UgdGhlIHRyYW5zbGF0aW9uc1xuICAgIGNvbnN0IHR4ID0gZSAtIGN4ICsgY3ggKiBjdCAqIHN4ICsgY3kgKiAobGFtICogY3QgKiBzeCAtIHN0ICogc3kpXG4gICAgY29uc3QgdHkgPSBmIC0gY3kgKyBjeCAqIHN0ICogc3ggKyBjeSAqIChsYW0gKiBzdCAqIHN4ICsgY3QgKiBzeSlcblxuICAgIC8vIENvbnN0cnVjdCB0aGUgZGVjb21wb3NpdGlvbiBhbmQgcmV0dXJuIGl0XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFJldHVybiB0aGUgYWZmaW5lIHBhcmFtZXRlcnNcbiAgICAgIHNjYWxlWDogc3gsXG4gICAgICBzY2FsZVk6IHN5LFxuICAgICAgc2hlYXI6IGxhbSxcbiAgICAgIHJvdGF0ZTogdGhldGEsXG4gICAgICB0cmFuc2xhdGVYOiB0eCxcbiAgICAgIHRyYW5zbGF0ZVk6IHR5LFxuICAgICAgb3JpZ2luWDogY3gsXG4gICAgICBvcmlnaW5ZOiBjeSxcblxuICAgICAgLy8gUmV0dXJuIHRoZSBtYXRyaXggcGFyYW1ldGVyc1xuICAgICAgYTogdGhpcy5hLFxuICAgICAgYjogdGhpcy5iLFxuICAgICAgYzogdGhpcy5jLFxuICAgICAgZDogdGhpcy5kLFxuICAgICAgZTogdGhpcy5lLFxuICAgICAgZjogdGhpcy5mXG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdHdvIG1hdHJpY2VzIGFyZSBlcXVhbFxuICBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAob3RoZXIgPT09IHRoaXMpIHJldHVybiB0cnVlXG4gICAgY29uc3QgY29tcCA9IG5ldyBNYXRyaXgob3RoZXIpXG4gICAgcmV0dXJuIChcbiAgICAgIGNsb3NlRW5vdWdoKHRoaXMuYSwgY29tcC5hKSAmJlxuICAgICAgY2xvc2VFbm91Z2godGhpcy5iLCBjb21wLmIpICYmXG4gICAgICBjbG9zZUVub3VnaCh0aGlzLmMsIGNvbXAuYykgJiZcbiAgICAgIGNsb3NlRW5vdWdoKHRoaXMuZCwgY29tcC5kKSAmJlxuICAgICAgY2xvc2VFbm91Z2godGhpcy5lLCBjb21wLmUpICYmXG4gICAgICBjbG9zZUVub3VnaCh0aGlzLmYsIGNvbXAuZilcbiAgICApXG4gIH1cblxuICAvLyBGbGlwIG1hdHJpeCBvbiB4IG9yIHksIGF0IGEgZ2l2ZW4gb2Zmc2V0XG4gIGZsaXAoYXhpcywgYXJvdW5kKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5mbGlwTyhheGlzLCBhcm91bmQpXG4gIH1cblxuICBmbGlwTyhheGlzLCBhcm91bmQpIHtcbiAgICByZXR1cm4gYXhpcyA9PT0gJ3gnXG4gICAgICA/IHRoaXMuc2NhbGVPKC0xLCAxLCBhcm91bmQsIDApXG4gICAgICA6IGF4aXMgPT09ICd5J1xuICAgICAgICA/IHRoaXMuc2NhbGVPKDEsIC0xLCAwLCBhcm91bmQpXG4gICAgICAgIDogdGhpcy5zY2FsZU8oLTEsIC0xLCBheGlzLCBhcm91bmQgfHwgYXhpcykgLy8gRGVmaW5lIGFuIHgsIHkgZmxpcCBwb2ludFxuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZVxuICBpbml0KHNvdXJjZSkge1xuICAgIGNvbnN0IGJhc2UgPSBNYXRyaXguZnJvbUFycmF5KFsxLCAwLCAwLCAxLCAwLCAwXSlcblxuICAgIC8vIGVuc3VyZSBzb3VyY2UgYXMgb2JqZWN0XG4gICAgc291cmNlID1cbiAgICAgIHNvdXJjZSBpbnN0YW5jZW9mIEVsZW1lbnRcbiAgICAgICAgPyBzb3VyY2UubWF0cml4aWZ5KClcbiAgICAgICAgOiB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJ1xuICAgICAgICAgID8gTWF0cml4LmZyb21BcnJheShzb3VyY2Uuc3BsaXQoZGVsaW1pdGVyKS5tYXAocGFyc2VGbG9hdCkpXG4gICAgICAgICAgOiBBcnJheS5pc0FycmF5KHNvdXJjZSlcbiAgICAgICAgICAgID8gTWF0cml4LmZyb21BcnJheShzb3VyY2UpXG4gICAgICAgICAgICA6IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnICYmIE1hdHJpeC5pc01hdHJpeExpa2Uoc291cmNlKVxuICAgICAgICAgICAgICA/IHNvdXJjZVxuICAgICAgICAgICAgICA6IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgPyBuZXcgTWF0cml4KCkudHJhbnNmb3JtKHNvdXJjZSlcbiAgICAgICAgICAgICAgICA6IGFyZ3VtZW50cy5sZW5ndGggPT09IDZcbiAgICAgICAgICAgICAgICAgID8gTWF0cml4LmZyb21BcnJheShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgICA6IGJhc2VcblxuICAgIC8vIE1lcmdlIHRoZSBzb3VyY2UgbWF0cml4IHdpdGggdGhlIGJhc2UgbWF0cml4XG4gICAgdGhpcy5hID0gc291cmNlLmEgIT0gbnVsbCA/IHNvdXJjZS5hIDogYmFzZS5hXG4gICAgdGhpcy5iID0gc291cmNlLmIgIT0gbnVsbCA/IHNvdXJjZS5iIDogYmFzZS5iXG4gICAgdGhpcy5jID0gc291cmNlLmMgIT0gbnVsbCA/IHNvdXJjZS5jIDogYmFzZS5jXG4gICAgdGhpcy5kID0gc291cmNlLmQgIT0gbnVsbCA/IHNvdXJjZS5kIDogYmFzZS5kXG4gICAgdGhpcy5lID0gc291cmNlLmUgIT0gbnVsbCA/IHNvdXJjZS5lIDogYmFzZS5lXG4gICAgdGhpcy5mID0gc291cmNlLmYgIT0gbnVsbCA/IHNvdXJjZS5mIDogYmFzZS5mXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgaW52ZXJzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmludmVyc2VPKClcbiAgfVxuXG4gIC8vIEludmVyc2VzIG1hdHJpeFxuICBpbnZlcnNlTygpIHtcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgcGFyYW1ldGVycyBvdXQgb2YgdGhlIG1hdHJpeFxuICAgIGNvbnN0IGEgPSB0aGlzLmFcbiAgICBjb25zdCBiID0gdGhpcy5iXG4gICAgY29uc3QgYyA9IHRoaXMuY1xuICAgIGNvbnN0IGQgPSB0aGlzLmRcbiAgICBjb25zdCBlID0gdGhpcy5lXG4gICAgY29uc3QgZiA9IHRoaXMuZlxuXG4gICAgLy8gSW52ZXJ0IHRoZSAyeDIgbWF0cml4IGluIHRoZSB0b3AgbGVmdFxuICAgIGNvbnN0IGRldCA9IGEgKiBkIC0gYiAqIGNcbiAgICBpZiAoIWRldCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52ZXJ0ICcgKyB0aGlzKVxuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSB0b3AgMngyIG1hdHJpeFxuICAgIGNvbnN0IG5hID0gZCAvIGRldFxuICAgIGNvbnN0IG5iID0gLWIgLyBkZXRcbiAgICBjb25zdCBuYyA9IC1jIC8gZGV0XG4gICAgY29uc3QgbmQgPSBhIC8gZGV0XG5cbiAgICAvLyBBcHBseSB0aGUgaW52ZXJ0ZWQgbWF0cml4IHRvIHRoZSB0b3AgcmlnaHRcbiAgICBjb25zdCBuZSA9IC0obmEgKiBlICsgbmMgKiBmKVxuICAgIGNvbnN0IG5mID0gLShuYiAqIGUgKyBuZCAqIGYpXG5cbiAgICAvLyBDb25zdHJ1Y3QgdGhlIGludmVydGVkIG1hdHJpeFxuICAgIHRoaXMuYSA9IG5hXG4gICAgdGhpcy5iID0gbmJcbiAgICB0aGlzLmMgPSBuY1xuICAgIHRoaXMuZCA9IG5kXG4gICAgdGhpcy5lID0gbmVcbiAgICB0aGlzLmYgPSBuZlxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGxtdWx0aXBseShtYXRyaXgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxtdWx0aXBseU8obWF0cml4KVxuICB9XG5cbiAgbG11bHRpcGx5TyhtYXRyaXgpIHtcbiAgICBjb25zdCByID0gdGhpc1xuICAgIGNvbnN0IGwgPSBtYXRyaXggaW5zdGFuY2VvZiBNYXRyaXggPyBtYXRyaXggOiBuZXcgTWF0cml4KG1hdHJpeClcblxuICAgIHJldHVybiBNYXRyaXgubWF0cml4TXVsdGlwbHkobCwgciwgdGhpcylcbiAgfVxuXG4gIC8vIExlZnQgbXVsdGlwbGllcyBieSB0aGUgZ2l2ZW4gbWF0cml4XG4gIG11bHRpcGx5KG1hdHJpeCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkubXVsdGlwbHlPKG1hdHJpeClcbiAgfVxuXG4gIG11bHRpcGx5TyhtYXRyaXgpIHtcbiAgICAvLyBHZXQgdGhlIG1hdHJpY2VzXG4gICAgY29uc3QgbCA9IHRoaXNcbiAgICBjb25zdCByID0gbWF0cml4IGluc3RhbmNlb2YgTWF0cml4ID8gbWF0cml4IDogbmV3IE1hdHJpeChtYXRyaXgpXG5cbiAgICByZXR1cm4gTWF0cml4Lm1hdHJpeE11bHRpcGx5KGwsIHIsIHRoaXMpXG4gIH1cblxuICAvLyBSb3RhdGUgbWF0cml4XG4gIHJvdGF0ZShyLCBjeCwgY3kpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnJvdGF0ZU8ociwgY3gsIGN5KVxuICB9XG5cbiAgcm90YXRlTyhyLCBjeCA9IDAsIGN5ID0gMCkge1xuICAgIC8vIENvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXG4gICAgciA9IHJhZGlhbnMocilcblxuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKHIpXG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4ocilcblxuICAgIGNvbnN0IHsgYSwgYiwgYywgZCwgZSwgZiB9ID0gdGhpc1xuXG4gICAgdGhpcy5hID0gYSAqIGNvcyAtIGIgKiBzaW5cbiAgICB0aGlzLmIgPSBiICogY29zICsgYSAqIHNpblxuICAgIHRoaXMuYyA9IGMgKiBjb3MgLSBkICogc2luXG4gICAgdGhpcy5kID0gZCAqIGNvcyArIGMgKiBzaW5cbiAgICB0aGlzLmUgPSBlICogY29zIC0gZiAqIHNpbiArIGN5ICogc2luIC0gY3ggKiBjb3MgKyBjeFxuICAgIHRoaXMuZiA9IGYgKiBjb3MgKyBlICogc2luIC0gY3ggKiBzaW4gLSBjeSAqIGNvcyArIGN5XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gU2NhbGUgbWF0cml4XG4gIHNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuc2NhbGVPKC4uLmFyZ3VtZW50cylcbiAgfVxuXG4gIHNjYWxlTyh4LCB5ID0geCwgY3ggPSAwLCBjeSA9IDApIHtcbiAgICAvLyBTdXBwb3J0IHVuaWZvcm0gc2NhbGluZ1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBjeSA9IGN4XG4gICAgICBjeCA9IHlcbiAgICAgIHkgPSB4XG4gICAgfVxuXG4gICAgY29uc3QgeyBhLCBiLCBjLCBkLCBlLCBmIH0gPSB0aGlzXG5cbiAgICB0aGlzLmEgPSBhICogeFxuICAgIHRoaXMuYiA9IGIgKiB5XG4gICAgdGhpcy5jID0gYyAqIHhcbiAgICB0aGlzLmQgPSBkICogeVxuICAgIHRoaXMuZSA9IGUgKiB4IC0gY3ggKiB4ICsgY3hcbiAgICB0aGlzLmYgPSBmICogeSAtIGN5ICogeSArIGN5XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gU2hlYXIgbWF0cml4XG4gIHNoZWFyKGEsIGN4LCBjeSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuc2hlYXJPKGEsIGN4LCBjeSlcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBzaGVhck8obHgsIGN4ID0gMCwgY3kgPSAwKSB7XG4gICAgY29uc3QgeyBhLCBiLCBjLCBkLCBlLCBmIH0gPSB0aGlzXG5cbiAgICB0aGlzLmEgPSBhICsgYiAqIGx4XG4gICAgdGhpcy5jID0gYyArIGQgKiBseFxuICAgIHRoaXMuZSA9IGUgKyBmICogbHggLSBjeSAqIGx4XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gU2tldyBNYXRyaXhcbiAgc2tldygpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnNrZXdPKC4uLmFyZ3VtZW50cylcbiAgfVxuXG4gIHNrZXdPKHgsIHkgPSB4LCBjeCA9IDAsIGN5ID0gMCkge1xuICAgIC8vIHN1cHBvcnQgdW5pZm9ybWFsIHNrZXdcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgY3kgPSBjeFxuICAgICAgY3ggPSB5XG4gICAgICB5ID0geFxuICAgIH1cblxuICAgIC8vIENvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXG4gICAgeCA9IHJhZGlhbnMoeClcbiAgICB5ID0gcmFkaWFucyh5KVxuXG4gICAgY29uc3QgbHggPSBNYXRoLnRhbih4KVxuICAgIGNvbnN0IGx5ID0gTWF0aC50YW4oeSlcblxuICAgIGNvbnN0IHsgYSwgYiwgYywgZCwgZSwgZiB9ID0gdGhpc1xuXG4gICAgdGhpcy5hID0gYSArIGIgKiBseFxuICAgIHRoaXMuYiA9IGIgKyBhICogbHlcbiAgICB0aGlzLmMgPSBjICsgZCAqIGx4XG4gICAgdGhpcy5kID0gZCArIGMgKiBseVxuICAgIHRoaXMuZSA9IGUgKyBmICogbHggLSBjeSAqIGx4XG4gICAgdGhpcy5mID0gZiArIGUgKiBseSAtIGN4ICogbHlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBTa2V3WFxuICBza2V3WCh4LCBjeCwgY3kpIHtcbiAgICByZXR1cm4gdGhpcy5za2V3KHgsIDAsIGN4LCBjeSlcbiAgfVxuXG4gIC8vIFNrZXdZXG4gIHNrZXdZKHksIGN4LCBjeSkge1xuICAgIHJldHVybiB0aGlzLnNrZXcoMCwgeSwgY3gsIGN5KVxuICB9XG5cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gW3RoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRoaXMuZCwgdGhpcy5lLCB0aGlzLmZdXG4gIH1cblxuICAvLyBDb252ZXJ0IG1hdHJpeCB0byBzdHJpbmdcbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICdtYXRyaXgoJyArXG4gICAgICB0aGlzLmEgK1xuICAgICAgJywnICtcbiAgICAgIHRoaXMuYiArXG4gICAgICAnLCcgK1xuICAgICAgdGhpcy5jICtcbiAgICAgICcsJyArXG4gICAgICB0aGlzLmQgK1xuICAgICAgJywnICtcbiAgICAgIHRoaXMuZSArXG4gICAgICAnLCcgK1xuICAgICAgdGhpcy5mICtcbiAgICAgICcpJ1xuICAgIClcbiAgfVxuXG4gIC8vIFRyYW5zZm9ybSBhIG1hdHJpeCBpbnRvIGFub3RoZXIgbWF0cml4IGJ5IG1hbmlwdWxhdGluZyB0aGUgc3BhY2VcbiAgdHJhbnNmb3JtKG8pIHtcbiAgICAvLyBDaGVjayBpZiBvIGlzIGEgbWF0cml4IGFuZCB0aGVuIGxlZnQgbXVsdGlwbHkgaXQgZGlyZWN0bHlcbiAgICBpZiAoTWF0cml4LmlzTWF0cml4TGlrZShvKSkge1xuICAgICAgY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeChvKVxuICAgICAgcmV0dXJuIG1hdHJpeC5tdWx0aXBseU8odGhpcylcbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIHByb3Bvc2VkIHRyYW5zZm9ybWF0aW9ucyBhbmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb25zXG4gICAgY29uc3QgdCA9IE1hdHJpeC5mb3JtYXRUcmFuc2Zvcm1zKG8pXG4gICAgY29uc3QgY3VycmVudCA9IHRoaXNcbiAgICBjb25zdCB7IHg6IG94LCB5OiBveSB9ID0gbmV3IFBvaW50KHQub3gsIHQub3kpLnRyYW5zZm9ybShjdXJyZW50KVxuXG4gICAgLy8gQ29uc3RydWN0IHRoZSByZXN1bHRpbmcgbWF0cml4XG4gICAgY29uc3QgdHJhbnNmb3JtZXIgPSBuZXcgTWF0cml4KClcbiAgICAgIC50cmFuc2xhdGVPKHQucngsIHQucnkpXG4gICAgICAubG11bHRpcGx5TyhjdXJyZW50KVxuICAgICAgLnRyYW5zbGF0ZU8oLW94LCAtb3kpXG4gICAgICAuc2NhbGVPKHQuc2NhbGVYLCB0LnNjYWxlWSlcbiAgICAgIC5za2V3Tyh0LnNrZXdYLCB0LnNrZXdZKVxuICAgICAgLnNoZWFyTyh0LnNoZWFyKVxuICAgICAgLnJvdGF0ZU8odC50aGV0YSlcbiAgICAgIC50cmFuc2xhdGVPKG94LCBveSlcblxuICAgIC8vIElmIHdlIHdhbnQgdGhlIG9yaWdpbiBhdCBhIHBhcnRpY3VsYXIgcGxhY2UsIHdlIGZvcmNlIGl0IHRoZXJlXG4gICAgaWYgKGlzRmluaXRlKHQucHgpIHx8IGlzRmluaXRlKHQucHkpKSB7XG4gICAgICBjb25zdCBvcmlnaW4gPSBuZXcgUG9pbnQob3gsIG95KS50cmFuc2Zvcm0odHJhbnNmb3JtZXIpXG4gICAgICAvLyBUT0RPOiBSZXBsYWNlIHQucHggd2l0aCBpc0Zpbml0ZSh0LnB4KVxuICAgICAgLy8gRG9lc24ndCB3b3JrIGJlY2F1c2UgdC5weCBpcyBhbHNvIDAgaWYgaXQgd2Fzbid0IHBhc3NlZFxuICAgICAgY29uc3QgZHggPSBpc0Zpbml0ZSh0LnB4KSA/IHQucHggLSBvcmlnaW4ueCA6IDBcbiAgICAgIGNvbnN0IGR5ID0gaXNGaW5pdGUodC5weSkgPyB0LnB5IC0gb3JpZ2luLnkgOiAwXG4gICAgICB0cmFuc2Zvcm1lci50cmFuc2xhdGVPKGR4LCBkeSlcbiAgICB9XG5cbiAgICAvLyBUcmFuc2xhdGUgbm93IGFmdGVyIHBvc2l0aW9uaW5nXG4gICAgdHJhbnNmb3JtZXIudHJhbnNsYXRlTyh0LnR4LCB0LnR5KVxuICAgIHJldHVybiB0cmFuc2Zvcm1lclxuICB9XG5cbiAgLy8gVHJhbnNsYXRlIG1hdHJpeFxuICB0cmFuc2xhdGUoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkudHJhbnNsYXRlTyh4LCB5KVxuICB9XG5cbiAgdHJhbnNsYXRlTyh4LCB5KSB7XG4gICAgdGhpcy5lICs9IHggfHwgMFxuICAgIHRoaXMuZiArPSB5IHx8IDBcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFsdWVPZigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYTogdGhpcy5hLFxuICAgICAgYjogdGhpcy5iLFxuICAgICAgYzogdGhpcy5jLFxuICAgICAgZDogdGhpcy5kLFxuICAgICAgZTogdGhpcy5lLFxuICAgICAgZjogdGhpcy5mXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjdG0oKSB7XG4gIHJldHVybiBuZXcgTWF0cml4KHRoaXMubm9kZS5nZXRDVE0oKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjcmVlbkNUTSgpIHtcbiAgdHJ5IHtcbiAgICAvKiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzQ0NTM3XG4gICAgICAgVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSBGRiBkb2VzIG5vdCByZXR1cm4gdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgICAgIGZvciB0aGUgaW5uZXIgY29vcmRpbmF0ZSBzeXN0ZW0gd2hlbiBnZXRTY3JlZW5DVE0oKSBpcyBjYWxsZWQgb24gbmVzdGVkIHN2Z3MuXG4gICAgICAgSG93ZXZlciBhbGwgb3RoZXIgQnJvd3NlcnMgZG8gdGhhdCAqL1xuICAgIGlmICh0eXBlb2YgdGhpcy5pc1Jvb3QgPT09ICdmdW5jdGlvbicgJiYgIXRoaXMuaXNSb290KCkpIHtcbiAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLnJlY3QoMSwgMSlcbiAgICAgIGNvbnN0IG0gPSByZWN0Lm5vZGUuZ2V0U2NyZWVuQ1RNKClcbiAgICAgIHJlY3QucmVtb3ZlKClcbiAgICAgIHJldHVybiBuZXcgTWF0cml4KG0pXG4gICAgfVxuICAgIHJldHVybiBuZXcgTWF0cml4KHRoaXMubm9kZS5nZXRTY3JlZW5DVE0oKSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBDYW5ub3QgZ2V0IENUTSBmcm9tIFNWRyBub2RlICR7dGhpcy5ub2RlLm5vZGVOYW1lfS4gSXMgdGhlIGVsZW1lbnQgcmVuZGVyZWQ/YFxuICAgIClcbiAgICByZXR1cm4gbmV3IE1hdHJpeCgpXG4gIH1cbn1cblxucmVnaXN0ZXIoTWF0cml4LCAnTWF0cml4JylcbiIsImltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi8uLi91dGlscy93aW5kb3cuanMnXG5pbXBvcnQgeyBtYWtlSW5zdGFuY2UgfSBmcm9tICcuLi8uLi91dGlscy9hZG9wdGVyLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYXJzZXIoKSB7XG4gIC8vIFJldXNlIGNhY2hlZCBlbGVtZW50IGlmIHBvc3NpYmxlXG4gIGlmICghcGFyc2VyLm5vZGVzKSB7XG4gICAgY29uc3Qgc3ZnID0gbWFrZUluc3RhbmNlKCkuc2l6ZSgyLCAwKVxuICAgIHN2Zy5ub2RlLnN0eWxlLmNzc1RleHQgPSBbXG4gICAgICAnb3BhY2l0eTogMCcsXG4gICAgICAncG9zaXRpb246IGFic29sdXRlJyxcbiAgICAgICdsZWZ0OiAtMTAwJScsXG4gICAgICAndG9wOiAtMTAwJScsXG4gICAgICAnb3ZlcmZsb3c6IGhpZGRlbidcbiAgICBdLmpvaW4oJzsnKVxuXG4gICAgc3ZnLmF0dHIoJ2ZvY3VzYWJsZScsICdmYWxzZScpXG4gICAgc3ZnLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKVxuXG4gICAgY29uc3QgcGF0aCA9IHN2Zy5wYXRoKCkubm9kZVxuXG4gICAgcGFyc2VyLm5vZGVzID0geyBzdmcsIHBhdGggfVxuICB9XG5cbiAgaWYgKCFwYXJzZXIubm9kZXMuc3ZnLm5vZGUucGFyZW50Tm9kZSkge1xuICAgIGNvbnN0IGIgPSBnbG9iYWxzLmRvY3VtZW50LmJvZHkgfHwgZ2xvYmFscy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcbiAgICBwYXJzZXIubm9kZXMuc3ZnLmFkZFRvKGIpXG4gIH1cblxuICByZXR1cm4gcGFyc2VyLm5vZGVzXG59XG4iLCJpbXBvcnQgeyBkZWxpbWl0ZXIgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcmVnZXguanMnXG5pbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vdXRpbHMvd2luZG93LmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXIgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcbmltcG9ydCBNYXRyaXggZnJvbSAnLi9NYXRyaXguanMnXG5pbXBvcnQgUG9pbnQgZnJvbSAnLi9Qb2ludC5qcydcbmltcG9ydCBwYXJzZXIgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3BhcnNlci5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVsbGVkQm94KGJveCkge1xuICByZXR1cm4gIWJveC53aWR0aCAmJiAhYm94LmhlaWdodCAmJiAhYm94LnggJiYgIWJveC55XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkb21Db250YWlucyhub2RlKSB7XG4gIHJldHVybiAoXG4gICAgbm9kZSA9PT0gZ2xvYmFscy5kb2N1bWVudCB8fFxuICAgIChcbiAgICAgIGdsb2JhbHMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zIHx8XG4gICAgICBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAvLyBUaGlzIGlzIElFIC0gaXQgZG9lcyBub3Qgc3VwcG9ydCBjb250YWlucygpIGZvciB0b3AtbGV2ZWwgU1ZHc1xuICAgICAgICB3aGlsZSAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlID09PSBnbG9iYWxzLmRvY3VtZW50XG4gICAgICB9XG4gICAgKS5jYWxsKGdsb2JhbHMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKVxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJveCB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmluaXQoLi4uYXJncylcbiAgfVxuXG4gIGFkZE9mZnNldCgpIHtcbiAgICAvLyBvZmZzZXQgYnkgd2luZG93IHNjcm9sbCBwb3NpdGlvbiwgYmVjYXVzZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgY2hhbmdlcyB3aGVuIHdpbmRvdyBpcyBzY3JvbGxlZFxuICAgIHRoaXMueCArPSBnbG9iYWxzLndpbmRvdy5wYWdlWE9mZnNldFxuICAgIHRoaXMueSArPSBnbG9iYWxzLndpbmRvdy5wYWdlWU9mZnNldFxuICAgIHJldHVybiBuZXcgQm94KHRoaXMpXG4gIH1cblxuICBpbml0KHNvdXJjZSkge1xuICAgIGNvbnN0IGJhc2UgPSBbMCwgMCwgMCwgMF1cbiAgICBzb3VyY2UgPVxuICAgICAgdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBzb3VyY2Uuc3BsaXQoZGVsaW1pdGVyKS5tYXAocGFyc2VGbG9hdClcbiAgICAgICAgOiBBcnJheS5pc0FycmF5KHNvdXJjZSlcbiAgICAgICAgICA/IHNvdXJjZVxuICAgICAgICAgIDogdHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgIHNvdXJjZS5sZWZ0ICE9IG51bGwgPyBzb3VyY2UubGVmdCA6IHNvdXJjZS54LFxuICAgICAgICAgICAgICAgIHNvdXJjZS50b3AgIT0gbnVsbCA/IHNvdXJjZS50b3AgOiBzb3VyY2UueSxcbiAgICAgICAgICAgICAgICBzb3VyY2Uud2lkdGgsXG4gICAgICAgICAgICAgICAgc291cmNlLmhlaWdodFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICA6IGFyZ3VtZW50cy5sZW5ndGggPT09IDRcbiAgICAgICAgICAgICAgPyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICAgICAgICAgICAgOiBiYXNlXG5cbiAgICB0aGlzLnggPSBzb3VyY2VbMF0gfHwgMFxuICAgIHRoaXMueSA9IHNvdXJjZVsxXSB8fCAwXG4gICAgdGhpcy53aWR0aCA9IHRoaXMudyA9IHNvdXJjZVsyXSB8fCAwXG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmggPSBzb3VyY2VbM10gfHwgMFxuXG4gICAgLy8gQWRkIG1vcmUgYm91bmRpbmcgYm94IHByb3BlcnRpZXNcbiAgICB0aGlzLngyID0gdGhpcy54ICsgdGhpcy53XG4gICAgdGhpcy55MiA9IHRoaXMueSArIHRoaXMuaFxuICAgIHRoaXMuY3ggPSB0aGlzLnggKyB0aGlzLncgLyAyXG4gICAgdGhpcy5jeSA9IHRoaXMueSArIHRoaXMuaCAvIDJcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBpc051bGxlZCgpIHtcbiAgICByZXR1cm4gaXNOdWxsZWRCb3godGhpcylcbiAgfVxuXG4gIC8vIE1lcmdlIHJlY3QgYm94IHdpdGggYW5vdGhlciwgcmV0dXJuIGEgbmV3IGluc3RhbmNlXG4gIG1lcmdlKGJveCkge1xuICAgIGNvbnN0IHggPSBNYXRoLm1pbih0aGlzLngsIGJveC54KVxuICAgIGNvbnN0IHkgPSBNYXRoLm1pbih0aGlzLnksIGJveC55KVxuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgYm94LnggKyBib3gud2lkdGgpIC0geFxuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCBib3gueSArIGJveC5oZWlnaHQpIC0geVxuXG4gICAgcmV0dXJuIG5ldyBCb3goeCwgeSwgd2lkdGgsIGhlaWdodClcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIFt0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdXG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy54ICsgJyAnICsgdGhpcy55ICsgJyAnICsgdGhpcy53aWR0aCArICcgJyArIHRoaXMuaGVpZ2h0XG4gIH1cblxuICB0cmFuc2Zvcm0obSkge1xuICAgIGlmICghKG0gaW5zdGFuY2VvZiBNYXRyaXgpKSB7XG4gICAgICBtID0gbmV3IE1hdHJpeChtKVxuICAgIH1cblxuICAgIGxldCB4TWluID0gSW5maW5pdHlcbiAgICBsZXQgeE1heCA9IC1JbmZpbml0eVxuICAgIGxldCB5TWluID0gSW5maW5pdHlcbiAgICBsZXQgeU1heCA9IC1JbmZpbml0eVxuXG4gICAgY29uc3QgcHRzID0gW1xuICAgICAgbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KSxcbiAgICAgIG5ldyBQb2ludCh0aGlzLngyLCB0aGlzLnkpLFxuICAgICAgbmV3IFBvaW50KHRoaXMueCwgdGhpcy55MiksXG4gICAgICBuZXcgUG9pbnQodGhpcy54MiwgdGhpcy55MilcbiAgICBdXG5cbiAgICBwdHMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgcCA9IHAudHJhbnNmb3JtKG0pXG4gICAgICB4TWluID0gTWF0aC5taW4oeE1pbiwgcC54KVxuICAgICAgeE1heCA9IE1hdGgubWF4KHhNYXgsIHAueClcbiAgICAgIHlNaW4gPSBNYXRoLm1pbih5TWluLCBwLnkpXG4gICAgICB5TWF4ID0gTWF0aC5tYXgoeU1heCwgcC55KVxuICAgIH0pXG5cbiAgICByZXR1cm4gbmV3IEJveCh4TWluLCB5TWluLCB4TWF4IC0geE1pbiwgeU1heCAtIHlNaW4pXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Qm94KGVsLCBnZXRCQm94Rm4sIHJldHJ5KSB7XG4gIGxldCBib3hcblxuICB0cnkge1xuICAgIC8vIFRyeSB0byBnZXQgdGhlIGJveCB3aXRoIHRoZSBwcm92aWRlZCBmdW5jdGlvblxuICAgIGJveCA9IGdldEJCb3hGbihlbC5ub2RlKVxuXG4gICAgLy8gSWYgdGhlIGJveCBpcyB3b3J0aGxlc3MgYW5kIG5vdCBldmVuIGluIHRoZSBkb20sIHJldHJ5XG4gICAgLy8gYnkgdGhyb3dpbmcgYW4gZXJyb3IgaGVyZS4uLlxuICAgIGlmIChpc051bGxlZEJveChib3gpICYmICFkb21Db250YWlucyhlbC5ub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50IG5vdCBpbiB0aGUgZG9tJylcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyAuLi4gYW5kIGNhbGxpbmcgdGhlIHJldHJ5IGhhbmRsZXIgaGVyZVxuICAgIGJveCA9IHJldHJ5KGVsKVxuICB9XG5cbiAgcmV0dXJuIGJveFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYmJveCgpIHtcbiAgLy8gRnVuY3Rpb24gdG8gZ2V0IGJib3ggaXMgZ2V0QkJveCgpXG4gIGNvbnN0IGdldEJCb3ggPSAobm9kZSkgPT4gbm9kZS5nZXRCQm94KClcblxuICAvLyBUYWtlIGFsbCBtZWFzdXJlcyBzbyB0aGF0IGEgc3R1cGlkIGJyb3dzZXIgcmVuZGVycyB0aGUgZWxlbWVudFxuICAvLyBzbyB3ZSBjYW4gZ2V0IHRoZSBiYm94IGZyb20gaXQgd2hlbiB3ZSB0cnkgYWdhaW5cbiAgY29uc3QgcmV0cnkgPSAoZWwpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2xvbmUgPSBlbC5jbG9uZSgpLmFkZFRvKHBhcnNlcigpLnN2Zykuc2hvdygpXG4gICAgICBjb25zdCBib3ggPSBjbG9uZS5ub2RlLmdldEJCb3goKVxuICAgICAgY2xvbmUucmVtb3ZlKClcbiAgICAgIHJldHVybiBib3hcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBXZSBnaXZlIHVwLi4uXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBHZXR0aW5nIGJib3ggb2YgZWxlbWVudCBcIiR7XG4gICAgICAgICAgZWwubm9kZS5ub2RlTmFtZVxuICAgICAgICB9XCIgaXMgbm90IHBvc3NpYmxlOiAke2UudG9TdHJpbmcoKX1gXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgY29uc3QgYm94ID0gZ2V0Qm94KHRoaXMsIGdldEJCb3gsIHJldHJ5KVxuICBjb25zdCBiYm94ID0gbmV3IEJveChib3gpXG5cbiAgcmV0dXJuIGJib3hcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJib3goZWwpIHtcbiAgY29uc3QgZ2V0UkJveCA9IChub2RlKSA9PiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gIGNvbnN0IHJldHJ5ID0gKGVsKSA9PiB7XG4gICAgLy8gVGhlcmUgaXMgbm8gcG9pbnQgaW4gdHJ5aW5nIHRyaWNrcyBoZXJlIGJlY2F1c2UgaWYgd2UgaW5zZXJ0IHRoZSBlbGVtZW50IGludG8gdGhlIGRvbSBvdXJzZWx2ZXNcbiAgICAvLyBpdCBvYnZpb3VzbHkgd2lsbCBiZSBhdCB0aGUgd3JvbmcgcG9zaXRpb25cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgR2V0dGluZyByYm94IG9mIGVsZW1lbnQgXCIke2VsLm5vZGUubm9kZU5hbWV9XCIgaXMgbm90IHBvc3NpYmxlYFxuICAgIClcbiAgfVxuXG4gIGNvbnN0IGJveCA9IGdldEJveCh0aGlzLCBnZXRSQm94LCByZXRyeSlcbiAgY29uc3QgcmJveCA9IG5ldyBCb3goYm94KVxuXG4gIC8vIElmIGFuIGVsZW1lbnQgd2FzIHBhc3NlZCwgd2Ugd2FudCB0aGUgYmJveCBpbiB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gb2YgdGhhdCBlbGVtZW50XG4gIGlmIChlbCkge1xuICAgIHJldHVybiByYm94LnRyYW5zZm9ybShlbC5zY3JlZW5DVE0oKS5pbnZlcnNlTygpKVxuICB9XG5cbiAgLy8gRWxzZSB3ZSB3YW50IGl0IGluIGFic29sdXRlIHNjcmVlbiBjb29yZGluYXRlc1xuICAvLyBUaGVyZWZvcmUgd2UgbmVlZCB0byBhZGQgdGhlIHNjcm9sbE9mZnNldFxuICByZXR1cm4gcmJveC5hZGRPZmZzZXQoKVxufVxuXG4vLyBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gcG9pbnQgaXMgaW5zaWRlIHRoZSBib3VuZGluZyBib3hcbmV4cG9ydCBmdW5jdGlvbiBpbnNpZGUoeCwgeSkge1xuICBjb25zdCBib3ggPSB0aGlzLmJib3goKVxuXG4gIHJldHVybiAoXG4gICAgeCA+IGJveC54ICYmIHkgPiBib3gueSAmJiB4IDwgYm94LnggKyBib3gud2lkdGggJiYgeSA8IGJveC55ICsgYm94LmhlaWdodFxuICApXG59XG5cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIHZpZXdib3g6IHtcbiAgICB2aWV3Ym94KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIC8vIGFjdCBhcyBnZXR0ZXJcbiAgICAgIGlmICh4ID09IG51bGwpIHJldHVybiBuZXcgQm94KHRoaXMuYXR0cigndmlld0JveCcpKVxuXG4gICAgICAvLyBhY3QgYXMgc2V0dGVyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCd2aWV3Qm94JywgbmV3IEJveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSlcbiAgICB9LFxuXG4gICAgem9vbShsZXZlbCwgcG9pbnQpIHtcbiAgICAgIC8vIEl0cyBiZXN0IHRvIHJlbHkgb24gdGhlIGF0dHJpYnV0ZXMgaGVyZSBhbmQgaGVyZSBpcyB3aHk6XG4gICAgICAvLyBjbGllbnRYWVo6IERvZXNuJ3Qgd29yayBvbiBub24tcm9vdCBzdmdzIGJlY2F1c2UgdGhleSBkb250IGhhdmUgYSBDU1NCb3ggKHNpbGx5ISlcbiAgICAgIC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdDogRG9lc24ndCB3b3JrIGJlY2F1c2UgQ2hyb21lIGp1c3QgaWdub3JlcyB3aWR0aCBhbmQgaGVpZ2h0IG9mIG5lc3RlZCBzdmdzIGNvbXBsZXRlbHlcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCBtZWFucywgdGhlaXIgY2xpZW50UmVjdCBpcyBhbHdheXMgYXMgYmlnIGFzIHRoZSBjb250ZW50LlxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICBGdXJ0aGVybW9yZSB0aGlzIHNpemUgaXMgaW5jb3JyZWN0IGlmIHRoZSBlbGVtZW50IGlzIGZ1cnRoZXIgdHJhbnNmb3JtZWQgYnkgaXRzIHBhcmVudHNcbiAgICAgIC8vIGNvbXB1dGVkU3R5bGU6IE9ubHkgcmV0dXJucyBtZWFuaW5nZnVsIHZhbHVlcyBpZiBjc3Mgd2FzIHVzZWQgd2l0aCBweC4gV2UgZG9udCBnbyB0aGlzIHJvdXRlIGhlcmUhXG4gICAgICAvLyBnZXRCQm94OiByZXR1cm5zIHRoZSBib3VuZGluZyBib3ggb2YgaXRzIGNvbnRlbnQgLSB0aGF0IGRvZXNuJ3QgaGVscCFcbiAgICAgIGxldCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuYXR0cihbJ3dpZHRoJywgJ2hlaWdodCddKVxuXG4gICAgICAvLyBXaWR0aCBhbmQgaGVpZ2h0IGlzIGEgc3RyaW5nIHdoZW4gYSBudW1iZXIgd2l0aCBhIHVuaXQgaXMgcHJlc2VudCB3aGljaCB3ZSBjYW4ndCB1c2VcbiAgICAgIC8vIFNvIHdlIHRyeSBjbGllbnRYWVpcbiAgICAgIGlmIChcbiAgICAgICAgKCF3aWR0aCAmJiAhaGVpZ2h0KSB8fFxuICAgICAgICB0eXBlb2Ygd2lkdGggPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIHR5cGVvZiBoZWlnaHQgPT09ICdzdHJpbmcnXG4gICAgICApIHtcbiAgICAgICAgd2lkdGggPSB0aGlzLm5vZGUuY2xpZW50V2lkdGhcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5ub2RlLmNsaWVudEhlaWdodFxuICAgICAgfVxuXG4gICAgICAvLyBHaXZpbmcgdXAuLi5cbiAgICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0ltcG9zc2libGUgdG8gZ2V0IGFic29sdXRlIHdpZHRoIGFuZCBoZWlnaHQuIFBsZWFzZSBwcm92aWRlIGFuIGFic29sdXRlIHdpZHRoIGFuZCBoZWlnaHQgYXR0cmlidXRlIG9uIHRoZSB6b29taW5nIGVsZW1lbnQnXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgY29uc3QgdiA9IHRoaXMudmlld2JveCgpXG5cbiAgICAgIGNvbnN0IHpvb21YID0gd2lkdGggLyB2LndpZHRoXG4gICAgICBjb25zdCB6b29tWSA9IGhlaWdodCAvIHYuaGVpZ2h0XG4gICAgICBjb25zdCB6b29tID0gTWF0aC5taW4oem9vbVgsIHpvb21ZKVxuXG4gICAgICBpZiAobGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gem9vbVxuICAgICAgfVxuXG4gICAgICBsZXQgem9vbUFtb3VudCA9IHpvb20gLyBsZXZlbFxuXG4gICAgICAvLyBTZXQgdGhlIHpvb21BbW91bnQgdG8gdGhlIGhpZ2hlc3QgdmFsdWUgd2hpY2ggaXMgc2FmZSB0byBwcm9jZXNzIGFuZCByZWNvdmVyIGZyb21cbiAgICAgIC8vIFRoZSAqIDEwMCBpcyBhIGJpdCBvZiB3aWdnbGUgcm9vbSBmb3IgdGhlIG1hdHJpeCB0cmFuc2Zvcm1hdGlvblxuICAgICAgaWYgKHpvb21BbW91bnQgPT09IEluZmluaXR5KSB6b29tQW1vdW50ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgLyAxMDBcblxuICAgICAgcG9pbnQgPVxuICAgICAgICBwb2ludCB8fCBuZXcgUG9pbnQod2lkdGggLyAyIC8gem9vbVggKyB2LngsIGhlaWdodCAvIDIgLyB6b29tWSArIHYueSlcblxuICAgICAgY29uc3QgYm94ID0gbmV3IEJveCh2KS50cmFuc2Zvcm0oXG4gICAgICAgIG5ldyBNYXRyaXgoeyBzY2FsZTogem9vbUFtb3VudCwgb3JpZ2luOiBwb2ludCB9KVxuICAgICAgKVxuXG4gICAgICByZXR1cm4gdGhpcy52aWV3Ym94KGJveClcbiAgICB9XG4gIH1cbn0pXG5cbnJlZ2lzdGVyKEJveCwgJ0JveCcpXG4iLCJpbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuLy8gaW1wb3J0IHsgc3ViQ2xhc3NBcnJheSB9IGZyb20gJy4vQXJyYXlQb2x5ZmlsbC5qcydcblxuY2xhc3MgTGlzdCBleHRlbmRzIEFycmF5IHtcbiAgY29uc3RydWN0b3IoYXJyID0gW10sIC4uLmFyZ3MpIHtcbiAgICBzdXBlcihhcnIsIC4uLmFyZ3MpXG4gICAgaWYgKHR5cGVvZiBhcnIgPT09ICdudW1iZXInKSByZXR1cm4gdGhpc1xuICAgIHRoaXMubGVuZ3RoID0gMFxuICAgIHRoaXMucHVzaCguLi5hcnIpXG4gIH1cbn1cblxuLyogPSBzdWJDbGFzc0FycmF5KCdMaXN0JywgQXJyYXksIGZ1bmN0aW9uIChhcnIgPSBbXSkge1xuICAvLyBUaGlzIGNhdGNoZXMgdGhlIGNhc2UsIHRoYXQgbmF0aXZlIG1hcCB0cmllcyB0byBjcmVhdGUgYW4gYXJyYXkgd2l0aCBuZXcgQXJyYXkoMSlcbiAgaWYgKHR5cGVvZiBhcnIgPT09ICdudW1iZXInKSByZXR1cm4gdGhpc1xuICB0aGlzLmxlbmd0aCA9IDBcbiAgdGhpcy5wdXNoKC4uLmFycilcbn0pICovXG5cbmV4cG9ydCBkZWZhdWx0IExpc3RcblxuZXh0ZW5kKFtMaXN0XSwge1xuICBlYWNoKGZuT3JNZXRob2ROYW1lLCAuLi5hcmdzKSB7XG4gICAgaWYgKHR5cGVvZiBmbk9yTWV0aG9kTmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMubWFwKChlbCwgaSwgYXJyKSA9PiB7XG4gICAgICAgIHJldHVybiBmbk9yTWV0aG9kTmFtZS5jYWxsKGVsLCBlbCwgaSwgYXJyKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMubWFwKChlbCkgPT4ge1xuICAgICAgICByZXR1cm4gZWxbZm5Pck1ldGhvZE5hbWVdKC4uLmFyZ3MpXG4gICAgICB9KVxuICAgIH1cbiAgfSxcblxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCB0aGlzKVxuICB9XG59KVxuXG5jb25zdCByZXNlcnZlZCA9IFsndG9BcnJheScsICdjb25zdHJ1Y3RvcicsICdlYWNoJ11cblxuTGlzdC5leHRlbmQgPSBmdW5jdGlvbiAobWV0aG9kcykge1xuICBtZXRob2RzID0gbWV0aG9kcy5yZWR1Y2UoKG9iaiwgbmFtZSkgPT4ge1xuICAgIC8vIERvbid0IG92ZXJ3cml0ZSBvd24gbWV0aG9kc1xuICAgIGlmIChyZXNlcnZlZC5pbmNsdWRlcyhuYW1lKSkgcmV0dXJuIG9ialxuXG4gICAgLy8gRG9uJ3QgYWRkIHByaXZhdGUgbWV0aG9kc1xuICAgIGlmIChuYW1lWzBdID09PSAnXycpIHJldHVybiBvYmpcblxuICAgIC8vIEFsbG93IGFjY2VzcyB0byBvcmlnaW5hbCBBcnJheSBtZXRob2RzIHRocm91Z2ggYSBwcmVmaXhcbiAgICBpZiAobmFtZSBpbiBBcnJheS5wcm90b3R5cGUpIHtcbiAgICAgIG9ialsnJCcgKyBuYW1lXSA9IEFycmF5LnByb3RvdHlwZVtuYW1lXVxuICAgIH1cblxuICAgIC8vIFJlbGF5IGV2ZXJ5IGNhbGwgdG8gZWFjaCgpXG4gICAgb2JqW25hbWVdID0gZnVuY3Rpb24gKC4uLmF0dHJzKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKG5hbWUsIC4uLmF0dHJzKVxuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH0sIHt9KVxuXG4gIGV4dGVuZChbTGlzdF0sIG1ldGhvZHMpXG59XG4iLCJpbXBvcnQgeyBhZG9wdCB9IGZyb20gJy4uLy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5pbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vLi4vdXRpbHMvd2luZG93LmpzJ1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi4vLi4vdXRpbHMvdXRpbHMuanMnXG5pbXBvcnQgTGlzdCBmcm9tICcuLi8uLi90eXBlcy9MaXN0LmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiYXNlRmluZChxdWVyeSwgcGFyZW50KSB7XG4gIHJldHVybiBuZXcgTGlzdChcbiAgICBtYXAoKHBhcmVudCB8fCBnbG9iYWxzLmRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBhZG9wdChub2RlKVxuICAgIH0pXG4gIClcbn1cblxuLy8gU2NvcGVkIGZpbmQgbWV0aG9kXG5leHBvcnQgZnVuY3Rpb24gZmluZChxdWVyeSkge1xuICByZXR1cm4gYmFzZUZpbmQocXVlcnksIHRoaXMubm9kZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRPbmUocXVlcnkpIHtcbiAgcmV0dXJuIGFkb3B0KHRoaXMubm9kZS5xdWVyeVNlbGVjdG9yKHF1ZXJ5KSlcbn1cbiIsImltcG9ydCB7IGRlbGltaXRlciB9IGZyb20gJy4vcmVnZXguanMnXG5pbXBvcnQgeyBtYWtlSW5zdGFuY2UgfSBmcm9tICcuLi8uLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4uLy4uL3V0aWxzL3dpbmRvdy5qcydcblxubGV0IGxpc3RlbmVySWQgPSAwXG5leHBvcnQgY29uc3Qgd2luZG93RXZlbnRzID0ge31cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEV2ZW50cyhpbnN0YW5jZSkge1xuICBsZXQgbiA9IGluc3RhbmNlLmdldEV2ZW50SG9sZGVyKClcblxuICAvLyBXZSBkb250IHdhbnQgdG8gc2F2ZSBldmVudHMgaW4gZ2xvYmFsIHNwYWNlXG4gIGlmIChuID09PSBnbG9iYWxzLndpbmRvdykgbiA9IHdpbmRvd0V2ZW50c1xuICBpZiAoIW4uZXZlbnRzKSBuLmV2ZW50cyA9IHt9XG4gIHJldHVybiBuLmV2ZW50c1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlLmdldEV2ZW50VGFyZ2V0KClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyRXZlbnRzKGluc3RhbmNlKSB7XG4gIGxldCBuID0gaW5zdGFuY2UuZ2V0RXZlbnRIb2xkZXIoKVxuICBpZiAobiA9PT0gZ2xvYmFscy53aW5kb3cpIG4gPSB3aW5kb3dFdmVudHNcbiAgaWYgKG4uZXZlbnRzKSBuLmV2ZW50cyA9IHt9XG59XG5cbi8vIEFkZCBldmVudCBiaW5kZXIgaW4gdGhlIFNWRyBuYW1lc3BhY2VcbmV4cG9ydCBmdW5jdGlvbiBvbihub2RlLCBldmVudHMsIGxpc3RlbmVyLCBiaW5kaW5nLCBvcHRpb25zKSB7XG4gIGNvbnN0IGwgPSBsaXN0ZW5lci5iaW5kKGJpbmRpbmcgfHwgbm9kZSlcbiAgY29uc3QgaW5zdGFuY2UgPSBtYWtlSW5zdGFuY2Uobm9kZSlcbiAgY29uc3QgYmFnID0gZ2V0RXZlbnRzKGluc3RhbmNlKVxuICBjb25zdCBuID0gZ2V0RXZlbnRUYXJnZXQoaW5zdGFuY2UpXG5cbiAgLy8gZXZlbnRzIGNhbiBiZSBhbiBhcnJheSBvZiBldmVudHMgb3IgYSBzdHJpbmcgb2YgZXZlbnRzXG4gIGV2ZW50cyA9IEFycmF5LmlzQXJyYXkoZXZlbnRzKSA/IGV2ZW50cyA6IGV2ZW50cy5zcGxpdChkZWxpbWl0ZXIpXG5cbiAgLy8gYWRkIGlkIHRvIGxpc3RlbmVyXG4gIGlmICghbGlzdGVuZXIuX3N2Z2pzTGlzdGVuZXJJZCkge1xuICAgIGxpc3RlbmVyLl9zdmdqc0xpc3RlbmVySWQgPSArK2xpc3RlbmVySWRcbiAgfVxuXG4gIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgIGNvbnN0IGV2ID0gZXZlbnQuc3BsaXQoJy4nKVswXVxuICAgIGNvbnN0IG5zID0gZXZlbnQuc3BsaXQoJy4nKVsxXSB8fCAnKidcblxuICAgIC8vIGVuc3VyZSB2YWxpZCBvYmplY3RcbiAgICBiYWdbZXZdID0gYmFnW2V2XSB8fCB7fVxuICAgIGJhZ1tldl1bbnNdID0gYmFnW2V2XVtuc10gfHwge31cblxuICAgIC8vIHJlZmVyZW5jZSBsaXN0ZW5lclxuICAgIGJhZ1tldl1bbnNdW2xpc3RlbmVyLl9zdmdqc0xpc3RlbmVySWRdID0gbFxuXG4gICAgLy8gYWRkIGxpc3RlbmVyXG4gICAgbi5hZGRFdmVudExpc3RlbmVyKGV2LCBsLCBvcHRpb25zIHx8IGZhbHNlKVxuICB9KVxufVxuXG4vLyBBZGQgZXZlbnQgdW5iaW5kZXIgaW4gdGhlIFNWRyBuYW1lc3BhY2VcbmV4cG9ydCBmdW5jdGlvbiBvZmYobm9kZSwgZXZlbnRzLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICBjb25zdCBpbnN0YW5jZSA9IG1ha2VJbnN0YW5jZShub2RlKVxuICBjb25zdCBiYWcgPSBnZXRFdmVudHMoaW5zdGFuY2UpXG4gIGNvbnN0IG4gPSBnZXRFdmVudFRhcmdldChpbnN0YW5jZSlcblxuICAvLyBsaXN0ZW5lciBjYW4gYmUgYSBmdW5jdGlvbiBvciBhIG51bWJlclxuICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkXG4gICAgaWYgKCFsaXN0ZW5lcikgcmV0dXJuXG4gIH1cblxuICAvLyBldmVudHMgY2FuIGJlIGFuIGFycmF5IG9mIGV2ZW50cyBvciBhIHN0cmluZyBvciB1bmRlZmluZWRcbiAgZXZlbnRzID0gQXJyYXkuaXNBcnJheShldmVudHMpID8gZXZlbnRzIDogKGV2ZW50cyB8fCAnJykuc3BsaXQoZGVsaW1pdGVyKVxuXG4gIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgIGNvbnN0IGV2ID0gZXZlbnQgJiYgZXZlbnQuc3BsaXQoJy4nKVswXVxuICAgIGNvbnN0IG5zID0gZXZlbnQgJiYgZXZlbnQuc3BsaXQoJy4nKVsxXVxuICAgIGxldCBuYW1lc3BhY2UsIGxcblxuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgLy8gcmVtb3ZlIGxpc3RlbmVyIHJlZmVyZW5jZVxuICAgICAgaWYgKGJhZ1tldl0gJiYgYmFnW2V2XVtucyB8fCAnKiddKSB7XG4gICAgICAgIC8vIHJlbW92ZUxpc3RlbmVyXG4gICAgICAgIG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICBldixcbiAgICAgICAgICBiYWdbZXZdW25zIHx8ICcqJ11bbGlzdGVuZXJdLFxuICAgICAgICAgIG9wdGlvbnMgfHwgZmFsc2VcbiAgICAgICAgKVxuXG4gICAgICAgIGRlbGV0ZSBiYWdbZXZdW25zIHx8ICcqJ11bbGlzdGVuZXJdXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChldiAmJiBucykge1xuICAgICAgLy8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIGEgbmFtZXNwYWNlZCBldmVudFxuICAgICAgaWYgKGJhZ1tldl0gJiYgYmFnW2V2XVtuc10pIHtcbiAgICAgICAgZm9yIChsIGluIGJhZ1tldl1bbnNdKSB7XG4gICAgICAgICAgb2ZmKG4sIFtldiwgbnNdLmpvaW4oJy4nKSwgbClcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBiYWdbZXZdW25zXVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobnMpIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmljIG5hbWVzcGFjZVxuICAgICAgZm9yIChldmVudCBpbiBiYWcpIHtcbiAgICAgICAgZm9yIChuYW1lc3BhY2UgaW4gYmFnW2V2ZW50XSkge1xuICAgICAgICAgIGlmIChucyA9PT0gbmFtZXNwYWNlKSB7XG4gICAgICAgICAgICBvZmYobiwgW2V2ZW50LCBuc10uam9pbignLicpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXYpIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciB0aGUgZXZlbnRcbiAgICAgIGlmIChiYWdbZXZdKSB7XG4gICAgICAgIGZvciAobmFtZXNwYWNlIGluIGJhZ1tldl0pIHtcbiAgICAgICAgICBvZmYobiwgW2V2LCBuYW1lc3BhY2VdLmpvaW4oJy4nKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBiYWdbZXZdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIGEgZ2l2ZW4gbm9kZVxuICAgICAgZm9yIChldmVudCBpbiBiYWcpIHtcbiAgICAgICAgb2ZmKG4sIGV2ZW50KVxuICAgICAgfVxuXG4gICAgICBjbGVhckV2ZW50cyhpbnN0YW5jZSlcbiAgICB9XG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwYXRjaChub2RlLCBldmVudCwgZGF0YSwgb3B0aW9ucykge1xuICBjb25zdCBuID0gZ2V0RXZlbnRUYXJnZXQobm9kZSlcblxuICAvLyBEaXNwYXRjaCBldmVudFxuICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBnbG9iYWxzLndpbmRvdy5FdmVudCkge1xuICAgIG4uZGlzcGF0Y2hFdmVudChldmVudClcbiAgfSBlbHNlIHtcbiAgICBldmVudCA9IG5ldyBnbG9iYWxzLndpbmRvdy5DdXN0b21FdmVudChldmVudCwge1xuICAgICAgZGV0YWlsOiBkYXRhLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KVxuICAgIG4uZGlzcGF0Y2hFdmVudChldmVudClcbiAgfVxuICByZXR1cm4gZXZlbnRcbn1cbiIsImltcG9ydCB7IGRpc3BhdGNoLCBvZmYsIG9uIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL2V2ZW50LmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXIgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IEJhc2UgZnJvbSAnLi9CYXNlLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudFRhcmdldCBleHRlbmRzIEJhc2Uge1xuICBhZGRFdmVudExpc3RlbmVyKCkge31cblxuICBkaXNwYXRjaChldmVudCwgZGF0YSwgb3B0aW9ucykge1xuICAgIHJldHVybiBkaXNwYXRjaCh0aGlzLCBldmVudCwgZGF0YSwgb3B0aW9ucylcbiAgfVxuXG4gIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCBiYWcgPSB0aGlzLmdldEV2ZW50SG9sZGVyKCkuZXZlbnRzXG4gICAgaWYgKCFiYWcpIHJldHVybiB0cnVlXG5cbiAgICBjb25zdCBldmVudHMgPSBiYWdbZXZlbnQudHlwZV1cblxuICAgIGZvciAoY29uc3QgaSBpbiBldmVudHMpIHtcbiAgICAgIGZvciAoY29uc3QgaiBpbiBldmVudHNbaV0pIHtcbiAgICAgICAgZXZlbnRzW2ldW2pdKGV2ZW50KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZFxuICB9XG5cbiAgLy8gRmlyZSBnaXZlbiBldmVudFxuICBmaXJlKGV2ZW50LCBkYXRhLCBvcHRpb25zKSB7XG4gICAgdGhpcy5kaXNwYXRjaChldmVudCwgZGF0YSwgb3B0aW9ucylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0RXZlbnRIb2xkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldEV2ZW50VGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBVbmJpbmQgZXZlbnQgZnJvbSBsaXN0ZW5lclxuICBvZmYoZXZlbnQsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgb2ZmKHRoaXMsIGV2ZW50LCBsaXN0ZW5lciwgb3B0aW9ucylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gQmluZCBnaXZlbiBldmVudCB0byBsaXN0ZW5lclxuICBvbihldmVudCwgbGlzdGVuZXIsIGJpbmRpbmcsIG9wdGlvbnMpIHtcbiAgICBvbih0aGlzLCBldmVudCwgbGlzdGVuZXIsIGJpbmRpbmcsIG9wdGlvbnMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoKSB7fVxufVxuXG5yZWdpc3RlcihFdmVudFRhcmdldCwgJ0V2ZW50VGFyZ2V0JylcbiIsImV4cG9ydCBmdW5jdGlvbiBub29wKCkge31cblxuLy8gRGVmYXVsdCBhbmltYXRpb24gdmFsdWVzXG5leHBvcnQgY29uc3QgdGltZWxpbmUgPSB7XG4gIGR1cmF0aW9uOiA0MDAsXG4gIGVhc2U6ICc+JyxcbiAgZGVsYXk6IDBcbn1cblxuLy8gRGVmYXVsdCBhdHRyaWJ1dGUgdmFsdWVzXG5leHBvcnQgY29uc3QgYXR0cnMgPSB7XG4gIC8vIGZpbGwgYW5kIHN0cm9rZVxuICAnZmlsbC1vcGFjaXR5JzogMSxcbiAgJ3N0cm9rZS1vcGFjaXR5JzogMSxcbiAgJ3N0cm9rZS13aWR0aCc6IDAsXG4gICdzdHJva2UtbGluZWpvaW4nOiAnbWl0ZXInLFxuICAnc3Ryb2tlLWxpbmVjYXAnOiAnYnV0dCcsXG4gIGZpbGw6ICcjMDAwMDAwJyxcbiAgc3Ryb2tlOiAnIzAwMDAwMCcsXG4gIG9wYWNpdHk6IDEsXG5cbiAgLy8gcG9zaXRpb25cbiAgeDogMCxcbiAgeTogMCxcbiAgY3g6IDAsXG4gIGN5OiAwLFxuXG4gIC8vIHNpemVcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMCxcblxuICAvLyByYWRpdXNcbiAgcjogMCxcbiAgcng6IDAsXG4gIHJ5OiAwLFxuXG4gIC8vIGdyYWRpZW50XG4gIG9mZnNldDogMCxcbiAgJ3N0b3Atb3BhY2l0eSc6IDEsXG4gICdzdG9wLWNvbG9yJzogJyMwMDAwMDAnLFxuXG4gIC8vIHRleHRcbiAgJ3RleHQtYW5jaG9yJzogJ3N0YXJ0J1xufVxuIiwiaW1wb3J0IHsgZGVsaW1pdGVyIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3JlZ2V4LmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTVkdBcnJheSBleHRlbmRzIEFycmF5IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgdGhpcy5pbml0KC4uLmFyZ3MpXG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcylcbiAgfVxuXG4gIGluaXQoYXJyKSB7XG4gICAgLy8gVGhpcyBjYXRjaGVzIHRoZSBjYXNlLCB0aGF0IG5hdGl2ZSBtYXAgdHJpZXMgdG8gY3JlYXRlIGFuIGFycmF5IHdpdGggbmV3IEFycmF5KDEpXG4gICAgaWYgKHR5cGVvZiBhcnIgPT09ICdudW1iZXInKSByZXR1cm4gdGhpc1xuICAgIHRoaXMubGVuZ3RoID0gMFxuICAgIHRoaXMucHVzaCguLi50aGlzLnBhcnNlKGFycikpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIFBhcnNlIHdoaXRlc3BhY2Ugc2VwYXJhdGVkIHN0cmluZ1xuICBwYXJzZShhcnJheSA9IFtdKSB7XG4gICAgLy8gSWYgYWxyZWFkeSBpcyBhbiBhcnJheSwgbm8gbmVlZCB0byBwYXJzZSBpdFxuICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gYXJyYXlcblxuICAgIHJldHVybiBhcnJheS50cmltKCkuc3BsaXQoZGVsaW1pdGVyKS5tYXAocGFyc2VGbG9hdClcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIHRoaXMpXG4gIH1cblxuICB0b1NldCgpIHtcbiAgICByZXR1cm4gbmV3IFNldCh0aGlzKVxuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuam9pbignICcpXG4gIH1cblxuICAvLyBGbGF0dGVucyB0aGUgYXJyYXkgaWYgbmVlZGVkXG4gIHZhbHVlT2YoKSB7XG4gICAgY29uc3QgcmV0ID0gW11cbiAgICByZXQucHVzaCguLi50aGlzKVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuIiwiaW1wb3J0IHsgbnVtYmVyQW5kVW5pdCB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9yZWdleC5qcydcblxuLy8gTW9kdWxlIGZvciB1bml0IGNvbnZlcnNpb25zXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTVkdOdW1iZXIge1xuICAvLyBJbml0aWFsaXplXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmluaXQoLi4uYXJncylcbiAgfVxuXG4gIGNvbnZlcnQodW5pdCkge1xuICAgIHJldHVybiBuZXcgU1ZHTnVtYmVyKHRoaXMudmFsdWUsIHVuaXQpXG4gIH1cblxuICAvLyBEaXZpZGUgbnVtYmVyXG4gIGRpdmlkZShudW1iZXIpIHtcbiAgICBudW1iZXIgPSBuZXcgU1ZHTnVtYmVyKG51bWJlcilcbiAgICByZXR1cm4gbmV3IFNWR051bWJlcih0aGlzIC8gbnVtYmVyLCB0aGlzLnVuaXQgfHwgbnVtYmVyLnVuaXQpXG4gIH1cblxuICBpbml0KHZhbHVlLCB1bml0KSB7XG4gICAgdW5pdCA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMV0gOiB1bml0XG4gICAgdmFsdWUgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzBdIDogdmFsdWVcblxuICAgIC8vIGluaXRpYWxpemUgZGVmYXVsdHNcbiAgICB0aGlzLnZhbHVlID0gMFxuICAgIHRoaXMudW5pdCA9IHVuaXQgfHwgJydcblxuICAgIC8vIHBhcnNlIHZhbHVlXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIGVuc3VyZSBhIHZhbGlkIG51bWVyaWMgdmFsdWVcbiAgICAgIHRoaXMudmFsdWUgPSBpc05hTih2YWx1ZSlcbiAgICAgICAgPyAwXG4gICAgICAgIDogIWlzRmluaXRlKHZhbHVlKVxuICAgICAgICAgID8gdmFsdWUgPCAwXG4gICAgICAgICAgICA/IC0zLjRlMzhcbiAgICAgICAgICAgIDogKzMuNGUzOFxuICAgICAgICAgIDogdmFsdWVcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHVuaXQgPSB2YWx1ZS5tYXRjaChudW1iZXJBbmRVbml0KVxuXG4gICAgICBpZiAodW5pdCkge1xuICAgICAgICAvLyBtYWtlIHZhbHVlIG51bWVyaWNcbiAgICAgICAgdGhpcy52YWx1ZSA9IHBhcnNlRmxvYXQodW5pdFsxXSlcblxuICAgICAgICAvLyBub3JtYWxpemVcbiAgICAgICAgaWYgKHVuaXRbNV0gPT09ICclJykge1xuICAgICAgICAgIHRoaXMudmFsdWUgLz0gMTAwXG4gICAgICAgIH0gZWxzZSBpZiAodW5pdFs1XSA9PT0gJ3MnKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSAqPSAxMDAwXG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdG9yZSB1bml0XG4gICAgICAgIHRoaXMudW5pdCA9IHVuaXRbNV1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU1ZHTnVtYmVyKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZS52YWx1ZU9mKClcbiAgICAgICAgdGhpcy51bml0ID0gdmFsdWUudW5pdFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBTdWJ0cmFjdCBudW1iZXJcbiAgbWludXMobnVtYmVyKSB7XG4gICAgbnVtYmVyID0gbmV3IFNWR051bWJlcihudW1iZXIpXG4gICAgcmV0dXJuIG5ldyBTVkdOdW1iZXIodGhpcyAtIG51bWJlciwgdGhpcy51bml0IHx8IG51bWJlci51bml0KVxuICB9XG5cbiAgLy8gQWRkIG51bWJlclxuICBwbHVzKG51bWJlcikge1xuICAgIG51bWJlciA9IG5ldyBTVkdOdW1iZXIobnVtYmVyKVxuICAgIHJldHVybiBuZXcgU1ZHTnVtYmVyKHRoaXMgKyBudW1iZXIsIHRoaXMudW5pdCB8fCBudW1iZXIudW5pdClcbiAgfVxuXG4gIC8vIE11bHRpcGx5IG51bWJlclxuICB0aW1lcyhudW1iZXIpIHtcbiAgICBudW1iZXIgPSBuZXcgU1ZHTnVtYmVyKG51bWJlcilcbiAgICByZXR1cm4gbmV3IFNWR051bWJlcih0aGlzICogbnVtYmVyLCB0aGlzLnVuaXQgfHwgbnVtYmVyLnVuaXQpXG4gIH1cblxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiBbdGhpcy52YWx1ZSwgdGhpcy51bml0XVxuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKClcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAoXG4gICAgICAodGhpcy51bml0ID09PSAnJSdcbiAgICAgICAgPyB+fih0aGlzLnZhbHVlICogMWU4KSAvIDFlNlxuICAgICAgICA6IHRoaXMudW5pdCA9PT0gJ3MnXG4gICAgICAgICAgPyB0aGlzLnZhbHVlIC8gMWUzXG4gICAgICAgICAgOiB0aGlzLnZhbHVlKSArIHRoaXMudW5pdFxuICAgIClcbiAgfVxuXG4gIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgfVxufVxuIiwiaW1wb3J0IHsgYXR0cnMgYXMgZGVmYXVsdHMgfSBmcm9tICcuL2RlZmF1bHRzLmpzJ1xuaW1wb3J0IHsgaXNOdW1iZXIgfSBmcm9tICcuL3JlZ2V4LmpzJ1xuaW1wb3J0IENvbG9yIGZyb20gJy4uLy4uL3R5cGVzL0NvbG9yLmpzJ1xuaW1wb3J0IFNWR0FycmF5IGZyb20gJy4uLy4uL3R5cGVzL1NWR0FycmF5LmpzJ1xuaW1wb3J0IFNWR051bWJlciBmcm9tICcuLi8uLi90eXBlcy9TVkdOdW1iZXIuanMnXG5cbmNvbnN0IGNvbG9yQXR0cmlidXRlcyA9IG5ldyBTZXQoW1xuICAnZmlsbCcsXG4gICdzdHJva2UnLFxuICAnY29sb3InLFxuICAnYmdjb2xvcicsXG4gICdzdG9wLWNvbG9yJyxcbiAgJ2Zsb29kLWNvbG9yJyxcbiAgJ2xpZ2h0aW5nLWNvbG9yJ1xuXSlcblxuY29uc3QgaG9va3MgPSBbXVxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyQXR0ckhvb2soZm4pIHtcbiAgaG9va3MucHVzaChmbilcbn1cblxuLy8gU2V0IHN2ZyBlbGVtZW50IGF0dHJpYnV0ZVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXR0cihhdHRyLCB2YWwsIG5zKSB7XG4gIC8vIGFjdCBhcyBmdWxsIGdldHRlclxuICBpZiAoYXR0ciA9PSBudWxsKSB7XG4gICAgLy8gZ2V0IGFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzXG4gICAgYXR0ciA9IHt9XG4gICAgdmFsID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXNcblxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiB2YWwpIHtcbiAgICAgIGF0dHJbbm9kZS5ub2RlTmFtZV0gPSBpc051bWJlci50ZXN0KG5vZGUubm9kZVZhbHVlKVxuICAgICAgICA/IHBhcnNlRmxvYXQobm9kZS5ub2RlVmFsdWUpXG4gICAgICAgIDogbm9kZS5ub2RlVmFsdWVcbiAgICB9XG5cbiAgICByZXR1cm4gYXR0clxuICB9IGVsc2UgaWYgKGF0dHIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIC8vIGxvb3AgdGhyb3VnaCBhcnJheSBhbmQgZ2V0IGFsbCB2YWx1ZXNcbiAgICByZXR1cm4gYXR0ci5yZWR1Y2UoKGxhc3QsIGN1cnIpID0+IHtcbiAgICAgIGxhc3RbY3Vycl0gPSB0aGlzLmF0dHIoY3VycilcbiAgICAgIHJldHVybiBsYXN0XG4gICAgfSwge30pXG4gIH0gZWxzZSBpZiAodHlwZW9mIGF0dHIgPT09ICdvYmplY3QnICYmIGF0dHIuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgIC8vIGFwcGx5IGV2ZXJ5IGF0dHJpYnV0ZSBpbmRpdmlkdWFsbHkgaWYgYW4gb2JqZWN0IGlzIHBhc3NlZFxuICAgIGZvciAodmFsIGluIGF0dHIpIHRoaXMuYXR0cih2YWwsIGF0dHJbdmFsXSlcbiAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAvLyByZW1vdmUgdmFsdWVcbiAgICB0aGlzLm5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHIpXG4gIH0gZWxzZSBpZiAodmFsID09IG51bGwpIHtcbiAgICAvLyBhY3QgYXMgYSBnZXR0ZXIgaWYgdGhlIGZpcnN0IGFuZCBvbmx5IGFyZ3VtZW50IGlzIG5vdCBhbiBvYmplY3RcbiAgICB2YWwgPSB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKGF0dHIpXG4gICAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgICA/IGRlZmF1bHRzW2F0dHJdXG4gICAgICA6IGlzTnVtYmVyLnRlc3QodmFsKVxuICAgICAgICA/IHBhcnNlRmxvYXQodmFsKVxuICAgICAgICA6IHZhbFxuICB9IGVsc2Uge1xuICAgIC8vIExvb3AgdGhyb3VnaCBob29rcyBhbmQgZXhlY3V0ZSB0aGVtIHRvIGNvbnZlcnQgdmFsdWVcbiAgICB2YWwgPSBob29rcy5yZWR1Y2UoKF92YWwsIGhvb2spID0+IHtcbiAgICAgIHJldHVybiBob29rKGF0dHIsIF92YWwsIHRoaXMpXG4gICAgfSwgdmFsKVxuXG4gICAgLy8gZW5zdXJlIGNvcnJlY3QgbnVtZXJpYyB2YWx1ZXMgKGFsc28gYWNjZXB0cyBOYU4gYW5kIEluZmluaXR5KVxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsID0gbmV3IFNWR051bWJlcih2YWwpXG4gICAgfSBlbHNlIGlmIChjb2xvckF0dHJpYnV0ZXMuaGFzKGF0dHIpICYmIENvbG9yLmlzQ29sb3IodmFsKSkge1xuICAgICAgLy8gZW5zdXJlIGZ1bGwgaGV4IGNvbG9yXG4gICAgICB2YWwgPSBuZXcgQ29sb3IodmFsKVxuICAgIH0gZWxzZSBpZiAodmFsLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgLy8gQ2hlY2sgZm9yIHBsYWluIGFycmF5cyBhbmQgcGFyc2UgYXJyYXkgdmFsdWVzXG4gICAgICB2YWwgPSBuZXcgU1ZHQXJyYXkodmFsKVxuICAgIH1cblxuICAgIC8vIGlmIHRoZSBwYXNzZWQgYXR0cmlidXRlIGlzIGxlYWRpbmcuLi5cbiAgICBpZiAoYXR0ciA9PT0gJ2xlYWRpbmcnKSB7XG4gICAgICAvLyAuLi4gY2FsbCB0aGUgbGVhZGluZyBtZXRob2QgaW5zdGVhZFxuICAgICAgaWYgKHRoaXMubGVhZGluZykge1xuICAgICAgICB0aGlzLmxlYWRpbmcodmFsKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzZXQgZ2l2ZW4gYXR0cmlidXRlIG9uIG5vZGVcbiAgICAgIHR5cGVvZiBucyA9PT0gJ3N0cmluZydcbiAgICAgICAgPyB0aGlzLm5vZGUuc2V0QXR0cmlidXRlTlMobnMsIGF0dHIsIHZhbC50b1N0cmluZygpKVxuICAgICAgICA6IHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsLnRvU3RyaW5nKCkpXG4gICAgfVxuXG4gICAgLy8gcmVidWlsZCBpZiByZXF1aXJlZFxuICAgIGlmICh0aGlzLnJlYnVpbGQgJiYgKGF0dHIgPT09ICdmb250LXNpemUnIHx8IGF0dHIgPT09ICd4JykpIHtcbiAgICAgIHRoaXMucmVidWlsZCgpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cbiIsImltcG9ydCB7XG4gIGFkb3B0LFxuICBhc3NpZ25OZXdJZCxcbiAgZWlkLFxuICBleHRlbmQsXG4gIG1ha2VJbnN0YW5jZSxcbiAgY3JlYXRlLFxuICByZWdpc3RlclxufSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgZmluZCwgZmluZE9uZSB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9zZWxlY3Rvci5qcydcbmltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi91dGlscy93aW5kb3cuanMnXG5pbXBvcnQgeyBtYXAgfSBmcm9tICcuLi91dGlscy91dGlscy5qcydcbmltcG9ydCB7IHN2ZywgaHRtbCB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9uYW1lc3BhY2VzLmpzJ1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4uL3R5cGVzL0V2ZW50VGFyZ2V0LmpzJ1xuaW1wb3J0IExpc3QgZnJvbSAnLi4vdHlwZXMvTGlzdC5qcydcbmltcG9ydCBhdHRyIGZyb20gJy4uL21vZHVsZXMvY29yZS9hdHRyLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb20gZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMubm9kZSA9IG5vZGVcbiAgICB0aGlzLnR5cGUgPSBub2RlLm5vZGVOYW1lXG5cbiAgICBpZiAoYXR0cnMgJiYgbm9kZSAhPT0gYXR0cnMpIHtcbiAgICAgIHRoaXMuYXR0cihhdHRycylcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgZ2l2ZW4gZWxlbWVudCBhdCBhIHBvc2l0aW9uXG4gIGFkZChlbGVtZW50LCBpKSB7XG4gICAgZWxlbWVudCA9IG1ha2VJbnN0YW5jZShlbGVtZW50KVxuXG4gICAgLy8gSWYgbm9uLXJvb3Qgc3ZnIG5vZGVzIGFyZSBhZGRlZCB3ZSBoYXZlIHRvIHJlbW92ZSB0aGVpciBuYW1lc3BhY2VzXG4gICAgaWYgKFxuICAgICAgZWxlbWVudC5yZW1vdmVOYW1lc3BhY2UgJiZcbiAgICAgIHRoaXMubm9kZSBpbnN0YW5jZW9mIGdsb2JhbHMud2luZG93LlNWR0VsZW1lbnRcbiAgICApIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlTmFtZXNwYWNlKClcbiAgICB9XG5cbiAgICBpZiAoaSA9PSBudWxsKSB7XG4gICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoZWxlbWVudC5ub2RlKVxuICAgIH0gZWxzZSBpZiAoZWxlbWVudC5ub2RlICE9PSB0aGlzLm5vZGUuY2hpbGROb2Rlc1tpXSkge1xuICAgICAgdGhpcy5ub2RlLmluc2VydEJlZm9yZShlbGVtZW50Lm5vZGUsIHRoaXMubm9kZS5jaGlsZE5vZGVzW2ldKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBBZGQgZWxlbWVudCB0byBnaXZlbiBjb250YWluZXIgYW5kIHJldHVybiBzZWxmXG4gIGFkZFRvKHBhcmVudCwgaSkge1xuICAgIHJldHVybiBtYWtlSW5zdGFuY2UocGFyZW50KS5wdXQodGhpcywgaSlcbiAgfVxuXG4gIC8vIFJldHVybnMgYWxsIGNoaWxkIGVsZW1lbnRzXG4gIGNoaWxkcmVuKCkge1xuICAgIHJldHVybiBuZXcgTGlzdChcbiAgICAgIG1hcCh0aGlzLm5vZGUuY2hpbGRyZW4sIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBhZG9wdChub2RlKVxuICAgICAgfSlcbiAgICApXG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIGVsZW1lbnRzIGluIHRoaXMgY29udGFpbmVyXG4gIGNsZWFyKCkge1xuICAgIC8vIHJlbW92ZSBjaGlsZHJlblxuICAgIHdoaWxlICh0aGlzLm5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICB0aGlzLm5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ub2RlLmxhc3RDaGlsZClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gQ2xvbmUgZWxlbWVudFxuICBjbG9uZShkZWVwID0gdHJ1ZSwgYXNzaWduTmV3SWRzID0gdHJ1ZSkge1xuICAgIC8vIHdyaXRlIGRvbSBkYXRhIHRvIHRoZSBkb20gc28gdGhlIGNsb25lIGNhbiBwaWNrdXAgdGhlIGRhdGFcbiAgICB0aGlzLndyaXRlRGF0YVRvRG9tKClcblxuICAgIC8vIGNsb25lIGVsZW1lbnRcbiAgICBsZXQgbm9kZUNsb25lID0gdGhpcy5ub2RlLmNsb25lTm9kZShkZWVwKVxuICAgIGlmIChhc3NpZ25OZXdJZHMpIHtcbiAgICAgIC8vIGFzc2lnbiBuZXcgaWRcbiAgICAgIG5vZGVDbG9uZSA9IGFzc2lnbk5ld0lkKG5vZGVDbG9uZSlcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKG5vZGVDbG9uZSlcbiAgfVxuXG4gIC8vIEl0ZXJhdGVzIG92ZXIgYWxsIGNoaWxkcmVuIGFuZCBpbnZva2VzIGEgZ2l2ZW4gYmxvY2tcbiAgZWFjaChibG9jaywgZGVlcCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbigpXG4gICAgbGV0IGksIGlsXG5cbiAgICBmb3IgKGkgPSAwLCBpbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGJsb2NrLmFwcGx5KGNoaWxkcmVuW2ldLCBbaSwgY2hpbGRyZW5dKVxuXG4gICAgICBpZiAoZGVlcCkge1xuICAgICAgICBjaGlsZHJlbltpXS5lYWNoKGJsb2NrLCBkZWVwKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBlbGVtZW50KG5vZGVOYW1lLCBhdHRycykge1xuICAgIHJldHVybiB0aGlzLnB1dChuZXcgRG9tKGNyZWF0ZShub2RlTmFtZSksIGF0dHJzKSlcbiAgfVxuXG4gIC8vIEdldCBmaXJzdCBjaGlsZFxuICBmaXJzdCgpIHtcbiAgICByZXR1cm4gYWRvcHQodGhpcy5ub2RlLmZpcnN0Q2hpbGQpXG4gIH1cblxuICAvLyBHZXQgYSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxuICBnZXQoaSkge1xuICAgIHJldHVybiBhZG9wdCh0aGlzLm5vZGUuY2hpbGROb2Rlc1tpXSlcbiAgfVxuXG4gIGdldEV2ZW50SG9sZGVyKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVcbiAgfVxuXG4gIGdldEV2ZW50VGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVcbiAgfVxuXG4gIC8vIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBhIGNoaWxkXG4gIGhhcyhlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXgoZWxlbWVudCkgPj0gMFxuICB9XG5cbiAgaHRtbChodG1sT3JGbiwgb3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIHRoaXMueG1sKGh0bWxPckZuLCBvdXRlckhUTUwsIGh0bWwpXG4gIH1cblxuICAvLyBHZXQgLyBzZXQgaWRcbiAgaWQoaWQpIHtcbiAgICAvLyBnZW5lcmF0ZSBuZXcgaWQgaWYgbm8gaWQgc2V0XG4gICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcgJiYgIXRoaXMubm9kZS5pZCkge1xuICAgICAgdGhpcy5ub2RlLmlkID0gZWlkKHRoaXMudHlwZSlcbiAgICB9XG5cbiAgICAvLyBkb24ndCBzZXQgZGlyZWN0bHkgd2l0aCB0aGlzLm5vZGUuaWQgdG8gbWFrZSBgbnVsbGAgd29yayBjb3JyZWN0bHlcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdpZCcsIGlkKVxuICB9XG5cbiAgLy8gR2V0cyBpbmRleCBvZiBnaXZlbiBlbGVtZW50XG4gIGluZGV4KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gW10uc2xpY2UuY2FsbCh0aGlzLm5vZGUuY2hpbGROb2RlcykuaW5kZXhPZihlbGVtZW50Lm5vZGUpXG4gIH1cblxuICAvLyBHZXQgdGhlIGxhc3QgY2hpbGRcbiAgbGFzdCgpIHtcbiAgICByZXR1cm4gYWRvcHQodGhpcy5ub2RlLmxhc3RDaGlsZClcbiAgfVxuXG4gIC8vIG1hdGNoZXMgdGhlIGVsZW1lbnQgdnMgYSBjc3Mgc2VsZWN0b3JcbiAgbWF0Y2hlcyhzZWxlY3Rvcikge1xuICAgIGNvbnN0IGVsID0gdGhpcy5ub2RlXG4gICAgY29uc3QgbWF0Y2hlciA9XG4gICAgICBlbC5tYXRjaGVzIHx8XG4gICAgICBlbC5tYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgIGVsLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICBlbC5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgIGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgZWwub01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgbnVsbFxuICAgIHJldHVybiBtYXRjaGVyICYmIG1hdGNoZXIuY2FsbChlbCwgc2VsZWN0b3IpXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBwYXJlbnQgZWxlbWVudCBpbnN0YW5jZVxuICBwYXJlbnQodHlwZSkge1xuICAgIGxldCBwYXJlbnQgPSB0aGlzXG5cbiAgICAvLyBjaGVjayBmb3IgcGFyZW50XG4gICAgaWYgKCFwYXJlbnQubm9kZS5wYXJlbnROb2RlKSByZXR1cm4gbnVsbFxuXG4gICAgLy8gZ2V0IHBhcmVudCBlbGVtZW50XG4gICAgcGFyZW50ID0gYWRvcHQocGFyZW50Lm5vZGUucGFyZW50Tm9kZSlcblxuICAgIGlmICghdHlwZSkgcmV0dXJuIHBhcmVudFxuXG4gICAgLy8gbG9vcCB0aHJvdWdoIGFuY2VzdG9ycyBpZiB0eXBlIGlzIGdpdmVuXG4gICAgZG8ge1xuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnQubWF0Y2hlcyh0eXBlKSA6IHBhcmVudCBpbnN0YW5jZW9mIHR5cGVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIHBhcmVudFxuICAgIH0gd2hpbGUgKChwYXJlbnQgPSBhZG9wdChwYXJlbnQubm9kZS5wYXJlbnROb2RlKSkpXG5cbiAgICByZXR1cm4gcGFyZW50XG4gIH1cblxuICAvLyBCYXNpY2FsbHkgZG9lcyB0aGUgc2FtZSBhcyBgYWRkKClgIGJ1dCByZXR1cm5zIHRoZSBhZGRlZCBlbGVtZW50IGluc3RlYWRcbiAgcHV0KGVsZW1lbnQsIGkpIHtcbiAgICBlbGVtZW50ID0gbWFrZUluc3RhbmNlKGVsZW1lbnQpXG4gICAgdGhpcy5hZGQoZWxlbWVudCwgaSlcbiAgICByZXR1cm4gZWxlbWVudFxuICB9XG5cbiAgLy8gQWRkIGVsZW1lbnQgdG8gZ2l2ZW4gY29udGFpbmVyIGFuZCByZXR1cm4gY29udGFpbmVyXG4gIHB1dEluKHBhcmVudCwgaSkge1xuICAgIHJldHVybiBtYWtlSW5zdGFuY2UocGFyZW50KS5hZGQodGhpcywgaSlcbiAgfVxuXG4gIC8vIFJlbW92ZSBlbGVtZW50XG4gIHJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQoKSkge1xuICAgICAgdGhpcy5wYXJlbnQoKS5yZW1vdmVFbGVtZW50KHRoaXMpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIFJlbW92ZSBhIGdpdmVuIGNoaWxkXG4gIHJlbW92ZUVsZW1lbnQoZWxlbWVudCkge1xuICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZChlbGVtZW50Lm5vZGUpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gUmVwbGFjZSB0aGlzIHdpdGggZWxlbWVudFxuICByZXBsYWNlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID0gbWFrZUluc3RhbmNlKGVsZW1lbnQpXG5cbiAgICBpZiAodGhpcy5ub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMubm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChlbGVtZW50Lm5vZGUsIHRoaXMubm9kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudFxuICB9XG5cbiAgcm91bmQocHJlY2lzaW9uID0gMiwgbWFwID0gbnVsbCkge1xuICAgIGNvbnN0IGZhY3RvciA9IDEwICoqIHByZWNpc2lvblxuICAgIGNvbnN0IGF0dHJzID0gdGhpcy5hdHRyKG1hcClcblxuICAgIGZvciAoY29uc3QgaSBpbiBhdHRycykge1xuICAgICAgaWYgKHR5cGVvZiBhdHRyc1tpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYXR0cnNbaV0gPSBNYXRoLnJvdW5kKGF0dHJzW2ldICogZmFjdG9yKSAvIGZhY3RvclxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYXR0cihhdHRycylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSW1wb3J0IC8gRXhwb3J0IHJhdyBzdmdcbiAgc3ZnKHN2Z09yRm4sIG91dGVyU1ZHKSB7XG4gICAgcmV0dXJuIHRoaXMueG1sKHN2Z09yRm4sIG91dGVyU1ZHLCBzdmcpXG4gIH1cblxuICAvLyBSZXR1cm4gaWQgb24gc3RyaW5nIGNvbnZlcnNpb25cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWQoKVxuICB9XG5cbiAgd29yZHModGV4dCkge1xuICAgIC8vIFRoaXMgaXMgZmFzdGVyIHRoYW4gcmVtb3ZpbmcgYWxsIGNoaWxkcmVuIGFuZCBhZGRpbmcgYSBuZXcgb25lXG4gICAgdGhpcy5ub2RlLnRleHRDb250ZW50ID0gdGV4dFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB3cmFwKG5vZGUpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudCgpXG5cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkVG8obm9kZSlcbiAgICB9XG5cbiAgICBjb25zdCBwb3NpdGlvbiA9IHBhcmVudC5pbmRleCh0aGlzKVxuICAgIHJldHVybiBwYXJlbnQucHV0KG5vZGUsIHBvc2l0aW9uKS5wdXQodGhpcylcbiAgfVxuXG4gIC8vIHdyaXRlIHN2Z2pzIGRhdGEgdG8gdGhlIGRvbVxuICB3cml0ZURhdGFUb0RvbSgpIHtcbiAgICAvLyBkdW1wIHZhcmlhYmxlcyByZWN1cnNpdmVseVxuICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLndyaXRlRGF0YVRvRG9tKClcbiAgICB9KVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEltcG9ydCAvIEV4cG9ydCByYXcgc3ZnXG4gIHhtbCh4bWxPckZuLCBvdXRlclhNTCwgbnMpIHtcbiAgICBpZiAodHlwZW9mIHhtbE9yRm4gPT09ICdib29sZWFuJykge1xuICAgICAgbnMgPSBvdXRlclhNTFxuICAgICAgb3V0ZXJYTUwgPSB4bWxPckZuXG4gICAgICB4bWxPckZuID0gbnVsbFxuICAgIH1cblxuICAgIC8vIGFjdCBhcyBnZXR0ZXIgaWYgbm8gc3ZnIHN0cmluZyBpcyBnaXZlblxuICAgIGlmICh4bWxPckZuID09IG51bGwgfHwgdHlwZW9mIHhtbE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFRoZSBkZWZhdWx0IGZvciBleHBvcnRzIGlzLCB0aGF0IHRoZSBvdXRlck5vZGUgaXMgaW5jbHVkZWRcbiAgICAgIG91dGVyWE1MID0gb3V0ZXJYTUwgPT0gbnVsbCA/IHRydWUgOiBvdXRlclhNTFxuXG4gICAgICAvLyB3cml0ZSBzdmdqcyBkYXRhIHRvIHRoZSBkb21cbiAgICAgIHRoaXMud3JpdGVEYXRhVG9Eb20oKVxuICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzXG5cbiAgICAgIC8vIEFuIGV4cG9ydCBtb2RpZmllciB3YXMgcGFzc2VkXG4gICAgICBpZiAoeG1sT3JGbiAhPSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnQgPSBhZG9wdChjdXJyZW50Lm5vZGUuY2xvbmVOb2RlKHRydWUpKVxuXG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHdhbnRzIG91dGVySFRNTCB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhpcyBub2RlLCB0b29cbiAgICAgICAgaWYgKG91dGVyWE1MKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0geG1sT3JGbihjdXJyZW50KVxuICAgICAgICAgIGN1cnJlbnQgPSByZXN1bHQgfHwgY3VycmVudFxuXG4gICAgICAgICAgLy8gVGhlIHVzZXIgZG9lcyBub3Qgd2FudCB0aGlzIG5vZGU/IFdlbGwsIHRoZW4gaGUgZ2V0cyBub3RoaW5nXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHJldHVybiAnJ1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVlcCBsb29wIHRocm91Z2ggYWxsIGNoaWxkcmVuIGFuZCBhcHBseSBtb2RpZmllclxuICAgICAgICBjdXJyZW50LmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHhtbE9yRm4odGhpcylcbiAgICAgICAgICBjb25zdCBfdGhpcyA9IHJlc3VsdCB8fCB0aGlzXG5cbiAgICAgICAgICAvLyBJZiBtb2RpZmllciByZXR1cm5zIGZhbHNlLCBkaXNjYXJkIG5vZGVcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoKVxuXG4gICAgICAgICAgICAvLyBJZiBtb2RpZmllciByZXR1cm5zIG5ldyBub2RlLCB1c2UgaXRcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCAmJiB0aGlzICE9PSBfdGhpcykge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlKF90aGlzKVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSlcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIG91dGVyIG9yIGlubmVyIGNvbnRlbnRcbiAgICAgIHJldHVybiBvdXRlclhNTCA/IGN1cnJlbnQubm9kZS5vdXRlckhUTUwgOiBjdXJyZW50Lm5vZGUuaW5uZXJIVE1MXG4gICAgfVxuXG4gICAgLy8gQWN0IGFzIHNldHRlciBpZiB3ZSBnb3QgYSBzdHJpbmdcblxuICAgIC8vIFRoZSBkZWZhdWx0IGZvciBpbXBvcnQgaXMsIHRoYXQgdGhlIGN1cnJlbnQgbm9kZSBpcyBub3QgcmVwbGFjZWRcbiAgICBvdXRlclhNTCA9IG91dGVyWE1MID09IG51bGwgPyBmYWxzZSA6IG91dGVyWE1MXG5cbiAgICAvLyBDcmVhdGUgdGVtcG9yYXJ5IGhvbGRlclxuICAgIGNvbnN0IHdlbGwgPSBjcmVhdGUoJ3dyYXBwZXInLCBucylcbiAgICBjb25zdCBmcmFnbWVudCA9IGdsb2JhbHMuZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cbiAgICAvLyBEdW1wIHJhdyBzdmdcbiAgICB3ZWxsLmlubmVySFRNTCA9IHhtbE9yRm5cblxuICAgIC8vIFRyYW5zcGxhbnQgbm9kZXMgaW50byB0aGUgZnJhZ21lbnRcbiAgICBmb3IgKGxldCBsZW4gPSB3ZWxsLmNoaWxkcmVuLmxlbmd0aDsgbGVuLS07ICkge1xuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQod2VsbC5maXJzdEVsZW1lbnRDaGlsZClcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudCgpXG5cbiAgICAvLyBBZGQgdGhlIHdob2xlIGZyYWdtZW50IGF0IG9uY2VcbiAgICByZXR1cm4gb3V0ZXJYTUwgPyB0aGlzLnJlcGxhY2UoZnJhZ21lbnQpICYmIHBhcmVudCA6IHRoaXMuYWRkKGZyYWdtZW50KVxuICB9XG59XG5cbmV4dGVuZChEb20sIHsgYXR0ciwgZmluZCwgZmluZE9uZSB9KVxucmVnaXN0ZXIoRG9tLCAnRG9tJylcbiIsImltcG9ydCB7IGJib3gsIHJib3gsIGluc2lkZSB9IGZyb20gJy4uL3R5cGVzL0JveC5qcydcbmltcG9ydCB7IGN0bSwgc2NyZWVuQ1RNIH0gZnJvbSAnLi4vdHlwZXMvTWF0cml4LmpzJ1xuaW1wb3J0IHtcbiAgZXh0ZW5kLFxuICBnZXRDbGFzcyxcbiAgbWFrZUluc3RhbmNlLFxuICByZWdpc3RlcixcbiAgcm9vdFxufSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4uL3V0aWxzL3dpbmRvdy5qcydcbmltcG9ydCB7IHBvaW50IH0gZnJvbSAnLi4vdHlwZXMvUG9pbnQuanMnXG5pbXBvcnQgeyBwcm9wb3J0aW9uYWxTaXplLCB3cml0ZURhdGFUb0RvbSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLmpzJ1xuaW1wb3J0IHsgcmVmZXJlbmNlIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3JlZ2V4LmpzJ1xuaW1wb3J0IERvbSBmcm9tICcuL0RvbS5qcydcbmltcG9ydCBMaXN0IGZyb20gJy4uL3R5cGVzL0xpc3QuanMnXG5pbXBvcnQgU1ZHTnVtYmVyIGZyb20gJy4uL3R5cGVzL1NWR051bWJlci5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWxlbWVudCBleHRlbmRzIERvbSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzKSB7XG4gICAgc3VwZXIobm9kZSwgYXR0cnMpXG5cbiAgICAvLyBpbml0aWFsaXplIGRhdGEgb2JqZWN0XG4gICAgdGhpcy5kb20gPSB7fVxuXG4gICAgLy8gY3JlYXRlIGNpcmN1bGFyIHJlZmVyZW5jZVxuICAgIHRoaXMubm9kZS5pbnN0YW5jZSA9IHRoaXNcblxuICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1zdmdqcycpIHx8IG5vZGUuaGFzQXR0cmlidXRlKCdzdmdqczpkYXRhJykpIHtcbiAgICAgIC8vIHB1bGwgc3ZnanMgZGF0YSBmcm9tIHRoZSBkb20gKGdldEF0dHJpYnV0ZU5TIGRvZXNuJ3Qgd29yayBpbiBodG1sNSlcbiAgICAgIHRoaXMuc2V0RGF0YShcbiAgICAgICAgSlNPTi5wYXJzZShub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1zdmdqcycpKSA/P1xuICAgICAgICAgIEpTT04ucGFyc2Uobm9kZS5nZXRBdHRyaWJ1dGUoJ3N2Z2pzOmRhdGEnKSkgPz9cbiAgICAgICAgICB7fVxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8vIE1vdmUgZWxlbWVudCBieSBpdHMgY2VudGVyXG4gIGNlbnRlcih4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuY3goeCkuY3koeSlcbiAgfVxuXG4gIC8vIE1vdmUgYnkgY2VudGVyIG92ZXIgeC1heGlzXG4gIGN4KHgpIHtcbiAgICByZXR1cm4geCA9PSBudWxsXG4gICAgICA/IHRoaXMueCgpICsgdGhpcy53aWR0aCgpIC8gMlxuICAgICAgOiB0aGlzLngoeCAtIHRoaXMud2lkdGgoKSAvIDIpXG4gIH1cblxuICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHktYXhpc1xuICBjeSh5KSB7XG4gICAgcmV0dXJuIHkgPT0gbnVsbFxuICAgICAgPyB0aGlzLnkoKSArIHRoaXMuaGVpZ2h0KCkgLyAyXG4gICAgICA6IHRoaXMueSh5IC0gdGhpcy5oZWlnaHQoKSAvIDIpXG4gIH1cblxuICAvLyBHZXQgZGVmc1xuICBkZWZzKCkge1xuICAgIGNvbnN0IHJvb3QgPSB0aGlzLnJvb3QoKVxuICAgIHJldHVybiByb290ICYmIHJvb3QuZGVmcygpXG4gIH1cblxuICAvLyBSZWxhdGl2ZSBtb3ZlIG92ZXIgeCBhbmQgeSBheGVzXG4gIGRtb3ZlKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5keCh4KS5keSh5KVxuICB9XG5cbiAgLy8gUmVsYXRpdmUgbW92ZSBvdmVyIHggYXhpc1xuICBkeCh4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLngobmV3IFNWR051bWJlcih4KS5wbHVzKHRoaXMueCgpKSlcbiAgfVxuXG4gIC8vIFJlbGF0aXZlIG1vdmUgb3ZlciB5IGF4aXNcbiAgZHkoeSA9IDApIHtcbiAgICByZXR1cm4gdGhpcy55KG5ldyBTVkdOdW1iZXIoeSkucGx1cyh0aGlzLnkoKSkpXG4gIH1cblxuICBnZXRFdmVudEhvbGRlcigpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XG4gIGhlaWdodChoZWlnaHQpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpXG4gIH1cblxuICAvLyBNb3ZlIGVsZW1lbnQgdG8gZ2l2ZW4geCBhbmQgeSB2YWx1ZXNcbiAgbW92ZSh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMueCh4KS55KHkpXG4gIH1cblxuICAvLyByZXR1cm4gYXJyYXkgb2YgYWxsIGFuY2VzdG9ycyBvZiBnaXZlbiB0eXBlIHVwIHRvIHRoZSByb290IHN2Z1xuICBwYXJlbnRzKHVudGlsID0gdGhpcy5yb290KCkpIHtcbiAgICBjb25zdCBpc1NlbGVjdG9yID0gdHlwZW9mIHVudGlsID09PSAnc3RyaW5nJ1xuICAgIGlmICghaXNTZWxlY3Rvcikge1xuICAgICAgdW50aWwgPSBtYWtlSW5zdGFuY2UodW50aWwpXG4gICAgfVxuICAgIGNvbnN0IHBhcmVudHMgPSBuZXcgTGlzdCgpXG4gICAgbGV0IHBhcmVudCA9IHRoaXNcblxuICAgIHdoaWxlIChcbiAgICAgIChwYXJlbnQgPSBwYXJlbnQucGFyZW50KCkpICYmXG4gICAgICBwYXJlbnQubm9kZSAhPT0gZ2xvYmFscy5kb2N1bWVudCAmJlxuICAgICAgcGFyZW50Lm5vZGVOYW1lICE9PSAnI2RvY3VtZW50LWZyYWdtZW50J1xuICAgICkge1xuICAgICAgcGFyZW50cy5wdXNoKHBhcmVudClcblxuICAgICAgaWYgKCFpc1NlbGVjdG9yICYmIHBhcmVudC5ub2RlID09PSB1bnRpbC5ub2RlKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAoaXNTZWxlY3RvciAmJiBwYXJlbnQubWF0Y2hlcyh1bnRpbCkpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQubm9kZSA9PT0gdGhpcy5yb290KCkubm9kZSkge1xuICAgICAgICAvLyBXZSB3b3JrZWQgb3VyIHdheSB0byB0aGUgcm9vdCBhbmQgZGlkbid0IG1hdGNoIGB1bnRpbGBcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50c1xuICB9XG5cbiAgLy8gR2V0IHJlZmVyZW5jZWQgZWxlbWVudCBmb3JtIGF0dHJpYnV0ZSB2YWx1ZVxuICByZWZlcmVuY2UoYXR0cikge1xuICAgIGF0dHIgPSB0aGlzLmF0dHIoYXR0cilcbiAgICBpZiAoIWF0dHIpIHJldHVybiBudWxsXG5cbiAgICBjb25zdCBtID0gKGF0dHIgKyAnJykubWF0Y2gocmVmZXJlbmNlKVxuICAgIHJldHVybiBtID8gbWFrZUluc3RhbmNlKG1bMV0pIDogbnVsbFxuICB9XG5cbiAgLy8gR2V0IHBhcmVudCBkb2N1bWVudFxuICByb290KCkge1xuICAgIGNvbnN0IHAgPSB0aGlzLnBhcmVudChnZXRDbGFzcyhyb290KSlcbiAgICByZXR1cm4gcCAmJiBwLnJvb3QoKVxuICB9XG5cbiAgLy8gc2V0IGdpdmVuIGRhdGEgdG8gdGhlIGVsZW1lbnRzIGRhdGEgcHJvcGVydHlcbiAgc2V0RGF0YShvKSB7XG4gICAgdGhpcy5kb20gPSBvXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIFNldCBlbGVtZW50IHNpemUgdG8gZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuICBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0KVxuXG4gICAgcmV0dXJuIHRoaXMud2lkdGgobmV3IFNWR051bWJlcihwLndpZHRoKSkuaGVpZ2h0KG5ldyBTVkdOdW1iZXIocC5oZWlnaHQpKVxuICB9XG5cbiAgLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcbiAgd2lkdGgod2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd3aWR0aCcsIHdpZHRoKVxuICB9XG5cbiAgLy8gd3JpdGUgc3ZnanMgZGF0YSB0byB0aGUgZG9tXG4gIHdyaXRlRGF0YVRvRG9tKCkge1xuICAgIHdyaXRlRGF0YVRvRG9tKHRoaXMsIHRoaXMuZG9tKVxuICAgIHJldHVybiBzdXBlci53cml0ZURhdGFUb0RvbSgpXG4gIH1cblxuICAvLyBNb3ZlIG92ZXIgeC1heGlzXG4gIHgoeCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ3gnLCB4KVxuICB9XG5cbiAgLy8gTW92ZSBvdmVyIHktYXhpc1xuICB5KHkpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd5JywgeSlcbiAgfVxufVxuXG5leHRlbmQoRWxlbWVudCwge1xuICBiYm94LFxuICByYm94LFxuICBpbnNpZGUsXG4gIHBvaW50LFxuICBjdG0sXG4gIHNjcmVlbkNUTVxufSlcblxucmVnaXN0ZXIoRWxlbWVudCwgJ0VsZW1lbnQnKVxuIiwiaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vLi4vdXRpbHMvbWV0aG9kcy5qcydcbmltcG9ydCBDb2xvciBmcm9tICcuLi8uLi90eXBlcy9Db2xvci5qcydcbmltcG9ydCBFbGVtZW50IGZyb20gJy4uLy4uL2VsZW1lbnRzL0VsZW1lbnQuanMnXG5pbXBvcnQgTWF0cml4IGZyb20gJy4uLy4uL3R5cGVzL01hdHJpeC5qcydcbmltcG9ydCBQb2ludCBmcm9tICcuLi8uLi90eXBlcy9Qb2ludC5qcydcbmltcG9ydCBTVkdOdW1iZXIgZnJvbSAnLi4vLi4vdHlwZXMvU1ZHTnVtYmVyLmpzJ1xuXG4vLyBEZWZpbmUgbGlzdCBvZiBhdmFpbGFibGUgYXR0cmlidXRlcyBmb3Igc3Ryb2tlIGFuZCBmaWxsXG5jb25zdCBzdWdhciA9IHtcbiAgc3Ryb2tlOiBbXG4gICAgJ2NvbG9yJyxcbiAgICAnd2lkdGgnLFxuICAgICdvcGFjaXR5JyxcbiAgICAnbGluZWNhcCcsXG4gICAgJ2xpbmVqb2luJyxcbiAgICAnbWl0ZXJsaW1pdCcsXG4gICAgJ2Rhc2hhcnJheScsXG4gICAgJ2Rhc2hvZmZzZXQnXG4gIF0sXG4gIGZpbGw6IFsnY29sb3InLCAnb3BhY2l0eScsICdydWxlJ10sXG4gIHByZWZpeDogZnVuY3Rpb24gKHQsIGEpIHtcbiAgICByZXR1cm4gYSA9PT0gJ2NvbG9yJyA/IHQgOiB0ICsgJy0nICsgYVxuICB9XG59XG5cbi8vIEFkZCBzdWdhciBmb3IgZmlsbCBhbmQgc3Ryb2tlXG47WydmaWxsJywgJ3N0cm9rZSddLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgY29uc3QgZXh0ZW5zaW9uID0ge31cbiAgbGV0IGlcblxuICBleHRlbnNpb25bbV0gPSBmdW5jdGlvbiAobykge1xuICAgIGlmICh0eXBlb2YgbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIobSlcbiAgICB9XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG8gPT09ICdzdHJpbmcnIHx8XG4gICAgICBvIGluc3RhbmNlb2YgQ29sb3IgfHxcbiAgICAgIENvbG9yLmlzUmdiKG8pIHx8XG4gICAgICBvIGluc3RhbmNlb2YgRWxlbWVudFxuICAgICkge1xuICAgICAgdGhpcy5hdHRyKG0sIG8pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNldCBhbGwgYXR0cmlidXRlcyBmcm9tIHN1Z2FyLmZpbGwgYW5kIHN1Z2FyLnN0cm9rZSBsaXN0XG4gICAgICBmb3IgKGkgPSBzdWdhclttXS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAob1tzdWdhclttXVtpXV0gIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuYXR0cihzdWdhci5wcmVmaXgobSwgc3VnYXJbbV1baV0pLCBvW3N1Z2FyW21dW2ldXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByZWdpc3Rlck1ldGhvZHMoWydFbGVtZW50JywgJ1J1bm5lciddLCBleHRlbnNpb24pXG59KVxuXG5yZWdpc3Rlck1ldGhvZHMoWydFbGVtZW50JywgJ1J1bm5lciddLCB7XG4gIC8vIExldCB0aGUgdXNlciBzZXQgdGhlIG1hdHJpeCBkaXJlY3RseVxuICBtYXRyaXg6IGZ1bmN0aW9uIChtYXQsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAvLyBBY3QgYXMgYSBnZXR0ZXJcbiAgICBpZiAobWF0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgTWF0cml4KHRoaXMpXG4gICAgfVxuXG4gICAgLy8gQWN0IGFzIGEgc2V0dGVyLCB0aGUgdXNlciBjYW4gcGFzcyBhIG1hdHJpeCBvciBhIHNldCBvZiBudW1iZXJzXG4gICAgcmV0dXJuIHRoaXMuYXR0cigndHJhbnNmb3JtJywgbmV3IE1hdHJpeChtYXQsIGIsIGMsIGQsIGUsIGYpKVxuICB9LFxuXG4gIC8vIE1hcCByb3RhdGlvbiB0byB0cmFuc2Zvcm1cbiAgcm90YXRlOiBmdW5jdGlvbiAoYW5nbGUsIGN4LCBjeSkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh7IHJvdGF0ZTogYW5nbGUsIG94OiBjeCwgb3k6IGN5IH0sIHRydWUpXG4gIH0sXG5cbiAgLy8gTWFwIHNrZXcgdG8gdHJhbnNmb3JtXG4gIHNrZXc6IGZ1bmN0aW9uICh4LCB5LCBjeCwgY3kpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAzXG4gICAgICA/IHRoaXMudHJhbnNmb3JtKHsgc2tldzogeCwgb3g6IHksIG95OiBjeCB9LCB0cnVlKVxuICAgICAgOiB0aGlzLnRyYW5zZm9ybSh7IHNrZXc6IFt4LCB5XSwgb3g6IGN4LCBveTogY3kgfSwgdHJ1ZSlcbiAgfSxcblxuICBzaGVhcjogZnVuY3Rpb24gKGxhbSwgY3gsIGN5KSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHsgc2hlYXI6IGxhbSwgb3g6IGN4LCBveTogY3kgfSwgdHJ1ZSlcbiAgfSxcblxuICAvLyBNYXAgc2NhbGUgdG8gdHJhbnNmb3JtXG4gIHNjYWxlOiBmdW5jdGlvbiAoeCwgeSwgY3gsIGN5KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gM1xuICAgICAgPyB0aGlzLnRyYW5zZm9ybSh7IHNjYWxlOiB4LCBveDogeSwgb3k6IGN4IH0sIHRydWUpXG4gICAgICA6IHRoaXMudHJhbnNmb3JtKHsgc2NhbGU6IFt4LCB5XSwgb3g6IGN4LCBveTogY3kgfSwgdHJ1ZSlcbiAgfSxcblxuICAvLyBNYXAgdHJhbnNsYXRlIHRvIHRyYW5zZm9ybVxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHsgdHJhbnNsYXRlOiBbeCwgeV0gfSwgdHJ1ZSlcbiAgfSxcblxuICAvLyBNYXAgcmVsYXRpdmUgdHJhbnNsYXRpb25zIHRvIHRyYW5zZm9ybVxuICByZWxhdGl2ZTogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oeyByZWxhdGl2ZTogW3gsIHldIH0sIHRydWUpXG4gIH0sXG5cbiAgLy8gTWFwIGZsaXAgdG8gdHJhbnNmb3JtXG4gIGZsaXA6IGZ1bmN0aW9uIChkaXJlY3Rpb24gPSAnYm90aCcsIG9yaWdpbiA9ICdjZW50ZXInKSB7XG4gICAgaWYgKCd4eWJvdGh0cnVlJy5pbmRleE9mKGRpcmVjdGlvbikgPT09IC0xKSB7XG4gICAgICBvcmlnaW4gPSBkaXJlY3Rpb25cbiAgICAgIGRpcmVjdGlvbiA9ICdib3RoJ1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh7IGZsaXA6IGRpcmVjdGlvbiwgb3JpZ2luOiBvcmlnaW4gfSwgdHJ1ZSlcbiAgfSxcblxuICAvLyBPcGFjaXR5XG4gIG9wYWNpdHk6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ29wYWNpdHknLCB2YWx1ZSlcbiAgfVxufSlcblxucmVnaXN0ZXJNZXRob2RzKCdyYWRpdXMnLCB7XG4gIC8vIEFkZCB4IGFuZCB5IHJhZGl1c1xuICByYWRpdXM6IGZ1bmN0aW9uICh4LCB5ID0geCkge1xuICAgIGNvbnN0IHR5cGUgPSAodGhpcy5fZWxlbWVudCB8fCB0aGlzKS50eXBlXG4gICAgcmV0dXJuIHR5cGUgPT09ICdyYWRpYWxHcmFkaWVudCdcbiAgICAgID8gdGhpcy5hdHRyKCdyJywgbmV3IFNWR051bWJlcih4KSlcbiAgICAgIDogdGhpcy5yeCh4KS5yeSh5KVxuICB9XG59KVxuXG5yZWdpc3Rlck1ldGhvZHMoJ1BhdGgnLCB7XG4gIC8vIEdldCBwYXRoIGxlbmd0aFxuICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlLmdldFRvdGFsTGVuZ3RoKClcbiAgfSxcbiAgLy8gR2V0IHBvaW50IGF0IGxlbmd0aFxuICBwb2ludEF0OiBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLm5vZGUuZ2V0UG9pbnRBdExlbmd0aChsZW5ndGgpKVxuICB9XG59KVxuXG5yZWdpc3Rlck1ldGhvZHMoWydFbGVtZW50JywgJ1J1bm5lciddLCB7XG4gIC8vIFNldCBmb250XG4gIGZvbnQ6IGZ1bmN0aW9uIChhLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2IGluIGEpIHRoaXMuZm9udCh2LCBhW3ZdKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICByZXR1cm4gYSA9PT0gJ2xlYWRpbmcnXG4gICAgICA/IHRoaXMubGVhZGluZyh2KVxuICAgICAgOiBhID09PSAnYW5jaG9yJ1xuICAgICAgICA/IHRoaXMuYXR0cigndGV4dC1hbmNob3InLCB2KVxuICAgICAgICA6IGEgPT09ICdzaXplJyB8fFxuICAgICAgICAgICAgYSA9PT0gJ2ZhbWlseScgfHxcbiAgICAgICAgICAgIGEgPT09ICd3ZWlnaHQnIHx8XG4gICAgICAgICAgICBhID09PSAnc3RyZXRjaCcgfHxcbiAgICAgICAgICAgIGEgPT09ICd2YXJpYW50JyB8fFxuICAgICAgICAgICAgYSA9PT0gJ3N0eWxlJ1xuICAgICAgICAgID8gdGhpcy5hdHRyKCdmb250LScgKyBhLCB2KVxuICAgICAgICAgIDogdGhpcy5hdHRyKGEsIHYpXG4gIH1cbn0pXG5cbi8vIEFkZCBldmVudHMgdG8gZWxlbWVudHNcbmNvbnN0IG1ldGhvZHMgPSBbXG4gICdjbGljaycsXG4gICdkYmxjbGljaycsXG4gICdtb3VzZWRvd24nLFxuICAnbW91c2V1cCcsXG4gICdtb3VzZW92ZXInLFxuICAnbW91c2VvdXQnLFxuICAnbW91c2Vtb3ZlJyxcbiAgJ21vdXNlZW50ZXInLFxuICAnbW91c2VsZWF2ZScsXG4gICd0b3VjaHN0YXJ0JyxcbiAgJ3RvdWNobW92ZScsXG4gICd0b3VjaGxlYXZlJyxcbiAgJ3RvdWNoZW5kJyxcbiAgJ3RvdWNoY2FuY2VsJyxcbiAgJ2NvbnRleHRtZW51JyxcbiAgJ3doZWVsJyxcbiAgJ3BvaW50ZXJkb3duJyxcbiAgJ3BvaW50ZXJtb3ZlJyxcbiAgJ3BvaW50ZXJ1cCcsXG4gICdwb2ludGVybGVhdmUnLFxuICAncG9pbnRlcmNhbmNlbCdcbl0ucmVkdWNlKGZ1bmN0aW9uIChsYXN0LCBldmVudCkge1xuICAvLyBhZGQgZXZlbnQgdG8gRWxlbWVudFxuICBjb25zdCBmbiA9IGZ1bmN0aW9uIChmKSB7XG4gICAgaWYgKGYgPT09IG51bGwpIHtcbiAgICAgIHRoaXMub2ZmKGV2ZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKGV2ZW50LCBmKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgbGFzdFtldmVudF0gPSBmblxuICByZXR1cm4gbGFzdFxufSwge30pXG5cbnJlZ2lzdGVyTWV0aG9kcygnRWxlbWVudCcsIG1ldGhvZHMpXG4iLCJpbXBvcnQgeyBnZXRPcmlnaW4sIGlzRGVzY3JpcHRpdmUgfSBmcm9tICcuLi8uLi91dGlscy91dGlscy5qcydcbmltcG9ydCB7IGRlbGltaXRlciwgdHJhbnNmb3JtcyB9IGZyb20gJy4uL2NvcmUvcmVnZXguanMnXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi8uLi91dGlscy9tZXRob2RzLmpzJ1xuaW1wb3J0IE1hdHJpeCBmcm9tICcuLi8uLi90eXBlcy9NYXRyaXguanMnXG5cbi8vIFJlc2V0IGFsbCB0cmFuc2Zvcm1hdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiB1bnRyYW5zZm9ybSgpIHtcbiAgcmV0dXJuIHRoaXMuYXR0cigndHJhbnNmb3JtJywgbnVsbClcbn1cblxuLy8gbWVyZ2UgdGhlIHdob2xlIHRyYW5zZm9ybWF0aW9uIGNoYWluIGludG8gb25lIG1hdHJpeCBhbmQgcmV0dXJucyBpdFxuZXhwb3J0IGZ1bmN0aW9uIG1hdHJpeGlmeSgpIHtcbiAgY29uc3QgbWF0cml4ID0gKHRoaXMuYXR0cigndHJhbnNmb3JtJykgfHwgJycpXG4gICAgLy8gc3BsaXQgdHJhbnNmb3JtYXRpb25zXG4gICAgLnNwbGl0KHRyYW5zZm9ybXMpXG4gICAgLnNsaWNlKDAsIC0xKVxuICAgIC5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgLy8gZ2VuZXJhdGUga2V5ID0+IHZhbHVlIHBhaXJzXG4gICAgICBjb25zdCBrdiA9IHN0ci50cmltKCkuc3BsaXQoJygnKVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAga3ZbMF0sXG4gICAgICAgIGt2WzFdLnNwbGl0KGRlbGltaXRlcikubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIpXG4gICAgICAgIH0pXG4gICAgICBdXG4gICAgfSlcbiAgICAucmV2ZXJzZSgpXG4gICAgLy8gbWVyZ2UgZXZlcnkgdHJhbnNmb3JtYXRpb24gaW50byBvbmUgbWF0cml4XG4gICAgLnJlZHVjZShmdW5jdGlvbiAobWF0cml4LCB0cmFuc2Zvcm0pIHtcbiAgICAgIGlmICh0cmFuc2Zvcm1bMF0gPT09ICdtYXRyaXgnKSB7XG4gICAgICAgIHJldHVybiBtYXRyaXgubG11bHRpcGx5KE1hdHJpeC5mcm9tQXJyYXkodHJhbnNmb3JtWzFdKSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRyaXhbdHJhbnNmb3JtWzBdXS5hcHBseShtYXRyaXgsIHRyYW5zZm9ybVsxXSlcbiAgICB9LCBuZXcgTWF0cml4KCkpXG5cbiAgcmV0dXJuIG1hdHJpeFxufVxuXG4vLyBhZGQgYW4gZWxlbWVudCB0byBhbm90aGVyIHBhcmVudCB3aXRob3V0IGNoYW5naW5nIHRoZSB2aXN1YWwgcmVwcmVzZW50YXRpb24gb24gdGhlIHNjcmVlblxuZXhwb3J0IGZ1bmN0aW9uIHRvUGFyZW50KHBhcmVudCwgaSkge1xuICBpZiAodGhpcyA9PT0gcGFyZW50KSByZXR1cm4gdGhpc1xuXG4gIGlmIChpc0Rlc2NyaXB0aXZlKHRoaXMubm9kZSkpIHJldHVybiB0aGlzLmFkZFRvKHBhcmVudCwgaSlcblxuICBjb25zdCBjdG0gPSB0aGlzLnNjcmVlbkNUTSgpXG4gIGNvbnN0IHBDdG0gPSBwYXJlbnQuc2NyZWVuQ1RNKCkuaW52ZXJzZSgpXG5cbiAgdGhpcy5hZGRUbyhwYXJlbnQsIGkpLnVudHJhbnNmb3JtKCkudHJhbnNmb3JtKHBDdG0ubXVsdGlwbHkoY3RtKSlcblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBzYW1lIGFzIGFib3ZlIHdpdGggcGFyZW50IGVxdWFscyByb290LXN2Z1xuZXhwb3J0IGZ1bmN0aW9uIHRvUm9vdChpKSB7XG4gIHJldHVybiB0aGlzLnRvUGFyZW50KHRoaXMucm9vdCgpLCBpKVxufVxuXG4vLyBBZGQgdHJhbnNmb3JtYXRpb25zXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtKG8sIHJlbGF0aXZlKSB7XG4gIC8vIEFjdCBhcyBhIGdldHRlciBpZiBubyBvYmplY3Qgd2FzIHBhc3NlZFxuICBpZiAobyA9PSBudWxsIHx8IHR5cGVvZiBvID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGRlY29tcG9zZWQgPSBuZXcgTWF0cml4KHRoaXMpLmRlY29tcG9zZSgpXG4gICAgcmV0dXJuIG8gPT0gbnVsbCA/IGRlY29tcG9zZWQgOiBkZWNvbXBvc2VkW29dXG4gIH1cblxuICBpZiAoIU1hdHJpeC5pc01hdHJpeExpa2UobykpIHtcbiAgICAvLyBTZXQgdGhlIG9yaWdpbiBhY2NvcmRpbmcgdG8gdGhlIGRlZmluZWQgdHJhbnNmb3JtXG4gICAgbyA9IHsgLi4ubywgb3JpZ2luOiBnZXRPcmlnaW4obywgdGhpcykgfVxuICB9XG5cbiAgLy8gVGhlIHVzZXIgY2FuIHBhc3MgYSBib29sZWFuLCBhbiBFbGVtZW50IG9yIGFuIE1hdHJpeCBvciBub3RoaW5nXG4gIGNvbnN0IGNsZWFuUmVsYXRpdmUgPSByZWxhdGl2ZSA9PT0gdHJ1ZSA/IHRoaXMgOiByZWxhdGl2ZSB8fCBmYWxzZVxuICBjb25zdCByZXN1bHQgPSBuZXcgTWF0cml4KGNsZWFuUmVsYXRpdmUpLnRyYW5zZm9ybShvKVxuICByZXR1cm4gdGhpcy5hdHRyKCd0cmFuc2Zvcm0nLCByZXN1bHQpXG59XG5cbnJlZ2lzdGVyTWV0aG9kcygnRWxlbWVudCcsIHtcbiAgdW50cmFuc2Zvcm0sXG4gIG1hdHJpeGlmeSxcbiAgdG9QYXJlbnQsXG4gIHRvUm9vdCxcbiAgdHJhbnNmb3JtXG59KVxuIiwiaW1wb3J0IHsgcmVnaXN0ZXIgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9FbGVtZW50LmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250YWluZXIgZXh0ZW5kcyBFbGVtZW50IHtcbiAgZmxhdHRlbigpIHtcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBDb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhdHRlbigpLnVuZ3JvdXAoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdW5ncm91cChwYXJlbnQgPSB0aGlzLnBhcmVudCgpLCBpbmRleCA9IHBhcmVudC5pbmRleCh0aGlzKSkge1xuICAgIC8vIHdoZW4gcGFyZW50ICE9IHRoaXMsIHdlIHdhbnQgYXBwZW5kIGFsbCBlbGVtZW50cyB0byB0aGUgZW5kXG4gICAgaW5kZXggPSBpbmRleCA9PT0gLTEgPyBwYXJlbnQuY2hpbGRyZW4oKS5sZW5ndGggOiBpbmRleFxuXG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChpLCBjaGlsZHJlbikge1xuICAgICAgLy8gcmV2ZXJzZSBlYWNoXG4gICAgICByZXR1cm4gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gaSAtIDFdLnRvUGFyZW50KHBhcmVudCwgaW5kZXgpXG4gICAgfSlcblxuICAgIHJldHVybiB0aGlzLnJlbW92ZSgpXG4gIH1cbn1cblxucmVnaXN0ZXIoQ29udGFpbmVyLCAnQ29udGFpbmVyJylcbiIsImltcG9ydCB7IG5vZGVPck5ldywgcmVnaXN0ZXIgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL0NvbnRhaW5lci5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVmcyBleHRlbmRzIENvbnRhaW5lciB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygnZGVmcycsIG5vZGUpLCBhdHRycylcbiAgfVxuXG4gIGZsYXR0ZW4oKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHVuZ3JvdXAoKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5yZWdpc3RlcihEZWZzLCAnRGVmcycpXG4iLCJpbXBvcnQgeyByZWdpc3RlciB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5pbXBvcnQgRWxlbWVudCBmcm9tICcuL0VsZW1lbnQuanMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYXBlIGV4dGVuZHMgRWxlbWVudCB7fVxuXG5yZWdpc3RlcihTaGFwZSwgJ1NoYXBlJylcbiIsImltcG9ydCBTVkdOdW1iZXIgZnJvbSAnLi4vLi4vdHlwZXMvU1ZHTnVtYmVyLmpzJ1xuXG4vLyBSYWRpdXMgeCB2YWx1ZVxuZXhwb3J0IGZ1bmN0aW9uIHJ4KHJ4KSB7XG4gIHJldHVybiB0aGlzLmF0dHIoJ3J4JywgcngpXG59XG5cbi8vIFJhZGl1cyB5IHZhbHVlXG5leHBvcnQgZnVuY3Rpb24gcnkocnkpIHtcbiAgcmV0dXJuIHRoaXMuYXR0cigncnknLCByeSlcbn1cblxuLy8gTW92ZSBvdmVyIHgtYXhpc1xuZXhwb3J0IGZ1bmN0aW9uIHgoeCkge1xuICByZXR1cm4geCA9PSBudWxsID8gdGhpcy5jeCgpIC0gdGhpcy5yeCgpIDogdGhpcy5jeCh4ICsgdGhpcy5yeCgpKVxufVxuXG4vLyBNb3ZlIG92ZXIgeS1heGlzXG5leHBvcnQgZnVuY3Rpb24geSh5KSB7XG4gIHJldHVybiB5ID09IG51bGwgPyB0aGlzLmN5KCkgLSB0aGlzLnJ5KCkgOiB0aGlzLmN5KHkgKyB0aGlzLnJ5KCkpXG59XG5cbi8vIE1vdmUgYnkgY2VudGVyIG92ZXIgeC1heGlzXG5leHBvcnQgZnVuY3Rpb24gY3goeCkge1xuICByZXR1cm4gdGhpcy5hdHRyKCdjeCcsIHgpXG59XG5cbi8vIE1vdmUgYnkgY2VudGVyIG92ZXIgeS1heGlzXG5leHBvcnQgZnVuY3Rpb24gY3koeSkge1xuICByZXR1cm4gdGhpcy5hdHRyKCdjeScsIHkpXG59XG5cbi8vIFNldCB3aWR0aCBvZiBlbGVtZW50XG5leHBvcnQgZnVuY3Rpb24gd2lkdGgod2lkdGgpIHtcbiAgcmV0dXJuIHdpZHRoID09IG51bGwgPyB0aGlzLnJ4KCkgKiAyIDogdGhpcy5yeChuZXcgU1ZHTnVtYmVyKHdpZHRoKS5kaXZpZGUoMikpXG59XG5cbi8vIFNldCBoZWlnaHQgb2YgZWxlbWVudFxuZXhwb3J0IGZ1bmN0aW9uIGhlaWdodChoZWlnaHQpIHtcbiAgcmV0dXJuIGhlaWdodCA9PSBudWxsXG4gICAgPyB0aGlzLnJ5KCkgKiAyXG4gICAgOiB0aGlzLnJ5KG5ldyBTVkdOdW1iZXIoaGVpZ2h0KS5kaXZpZGUoMikpXG59XG4iLCJpbXBvcnQge1xuICBleHRlbmQsXG4gIG5vZGVPck5ldyxcbiAgcmVnaXN0ZXIsXG4gIHdyYXBXaXRoQXR0ckNoZWNrXG59IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5pbXBvcnQgeyBwcm9wb3J0aW9uYWxTaXplIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMuanMnXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xuaW1wb3J0IFNWR051bWJlciBmcm9tICcuLi90eXBlcy9TVkdOdW1iZXIuanMnXG5pbXBvcnQgU2hhcGUgZnJvbSAnLi9TaGFwZS5qcydcbmltcG9ydCAqIGFzIGNpcmNsZWQgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL2NpcmNsZWQuanMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsbGlwc2UgZXh0ZW5kcyBTaGFwZSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygnZWxsaXBzZScsIG5vZGUpLCBhdHRycylcbiAgfVxuXG4gIHNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHAgPSBwcm9wb3J0aW9uYWxTaXplKHRoaXMsIHdpZHRoLCBoZWlnaHQpXG5cbiAgICByZXR1cm4gdGhpcy5yeChuZXcgU1ZHTnVtYmVyKHAud2lkdGgpLmRpdmlkZSgyKSkucnkoXG4gICAgICBuZXcgU1ZHTnVtYmVyKHAuaGVpZ2h0KS5kaXZpZGUoMilcbiAgICApXG4gIH1cbn1cblxuZXh0ZW5kKEVsbGlwc2UsIGNpcmNsZWQpXG5cbnJlZ2lzdGVyTWV0aG9kcygnQ29udGFpbmVyJywge1xuICAvLyBDcmVhdGUgYW4gZWxsaXBzZVxuICBlbGxpcHNlOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAod2lkdGggPSAwLCBoZWlnaHQgPSB3aWR0aCkge1xuICAgIHJldHVybiB0aGlzLnB1dChuZXcgRWxsaXBzZSgpKS5zaXplKHdpZHRoLCBoZWlnaHQpLm1vdmUoMCwgMClcbiAgfSlcbn0pXG5cbnJlZ2lzdGVyKEVsbGlwc2UsICdFbGxpcHNlJylcbiIsImltcG9ydCBEb20gZnJvbSAnLi9Eb20uanMnXG5pbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vdXRpbHMvd2luZG93LmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXIsIGNyZWF0ZSB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5cbmNsYXNzIEZyYWdtZW50IGV4dGVuZHMgRG9tIHtcbiAgY29uc3RydWN0b3Iobm9kZSA9IGdsb2JhbHMuZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpKSB7XG4gICAgc3VwZXIobm9kZSlcbiAgfVxuXG4gIC8vIEltcG9ydCAvIEV4cG9ydCByYXcgeG1sXG4gIHhtbCh4bWxPckZuLCBvdXRlclhNTCwgbnMpIHtcbiAgICBpZiAodHlwZW9mIHhtbE9yRm4gPT09ICdib29sZWFuJykge1xuICAgICAgbnMgPSBvdXRlclhNTFxuICAgICAgb3V0ZXJYTUwgPSB4bWxPckZuXG4gICAgICB4bWxPckZuID0gbnVsbFxuICAgIH1cblxuICAgIC8vIGJlY2F1c2UgdGhpcyBpcyBhIGZyYWdtZW50IHdlIGhhdmUgdG8gcHV0IGFsbCBlbGVtZW50cyBpbnRvIGEgd3JhcHBlciBmaXJzdFxuICAgIC8vIGJlZm9yZSB3ZSBjYW4gZ2V0IHRoZSBpbm5lclhNTCBmcm9tIGl0XG4gICAgaWYgKHhtbE9yRm4gPT0gbnVsbCB8fCB0eXBlb2YgeG1sT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3Qgd3JhcHBlciA9IG5ldyBEb20oY3JlYXRlKCd3cmFwcGVyJywgbnMpKVxuICAgICAgd3JhcHBlci5hZGQodGhpcy5ub2RlLmNsb25lTm9kZSh0cnVlKSlcblxuICAgICAgcmV0dXJuIHdyYXBwZXIueG1sKGZhbHNlLCBucylcbiAgICB9XG5cbiAgICAvLyBBY3QgYXMgc2V0dGVyIGlmIHdlIGdvdCBhIHN0cmluZ1xuICAgIHJldHVybiBzdXBlci54bWwoeG1sT3JGbiwgZmFsc2UsIG5zKVxuICB9XG59XG5cbnJlZ2lzdGVyKEZyYWdtZW50LCAnRnJhZ21lbnQnKVxuXG5leHBvcnQgZGVmYXVsdCBGcmFnbWVudFxuIiwiaW1wb3J0IFNWR051bWJlciBmcm9tICcuLi8uLi90eXBlcy9TVkdOdW1iZXIuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHgsIHkpIHtcbiAgcmV0dXJuICh0aGlzLl9lbGVtZW50IHx8IHRoaXMpLnR5cGUgPT09ICdyYWRpYWxHcmFkaWVudCdcbiAgICA/IHRoaXMuYXR0cih7IGZ4OiBuZXcgU1ZHTnVtYmVyKHgpLCBmeTogbmV3IFNWR051bWJlcih5KSB9KVxuICAgIDogdGhpcy5hdHRyKHsgeDE6IG5ldyBTVkdOdW1iZXIoeCksIHkxOiBuZXcgU1ZHTnVtYmVyKHkpIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0byh4LCB5KSB7XG4gIHJldHVybiAodGhpcy5fZWxlbWVudCB8fCB0aGlzKS50eXBlID09PSAncmFkaWFsR3JhZGllbnQnXG4gICAgPyB0aGlzLmF0dHIoeyBjeDogbmV3IFNWR051bWJlcih4KSwgY3k6IG5ldyBTVkdOdW1iZXIoeSkgfSlcbiAgICA6IHRoaXMuYXR0cih7IHgyOiBuZXcgU1ZHTnVtYmVyKHgpLCB5MjogbmV3IFNWR051bWJlcih5KSB9KVxufVxuIiwiaW1wb3J0IHtcbiAgZXh0ZW5kLFxuICBub2RlT3JOZXcsXG4gIHJlZ2lzdGVyLFxuICB3cmFwV2l0aEF0dHJDaGVja1xufSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcbmltcG9ydCBCb3ggZnJvbSAnLi4vdHlwZXMvQm94LmpzJ1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL0NvbnRhaW5lci5qcydcbmltcG9ydCBiYXNlRmluZCBmcm9tICcuLi9tb2R1bGVzL2NvcmUvc2VsZWN0b3IuanMnXG5pbXBvcnQgKiBhcyBncmFkaWVudGVkIGZyb20gJy4uL21vZHVsZXMvY29yZS9ncmFkaWVudGVkLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFkaWVudCBleHRlbmRzIENvbnRhaW5lciB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGF0dHJzKSB7XG4gICAgc3VwZXIoXG4gICAgICBub2RlT3JOZXcodHlwZSArICdHcmFkaWVudCcsIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IG51bGwgOiB0eXBlKSxcbiAgICAgIGF0dHJzXG4gICAgKVxuICB9XG5cbiAgLy8gY3VzdG9tIGF0dHIgdG8gaGFuZGxlIHRyYW5zZm9ybVxuICBhdHRyKGEsIGIsIGMpIHtcbiAgICBpZiAoYSA9PT0gJ3RyYW5zZm9ybScpIGEgPSAnZ3JhZGllbnRUcmFuc2Zvcm0nXG4gICAgcmV0dXJuIHN1cGVyLmF0dHIoYSwgYiwgYylcbiAgfVxuXG4gIGJib3goKSB7XG4gICAgcmV0dXJuIG5ldyBCb3goKVxuICB9XG5cbiAgdGFyZ2V0cygpIHtcbiAgICByZXR1cm4gYmFzZUZpbmQoJ3N2ZyBbZmlsbCo9JyArIHRoaXMuaWQoKSArICddJylcbiAgfVxuXG4gIC8vIEFsaWFzIHN0cmluZyBjb252ZXJzaW9uIHRvIGZpbGxcbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudXJsKClcbiAgfVxuXG4gIC8vIFVwZGF0ZSBncmFkaWVudFxuICB1cGRhdGUoYmxvY2spIHtcbiAgICAvLyByZW1vdmUgYWxsIHN0b3BzXG4gICAgdGhpcy5jbGVhcigpXG5cbiAgICAvLyBpbnZva2UgcGFzc2VkIGJsb2NrXG4gICAgaWYgKHR5cGVvZiBibG9jayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYmxvY2suY2FsbCh0aGlzLCB0aGlzKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIGZpbGwgaWRcbiAgdXJsKCkge1xuICAgIHJldHVybiAndXJsKCMnICsgdGhpcy5pZCgpICsgJyknXG4gIH1cbn1cblxuZXh0ZW5kKEdyYWRpZW50LCBncmFkaWVudGVkKVxuXG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgZ3JhZGllbnQgZWxlbWVudCBpbiBkZWZzXG4gICAgZ3JhZGllbnQoLi4uYXJncykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLmdyYWRpZW50KC4uLmFyZ3MpXG4gICAgfVxuICB9LFxuICAvLyBkZWZpbmUgZ3JhZGllbnRcbiAgRGVmczoge1xuICAgIGdyYWRpZW50OiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAodHlwZSwgYmxvY2spIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgR3JhZGllbnQodHlwZSkpLnVwZGF0ZShibG9jaylcbiAgICB9KVxuICB9XG59KVxuXG5yZWdpc3RlcihHcmFkaWVudCwgJ0dyYWRpZW50JylcbiIsImltcG9ydCB7IG5vZGVPck5ldywgcmVnaXN0ZXIsIHdyYXBXaXRoQXR0ckNoZWNrIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgQm94IGZyb20gJy4uL3R5cGVzL0JveC5qcydcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9Db250YWluZXIuanMnXG5pbXBvcnQgYmFzZUZpbmQgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3NlbGVjdG9yLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXR0ZXJuIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygncGF0dGVybicsIG5vZGUpLCBhdHRycylcbiAgfVxuXG4gIC8vIGN1c3RvbSBhdHRyIHRvIGhhbmRsZSB0cmFuc2Zvcm1cbiAgYXR0cihhLCBiLCBjKSB7XG4gICAgaWYgKGEgPT09ICd0cmFuc2Zvcm0nKSBhID0gJ3BhdHRlcm5UcmFuc2Zvcm0nXG4gICAgcmV0dXJuIHN1cGVyLmF0dHIoYSwgYiwgYylcbiAgfVxuXG4gIGJib3goKSB7XG4gICAgcmV0dXJuIG5ldyBCb3goKVxuICB9XG5cbiAgdGFyZ2V0cygpIHtcbiAgICByZXR1cm4gYmFzZUZpbmQoJ3N2ZyBbZmlsbCo9JyArIHRoaXMuaWQoKSArICddJylcbiAgfVxuXG4gIC8vIEFsaWFzIHN0cmluZyBjb252ZXJzaW9uIHRvIGZpbGxcbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudXJsKClcbiAgfVxuXG4gIC8vIFVwZGF0ZSBwYXR0ZXJuIGJ5IHJlYnVpbGRpbmdcbiAgdXBkYXRlKGJsb2NrKSB7XG4gICAgLy8gcmVtb3ZlIGNvbnRlbnRcbiAgICB0aGlzLmNsZWFyKClcblxuICAgIC8vIGludm9rZSBwYXNzZWQgYmxvY2tcbiAgICBpZiAodHlwZW9mIGJsb2NrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBibG9jay5jYWxsKHRoaXMsIHRoaXMpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgZmlsbCBpZFxuICB1cmwoKSB7XG4gICAgcmV0dXJuICd1cmwoIycgKyB0aGlzLmlkKCkgKyAnKSdcbiAgfVxufVxuXG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgcGF0dGVybiBlbGVtZW50IGluIGRlZnNcbiAgICBwYXR0ZXJuKC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5wYXR0ZXJuKC4uLmFyZ3MpXG4gICAgfVxuICB9LFxuICBEZWZzOiB7XG4gICAgcGF0dGVybjogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIGJsb2NrKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFBhdHRlcm4oKSkudXBkYXRlKGJsb2NrKS5hdHRyKHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgcGF0dGVyblVuaXRzOiAndXNlclNwYWNlT25Vc2UnXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn0pXG5cbnJlZ2lzdGVyKFBhdHRlcm4sICdQYXR0ZXJuJylcbiIsImltcG9ydCB7IGlzSW1hZ2UgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcmVnZXguanMnXG5pbXBvcnQgeyBub2RlT3JOZXcsIHJlZ2lzdGVyLCB3cmFwV2l0aEF0dHJDaGVjayB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5pbXBvcnQgeyBvZmYsIG9uIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL2V2ZW50LmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJBdHRySG9vayB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9hdHRyLmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcbmltcG9ydCB7IHhsaW5rIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL25hbWVzcGFjZXMuanMnXG5pbXBvcnQgUGF0dGVybiBmcm9tICcuL1BhdHRlcm4uanMnXG5pbXBvcnQgU2hhcGUgZnJvbSAnLi9TaGFwZS5qcydcbmltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi91dGlscy93aW5kb3cuanMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEltYWdlIGV4dGVuZHMgU2hhcGUge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ2ltYWdlJywgbm9kZSksIGF0dHJzKVxuICB9XG5cbiAgLy8gKHJlKWxvYWQgaW1hZ2VcbiAgbG9hZCh1cmwsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF1cmwpIHJldHVybiB0aGlzXG5cbiAgICBjb25zdCBpbWcgPSBuZXcgZ2xvYmFscy53aW5kb3cuSW1hZ2UoKVxuXG4gICAgb24oXG4gICAgICBpbWcsXG4gICAgICAnbG9hZCcsXG4gICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5wYXJlbnQoUGF0dGVybilcblxuICAgICAgICAvLyBlbnN1cmUgaW1hZ2Ugc2l6ZVxuICAgICAgICBpZiAodGhpcy53aWR0aCgpID09PSAwICYmIHRoaXMuaGVpZ2h0KCkgPT09IDApIHtcbiAgICAgICAgICB0aGlzLnNpemUoaW1nLndpZHRoLCBpbWcuaGVpZ2h0KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQYXR0ZXJuKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIHBhdHRlcm4gc2l6ZSBpZiBub3Qgc2V0XG4gICAgICAgICAgaWYgKHAud2lkdGgoKSA9PT0gMCAmJiBwLmhlaWdodCgpID09PSAwKSB7XG4gICAgICAgICAgICBwLnNpemUodGhpcy53aWR0aCgpLCB0aGlzLmhlaWdodCgpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGUpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0aGlzXG4gICAgKVxuXG4gICAgb24oaW1nLCAnbG9hZCBlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGRvbnQgZm9yZ2V0IHRvIHVuYmluZCBtZW1vcnkgbGVha2luZyBldmVudHNcbiAgICAgIG9mZihpbWcpXG4gICAgfSlcblxuICAgIHJldHVybiB0aGlzLmF0dHIoJ2hyZWYnLCAoaW1nLnNyYyA9IHVybCksIHhsaW5rKVxuICB9XG59XG5cbnJlZ2lzdGVyQXR0ckhvb2soZnVuY3Rpb24gKGF0dHIsIHZhbCwgX3RoaXMpIHtcbiAgLy8gY29udmVydCBpbWFnZSBmaWxsIGFuZCBzdHJva2UgdG8gcGF0dGVybnNcbiAgaWYgKGF0dHIgPT09ICdmaWxsJyB8fCBhdHRyID09PSAnc3Ryb2tlJykge1xuICAgIGlmIChpc0ltYWdlLnRlc3QodmFsKSkge1xuICAgICAgdmFsID0gX3RoaXMucm9vdCgpLmRlZnMoKS5pbWFnZSh2YWwpXG4gICAgfVxuICB9XG5cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEltYWdlKSB7XG4gICAgdmFsID0gX3RoaXNcbiAgICAgIC5yb290KClcbiAgICAgIC5kZWZzKClcbiAgICAgIC5wYXR0ZXJuKDAsIDAsIChwYXR0ZXJuKSA9PiB7XG4gICAgICAgIHBhdHRlcm4uYWRkKHZhbClcbiAgICAgIH0pXG4gIH1cblxuICByZXR1cm4gdmFsXG59KVxuXG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBjcmVhdGUgaW1hZ2UgZWxlbWVudCwgbG9hZCBpbWFnZSBhbmQgc2V0IGl0cyBzaXplXG4gICAgaW1hZ2U6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IEltYWdlKCkpLnNpemUoMCwgMCkubG9hZChzb3VyY2UsIGNhbGxiYWNrKVxuICAgIH0pXG4gIH1cbn0pXG5cbnJlZ2lzdGVyKEltYWdlLCAnSW1hZ2UnKVxuIiwiaW1wb3J0IHsgZGVsaW1pdGVyIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3JlZ2V4LmpzJ1xuaW1wb3J0IFNWR0FycmF5IGZyb20gJy4vU1ZHQXJyYXkuanMnXG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJ1xuaW1wb3J0IE1hdHJpeCBmcm9tICcuL01hdHJpeC5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9pbnRBcnJheSBleHRlbmRzIFNWR0FycmF5IHtcbiAgLy8gR2V0IGJvdW5kaW5nIGJveCBvZiBwb2ludHNcbiAgYmJveCgpIHtcbiAgICBsZXQgbWF4WCA9IC1JbmZpbml0eVxuICAgIGxldCBtYXhZID0gLUluZmluaXR5XG4gICAgbGV0IG1pblggPSBJbmZpbml0eVxuICAgIGxldCBtaW5ZID0gSW5maW5pdHlcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICBtYXhYID0gTWF0aC5tYXgoZWxbMF0sIG1heFgpXG4gICAgICBtYXhZID0gTWF0aC5tYXgoZWxbMV0sIG1heFkpXG4gICAgICBtaW5YID0gTWF0aC5taW4oZWxbMF0sIG1pblgpXG4gICAgICBtaW5ZID0gTWF0aC5taW4oZWxbMV0sIG1pblkpXG4gICAgfSlcbiAgICByZXR1cm4gbmV3IEJveChtaW5YLCBtaW5ZLCBtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpXG4gIH1cblxuICAvLyBNb3ZlIHBvaW50IHN0cmluZ1xuICBtb3ZlKHgsIHkpIHtcbiAgICBjb25zdCBib3ggPSB0aGlzLmJib3goKVxuXG4gICAgLy8gZ2V0IHJlbGF0aXZlIG9mZnNldFxuICAgIHggLT0gYm94LnhcbiAgICB5IC09IGJveC55XG5cbiAgICAvLyBtb3ZlIGV2ZXJ5IHBvaW50XG4gICAgaWYgKCFpc05hTih4KSAmJiAhaXNOYU4oeSkpIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXNbaV0gPSBbdGhpc1tpXVswXSArIHgsIHRoaXNbaV1bMV0gKyB5XVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBQYXJzZSBwb2ludCBzdHJpbmcgYW5kIGZsYXQgYXJyYXlcbiAgcGFyc2UoYXJyYXkgPSBbMCwgMF0pIHtcbiAgICBjb25zdCBwb2ludHMgPSBbXVxuXG4gICAgLy8gaWYgaXQgaXMgYW4gYXJyYXksIHdlIGZsYXR0ZW4gaXQgYW5kIHRoZXJlZm9yZSBjbG9uZSBpdCB0byAxIGRlcHRoc1xuICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBhcnJheSA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycmF5KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbHNlLCBpdCBpcyBjb25zaWRlcmVkIGFzIGEgc3RyaW5nXG4gICAgICAvLyBwYXJzZSBwb2ludHNcbiAgICAgIGFycmF5ID0gYXJyYXkudHJpbSgpLnNwbGl0KGRlbGltaXRlcikubWFwKHBhcnNlRmxvYXQpXG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgcG9pbnRzIC0gaHR0cHM6Ly9zdmd3Zy5vcmcvc3ZnMi1kcmFmdC9zaGFwZXMuaHRtbCNEYXRhVHlwZVBvaW50c1xuICAgIC8vIE9kZCBudW1iZXIgb2YgY29vcmRpbmF0ZXMgaXMgYW4gZXJyb3IuIEluIHN1Y2ggY2FzZXMsIGRyb3AgdGhlIGxhc3Qgb2RkIGNvb3JkaW5hdGUuXG4gICAgaWYgKGFycmF5Lmxlbmd0aCAlIDIgIT09IDApIGFycmF5LnBvcCgpXG5cbiAgICAvLyB3cmFwIHBvaW50cyBpbiB0d28tdHVwbGVzXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSA9IGkgKyAyKSB7XG4gICAgICBwb2ludHMucHVzaChbYXJyYXlbaV0sIGFycmF5W2kgKyAxXV0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50c1xuICB9XG5cbiAgLy8gUmVzaXplIHBvbHkgc3RyaW5nXG4gIHNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGxldCBpXG4gICAgY29uc3QgYm94ID0gdGhpcy5iYm94KClcblxuICAgIC8vIHJlY2FsY3VsYXRlIHBvc2l0aW9uIG9mIGFsbCBwb2ludHMgYWNjb3JkaW5nIHRvIG5ldyBzaXplXG4gICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGJveC53aWR0aClcbiAgICAgICAgdGhpc1tpXVswXSA9ICgodGhpc1tpXVswXSAtIGJveC54KSAqIHdpZHRoKSAvIGJveC53aWR0aCArIGJveC54XG4gICAgICBpZiAoYm94LmhlaWdodClcbiAgICAgICAgdGhpc1tpXVsxXSA9ICgodGhpc1tpXVsxXSAtIGJveC55KSAqIGhlaWdodCkgLyBib3guaGVpZ2h0ICsgYm94LnlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gQ29udmVydCBhcnJheSB0byBsaW5lIG9iamVjdFxuICB0b0xpbmUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiB0aGlzWzBdWzBdLFxuICAgICAgeTE6IHRoaXNbMF1bMV0sXG4gICAgICB4MjogdGhpc1sxXVswXSxcbiAgICAgIHkyOiB0aGlzWzFdWzFdXG4gICAgfVxuICB9XG5cbiAgLy8gQ29udmVydCBhcnJheSB0byBzdHJpbmdcbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgYXJyYXkgPSBbXVxuICAgIC8vIGNvbnZlcnQgdG8gYSBwb2x5IHBvaW50IHN0cmluZ1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHRoaXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgYXJyYXkucHVzaCh0aGlzW2ldLmpvaW4oJywnKSlcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXkuam9pbignICcpXG4gIH1cblxuICB0cmFuc2Zvcm0obSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkudHJhbnNmb3JtTyhtKVxuICB9XG5cbiAgLy8gdHJhbnNmb3JtIHBvaW50cyB3aXRoIG1hdHJpeCAoc2ltaWxhciB0byBQb2ludC50cmFuc2Zvcm0pXG4gIHRyYW5zZm9ybU8obSkge1xuICAgIGlmICghTWF0cml4LmlzTWF0cml4TGlrZShtKSkge1xuICAgICAgbSA9IG5ldyBNYXRyaXgobSlcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gdGhpcy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAvLyBQZXJmb3JtIHRoZSBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICAgIGNvbnN0IFt4LCB5XSA9IHRoaXNbaV1cbiAgICAgIHRoaXNbaV1bMF0gPSBtLmEgKiB4ICsgbS5jICogeSArIG0uZVxuICAgICAgdGhpc1tpXVsxXSA9IG0uYiAqIHggKyBtLmQgKiB5ICsgbS5mXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuIiwiaW1wb3J0IFBvaW50QXJyYXkgZnJvbSAnLi4vLi4vdHlwZXMvUG9pbnRBcnJheS5qcydcblxuZXhwb3J0IGNvbnN0IE1vcnBoQXJyYXkgPSBQb2ludEFycmF5XG5cbi8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyIG92ZXIgeC1heGlzXG5leHBvcnQgZnVuY3Rpb24geCh4KSB7XG4gIHJldHVybiB4ID09IG51bGwgPyB0aGlzLmJib3goKS54IDogdGhpcy5tb3ZlKHgsIHRoaXMuYmJveCgpLnkpXG59XG5cbi8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyIG92ZXIgeS1heGlzXG5leHBvcnQgZnVuY3Rpb24geSh5KSB7XG4gIHJldHVybiB5ID09IG51bGwgPyB0aGlzLmJib3goKS55IDogdGhpcy5tb3ZlKHRoaXMuYmJveCgpLngsIHkpXG59XG5cbi8vIFNldCB3aWR0aCBvZiBlbGVtZW50XG5leHBvcnQgZnVuY3Rpb24gd2lkdGgod2lkdGgpIHtcbiAgY29uc3QgYiA9IHRoaXMuYmJveCgpXG4gIHJldHVybiB3aWR0aCA9PSBudWxsID8gYi53aWR0aCA6IHRoaXMuc2l6ZSh3aWR0aCwgYi5oZWlnaHQpXG59XG5cbi8vIFNldCBoZWlnaHQgb2YgZWxlbWVudFxuZXhwb3J0IGZ1bmN0aW9uIGhlaWdodChoZWlnaHQpIHtcbiAgY29uc3QgYiA9IHRoaXMuYmJveCgpXG4gIHJldHVybiBoZWlnaHQgPT0gbnVsbCA/IGIuaGVpZ2h0IDogdGhpcy5zaXplKGIud2lkdGgsIGhlaWdodClcbn1cbiIsImltcG9ydCB7XG4gIGV4dGVuZCxcbiAgbm9kZU9yTmV3LFxuICByZWdpc3RlcixcbiAgd3JhcFdpdGhBdHRyQ2hlY2tcbn0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCB7IHByb3BvcnRpb25hbFNpemUgfSBmcm9tICcuLi91dGlscy91dGlscy5qcydcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgUG9pbnRBcnJheSBmcm9tICcuLi90eXBlcy9Qb2ludEFycmF5LmpzJ1xuaW1wb3J0IFNoYXBlIGZyb20gJy4vU2hhcGUuanMnXG5pbXBvcnQgKiBhcyBwb2ludGVkIGZyb20gJy4uL21vZHVsZXMvY29yZS9wb2ludGVkLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lIGV4dGVuZHMgU2hhcGUge1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdsaW5lJywgbm9kZSksIGF0dHJzKVxuICB9XG5cbiAgLy8gR2V0IGFycmF5XG4gIGFycmF5KCkge1xuICAgIHJldHVybiBuZXcgUG9pbnRBcnJheShbXG4gICAgICBbdGhpcy5hdHRyKCd4MScpLCB0aGlzLmF0dHIoJ3kxJyldLFxuICAgICAgW3RoaXMuYXR0cigneDInKSwgdGhpcy5hdHRyKCd5MicpXVxuICAgIF0pXG4gIH1cblxuICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lclxuICBtb3ZlKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKHRoaXMuYXJyYXkoKS5tb3ZlKHgsIHkpLnRvTGluZSgpKVxuICB9XG5cbiAgLy8gT3ZlcndyaXRlIG5hdGl2ZSBwbG90KCkgbWV0aG9kXG4gIHBsb3QoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICBpZiAoeDEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXJyYXkoKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHkxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgeDEgPSB7IHgxLCB5MSwgeDIsIHkyIH1cbiAgICB9IGVsc2Uge1xuICAgICAgeDEgPSBuZXcgUG9pbnRBcnJheSh4MSkudG9MaW5lKClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hdHRyKHgxKVxuICB9XG5cbiAgLy8gU2V0IGVsZW1lbnQgc2l6ZSB0byBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XG4gIHNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHAgPSBwcm9wb3J0aW9uYWxTaXplKHRoaXMsIHdpZHRoLCBoZWlnaHQpXG4gICAgcmV0dXJuIHRoaXMuYXR0cih0aGlzLmFycmF5KCkuc2l6ZShwLndpZHRoLCBwLmhlaWdodCkudG9MaW5lKCkpXG4gIH1cbn1cblxuZXh0ZW5kKExpbmUsIHBvaW50ZWQpXG5cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIC8vIENyZWF0ZSBhIGxpbmUgZWxlbWVudFxuICAgIGxpbmU6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgcGxvdCBpcyBjYWxsZWQgYXMgYSBzZXR0ZXJcbiAgICAgIC8vIHgxIGlzIG5vdCBuZWNlc3NhcmlseSBhIG51bWJlciwgaXQgY2FuIGFsc28gYmUgYW4gYXJyYXksIGEgc3RyaW5nIGFuZCBhIFBvaW50QXJyYXlcbiAgICAgIHJldHVybiBMaW5lLnByb3RvdHlwZS5wbG90LmFwcGx5KFxuICAgICAgICB0aGlzLnB1dChuZXcgTGluZSgpKSxcbiAgICAgICAgYXJnc1swXSAhPSBudWxsID8gYXJncyA6IFswLCAwLCAwLCAwXVxuICAgICAgKVxuICAgIH0pXG4gIH1cbn0pXG5cbnJlZ2lzdGVyKExpbmUsICdMaW5lJylcbiIsImltcG9ydCB7IG5vZGVPck5ldywgcmVnaXN0ZXIsIHdyYXBXaXRoQXR0ckNoZWNrIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQ29udGFpbmVyLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXJrZXIgZXh0ZW5kcyBDb250YWluZXIge1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdtYXJrZXInLCBub2RlKSwgYXR0cnMpXG4gIH1cblxuICAvLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcbiAgaGVpZ2h0KGhlaWdodCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ21hcmtlckhlaWdodCcsIGhlaWdodClcbiAgfVxuXG4gIG9yaWVudChvcmllbnQpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdvcmllbnQnLCBvcmllbnQpXG4gIH1cblxuICAvLyBTZXQgbWFya2VyIHJlZlggYW5kIHJlZllcbiAgcmVmKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdyZWZYJywgeCkuYXR0cigncmVmWScsIHkpXG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIGZpbGwgaWRcbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICd1cmwoIycgKyB0aGlzLmlkKCkgKyAnKSdcbiAgfVxuXG4gIC8vIFVwZGF0ZSBtYXJrZXJcbiAgdXBkYXRlKGJsb2NrKSB7XG4gICAgLy8gcmVtb3ZlIGFsbCBjb250ZW50XG4gICAgdGhpcy5jbGVhcigpXG5cbiAgICAvLyBpbnZva2UgcGFzc2VkIGJsb2NrXG4gICAgaWYgKHR5cGVvZiBibG9jayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYmxvY2suY2FsbCh0aGlzLCB0aGlzKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBTZXQgd2lkdGggb2YgZWxlbWVudFxuICB3aWR0aCh3aWR0aCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ21hcmtlcldpZHRoJywgd2lkdGgpXG4gIH1cbn1cblxucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgbWFya2VyKC4uLmFyZ3MpIHtcbiAgICAgIC8vIENyZWF0ZSBtYXJrZXIgZWxlbWVudCBpbiBkZWZzXG4gICAgICByZXR1cm4gdGhpcy5kZWZzKCkubWFya2VyKC4uLmFyZ3MpXG4gICAgfVxuICB9LFxuICBEZWZzOiB7XG4gICAgLy8gQ3JlYXRlIG1hcmtlclxuICAgIG1hcmtlcjogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIGJsb2NrKSB7XG4gICAgICAvLyBTZXQgZGVmYXVsdCB2aWV3Ym94IHRvIG1hdGNoIHRoZSB3aWR0aCBhbmQgaGVpZ2h0LCBzZXQgcmVmIHRvIGN4IGFuZCBjeSBhbmQgc2V0IG9yaWVudCB0byBhdXRvXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IE1hcmtlcigpKVxuICAgICAgICAuc2l6ZSh3aWR0aCwgaGVpZ2h0KVxuICAgICAgICAucmVmKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMilcbiAgICAgICAgLnZpZXdib3goMCwgMCwgd2lkdGgsIGhlaWdodClcbiAgICAgICAgLmF0dHIoJ29yaWVudCcsICdhdXRvJylcbiAgICAgICAgLnVwZGF0ZShibG9jaylcbiAgICB9KVxuICB9LFxuICBtYXJrZXI6IHtcbiAgICAvLyBDcmVhdGUgYW5kIGF0dGFjaCBtYXJrZXJzXG4gICAgbWFya2VyKG1hcmtlciwgd2lkdGgsIGhlaWdodCwgYmxvY2spIHtcbiAgICAgIGxldCBhdHRyID0gWydtYXJrZXInXVxuXG4gICAgICAvLyBCdWlsZCBhdHRyaWJ1dGUgbmFtZVxuICAgICAgaWYgKG1hcmtlciAhPT0gJ2FsbCcpIGF0dHIucHVzaChtYXJrZXIpXG4gICAgICBhdHRyID0gYXR0ci5qb2luKCctJylcblxuICAgICAgLy8gU2V0IG1hcmtlciBhdHRyaWJ1dGVcbiAgICAgIG1hcmtlciA9XG4gICAgICAgIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIE1hcmtlclxuICAgICAgICAgID8gYXJndW1lbnRzWzFdXG4gICAgICAgICAgOiB0aGlzLmRlZnMoKS5tYXJrZXIod2lkdGgsIGhlaWdodCwgYmxvY2spXG5cbiAgICAgIHJldHVybiB0aGlzLmF0dHIoYXR0ciwgbWFya2VyKVxuICAgIH1cbiAgfVxufSlcblxucmVnaXN0ZXIoTWFya2VyLCAnTWFya2VyJylcbiIsImltcG9ydCB7IHRpbWVsaW5lIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL2RlZmF1bHRzLmpzJ1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcblxuLyoqKlxuQmFzZSBDbGFzc1xuPT09PT09PT09PVxuVGhlIGJhc2Ugc3RlcHBlciBjbGFzcyB0aGF0IHdpbGwgYmVcbioqKi9cblxuZnVuY3Rpb24gbWFrZVNldHRlckdldHRlcihrLCBmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIGlmICh2ID09IG51bGwpIHJldHVybiB0aGlzW2tdXG4gICAgdGhpc1trXSA9IHZcbiAgICBpZiAoZikgZi5jYWxsKHRoaXMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZWFzaW5nID0ge1xuICAnLSc6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gcG9zXG4gIH0sXG4gICc8Pic6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gLU1hdGguY29zKHBvcyAqIE1hdGguUEkpIC8gMiArIDAuNVxuICB9LFxuICAnPic6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gTWF0aC5zaW4oKHBvcyAqIE1hdGguUEkpIC8gMilcbiAgfSxcbiAgJzwnOiBmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIC1NYXRoLmNvcygocG9zICogTWF0aC5QSSkgLyAyKSArIDFcbiAgfSxcbiAgYmV6aWVyOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAvLyBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1lYXNpbmctMS8jY3ViaWMtYmV6aWVyLWFsZ29cbiAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmICh0IDwgMCkge1xuICAgICAgICBpZiAoeDEgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuICh5MSAvIHgxKSAqIHRcbiAgICAgICAgfSBlbHNlIGlmICh4MiA+IDApIHtcbiAgICAgICAgICByZXR1cm4gKHkyIC8geDIpICogdFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodCA+IDEpIHtcbiAgICAgICAgaWYgKHgyIDwgMSkge1xuICAgICAgICAgIHJldHVybiAoKDEgLSB5MikgLyAoMSAtIHgyKSkgKiB0ICsgKHkyIC0geDIpIC8gKDEgLSB4MilcbiAgICAgICAgfSBlbHNlIGlmICh4MSA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gKCgxIC0geTEpIC8gKDEgLSB4MSkpICogdCArICh5MSAtIHgxKSAvICgxIC0geDEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDMgKiB0ICogKDEgLSB0KSAqKiAyICogeTEgKyAzICogdCAqKiAyICogKDEgLSB0KSAqIHkyICsgdCAqKiAzXG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvLyBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1lYXNpbmctMS8jc3RlcC10aW1pbmctZnVuY3Rpb24tYWxnb1xuICBzdGVwczogZnVuY3Rpb24gKHN0ZXBzLCBzdGVwUG9zaXRpb24gPSAnZW5kJykge1xuICAgIC8vIGRlYWwgd2l0aCBcImp1bXAtXCIgcHJlZml4XG4gICAgc3RlcFBvc2l0aW9uID0gc3RlcFBvc2l0aW9uLnNwbGl0KCctJykucmV2ZXJzZSgpWzBdXG5cbiAgICBsZXQganVtcHMgPSBzdGVwc1xuICAgIGlmIChzdGVwUG9zaXRpb24gPT09ICdub25lJykge1xuICAgICAgLS1qdW1wc1xuICAgIH0gZWxzZSBpZiAoc3RlcFBvc2l0aW9uID09PSAnYm90aCcpIHtcbiAgICAgICsranVtcHNcbiAgICB9XG5cbiAgICAvLyBUaGUgYmVmb3JlRmxhZyBpcyBlc3NlbnRpYWxseSB1c2VsZXNzXG4gICAgcmV0dXJuICh0LCBiZWZvcmVGbGFnID0gZmFsc2UpID0+IHtcbiAgICAgIC8vIFN0ZXAgaXMgY2FsbGVkIGN1cnJlbnRTdGVwIGluIHJlZmVyZW5jZWQgdXJsXG4gICAgICBsZXQgc3RlcCA9IE1hdGguZmxvb3IodCAqIHN0ZXBzKVxuICAgICAgY29uc3QganVtcGluZyA9ICh0ICogc3RlcCkgJSAxID09PSAwXG5cbiAgICAgIGlmIChzdGVwUG9zaXRpb24gPT09ICdzdGFydCcgfHwgc3RlcFBvc2l0aW9uID09PSAnYm90aCcpIHtcbiAgICAgICAgKytzdGVwXG4gICAgICB9XG5cbiAgICAgIGlmIChiZWZvcmVGbGFnICYmIGp1bXBpbmcpIHtcbiAgICAgICAgLS1zdGVwXG4gICAgICB9XG5cbiAgICAgIGlmICh0ID49IDAgJiYgc3RlcCA8IDApIHtcbiAgICAgICAgc3RlcCA9IDBcbiAgICAgIH1cblxuICAgICAgaWYgKHQgPD0gMSAmJiBzdGVwID4ganVtcHMpIHtcbiAgICAgICAgc3RlcCA9IGp1bXBzXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGVwIC8ganVtcHNcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFN0ZXBwZXIge1xuICBkb25lKCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKipcbkVhc2luZyBGdW5jdGlvbnNcbj09PT09PT09PT09PT09PT1cbioqKi9cblxuZXhwb3J0IGNsYXNzIEVhc2UgZXh0ZW5kcyBTdGVwcGVyIHtcbiAgY29uc3RydWN0b3IoZm4gPSB0aW1lbGluZS5lYXNlKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuZWFzZSA9IGVhc2luZ1tmbl0gfHwgZm5cbiAgfVxuXG4gIHN0ZXAoZnJvbSwgdG8sIHBvcykge1xuICAgIGlmICh0eXBlb2YgZnJvbSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBwb3MgPCAxID8gZnJvbSA6IHRvXG4gICAgfVxuICAgIHJldHVybiBmcm9tICsgKHRvIC0gZnJvbSkgKiB0aGlzLmVhc2UocG9zKVxuICB9XG59XG5cbi8qKipcbkNvbnRyb2xsZXIgVHlwZXNcbj09PT09PT09PT09PT09PT1cbioqKi9cblxuZXhwb3J0IGNsYXNzIENvbnRyb2xsZXIgZXh0ZW5kcyBTdGVwcGVyIHtcbiAgY29uc3RydWN0b3IoZm4pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5zdGVwcGVyID0gZm5cbiAgfVxuXG4gIGRvbmUoYykge1xuICAgIHJldHVybiBjLmRvbmVcbiAgfVxuXG4gIHN0ZXAoY3VycmVudCwgdGFyZ2V0LCBkdCwgYykge1xuICAgIHJldHVybiB0aGlzLnN0ZXBwZXIoY3VycmVudCwgdGFyZ2V0LCBkdCwgYylcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNhbGN1bGF0ZSgpIHtcbiAgLy8gQXBwbHkgdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuICBjb25zdCBkdXJhdGlvbiA9ICh0aGlzLl9kdXJhdGlvbiB8fCA1MDApIC8gMTAwMFxuICBjb25zdCBvdmVyc2hvb3QgPSB0aGlzLl9vdmVyc2hvb3QgfHwgMFxuXG4gIC8vIENhbGN1bGF0ZSB0aGUgUElEIG5hdHVyYWwgcmVzcG9uc2VcbiAgY29uc3QgZXBzID0gMWUtMTBcbiAgY29uc3QgcGkgPSBNYXRoLlBJXG4gIGNvbnN0IG9zID0gTWF0aC5sb2cob3ZlcnNob290IC8gMTAwICsgZXBzKVxuICBjb25zdCB6ZXRhID0gLW9zIC8gTWF0aC5zcXJ0KHBpICogcGkgKyBvcyAqIG9zKVxuICBjb25zdCB3biA9IDMuOSAvICh6ZXRhICogZHVyYXRpb24pXG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBTcHJpbmcgdmFsdWVzXG4gIHRoaXMuZCA9IDIgKiB6ZXRhICogd25cbiAgdGhpcy5rID0gd24gKiB3blxufVxuXG5leHBvcnQgY2xhc3MgU3ByaW5nIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGR1cmF0aW9uID0gNTAwLCBvdmVyc2hvb3QgPSAwKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuZHVyYXRpb24oZHVyYXRpb24pLm92ZXJzaG9vdChvdmVyc2hvb3QpXG4gIH1cblxuICBzdGVwKGN1cnJlbnQsIHRhcmdldCwgZHQsIGMpIHtcbiAgICBpZiAodHlwZW9mIGN1cnJlbnQgPT09ICdzdHJpbmcnKSByZXR1cm4gY3VycmVudFxuICAgIGMuZG9uZSA9IGR0ID09PSBJbmZpbml0eVxuICAgIGlmIChkdCA9PT0gSW5maW5pdHkpIHJldHVybiB0YXJnZXRcbiAgICBpZiAoZHQgPT09IDApIHJldHVybiBjdXJyZW50XG5cbiAgICBpZiAoZHQgPiAxMDApIGR0ID0gMTZcblxuICAgIGR0IC89IDEwMDBcblxuICAgIC8vIEdldCB0aGUgcHJldmlvdXMgdmVsb2NpdHlcbiAgICBjb25zdCB2ZWxvY2l0eSA9IGMudmVsb2NpdHkgfHwgMFxuXG4gICAgLy8gQXBwbHkgdGhlIGNvbnRyb2wgdG8gZ2V0IHRoZSBuZXcgcG9zaXRpb24gYW5kIHN0b3JlIGl0XG4gICAgY29uc3QgYWNjZWxlcmF0aW9uID0gLXRoaXMuZCAqIHZlbG9jaXR5IC0gdGhpcy5rICogKGN1cnJlbnQgLSB0YXJnZXQpXG4gICAgY29uc3QgbmV3UG9zaXRpb24gPSBjdXJyZW50ICsgdmVsb2NpdHkgKiBkdCArIChhY2NlbGVyYXRpb24gKiBkdCAqIGR0KSAvIDJcblxuICAgIC8vIFN0b3JlIHRoZSB2ZWxvY2l0eVxuICAgIGMudmVsb2NpdHkgPSB2ZWxvY2l0eSArIGFjY2VsZXJhdGlvbiAqIGR0XG5cbiAgICAvLyBGaWd1cmUgb3V0IGlmIHdlIGhhdmUgY29udmVyZ2VkLCBhbmQgaWYgc28sIHBhc3MgdGhlIHZhbHVlXG4gICAgYy5kb25lID0gTWF0aC5hYnModGFyZ2V0IC0gbmV3UG9zaXRpb24pICsgTWF0aC5hYnModmVsb2NpdHkpIDwgMC4wMDJcbiAgICByZXR1cm4gYy5kb25lID8gdGFyZ2V0IDogbmV3UG9zaXRpb25cbiAgfVxufVxuXG5leHRlbmQoU3ByaW5nLCB7XG4gIGR1cmF0aW9uOiBtYWtlU2V0dGVyR2V0dGVyKCdfZHVyYXRpb24nLCByZWNhbGN1bGF0ZSksXG4gIG92ZXJzaG9vdDogbWFrZVNldHRlckdldHRlcignX292ZXJzaG9vdCcsIHJlY2FsY3VsYXRlKVxufSlcblxuZXhwb3J0IGNsYXNzIFBJRCBleHRlbmRzIENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihwID0gMC4xLCBpID0gMC4wMSwgZCA9IDAsIHdpbmR1cCA9IDEwMDApIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5wKHApLmkoaSkuZChkKS53aW5kdXAod2luZHVwKVxuICB9XG5cbiAgc3RlcChjdXJyZW50LCB0YXJnZXQsIGR0LCBjKSB7XG4gICAgaWYgKHR5cGVvZiBjdXJyZW50ID09PSAnc3RyaW5nJykgcmV0dXJuIGN1cnJlbnRcbiAgICBjLmRvbmUgPSBkdCA9PT0gSW5maW5pdHlcblxuICAgIGlmIChkdCA9PT0gSW5maW5pdHkpIHJldHVybiB0YXJnZXRcbiAgICBpZiAoZHQgPT09IDApIHJldHVybiBjdXJyZW50XG5cbiAgICBjb25zdCBwID0gdGFyZ2V0IC0gY3VycmVudFxuICAgIGxldCBpID0gKGMuaW50ZWdyYWwgfHwgMCkgKyBwICogZHRcbiAgICBjb25zdCBkID0gKHAgLSAoYy5lcnJvciB8fCAwKSkgLyBkdFxuICAgIGNvbnN0IHdpbmR1cCA9IHRoaXMuX3dpbmR1cFxuXG4gICAgLy8gYW50aXdpbmR1cFxuICAgIGlmICh3aW5kdXAgIT09IGZhbHNlKSB7XG4gICAgICBpID0gTWF0aC5tYXgoLXdpbmR1cCwgTWF0aC5taW4oaSwgd2luZHVwKSlcbiAgICB9XG5cbiAgICBjLmVycm9yID0gcFxuICAgIGMuaW50ZWdyYWwgPSBpXG5cbiAgICBjLmRvbmUgPSBNYXRoLmFicyhwKSA8IDAuMDAxXG5cbiAgICByZXR1cm4gYy5kb25lID8gdGFyZ2V0IDogY3VycmVudCArICh0aGlzLlAgKiBwICsgdGhpcy5JICogaSArIHRoaXMuRCAqIGQpXG4gIH1cbn1cblxuZXh0ZW5kKFBJRCwge1xuICB3aW5kdXA6IG1ha2VTZXR0ZXJHZXR0ZXIoJ193aW5kdXAnKSxcbiAgcDogbWFrZVNldHRlckdldHRlcignUCcpLFxuICBpOiBtYWtlU2V0dGVyR2V0dGVyKCdJJyksXG4gIGQ6IG1ha2VTZXR0ZXJHZXR0ZXIoJ0QnKVxufSlcbiIsImltcG9ydCB7IGlzUGF0aExldHRlciB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9yZWdleC5qcydcbmltcG9ydCBQb2ludCBmcm9tICcuLi90eXBlcy9Qb2ludC5qcydcblxuY29uc3Qgc2VnbWVudFBhcmFtZXRlcnMgPSB7XG4gIE06IDIsXG4gIEw6IDIsXG4gIEg6IDEsXG4gIFY6IDEsXG4gIEM6IDYsXG4gIFM6IDQsXG4gIFE6IDQsXG4gIFQ6IDIsXG4gIEE6IDcsXG4gIFo6IDBcbn1cblxuY29uc3QgcGF0aEhhbmRsZXJzID0ge1xuICBNOiBmdW5jdGlvbiAoYywgcCwgcDApIHtcbiAgICBwLnggPSBwMC54ID0gY1swXVxuICAgIHAueSA9IHAwLnkgPSBjWzFdXG5cbiAgICByZXR1cm4gWydNJywgcC54LCBwLnldXG4gIH0sXG4gIEw6IGZ1bmN0aW9uIChjLCBwKSB7XG4gICAgcC54ID0gY1swXVxuICAgIHAueSA9IGNbMV1cbiAgICByZXR1cm4gWydMJywgY1swXSwgY1sxXV1cbiAgfSxcbiAgSDogZnVuY3Rpb24gKGMsIHApIHtcbiAgICBwLnggPSBjWzBdXG4gICAgcmV0dXJuIFsnSCcsIGNbMF1dXG4gIH0sXG4gIFY6IGZ1bmN0aW9uIChjLCBwKSB7XG4gICAgcC55ID0gY1swXVxuICAgIHJldHVybiBbJ1YnLCBjWzBdXVxuICB9LFxuICBDOiBmdW5jdGlvbiAoYywgcCkge1xuICAgIHAueCA9IGNbNF1cbiAgICBwLnkgPSBjWzVdXG4gICAgcmV0dXJuIFsnQycsIGNbMF0sIGNbMV0sIGNbMl0sIGNbM10sIGNbNF0sIGNbNV1dXG4gIH0sXG4gIFM6IGZ1bmN0aW9uIChjLCBwKSB7XG4gICAgcC54ID0gY1syXVxuICAgIHAueSA9IGNbM11cbiAgICByZXR1cm4gWydTJywgY1swXSwgY1sxXSwgY1syXSwgY1szXV1cbiAgfSxcbiAgUTogZnVuY3Rpb24gKGMsIHApIHtcbiAgICBwLnggPSBjWzJdXG4gICAgcC55ID0gY1szXVxuICAgIHJldHVybiBbJ1EnLCBjWzBdLCBjWzFdLCBjWzJdLCBjWzNdXVxuICB9LFxuICBUOiBmdW5jdGlvbiAoYywgcCkge1xuICAgIHAueCA9IGNbMF1cbiAgICBwLnkgPSBjWzFdXG4gICAgcmV0dXJuIFsnVCcsIGNbMF0sIGNbMV1dXG4gIH0sXG4gIFo6IGZ1bmN0aW9uIChjLCBwLCBwMCkge1xuICAgIHAueCA9IHAwLnhcbiAgICBwLnkgPSBwMC55XG4gICAgcmV0dXJuIFsnWiddXG4gIH0sXG4gIEE6IGZ1bmN0aW9uIChjLCBwKSB7XG4gICAgcC54ID0gY1s1XVxuICAgIHAueSA9IGNbNl1cbiAgICByZXR1cm4gWydBJywgY1swXSwgY1sxXSwgY1syXSwgY1szXSwgY1s0XSwgY1s1XSwgY1s2XV1cbiAgfVxufVxuXG5jb25zdCBtbGh2cXRjc2F6ID0gJ21saHZxdGNzYXonLnNwbGl0KCcnKVxuXG5mb3IgKGxldCBpID0gMCwgaWwgPSBtbGh2cXRjc2F6Lmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgcGF0aEhhbmRsZXJzW21saHZxdGNzYXpbaV1dID0gKGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjLCBwLCBwMCkge1xuICAgICAgaWYgKGkgPT09ICdIJykgY1swXSA9IGNbMF0gKyBwLnhcbiAgICAgIGVsc2UgaWYgKGkgPT09ICdWJykgY1swXSA9IGNbMF0gKyBwLnlcbiAgICAgIGVsc2UgaWYgKGkgPT09ICdBJykge1xuICAgICAgICBjWzVdID0gY1s1XSArIHAueFxuICAgICAgICBjWzZdID0gY1s2XSArIHAueVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gYy5sZW5ndGg7IGogPCBqbDsgKytqKSB7XG4gICAgICAgICAgY1tqXSA9IGNbal0gKyAoaiAlIDIgPyBwLnkgOiBwLngpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGhIYW5kbGVyc1tpXShjLCBwLCBwMClcbiAgICB9XG4gIH0pKG1saHZxdGNzYXpbaV0udG9VcHBlckNhc2UoKSlcbn1cblxuZnVuY3Rpb24gbWFrZUFic29sdXQocGFyc2VyKSB7XG4gIGNvbnN0IGNvbW1hbmQgPSBwYXJzZXIuc2VnbWVudFswXVxuICByZXR1cm4gcGF0aEhhbmRsZXJzW2NvbW1hbmRdKHBhcnNlci5zZWdtZW50LnNsaWNlKDEpLCBwYXJzZXIucCwgcGFyc2VyLnAwKVxufVxuXG5mdW5jdGlvbiBzZWdtZW50Q29tcGxldGUocGFyc2VyKSB7XG4gIHJldHVybiAoXG4gICAgcGFyc2VyLnNlZ21lbnQubGVuZ3RoICYmXG4gICAgcGFyc2VyLnNlZ21lbnQubGVuZ3RoIC0gMSA9PT1cbiAgICAgIHNlZ21lbnRQYXJhbWV0ZXJzW3BhcnNlci5zZWdtZW50WzBdLnRvVXBwZXJDYXNlKCldXG4gIClcbn1cblxuZnVuY3Rpb24gc3RhcnROZXdTZWdtZW50KHBhcnNlciwgdG9rZW4pIHtcbiAgcGFyc2VyLmluTnVtYmVyICYmIGZpbmFsaXplTnVtYmVyKHBhcnNlciwgZmFsc2UpXG4gIGNvbnN0IHBhdGhMZXR0ZXIgPSBpc1BhdGhMZXR0ZXIudGVzdCh0b2tlbilcblxuICBpZiAocGF0aExldHRlcikge1xuICAgIHBhcnNlci5zZWdtZW50ID0gW3Rva2VuXVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxhc3RDb21tYW5kID0gcGFyc2VyLmxhc3RDb21tYW5kXG4gICAgY29uc3Qgc21hbGwgPSBsYXN0Q29tbWFuZC50b0xvd2VyQ2FzZSgpXG4gICAgY29uc3QgaXNTbWFsbCA9IGxhc3RDb21tYW5kID09PSBzbWFsbFxuICAgIHBhcnNlci5zZWdtZW50ID0gW3NtYWxsID09PSAnbScgPyAoaXNTbWFsbCA/ICdsJyA6ICdMJykgOiBsYXN0Q29tbWFuZF1cbiAgfVxuXG4gIHBhcnNlci5pblNlZ21lbnQgPSB0cnVlXG4gIHBhcnNlci5sYXN0Q29tbWFuZCA9IHBhcnNlci5zZWdtZW50WzBdXG5cbiAgcmV0dXJuIHBhdGhMZXR0ZXJcbn1cblxuZnVuY3Rpb24gZmluYWxpemVOdW1iZXIocGFyc2VyLCBpbk51bWJlcikge1xuICBpZiAoIXBhcnNlci5pbk51bWJlcikgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIgRXJyb3InKVxuICBwYXJzZXIubnVtYmVyICYmIHBhcnNlci5zZWdtZW50LnB1c2gocGFyc2VGbG9hdChwYXJzZXIubnVtYmVyKSlcbiAgcGFyc2VyLmluTnVtYmVyID0gaW5OdW1iZXJcbiAgcGFyc2VyLm51bWJlciA9ICcnXG4gIHBhcnNlci5wb2ludFNlZW4gPSBmYWxzZVxuICBwYXJzZXIuaGFzRXhwb25lbnQgPSBmYWxzZVxuXG4gIGlmIChzZWdtZW50Q29tcGxldGUocGFyc2VyKSkge1xuICAgIGZpbmFsaXplU2VnbWVudChwYXJzZXIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZmluYWxpemVTZWdtZW50KHBhcnNlcikge1xuICBwYXJzZXIuaW5TZWdtZW50ID0gZmFsc2VcbiAgaWYgKHBhcnNlci5hYnNvbHV0ZSkge1xuICAgIHBhcnNlci5zZWdtZW50ID0gbWFrZUFic29sdXQocGFyc2VyKVxuICB9XG4gIHBhcnNlci5zZWdtZW50cy5wdXNoKHBhcnNlci5zZWdtZW50KVxufVxuXG5mdW5jdGlvbiBpc0FyY0ZsYWcocGFyc2VyKSB7XG4gIGlmICghcGFyc2VyLnNlZ21lbnQubGVuZ3RoKSByZXR1cm4gZmFsc2VcbiAgY29uc3QgaXNBcmMgPSBwYXJzZXIuc2VnbWVudFswXS50b1VwcGVyQ2FzZSgpID09PSAnQSdcbiAgY29uc3QgbGVuZ3RoID0gcGFyc2VyLnNlZ21lbnQubGVuZ3RoXG5cbiAgcmV0dXJuIGlzQXJjICYmIChsZW5ndGggPT09IDQgfHwgbGVuZ3RoID09PSA1KVxufVxuXG5mdW5jdGlvbiBpc0V4cG9uZW50aWFsKHBhcnNlcikge1xuICByZXR1cm4gcGFyc2VyLmxhc3RUb2tlbi50b1VwcGVyQ2FzZSgpID09PSAnRSdcbn1cblxuY29uc3QgcGF0aERlbGltaXRlcnMgPSBuZXcgU2V0KFsnICcsICcsJywgJ1xcdCcsICdcXG4nLCAnXFxyJywgJ1xcZiddKVxuZXhwb3J0IGZ1bmN0aW9uIHBhdGhQYXJzZXIoZCwgdG9BYnNvbHV0ZSA9IHRydWUpIHtcbiAgbGV0IGluZGV4ID0gMFxuICBsZXQgdG9rZW4gPSAnJ1xuICBjb25zdCBwYXJzZXIgPSB7XG4gICAgc2VnbWVudDogW10sXG4gICAgaW5OdW1iZXI6IGZhbHNlLFxuICAgIG51bWJlcjogJycsXG4gICAgbGFzdFRva2VuOiAnJyxcbiAgICBpblNlZ21lbnQ6IGZhbHNlLFxuICAgIHNlZ21lbnRzOiBbXSxcbiAgICBwb2ludFNlZW46IGZhbHNlLFxuICAgIGhhc0V4cG9uZW50OiBmYWxzZSxcbiAgICBhYnNvbHV0ZTogdG9BYnNvbHV0ZSxcbiAgICBwMDogbmV3IFBvaW50KCksXG4gICAgcDogbmV3IFBvaW50KClcbiAgfVxuXG4gIHdoaWxlICgoKHBhcnNlci5sYXN0VG9rZW4gPSB0b2tlbiksICh0b2tlbiA9IGQuY2hhckF0KGluZGV4KyspKSkpIHtcbiAgICBpZiAoIXBhcnNlci5pblNlZ21lbnQpIHtcbiAgICAgIGlmIChzdGFydE5ld1NlZ21lbnQocGFyc2VyLCB0b2tlbikpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodG9rZW4gPT09ICcuJykge1xuICAgICAgaWYgKHBhcnNlci5wb2ludFNlZW4gfHwgcGFyc2VyLmhhc0V4cG9uZW50KSB7XG4gICAgICAgIGZpbmFsaXplTnVtYmVyKHBhcnNlciwgZmFsc2UpXG4gICAgICAgIC0taW5kZXhcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIHBhcnNlci5pbk51bWJlciA9IHRydWVcbiAgICAgIHBhcnNlci5wb2ludFNlZW4gPSB0cnVlXG4gICAgICBwYXJzZXIubnVtYmVyICs9IHRva2VuXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmICghaXNOYU4ocGFyc2VJbnQodG9rZW4pKSkge1xuICAgICAgaWYgKHBhcnNlci5udW1iZXIgPT09ICcwJyB8fCBpc0FyY0ZsYWcocGFyc2VyKSkge1xuICAgICAgICBwYXJzZXIuaW5OdW1iZXIgPSB0cnVlXG4gICAgICAgIHBhcnNlci5udW1iZXIgPSB0b2tlblxuICAgICAgICBmaW5hbGl6ZU51bWJlcihwYXJzZXIsIHRydWUpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHBhcnNlci5pbk51bWJlciA9IHRydWVcbiAgICAgIHBhcnNlci5udW1iZXIgKz0gdG9rZW5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKHBhdGhEZWxpbWl0ZXJzLmhhcyh0b2tlbikpIHtcbiAgICAgIGlmIChwYXJzZXIuaW5OdW1iZXIpIHtcbiAgICAgICAgZmluYWxpemVOdW1iZXIocGFyc2VyLCBmYWxzZSlcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKHRva2VuID09PSAnLScgfHwgdG9rZW4gPT09ICcrJykge1xuICAgICAgaWYgKHBhcnNlci5pbk51bWJlciAmJiAhaXNFeHBvbmVudGlhbChwYXJzZXIpKSB7XG4gICAgICAgIGZpbmFsaXplTnVtYmVyKHBhcnNlciwgZmFsc2UpXG4gICAgICAgIC0taW5kZXhcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIHBhcnNlci5udW1iZXIgKz0gdG9rZW5cbiAgICAgIHBhcnNlci5pbk51bWJlciA9IHRydWVcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnRvVXBwZXJDYXNlKCkgPT09ICdFJykge1xuICAgICAgcGFyc2VyLm51bWJlciArPSB0b2tlblxuICAgICAgcGFyc2VyLmhhc0V4cG9uZW50ID0gdHJ1ZVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoaXNQYXRoTGV0dGVyLnRlc3QodG9rZW4pKSB7XG4gICAgICBpZiAocGFyc2VyLmluTnVtYmVyKSB7XG4gICAgICAgIGZpbmFsaXplTnVtYmVyKHBhcnNlciwgZmFsc2UpXG4gICAgICB9IGVsc2UgaWYgKCFzZWdtZW50Q29tcGxldGUocGFyc2VyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnNlciBFcnJvcicpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5hbGl6ZVNlZ21lbnQocGFyc2VyKVxuICAgICAgfVxuICAgICAgLS1pbmRleFxuICAgIH1cbiAgfVxuXG4gIGlmIChwYXJzZXIuaW5OdW1iZXIpIHtcbiAgICBmaW5hbGl6ZU51bWJlcihwYXJzZXIsIGZhbHNlKVxuICB9XG5cbiAgaWYgKHBhcnNlci5pblNlZ21lbnQgJiYgc2VnbWVudENvbXBsZXRlKHBhcnNlcikpIHtcbiAgICBmaW5hbGl6ZVNlZ21lbnQocGFyc2VyKVxuICB9XG5cbiAgcmV0dXJuIHBhcnNlci5zZWdtZW50c1xufVxuIiwiaW1wb3J0IFNWR0FycmF5IGZyb20gJy4vU1ZHQXJyYXkuanMnXG5pbXBvcnQgcGFyc2VyIGZyb20gJy4uL21vZHVsZXMvY29yZS9wYXJzZXIuanMnXG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJ1xuaW1wb3J0IHsgcGF0aFBhcnNlciB9IGZyb20gJy4uL3V0aWxzL3BhdGhQYXJzZXIuanMnXG5cbmZ1bmN0aW9uIGFycmF5VG9TdHJpbmcoYSkge1xuICBsZXQgcyA9ICcnXG4gIGZvciAobGV0IGkgPSAwLCBpbCA9IGEubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIHMgKz0gYVtpXVswXVxuXG4gICAgaWYgKGFbaV1bMV0gIT0gbnVsbCkge1xuICAgICAgcyArPSBhW2ldWzFdXG5cbiAgICAgIGlmIChhW2ldWzJdICE9IG51bGwpIHtcbiAgICAgICAgcyArPSAnICdcbiAgICAgICAgcyArPSBhW2ldWzJdXG5cbiAgICAgICAgaWYgKGFbaV1bM10gIT0gbnVsbCkge1xuICAgICAgICAgIHMgKz0gJyAnXG4gICAgICAgICAgcyArPSBhW2ldWzNdXG4gICAgICAgICAgcyArPSAnICdcbiAgICAgICAgICBzICs9IGFbaV1bNF1cblxuICAgICAgICAgIGlmIChhW2ldWzVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHMgKz0gJyAnXG4gICAgICAgICAgICBzICs9IGFbaV1bNV1cbiAgICAgICAgICAgIHMgKz0gJyAnXG4gICAgICAgICAgICBzICs9IGFbaV1bNl1cblxuICAgICAgICAgICAgaWYgKGFbaV1bN10gIT0gbnVsbCkge1xuICAgICAgICAgICAgICBzICs9ICcgJ1xuICAgICAgICAgICAgICBzICs9IGFbaV1bN11cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcyArICcgJ1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXRoQXJyYXkgZXh0ZW5kcyBTVkdBcnJheSB7XG4gIC8vIEdldCBib3VuZGluZyBib3ggb2YgcGF0aFxuICBiYm94KCkge1xuICAgIHBhcnNlcigpLnBhdGguc2V0QXR0cmlidXRlKCdkJywgdGhpcy50b1N0cmluZygpKVxuICAgIHJldHVybiBuZXcgQm94KHBhcnNlci5ub2Rlcy5wYXRoLmdldEJCb3goKSlcbiAgfVxuXG4gIC8vIE1vdmUgcGF0aCBzdHJpbmdcbiAgbW92ZSh4LCB5KSB7XG4gICAgLy8gZ2V0IGJvdW5kaW5nIGJveCBvZiBjdXJyZW50IHNpdHVhdGlvblxuICAgIGNvbnN0IGJveCA9IHRoaXMuYmJveCgpXG5cbiAgICAvLyBnZXQgcmVsYXRpdmUgb2Zmc2V0XG4gICAgeCAtPSBib3gueFxuICAgIHkgLT0gYm94LnlcblxuICAgIGlmICghaXNOYU4oeCkgJiYgIWlzTmFOKHkpKSB7XG4gICAgICAvLyBtb3ZlIGV2ZXJ5IHBvaW50XG4gICAgICBmb3IgKGxldCBsLCBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsID0gdGhpc1tpXVswXVxuXG4gICAgICAgIGlmIChsID09PSAnTScgfHwgbCA9PT0gJ0wnIHx8IGwgPT09ICdUJykge1xuICAgICAgICAgIHRoaXNbaV1bMV0gKz0geFxuICAgICAgICAgIHRoaXNbaV1bMl0gKz0geVxuICAgICAgICB9IGVsc2UgaWYgKGwgPT09ICdIJykge1xuICAgICAgICAgIHRoaXNbaV1bMV0gKz0geFxuICAgICAgICB9IGVsc2UgaWYgKGwgPT09ICdWJykge1xuICAgICAgICAgIHRoaXNbaV1bMV0gKz0geVxuICAgICAgICB9IGVsc2UgaWYgKGwgPT09ICdDJyB8fCBsID09PSAnUycgfHwgbCA9PT0gJ1EnKSB7XG4gICAgICAgICAgdGhpc1tpXVsxXSArPSB4XG4gICAgICAgICAgdGhpc1tpXVsyXSArPSB5XG4gICAgICAgICAgdGhpc1tpXVszXSArPSB4XG4gICAgICAgICAgdGhpc1tpXVs0XSArPSB5XG5cbiAgICAgICAgICBpZiAobCA9PT0gJ0MnKSB7XG4gICAgICAgICAgICB0aGlzW2ldWzVdICs9IHhcbiAgICAgICAgICAgIHRoaXNbaV1bNl0gKz0geVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsID09PSAnQScpIHtcbiAgICAgICAgICB0aGlzW2ldWzZdICs9IHhcbiAgICAgICAgICB0aGlzW2ldWzddICs9IHlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBBYnNvbHV0aXplIGFuZCBwYXJzZSBwYXRoIHRvIGFycmF5XG4gIHBhcnNlKGQgPSAnTTAgMCcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkKSkge1xuICAgICAgZCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGQpLnRvU3RyaW5nKClcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aFBhcnNlcihkKVxuICB9XG5cbiAgLy8gUmVzaXplIHBhdGggc3RyaW5nXG4gIHNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIC8vIGdldCBib3VuZGluZyBib3ggb2YgY3VycmVudCBzaXR1YXRpb25cbiAgICBjb25zdCBib3ggPSB0aGlzLmJib3goKVxuICAgIGxldCBpLCBsXG5cbiAgICAvLyBJZiB0aGUgYm94IHdpZHRoIG9yIGhlaWdodCBpcyAwIHRoZW4gd2UgaWdub3JlXG4gICAgLy8gdHJhbnNmb3JtYXRpb25zIG9uIHRoZSByZXNwZWN0aXZlIGF4aXNcbiAgICBib3gud2lkdGggPSBib3gud2lkdGggPT09IDAgPyAxIDogYm94LndpZHRoXG4gICAgYm94LmhlaWdodCA9IGJveC5oZWlnaHQgPT09IDAgPyAxIDogYm94LmhlaWdodFxuXG4gICAgLy8gcmVjYWxjdWxhdGUgcG9zaXRpb24gb2YgYWxsIHBvaW50cyBhY2NvcmRpbmcgdG8gbmV3IHNpemVcbiAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBsID0gdGhpc1tpXVswXVxuXG4gICAgICBpZiAobCA9PT0gJ00nIHx8IGwgPT09ICdMJyB8fCBsID09PSAnVCcpIHtcbiAgICAgICAgdGhpc1tpXVsxXSA9ICgodGhpc1tpXVsxXSAtIGJveC54KSAqIHdpZHRoKSAvIGJveC53aWR0aCArIGJveC54XG4gICAgICAgIHRoaXNbaV1bMl0gPSAoKHRoaXNbaV1bMl0gLSBib3gueSkgKiBoZWlnaHQpIC8gYm94LmhlaWdodCArIGJveC55XG4gICAgICB9IGVsc2UgaWYgKGwgPT09ICdIJykge1xuICAgICAgICB0aGlzW2ldWzFdID0gKCh0aGlzW2ldWzFdIC0gYm94LngpICogd2lkdGgpIC8gYm94LndpZHRoICsgYm94LnhcbiAgICAgIH0gZWxzZSBpZiAobCA9PT0gJ1YnKSB7XG4gICAgICAgIHRoaXNbaV1bMV0gPSAoKHRoaXNbaV1bMV0gLSBib3gueSkgKiBoZWlnaHQpIC8gYm94LmhlaWdodCArIGJveC55XG4gICAgICB9IGVsc2UgaWYgKGwgPT09ICdDJyB8fCBsID09PSAnUycgfHwgbCA9PT0gJ1EnKSB7XG4gICAgICAgIHRoaXNbaV1bMV0gPSAoKHRoaXNbaV1bMV0gLSBib3gueCkgKiB3aWR0aCkgLyBib3gud2lkdGggKyBib3gueFxuICAgICAgICB0aGlzW2ldWzJdID0gKCh0aGlzW2ldWzJdIC0gYm94LnkpICogaGVpZ2h0KSAvIGJveC5oZWlnaHQgKyBib3gueVxuICAgICAgICB0aGlzW2ldWzNdID0gKCh0aGlzW2ldWzNdIC0gYm94LngpICogd2lkdGgpIC8gYm94LndpZHRoICsgYm94LnhcbiAgICAgICAgdGhpc1tpXVs0XSA9ICgodGhpc1tpXVs0XSAtIGJveC55KSAqIGhlaWdodCkgLyBib3guaGVpZ2h0ICsgYm94LnlcblxuICAgICAgICBpZiAobCA9PT0gJ0MnKSB7XG4gICAgICAgICAgdGhpc1tpXVs1XSA9ICgodGhpc1tpXVs1XSAtIGJveC54KSAqIHdpZHRoKSAvIGJveC53aWR0aCArIGJveC54XG4gICAgICAgICAgdGhpc1tpXVs2XSA9ICgodGhpc1tpXVs2XSAtIGJveC55KSAqIGhlaWdodCkgLyBib3guaGVpZ2h0ICsgYm94LnlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsID09PSAnQScpIHtcbiAgICAgICAgLy8gcmVzaXplIHJhZGlpXG4gICAgICAgIHRoaXNbaV1bMV0gPSAodGhpc1tpXVsxXSAqIHdpZHRoKSAvIGJveC53aWR0aFxuICAgICAgICB0aGlzW2ldWzJdID0gKHRoaXNbaV1bMl0gKiBoZWlnaHQpIC8gYm94LmhlaWdodFxuXG4gICAgICAgIC8vIG1vdmUgcG9zaXRpb24gdmFsdWVzXG4gICAgICAgIHRoaXNbaV1bNl0gPSAoKHRoaXNbaV1bNl0gLSBib3gueCkgKiB3aWR0aCkgLyBib3gud2lkdGggKyBib3gueFxuICAgICAgICB0aGlzW2ldWzddID0gKCh0aGlzW2ldWzddIC0gYm94LnkpICogaGVpZ2h0KSAvIGJveC5oZWlnaHQgKyBib3gueVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBDb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYXJyYXlUb1N0cmluZyh0aGlzKVxuICB9XG59XG4iLCJpbXBvcnQgeyBFYXNlIH0gZnJvbSAnLi9Db250cm9sbGVyLmpzJ1xuaW1wb3J0IHtcbiAgZGVsaW1pdGVyLFxuICBudW1iZXJBbmRVbml0LFxuICBpc1BhdGhMZXR0ZXJcbn0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3JlZ2V4LmpzJ1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCBDb2xvciBmcm9tICcuLi90eXBlcy9Db2xvci5qcydcbmltcG9ydCBQYXRoQXJyYXkgZnJvbSAnLi4vdHlwZXMvUGF0aEFycmF5LmpzJ1xuaW1wb3J0IFNWR0FycmF5IGZyb20gJy4uL3R5cGVzL1NWR0FycmF5LmpzJ1xuaW1wb3J0IFNWR051bWJlciBmcm9tICcuLi90eXBlcy9TVkdOdW1iZXIuanMnXG5cbmNvbnN0IGdldENsYXNzRm9yVHlwZSA9ICh2YWx1ZSkgPT4ge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlXG5cbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIFNWR051bWJlclxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKENvbG9yLmlzQ29sb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gQ29sb3JcbiAgICB9IGVsc2UgaWYgKGRlbGltaXRlci50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGlzUGF0aExldHRlci50ZXN0KHZhbHVlKSA/IFBhdGhBcnJheSA6IFNWR0FycmF5XG4gICAgfSBlbHNlIGlmIChudW1iZXJBbmRVbml0LnRlc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gU1ZHTnVtYmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBOb25Nb3JwaGFibGVcbiAgICB9XG4gIH0gZWxzZSBpZiAobW9ycGhhYmxlVHlwZXMuaW5kZXhPZih2YWx1ZS5jb25zdHJ1Y3RvcikgPiAtMSkge1xuICAgIHJldHVybiB2YWx1ZS5jb25zdHJ1Y3RvclxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIFNWR0FycmF5XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gT2JqZWN0QmFnXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE5vbk1vcnBoYWJsZVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vcnBoYWJsZSB7XG4gIGNvbnN0cnVjdG9yKHN0ZXBwZXIpIHtcbiAgICB0aGlzLl9zdGVwcGVyID0gc3RlcHBlciB8fCBuZXcgRWFzZSgnLScpXG5cbiAgICB0aGlzLl9mcm9tID0gbnVsbFxuICAgIHRoaXMuX3RvID0gbnVsbFxuICAgIHRoaXMuX3R5cGUgPSBudWxsXG4gICAgdGhpcy5fY29udGV4dCA9IG51bGxcbiAgICB0aGlzLl9tb3JwaE9iaiA9IG51bGxcbiAgfVxuXG4gIGF0KHBvcykge1xuICAgIHJldHVybiB0aGlzLl9tb3JwaE9iai5tb3JwaChcbiAgICAgIHRoaXMuX2Zyb20sXG4gICAgICB0aGlzLl90byxcbiAgICAgIHBvcyxcbiAgICAgIHRoaXMuX3N0ZXBwZXIsXG4gICAgICB0aGlzLl9jb250ZXh0XG4gICAgKVxuICB9XG5cbiAgZG9uZSgpIHtcbiAgICBjb25zdCBjb21wbGV0ZSA9IHRoaXMuX2NvbnRleHQubWFwKHRoaXMuX3N0ZXBwZXIuZG9uZSkucmVkdWNlKGZ1bmN0aW9uIChcbiAgICAgIGxhc3QsXG4gICAgICBjdXJyXG4gICAgKSB7XG4gICAgICByZXR1cm4gbGFzdCAmJiBjdXJyXG4gICAgfSwgdHJ1ZSlcbiAgICByZXR1cm4gY29tcGxldGVcbiAgfVxuXG4gIGZyb20odmFsKSB7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZnJvbVxuICAgIH1cblxuICAgIHRoaXMuX2Zyb20gPSB0aGlzLl9zZXQodmFsKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGVwcGVyKHN0ZXBwZXIpIHtcbiAgICBpZiAoc3RlcHBlciA9PSBudWxsKSByZXR1cm4gdGhpcy5fc3RlcHBlclxuICAgIHRoaXMuX3N0ZXBwZXIgPSBzdGVwcGVyXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRvKHZhbCkge1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RvXG4gICAgfVxuXG4gICAgdGhpcy5fdG8gPSB0aGlzLl9zZXQodmFsKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB0eXBlKHR5cGUpIHtcbiAgICAvLyBnZXR0ZXJcbiAgICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHlwZVxuICAgIH1cblxuICAgIC8vIHNldHRlclxuICAgIHRoaXMuX3R5cGUgPSB0eXBlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIF9zZXQodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuX3R5cGUpIHtcbiAgICAgIHRoaXMudHlwZShnZXRDbGFzc0ZvclR5cGUodmFsdWUpKVxuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSBuZXcgdGhpcy5fdHlwZSh2YWx1ZSlcbiAgICBpZiAodGhpcy5fdHlwZSA9PT0gQ29sb3IpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX3RvXG4gICAgICAgID8gcmVzdWx0W3RoaXMuX3RvWzRdXSgpXG4gICAgICAgIDogdGhpcy5fZnJvbVxuICAgICAgICAgID8gcmVzdWx0W3RoaXMuX2Zyb21bNF1dKClcbiAgICAgICAgICA6IHJlc3VsdFxuICAgIH1cblxuICAgIGlmICh0aGlzLl90eXBlID09PSBPYmplY3RCYWcpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX3RvXG4gICAgICAgID8gcmVzdWx0LmFsaWduKHRoaXMuX3RvKVxuICAgICAgICA6IHRoaXMuX2Zyb21cbiAgICAgICAgICA/IHJlc3VsdC5hbGlnbih0aGlzLl9mcm9tKVxuICAgICAgICAgIDogcmVzdWx0XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gcmVzdWx0LnRvQ29uc3VtYWJsZSgpXG5cbiAgICB0aGlzLl9tb3JwaE9iaiA9IHRoaXMuX21vcnBoT2JqIHx8IG5ldyB0aGlzLl90eXBlKClcbiAgICB0aGlzLl9jb250ZXh0ID1cbiAgICAgIHRoaXMuX2NvbnRleHQgfHxcbiAgICAgIEFycmF5LmFwcGx5KG51bGwsIEFycmF5KHJlc3VsdC5sZW5ndGgpKVxuICAgICAgICAubWFwKE9iamVjdClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAobykge1xuICAgICAgICAgIG8uZG9uZSA9IHRydWVcbiAgICAgICAgICByZXR1cm4gb1xuICAgICAgICB9KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTm9uTW9ycGhhYmxlIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHRoaXMuaW5pdCguLi5hcmdzKVxuICB9XG5cbiAgaW5pdCh2YWwpIHtcbiAgICB2YWwgPSBBcnJheS5pc0FycmF5KHZhbCkgPyB2YWxbMF0gOiB2YWxcbiAgICB0aGlzLnZhbHVlID0gdmFsXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIFt0aGlzLnZhbHVlXVxuICB9XG5cbiAgdmFsdWVPZigpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBUcmFuc2Zvcm1CYWcge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgdGhpcy5pbml0KC4uLmFyZ3MpXG4gIH1cblxuICBpbml0KG9iaikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIG9iaiA9IHtcbiAgICAgICAgc2NhbGVYOiBvYmpbMF0sXG4gICAgICAgIHNjYWxlWTogb2JqWzFdLFxuICAgICAgICBzaGVhcjogb2JqWzJdLFxuICAgICAgICByb3RhdGU6IG9ialszXSxcbiAgICAgICAgdHJhbnNsYXRlWDogb2JqWzRdLFxuICAgICAgICB0cmFuc2xhdGVZOiBvYmpbNV0sXG4gICAgICAgIG9yaWdpblg6IG9ials2XSxcbiAgICAgICAgb3JpZ2luWTogb2JqWzddXG4gICAgICB9XG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBUcmFuc2Zvcm1CYWcuZGVmYXVsdHMsIG9iailcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdG9BcnJheSgpIHtcbiAgICBjb25zdCB2ID0gdGhpc1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIHYuc2NhbGVYLFxuICAgICAgdi5zY2FsZVksXG4gICAgICB2LnNoZWFyLFxuICAgICAgdi5yb3RhdGUsXG4gICAgICB2LnRyYW5zbGF0ZVgsXG4gICAgICB2LnRyYW5zbGF0ZVksXG4gICAgICB2Lm9yaWdpblgsXG4gICAgICB2Lm9yaWdpbllcbiAgICBdXG4gIH1cbn1cblxuVHJhbnNmb3JtQmFnLmRlZmF1bHRzID0ge1xuICBzY2FsZVg6IDEsXG4gIHNjYWxlWTogMSxcbiAgc2hlYXI6IDAsXG4gIHJvdGF0ZTogMCxcbiAgdHJhbnNsYXRlWDogMCxcbiAgdHJhbnNsYXRlWTogMCxcbiAgb3JpZ2luWDogMCxcbiAgb3JpZ2luWTogMFxufVxuXG5jb25zdCBzb3J0QnlLZXkgPSAoYSwgYikgPT4ge1xuICByZXR1cm4gYVswXSA8IGJbMF0gPyAtMSA6IGFbMF0gPiBiWzBdID8gMSA6IDBcbn1cblxuZXhwb3J0IGNsYXNzIE9iamVjdEJhZyB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmluaXQoLi4uYXJncylcbiAgfVxuXG4gIGFsaWduKG90aGVyKSB7XG4gICAgY29uc3QgdmFsdWVzID0gdGhpcy52YWx1ZXNcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSB2YWx1ZXMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgLy8gSWYgdGhlIHR5cGUgaXMgdGhlIHNhbWUgd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBjb2xvciBpcyBpbiB0aGUgY29ycmVjdCBmb3JtYXRcbiAgICAgIGlmICh2YWx1ZXNbaSArIDFdID09PSBvdGhlcltpICsgMV0pIHtcbiAgICAgICAgaWYgKHZhbHVlc1tpICsgMV0gPT09IENvbG9yICYmIG90aGVyW2kgKyA3XSAhPT0gdmFsdWVzW2kgKyA3XSkge1xuICAgICAgICAgIGNvbnN0IHNwYWNlID0gb3RoZXJbaSArIDddXG4gICAgICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IodGhpcy52YWx1ZXMuc3BsaWNlKGkgKyAzLCA1KSlcbiAgICAgICAgICAgIFtzcGFjZV0oKVxuICAgICAgICAgICAgLnRvQXJyYXkoKVxuICAgICAgICAgIHRoaXMudmFsdWVzLnNwbGljZShpICsgMywgMCwgLi4uY29sb3IpXG4gICAgICAgIH1cblxuICAgICAgICBpICs9IHZhbHVlc1tpICsgMl0gKyAyXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmICghb3RoZXJbaSArIDFdKSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSB0eXBlcyBkaWZmZXIsIHNvIHdlIG92ZXJ3cml0ZSB0aGUgbmV3IHR5cGUgd2l0aCB0aGUgb2xkIG9uZVxuICAgICAgLy8gQW5kIGluaXRpYWxpemUgaXQgd2l0aCB0aGUgdHlwZXMgZGVmYXVsdCAoZS5nLiBibGFjayBmb3IgY29sb3Igb3IgMCBmb3IgbnVtYmVyKVxuICAgICAgY29uc3QgZGVmYXVsdE9iamVjdCA9IG5ldyBvdGhlcltpICsgMV0oKS50b0FycmF5KClcblxuICAgICAgLy8gVGhhbiB3ZSBmaXggdGhlIHZhbHVlcyBhcnJheVxuICAgICAgY29uc3QgdG9EZWxldGUgPSB2YWx1ZXNbaSArIDJdICsgM1xuXG4gICAgICB2YWx1ZXMuc3BsaWNlKFxuICAgICAgICBpLFxuICAgICAgICB0b0RlbGV0ZSxcbiAgICAgICAgb3RoZXJbaV0sXG4gICAgICAgIG90aGVyW2kgKyAxXSxcbiAgICAgICAgb3RoZXJbaSArIDJdLFxuICAgICAgICAuLi5kZWZhdWx0T2JqZWN0XG4gICAgICApXG5cbiAgICAgIGkgKz0gdmFsdWVzW2kgKyAyXSArIDJcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGluaXQob2JqT3JBcnIpIHtcbiAgICB0aGlzLnZhbHVlcyA9IFtdXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpPckFycikpIHtcbiAgICAgIHRoaXMudmFsdWVzID0gb2JqT3JBcnIuc2xpY2UoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgb2JqT3JBcnIgPSBvYmpPckFyciB8fCB7fVxuICAgIGNvbnN0IGVudHJpZXMgPSBbXVxuXG4gICAgZm9yIChjb25zdCBpIGluIG9iak9yQXJyKSB7XG4gICAgICBjb25zdCBUeXBlID0gZ2V0Q2xhc3NGb3JUeXBlKG9iak9yQXJyW2ldKVxuICAgICAgY29uc3QgdmFsID0gbmV3IFR5cGUob2JqT3JBcnJbaV0pLnRvQXJyYXkoKVxuICAgICAgZW50cmllcy5wdXNoKFtpLCBUeXBlLCB2YWwubGVuZ3RoLCAuLi52YWxdKVxuICAgIH1cblxuICAgIGVudHJpZXMuc29ydChzb3J0QnlLZXkpXG5cbiAgICB0aGlzLnZhbHVlcyA9IGVudHJpZXMucmVkdWNlKChsYXN0LCBjdXJyKSA9PiBsYXN0LmNvbmNhdChjdXJyKSwgW10pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzXG4gIH1cblxuICB2YWx1ZU9mKCkge1xuICAgIGNvbnN0IG9iaiA9IHt9XG4gICAgY29uc3QgYXJyID0gdGhpcy52YWx1ZXNcblxuICAgIC8vIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB3aGlsZSAoYXJyLmxlbmd0aCkge1xuICAgICAgY29uc3Qga2V5ID0gYXJyLnNoaWZ0KClcbiAgICAgIGNvbnN0IFR5cGUgPSBhcnIuc2hpZnQoKVxuICAgICAgY29uc3QgbnVtID0gYXJyLnNoaWZ0KClcbiAgICAgIGNvbnN0IHZhbHVlcyA9IGFyci5zcGxpY2UoMCwgbnVtKVxuICAgICAgb2JqW2tleV0gPSBuZXcgVHlwZSh2YWx1ZXMpIC8vIC52YWx1ZU9mKClcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqXG4gIH1cbn1cblxuY29uc3QgbW9ycGhhYmxlVHlwZXMgPSBbTm9uTW9ycGhhYmxlLCBUcmFuc2Zvcm1CYWcsIE9iamVjdEJhZ11cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyTW9ycGhhYmxlVHlwZSh0eXBlID0gW10pIHtcbiAgbW9ycGhhYmxlVHlwZXMucHVzaCguLi5bXS5jb25jYXQodHlwZSkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlTW9ycGhhYmxlKCkge1xuICBleHRlbmQobW9ycGhhYmxlVHlwZXMsIHtcbiAgICB0byh2YWwpIHtcbiAgICAgIHJldHVybiBuZXcgTW9ycGhhYmxlKClcbiAgICAgICAgLnR5cGUodGhpcy5jb25zdHJ1Y3RvcilcbiAgICAgICAgLmZyb20odGhpcy50b0FycmF5KCkpIC8vIHRoaXMudmFsdWVPZigpKVxuICAgICAgICAudG8odmFsKVxuICAgIH0sXG4gICAgZnJvbUFycmF5KGFycikge1xuICAgICAgdGhpcy5pbml0KGFycilcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgICB0b0NvbnN1bWFibGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0FycmF5KClcbiAgICB9LFxuICAgIG1vcnBoKGZyb20sIHRvLCBwb3MsIHN0ZXBwZXIsIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IG1hcHBlciA9IGZ1bmN0aW9uIChpLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gc3RlcHBlci5zdGVwKGksIHRvW2luZGV4XSwgcG9zLCBjb250ZXh0W2luZGV4XSwgY29udGV4dClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZnJvbUFycmF5KGZyb20ubWFwKG1hcHBlcikpXG4gICAgfVxuICB9KVxufVxuIiwiaW1wb3J0IHsgbm9kZU9yTmV3LCByZWdpc3Rlciwgd3JhcFdpdGhBdHRyQ2hlY2sgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgcHJvcG9ydGlvbmFsU2l6ZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcbmltcG9ydCBQYXRoQXJyYXkgZnJvbSAnLi4vdHlwZXMvUGF0aEFycmF5LmpzJ1xuaW1wb3J0IFNoYXBlIGZyb20gJy4vU2hhcGUuanMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhdGggZXh0ZW5kcyBTaGFwZSB7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ3BhdGgnLCBub2RlKSwgYXR0cnMpXG4gIH1cblxuICAvLyBHZXQgYXJyYXlcbiAgYXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5IHx8ICh0aGlzLl9hcnJheSA9IG5ldyBQYXRoQXJyYXkodGhpcy5hdHRyKCdkJykpKVxuICB9XG5cbiAgLy8gQ2xlYXIgYXJyYXkgY2FjaGVcbiAgY2xlYXIoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2FycmF5XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIFNldCBoZWlnaHQgb2YgZWxlbWVudFxuICBoZWlnaHQoaGVpZ2h0KSB7XG4gICAgcmV0dXJuIGhlaWdodCA9PSBudWxsXG4gICAgICA/IHRoaXMuYmJveCgpLmhlaWdodFxuICAgICAgOiB0aGlzLnNpemUodGhpcy5iYm94KCkud2lkdGgsIGhlaWdodClcbiAgfVxuXG4gIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyXG4gIG1vdmUoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ2QnLCB0aGlzLmFycmF5KCkubW92ZSh4LCB5KSlcbiAgfVxuXG4gIC8vIFBsb3QgbmV3IHBhdGhcbiAgcGxvdChkKSB7XG4gICAgcmV0dXJuIGQgPT0gbnVsbFxuICAgICAgPyB0aGlzLmFycmF5KClcbiAgICAgIDogdGhpcy5jbGVhcigpLmF0dHIoXG4gICAgICAgICAgJ2QnLFxuICAgICAgICAgIHR5cGVvZiBkID09PSAnc3RyaW5nJyA/IGQgOiAodGhpcy5fYXJyYXkgPSBuZXcgUGF0aEFycmF5KGQpKVxuICAgICAgICApXG4gIH1cblxuICAvLyBTZXQgZWxlbWVudCBzaXplIHRvIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcbiAgc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodClcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdkJywgdGhpcy5hcnJheSgpLnNpemUocC53aWR0aCwgcC5oZWlnaHQpKVxuICB9XG5cbiAgLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcbiAgd2lkdGgod2lkdGgpIHtcbiAgICByZXR1cm4gd2lkdGggPT0gbnVsbFxuICAgICAgPyB0aGlzLmJib3goKS53aWR0aFxuICAgICAgOiB0aGlzLnNpemUod2lkdGgsIHRoaXMuYmJveCgpLmhlaWdodClcbiAgfVxuXG4gIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyIG92ZXIgeC1heGlzXG4gIHgoeCkge1xuICAgIHJldHVybiB4ID09IG51bGwgPyB0aGlzLmJib3goKS54IDogdGhpcy5tb3ZlKHgsIHRoaXMuYmJveCgpLnkpXG4gIH1cblxuICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lciBvdmVyIHktYXhpc1xuICB5KHkpIHtcbiAgICByZXR1cm4geSA9PSBudWxsID8gdGhpcy5iYm94KCkueSA6IHRoaXMubW92ZSh0aGlzLmJib3goKS54LCB5KVxuICB9XG59XG5cbi8vIERlZmluZSBtb3JwaGFibGUgYXJyYXlcblBhdGgucHJvdG90eXBlLk1vcnBoQXJyYXkgPSBQYXRoQXJyYXlcblxuLy8gQWRkIHBhcmVudCBtZXRob2RcbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIC8vIENyZWF0ZSBhIHdyYXBwZWQgcGF0aCBlbGVtZW50XG4gICAgcGF0aDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKGQpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBwbG90IGlzIGNhbGxlZCBhcyBhIHNldHRlclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBQYXRoKCkpLnBsb3QoZCB8fCBuZXcgUGF0aEFycmF5KCkpXG4gICAgfSlcbiAgfVxufSlcblxucmVnaXN0ZXIoUGF0aCwgJ1BhdGgnKVxuIiwiaW1wb3J0IHsgcHJvcG9ydGlvbmFsU2l6ZSB9IGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzLmpzJ1xuaW1wb3J0IFBvaW50QXJyYXkgZnJvbSAnLi4vLi4vdHlwZXMvUG9pbnRBcnJheS5qcydcblxuLy8gR2V0IGFycmF5XG5leHBvcnQgZnVuY3Rpb24gYXJyYXkoKSB7XG4gIHJldHVybiB0aGlzLl9hcnJheSB8fCAodGhpcy5fYXJyYXkgPSBuZXcgUG9pbnRBcnJheSh0aGlzLmF0dHIoJ3BvaW50cycpKSlcbn1cblxuLy8gQ2xlYXIgYXJyYXkgY2FjaGVcbmV4cG9ydCBmdW5jdGlvbiBjbGVhcigpIHtcbiAgZGVsZXRlIHRoaXMuX2FycmF5XG4gIHJldHVybiB0aGlzXG59XG5cbi8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyXG5leHBvcnQgZnVuY3Rpb24gbW92ZSh4LCB5KSB7XG4gIHJldHVybiB0aGlzLmF0dHIoJ3BvaW50cycsIHRoaXMuYXJyYXkoKS5tb3ZlKHgsIHkpKVxufVxuXG4vLyBQbG90IG5ldyBwYXRoXG5leHBvcnQgZnVuY3Rpb24gcGxvdChwKSB7XG4gIHJldHVybiBwID09IG51bGxcbiAgICA/IHRoaXMuYXJyYXkoKVxuICAgIDogdGhpcy5jbGVhcigpLmF0dHIoXG4gICAgICAgICdwb2ludHMnLFxuICAgICAgICB0eXBlb2YgcCA9PT0gJ3N0cmluZycgPyBwIDogKHRoaXMuX2FycmF5ID0gbmV3IFBvaW50QXJyYXkocCkpXG4gICAgICApXG59XG5cbi8vIFNldCBlbGVtZW50IHNpemUgdG8gZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuZXhwb3J0IGZ1bmN0aW9uIHNpemUod2lkdGgsIGhlaWdodCkge1xuICBjb25zdCBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0KVxuICByZXR1cm4gdGhpcy5hdHRyKCdwb2ludHMnLCB0aGlzLmFycmF5KCkuc2l6ZShwLndpZHRoLCBwLmhlaWdodCkpXG59XG4iLCJpbXBvcnQge1xuICBleHRlbmQsXG4gIG5vZGVPck5ldyxcbiAgcmVnaXN0ZXIsXG4gIHdyYXBXaXRoQXR0ckNoZWNrXG59IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xuaW1wb3J0IFBvaW50QXJyYXkgZnJvbSAnLi4vdHlwZXMvUG9pbnRBcnJheS5qcydcbmltcG9ydCBTaGFwZSBmcm9tICcuL1NoYXBlLmpzJ1xuaW1wb3J0ICogYXMgcG9pbnRlZCBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcG9pbnRlZC5qcydcbmltcG9ydCAqIGFzIHBvbHkgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3BvbHkuanMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbHlnb24gZXh0ZW5kcyBTaGFwZSB7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ3BvbHlnb24nLCBub2RlKSwgYXR0cnMpXG4gIH1cbn1cblxucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgLy8gQ3JlYXRlIGEgd3JhcHBlZCBwb2x5Z29uIGVsZW1lbnRcbiAgICBwb2x5Z29uOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAocCkge1xuICAgICAgLy8gbWFrZSBzdXJlIHBsb3QgaXMgY2FsbGVkIGFzIGEgc2V0dGVyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFBvbHlnb24oKSkucGxvdChwIHx8IG5ldyBQb2ludEFycmF5KCkpXG4gICAgfSlcbiAgfVxufSlcblxuZXh0ZW5kKFBvbHlnb24sIHBvaW50ZWQpXG5leHRlbmQoUG9seWdvbiwgcG9seSlcbnJlZ2lzdGVyKFBvbHlnb24sICdQb2x5Z29uJylcbiIsImltcG9ydCB7XG4gIGV4dGVuZCxcbiAgbm9kZU9yTmV3LFxuICByZWdpc3RlcixcbiAgd3JhcFdpdGhBdHRyQ2hlY2tcbn0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgUG9pbnRBcnJheSBmcm9tICcuLi90eXBlcy9Qb2ludEFycmF5LmpzJ1xuaW1wb3J0IFNoYXBlIGZyb20gJy4vU2hhcGUuanMnXG5pbXBvcnQgKiBhcyBwb2ludGVkIGZyb20gJy4uL21vZHVsZXMvY29yZS9wb2ludGVkLmpzJ1xuaW1wb3J0ICogYXMgcG9seSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcG9seS5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9seWxpbmUgZXh0ZW5kcyBTaGFwZSB7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ3BvbHlsaW5lJywgbm9kZSksIGF0dHJzKVxuICB9XG59XG5cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIC8vIENyZWF0ZSBhIHdyYXBwZWQgcG9seWdvbiBlbGVtZW50XG4gICAgcG9seWxpbmU6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uIChwKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgcGxvdCBpcyBjYWxsZWQgYXMgYSBzZXR0ZXJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgUG9seWxpbmUoKSkucGxvdChwIHx8IG5ldyBQb2ludEFycmF5KCkpXG4gICAgfSlcbiAgfVxufSlcblxuZXh0ZW5kKFBvbHlsaW5lLCBwb2ludGVkKVxuZXh0ZW5kKFBvbHlsaW5lLCBwb2x5KVxucmVnaXN0ZXIoUG9seWxpbmUsICdQb2x5bGluZScpXG4iLCJpbXBvcnQge1xuICBleHRlbmQsXG4gIG5vZGVPck5ldyxcbiAgcmVnaXN0ZXIsXG4gIHdyYXBXaXRoQXR0ckNoZWNrXG59IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xuaW1wb3J0IHsgcngsIHJ5IH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL2NpcmNsZWQuanMnXG5pbXBvcnQgU2hhcGUgZnJvbSAnLi9TaGFwZS5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjdCBleHRlbmRzIFNoYXBlIHtcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygncmVjdCcsIG5vZGUpLCBhdHRycylcbiAgfVxufVxuXG5leHRlbmQoUmVjdCwgeyByeCwgcnkgfSlcblxucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgLy8gQ3JlYXRlIGEgcmVjdCBlbGVtZW50XG4gICAgcmVjdDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgUmVjdCgpKS5zaXplKHdpZHRoLCBoZWlnaHQpXG4gICAgfSlcbiAgfVxufSlcblxucmVnaXN0ZXIoUmVjdCwgJ1JlY3QnKVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVldWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9maXJzdCA9IG51bGxcbiAgICB0aGlzLl9sYXN0ID0gbnVsbFxuICB9XG5cbiAgLy8gU2hvd3MgdXMgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3RcbiAgZmlyc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpcnN0ICYmIHRoaXMuX2ZpcnN0LnZhbHVlXG4gIH1cblxuICAvLyBTaG93cyB1cyB0aGUgbGFzdCBpdGVtIGluIHRoZSBsaXN0XG4gIGxhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xhc3QgJiYgdGhpcy5fbGFzdC52YWx1ZVxuICB9XG5cbiAgcHVzaCh2YWx1ZSkge1xuICAgIC8vIEFuIGl0ZW0gc3RvcmVzIGFuIGlkIGFuZCB0aGUgcHJvdmlkZWQgdmFsdWVcbiAgICBjb25zdCBpdGVtID1cbiAgICAgIHR5cGVvZiB2YWx1ZS5uZXh0ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogeyB2YWx1ZTogdmFsdWUsIG5leHQ6IG51bGwsIHByZXY6IG51bGwgfVxuXG4gICAgLy8gRGVhbCB3aXRoIHRoZSBxdWV1ZSBiZWluZyBlbXB0eSBvciBwb3B1bGF0ZWRcbiAgICBpZiAodGhpcy5fbGFzdCkge1xuICAgICAgaXRlbS5wcmV2ID0gdGhpcy5fbGFzdFxuICAgICAgdGhpcy5fbGFzdC5uZXh0ID0gaXRlbVxuICAgICAgdGhpcy5fbGFzdCA9IGl0ZW1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbGFzdCA9IGl0ZW1cbiAgICAgIHRoaXMuX2ZpcnN0ID0gaXRlbVxuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGUgY3VycmVudCBpdGVtXG4gICAgcmV0dXJuIGl0ZW1cbiAgfVxuXG4gIC8vIFJlbW92ZXMgdGhlIGl0ZW0gdGhhdCB3YXMgcmV0dXJuZWQgZnJvbSB0aGUgcHVzaFxuICByZW1vdmUoaXRlbSkge1xuICAgIC8vIFJlbGluayB0aGUgcHJldmlvdXMgaXRlbVxuICAgIGlmIChpdGVtLnByZXYpIGl0ZW0ucHJldi5uZXh0ID0gaXRlbS5uZXh0XG4gICAgaWYgKGl0ZW0ubmV4dCkgaXRlbS5uZXh0LnByZXYgPSBpdGVtLnByZXZcbiAgICBpZiAoaXRlbSA9PT0gdGhpcy5fbGFzdCkgdGhpcy5fbGFzdCA9IGl0ZW0ucHJldlxuICAgIGlmIChpdGVtID09PSB0aGlzLl9maXJzdCkgdGhpcy5fZmlyc3QgPSBpdGVtLm5leHRcblxuICAgIC8vIEludmFsaWRhdGUgaXRlbVxuICAgIGl0ZW0ucHJldiA9IG51bGxcbiAgICBpdGVtLm5leHQgPSBudWxsXG4gIH1cblxuICBzaGlmdCgpIHtcbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGEgdmFsdWVcbiAgICBjb25zdCByZW1vdmUgPSB0aGlzLl9maXJzdFxuICAgIGlmICghcmVtb3ZlKSByZXR1cm4gbnVsbFxuXG4gICAgLy8gSWYgd2UgZG8sIHJlbW92ZSBpdCBhbmQgcmVsaW5rIHRoaW5nc1xuICAgIHRoaXMuX2ZpcnN0ID0gcmVtb3ZlLm5leHRcbiAgICBpZiAodGhpcy5fZmlyc3QpIHRoaXMuX2ZpcnN0LnByZXYgPSBudWxsXG4gICAgdGhpcy5fbGFzdCA9IHRoaXMuX2ZpcnN0ID8gdGhpcy5fbGFzdCA6IG51bGxcbiAgICByZXR1cm4gcmVtb3ZlLnZhbHVlXG4gIH1cbn1cbiIsImltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi91dGlscy93aW5kb3cuanMnXG5pbXBvcnQgUXVldWUgZnJvbSAnLi9RdWV1ZS5qcydcblxuY29uc3QgQW5pbWF0b3IgPSB7XG4gIG5leHREcmF3OiBudWxsLFxuICBmcmFtZXM6IG5ldyBRdWV1ZSgpLFxuICB0aW1lb3V0czogbmV3IFF1ZXVlKCksXG4gIGltbWVkaWF0ZXM6IG5ldyBRdWV1ZSgpLFxuICB0aW1lcjogKCkgPT4gZ2xvYmFscy53aW5kb3cucGVyZm9ybWFuY2UgfHwgZ2xvYmFscy53aW5kb3cuRGF0ZSxcbiAgdHJhbnNmb3JtczogW10sXG5cbiAgZnJhbWUoZm4pIHtcbiAgICAvLyBTdG9yZSB0aGUgbm9kZVxuICAgIGNvbnN0IG5vZGUgPSBBbmltYXRvci5mcmFtZXMucHVzaCh7IHJ1bjogZm4gfSlcblxuICAgIC8vIFJlcXVlc3QgYW4gYW5pbWF0aW9uIGZyYW1lIGlmIHdlIGRvbid0IGhhdmUgb25lXG4gICAgaWYgKEFuaW1hdG9yLm5leHREcmF3ID09PSBudWxsKSB7XG4gICAgICBBbmltYXRvci5uZXh0RHJhdyA9IGdsb2JhbHMud2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShBbmltYXRvci5fZHJhdylcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdGhlIG5vZGUgc28gd2UgY2FuIHJlbW92ZSBpdCBlYXNpbHlcbiAgICByZXR1cm4gbm9kZVxuICB9LFxuXG4gIHRpbWVvdXQoZm4sIGRlbGF5KSB7XG4gICAgZGVsYXkgPSBkZWxheSB8fCAwXG5cbiAgICAvLyBXb3JrIG91dCB3aGVuIHRoZSBldmVudCBzaG91bGQgZmlyZVxuICAgIGNvbnN0IHRpbWUgPSBBbmltYXRvci50aW1lcigpLm5vdygpICsgZGVsYXlcblxuICAgIC8vIEFkZCB0aGUgdGltZW91dCB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuICAgIGNvbnN0IG5vZGUgPSBBbmltYXRvci50aW1lb3V0cy5wdXNoKHsgcnVuOiBmbiwgdGltZTogdGltZSB9KVxuXG4gICAgLy8gUmVxdWVzdCBhbm90aGVyIGFuaW1hdGlvbiBmcmFtZSBpZiB3ZSBuZWVkIG9uZVxuICAgIGlmIChBbmltYXRvci5uZXh0RHJhdyA9PT0gbnVsbCkge1xuICAgICAgQW5pbWF0b3IubmV4dERyYXcgPSBnbG9iYWxzLndpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoQW5pbWF0b3IuX2RyYXcpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVcbiAgfSxcblxuICBpbW1lZGlhdGUoZm4pIHtcbiAgICAvLyBBZGQgdGhlIGltbWVkaWF0ZSBmbiB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuICAgIGNvbnN0IG5vZGUgPSBBbmltYXRvci5pbW1lZGlhdGVzLnB1c2goZm4pXG4gICAgLy8gUmVxdWVzdCBhbm90aGVyIGFuaW1hdGlvbiBmcmFtZSBpZiB3ZSBuZWVkIG9uZVxuICAgIGlmIChBbmltYXRvci5uZXh0RHJhdyA9PT0gbnVsbCkge1xuICAgICAgQW5pbWF0b3IubmV4dERyYXcgPSBnbG9iYWxzLndpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoQW5pbWF0b3IuX2RyYXcpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVcbiAgfSxcblxuICBjYW5jZWxGcmFtZShub2RlKSB7XG4gICAgbm9kZSAhPSBudWxsICYmIEFuaW1hdG9yLmZyYW1lcy5yZW1vdmUobm9kZSlcbiAgfSxcblxuICBjbGVhclRpbWVvdXQobm9kZSkge1xuICAgIG5vZGUgIT0gbnVsbCAmJiBBbmltYXRvci50aW1lb3V0cy5yZW1vdmUobm9kZSlcbiAgfSxcblxuICBjYW5jZWxJbW1lZGlhdGUobm9kZSkge1xuICAgIG5vZGUgIT0gbnVsbCAmJiBBbmltYXRvci5pbW1lZGlhdGVzLnJlbW92ZShub2RlKVxuICB9LFxuXG4gIF9kcmF3KG5vdykge1xuICAgIC8vIFJ1biBhbGwgdGhlIHRpbWVvdXRzIHdlIGNhbiBydW4sIGlmIHRoZXkgYXJlIG5vdCByZWFkeSB5ZXQsIGFkZCB0aGVtXG4gICAgLy8gdG8gdGhlIGVuZCBvZiB0aGUgcXVldWUgaW1tZWRpYXRlbHkhIChiYWQgdGltZW91dHMhISEgW3NhcmNhc21dKVxuICAgIGxldCBuZXh0VGltZW91dCA9IG51bGxcbiAgICBjb25zdCBsYXN0VGltZW91dCA9IEFuaW1hdG9yLnRpbWVvdXRzLmxhc3QoKVxuICAgIHdoaWxlICgobmV4dFRpbWVvdXQgPSBBbmltYXRvci50aW1lb3V0cy5zaGlmdCgpKSkge1xuICAgICAgLy8gUnVuIHRoZSB0aW1lb3V0IGlmIGl0cyB0aW1lLCBvciBwdXNoIGl0IHRvIHRoZSBlbmRcbiAgICAgIGlmIChub3cgPj0gbmV4dFRpbWVvdXQudGltZSkge1xuICAgICAgICBuZXh0VGltZW91dC5ydW4oKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQW5pbWF0b3IudGltZW91dHMucHVzaChuZXh0VGltZW91dClcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgaGl0IHRoZSBsYXN0IGl0ZW0sIHdlIHNob3VsZCBzdG9wIHNoaWZ0aW5nIG91dCBtb3JlIGl0ZW1zXG4gICAgICBpZiAobmV4dFRpbWVvdXQgPT09IGxhc3RUaW1lb3V0KSBicmVha1xuICAgIH1cblxuICAgIC8vIFJ1biBhbGwgb2YgdGhlIGFuaW1hdGlvbiBmcmFtZXNcbiAgICBsZXQgbmV4dEZyYW1lID0gbnVsbFxuICAgIGNvbnN0IGxhc3RGcmFtZSA9IEFuaW1hdG9yLmZyYW1lcy5sYXN0KClcbiAgICB3aGlsZSAobmV4dEZyYW1lICE9PSBsYXN0RnJhbWUgJiYgKG5leHRGcmFtZSA9IEFuaW1hdG9yLmZyYW1lcy5zaGlmdCgpKSkge1xuICAgICAgbmV4dEZyYW1lLnJ1bihub3cpXG4gICAgfVxuXG4gICAgbGV0IG5leHRJbW1lZGlhdGUgPSBudWxsXG4gICAgd2hpbGUgKChuZXh0SW1tZWRpYXRlID0gQW5pbWF0b3IuaW1tZWRpYXRlcy5zaGlmdCgpKSkge1xuICAgICAgbmV4dEltbWVkaWF0ZSgpXG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSByZW1haW5pbmcgdGltZW91dHMgb3IgZnJhbWVzLCBkcmF3IHVudGlsIHdlIGRvbid0IGFueW1vcmVcbiAgICBBbmltYXRvci5uZXh0RHJhdyA9XG4gICAgICBBbmltYXRvci50aW1lb3V0cy5maXJzdCgpIHx8IEFuaW1hdG9yLmZyYW1lcy5maXJzdCgpXG4gICAgICAgID8gZ2xvYmFscy53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKEFuaW1hdG9yLl9kcmF3KVxuICAgICAgICA6IG51bGxcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBbmltYXRvclxuIiwiaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4uL3V0aWxzL3dpbmRvdy5qcydcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgQW5pbWF0b3IgZnJvbSAnLi9BbmltYXRvci5qcydcbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuLi90eXBlcy9FdmVudFRhcmdldC5qcydcblxuY29uc3QgbWFrZVNjaGVkdWxlID0gZnVuY3Rpb24gKHJ1bm5lckluZm8pIHtcbiAgY29uc3Qgc3RhcnQgPSBydW5uZXJJbmZvLnN0YXJ0XG4gIGNvbnN0IGR1cmF0aW9uID0gcnVubmVySW5mby5ydW5uZXIuZHVyYXRpb24oKVxuICBjb25zdCBlbmQgPSBzdGFydCArIGR1cmF0aW9uXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICBlbmQ6IGVuZCxcbiAgICBydW5uZXI6IHJ1bm5lckluZm8ucnVubmVyXG4gIH1cbn1cblxuY29uc3QgZGVmYXVsdFNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgdyA9IGdsb2JhbHMud2luZG93XG4gIHJldHVybiAody5wZXJmb3JtYW5jZSB8fCB3LkRhdGUpLm5vdygpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVsaW5lIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAvLyBDb25zdHJ1Y3QgYSBuZXcgdGltZWxpbmUgb24gdGhlIGdpdmVuIGVsZW1lbnRcbiAgY29uc3RydWN0b3IodGltZVNvdXJjZSA9IGRlZmF1bHRTb3VyY2UpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzLl90aW1lU291cmNlID0gdGltZVNvdXJjZVxuXG4gICAgLy8gdGVybWluYXRlIHJlc2V0cyBhbGwgdmFyaWFibGVzIHRvIHRoZWlyIGluaXRpYWwgc3RhdGVcbiAgICB0aGlzLnRlcm1pbmF0ZSgpXG4gIH1cblxuICBhY3RpdmUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fbmV4dEZyYW1lXG4gIH1cblxuICBmaW5pc2goKSB7XG4gICAgLy8gR28gdG8gZW5kIGFuZCBwYXVzZVxuICAgIHRoaXMudGltZSh0aGlzLmdldEVuZFRpbWVPZlRpbWVsaW5lKCkgKyAxKVxuICAgIHJldHVybiB0aGlzLnBhdXNlKClcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZXMgdGhlIGVuZCBvZiB0aGUgdGltZWxpbmVcbiAgZ2V0RW5kVGltZSgpIHtcbiAgICBjb25zdCBsYXN0UnVubmVySW5mbyA9IHRoaXMuZ2V0TGFzdFJ1bm5lckluZm8oKVxuICAgIGNvbnN0IGxhc3REdXJhdGlvbiA9IGxhc3RSdW5uZXJJbmZvID8gbGFzdFJ1bm5lckluZm8ucnVubmVyLmR1cmF0aW9uKCkgOiAwXG4gICAgY29uc3QgbGFzdFN0YXJ0VGltZSA9IGxhc3RSdW5uZXJJbmZvID8gbGFzdFJ1bm5lckluZm8uc3RhcnQgOiB0aGlzLl90aW1lXG4gICAgcmV0dXJuIGxhc3RTdGFydFRpbWUgKyBsYXN0RHVyYXRpb25cbiAgfVxuXG4gIGdldEVuZFRpbWVPZlRpbWVsaW5lKCkge1xuICAgIGNvbnN0IGVuZFRpbWVzID0gdGhpcy5fcnVubmVycy5tYXAoKGkpID0+IGkuc3RhcnQgKyBpLnJ1bm5lci5kdXJhdGlvbigpKVxuICAgIHJldHVybiBNYXRoLm1heCgwLCAuLi5lbmRUaW1lcylcbiAgfVxuXG4gIGdldExhc3RSdW5uZXJJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLmdldFJ1bm5lckluZm9CeUlkKHRoaXMuX2xhc3RSdW5uZXJJZClcbiAgfVxuXG4gIGdldFJ1bm5lckluZm9CeUlkKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3J1bm5lcnNbdGhpcy5fcnVubmVySWRzLmluZGV4T2YoaWQpXSB8fCBudWxsXG4gIH1cblxuICBwYXVzZSgpIHtcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlXG4gICAgcmV0dXJuIHRoaXMuX2NvbnRpbnVlKClcbiAgfVxuXG4gIHBlcnNpc3QoZHRPckZvcmV2ZXIpIHtcbiAgICBpZiAoZHRPckZvcmV2ZXIgPT0gbnVsbCkgcmV0dXJuIHRoaXMuX3BlcnNpc3RcbiAgICB0aGlzLl9wZXJzaXN0ID0gZHRPckZvcmV2ZXJcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcGxheSgpIHtcbiAgICAvLyBOb3cgbWFrZSBzdXJlIHdlIGFyZSBub3QgcGF1c2VkIGFuZCBjb250aW51ZSB0aGUgYW5pbWF0aW9uXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2VcbiAgICByZXR1cm4gdGhpcy51cGRhdGVUaW1lKCkuX2NvbnRpbnVlKClcbiAgfVxuXG4gIHJldmVyc2UoeWVzKSB7XG4gICAgY29uc3QgY3VycmVudFNwZWVkID0gdGhpcy5zcGVlZCgpXG4gICAgaWYgKHllcyA9PSBudWxsKSByZXR1cm4gdGhpcy5zcGVlZCgtY3VycmVudFNwZWVkKVxuXG4gICAgY29uc3QgcG9zaXRpdmUgPSBNYXRoLmFicyhjdXJyZW50U3BlZWQpXG4gICAgcmV0dXJuIHRoaXMuc3BlZWQoeWVzID8gLXBvc2l0aXZlIDogcG9zaXRpdmUpXG4gIH1cblxuICAvLyBzY2hlZHVsZXMgYSBydW5uZXIgb24gdGhlIHRpbWVsaW5lXG4gIHNjaGVkdWxlKHJ1bm5lciwgZGVsYXksIHdoZW4pIHtcbiAgICBpZiAocnVubmVyID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5uZXJzLm1hcChtYWtlU2NoZWR1bGUpXG4gICAgfVxuXG4gICAgLy8gVGhlIHN0YXJ0IHRpbWUgZm9yIHRoZSBuZXh0IGFuaW1hdGlvbiBjYW4gZWl0aGVyIGJlIGdpdmVuIGV4cGxpY2l0bHksXG4gICAgLy8gZGVyaXZlZCBmcm9tIHRoZSBjdXJyZW50IHRpbWVsaW5lIHRpbWUgb3IgaXQgY2FuIGJlIHJlbGF0aXZlIHRvIHRoZVxuICAgIC8vIGxhc3Qgc3RhcnQgdGltZSB0byBjaGFpbiBhbmltYXRpb25zIGRpcmVjdGx5XG5cbiAgICBsZXQgYWJzb2x1dGVTdGFydFRpbWUgPSAwXG4gICAgY29uc3QgZW5kVGltZSA9IHRoaXMuZ2V0RW5kVGltZSgpXG4gICAgZGVsYXkgPSBkZWxheSB8fCAwXG5cbiAgICAvLyBXb3JrIG91dCB3aGVuIHRvIHN0YXJ0IHRoZSBhbmltYXRpb25cbiAgICBpZiAod2hlbiA9PSBudWxsIHx8IHdoZW4gPT09ICdsYXN0JyB8fCB3aGVuID09PSAnYWZ0ZXInKSB7XG4gICAgICAvLyBUYWtlIHRoZSBsYXN0IHRpbWUgYW5kIGluY3JlbWVudFxuICAgICAgYWJzb2x1dGVTdGFydFRpbWUgPSBlbmRUaW1lXG4gICAgfSBlbHNlIGlmICh3aGVuID09PSAnYWJzb2x1dGUnIHx8IHdoZW4gPT09ICdzdGFydCcpIHtcbiAgICAgIGFic29sdXRlU3RhcnRUaW1lID0gZGVsYXlcbiAgICAgIGRlbGF5ID0gMFxuICAgIH0gZWxzZSBpZiAod2hlbiA9PT0gJ25vdycpIHtcbiAgICAgIGFic29sdXRlU3RhcnRUaW1lID0gdGhpcy5fdGltZVxuICAgIH0gZWxzZSBpZiAod2hlbiA9PT0gJ3JlbGF0aXZlJykge1xuICAgICAgY29uc3QgcnVubmVySW5mbyA9IHRoaXMuZ2V0UnVubmVySW5mb0J5SWQocnVubmVyLmlkKVxuICAgICAgaWYgKHJ1bm5lckluZm8pIHtcbiAgICAgICAgYWJzb2x1dGVTdGFydFRpbWUgPSBydW5uZXJJbmZvLnN0YXJ0ICsgZGVsYXlcbiAgICAgICAgZGVsYXkgPSAwXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh3aGVuID09PSAnd2l0aC1sYXN0Jykge1xuICAgICAgY29uc3QgbGFzdFJ1bm5lckluZm8gPSB0aGlzLmdldExhc3RSdW5uZXJJbmZvKClcbiAgICAgIGNvbnN0IGxhc3RTdGFydFRpbWUgPSBsYXN0UnVubmVySW5mbyA/IGxhc3RSdW5uZXJJbmZvLnN0YXJ0IDogdGhpcy5fdGltZVxuICAgICAgYWJzb2x1dGVTdGFydFRpbWUgPSBsYXN0U3RhcnRUaW1lXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgdGhlIFwid2hlblwiIHBhcmFtZXRlcicpXG4gICAgfVxuXG4gICAgLy8gTWFuYWdlIHJ1bm5lclxuICAgIHJ1bm5lci51bnNjaGVkdWxlKClcbiAgICBydW5uZXIudGltZWxpbmUodGhpcylcblxuICAgIGNvbnN0IHBlcnNpc3QgPSBydW5uZXIucGVyc2lzdCgpXG4gICAgY29uc3QgcnVubmVySW5mbyA9IHtcbiAgICAgIHBlcnNpc3Q6IHBlcnNpc3QgPT09IG51bGwgPyB0aGlzLl9wZXJzaXN0IDogcGVyc2lzdCxcbiAgICAgIHN0YXJ0OiBhYnNvbHV0ZVN0YXJ0VGltZSArIGRlbGF5LFxuICAgICAgcnVubmVyXG4gICAgfVxuXG4gICAgdGhpcy5fbGFzdFJ1bm5lcklkID0gcnVubmVyLmlkXG5cbiAgICB0aGlzLl9ydW5uZXJzLnB1c2gocnVubmVySW5mbylcbiAgICB0aGlzLl9ydW5uZXJzLnNvcnQoKGEsIGIpID0+IGEuc3RhcnQgLSBiLnN0YXJ0KVxuICAgIHRoaXMuX3J1bm5lcklkcyA9IHRoaXMuX3J1bm5lcnMubWFwKChpbmZvKSA9PiBpbmZvLnJ1bm5lci5pZClcblxuICAgIHRoaXMudXBkYXRlVGltZSgpLl9jb250aW51ZSgpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHNlZWsoZHQpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lKHRoaXMuX3RpbWUgKyBkdClcbiAgfVxuXG4gIHNvdXJjZShmbikge1xuICAgIGlmIChmbiA9PSBudWxsKSByZXR1cm4gdGhpcy5fdGltZVNvdXJjZVxuICAgIHRoaXMuX3RpbWVTb3VyY2UgPSBmblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzcGVlZChzcGVlZCkge1xuICAgIGlmIChzcGVlZCA9PSBudWxsKSByZXR1cm4gdGhpcy5fc3BlZWRcbiAgICB0aGlzLl9zcGVlZCA9IHNwZWVkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgLy8gR28gdG8gc3RhcnQgYW5kIHBhdXNlXG4gICAgdGhpcy50aW1lKDApXG4gICAgcmV0dXJuIHRoaXMucGF1c2UoKVxuICB9XG5cbiAgdGltZSh0aW1lKSB7XG4gICAgaWYgKHRpbWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMuX3RpbWVcbiAgICB0aGlzLl90aW1lID0gdGltZVxuICAgIHJldHVybiB0aGlzLl9jb250aW51ZSh0cnVlKVxuICB9XG5cbiAgLy8gUmVtb3ZlIHRoZSBydW5uZXIgZnJvbSB0aGlzIHRpbWVsaW5lXG4gIHVuc2NoZWR1bGUocnVubmVyKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9ydW5uZXJJZHMuaW5kZXhPZihydW5uZXIuaWQpXG4gICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuIHRoaXNcblxuICAgIHRoaXMuX3J1bm5lcnMuc3BsaWNlKGluZGV4LCAxKVxuICAgIHRoaXMuX3J1bm5lcklkcy5zcGxpY2UoaW5kZXgsIDEpXG5cbiAgICBydW5uZXIudGltZWxpbmUobnVsbClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gTWFrZXMgc3VyZSwgdGhhdCBhZnRlciBwYXVzaW5nIHRoZSB0aW1lIGRvZXNuJ3QganVtcFxuICB1cGRhdGVUaW1lKCkge1xuICAgIGlmICghdGhpcy5hY3RpdmUoKSkge1xuICAgICAgdGhpcy5fbGFzdFNvdXJjZVRpbWUgPSB0aGlzLl90aW1lU291cmNlKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIENoZWNrcyBpZiB3ZSBhcmUgcnVubmluZyBhbmQgY29udGludWVzIHRoZSBhbmltYXRpb25cbiAgX2NvbnRpbnVlKGltbWVkaWF0ZVN0ZXAgPSBmYWxzZSkge1xuICAgIEFuaW1hdG9yLmNhbmNlbEZyYW1lKHRoaXMuX25leHRGcmFtZSlcbiAgICB0aGlzLl9uZXh0RnJhbWUgPSBudWxsXG5cbiAgICBpZiAoaW1tZWRpYXRlU3RlcCkgcmV0dXJuIHRoaXMuX3N0ZXBJbW1lZGlhdGUoKVxuICAgIGlmICh0aGlzLl9wYXVzZWQpIHJldHVybiB0aGlzXG5cbiAgICB0aGlzLl9uZXh0RnJhbWUgPSBBbmltYXRvci5mcmFtZSh0aGlzLl9zdGVwKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBfc3RlcEZuKGltbWVkaWF0ZVN0ZXAgPSBmYWxzZSkge1xuICAgIC8vIEdldCB0aGUgdGltZSBkZWx0YSBmcm9tIHRoZSBsYXN0IHRpbWUgYW5kIHVwZGF0ZSB0aGUgdGltZVxuICAgIGNvbnN0IHRpbWUgPSB0aGlzLl90aW1lU291cmNlKClcbiAgICBsZXQgZHRTb3VyY2UgPSB0aW1lIC0gdGhpcy5fbGFzdFNvdXJjZVRpbWVcblxuICAgIGlmIChpbW1lZGlhdGVTdGVwKSBkdFNvdXJjZSA9IDBcblxuICAgIGNvbnN0IGR0VGltZSA9IHRoaXMuX3NwZWVkICogZHRTb3VyY2UgKyAodGhpcy5fdGltZSAtIHRoaXMuX2xhc3RTdGVwVGltZSlcbiAgICB0aGlzLl9sYXN0U291cmNlVGltZSA9IHRpbWVcblxuICAgIC8vIE9ubHkgdXBkYXRlIHRoZSB0aW1lIGlmIHdlIHVzZSB0aGUgdGltZVNvdXJjZS5cbiAgICAvLyBPdGhlcndpc2UgdXNlIHRoZSBjdXJyZW50IHRpbWVcbiAgICBpZiAoIWltbWVkaWF0ZVN0ZXApIHtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgdGltZVxuICAgICAgdGhpcy5fdGltZSArPSBkdFRpbWVcbiAgICAgIHRoaXMuX3RpbWUgPSB0aGlzLl90aW1lIDwgMCA/IDAgOiB0aGlzLl90aW1lXG4gICAgfVxuICAgIHRoaXMuX2xhc3RTdGVwVGltZSA9IHRoaXMuX3RpbWVcbiAgICB0aGlzLmZpcmUoJ3RpbWUnLCB0aGlzLl90aW1lKVxuXG4gICAgLy8gVGhpcyBpcyBmb3IgdGhlIGNhc2UgdGhhdCB0aGUgdGltZWxpbmUgd2FzIHNlZWtlZCBzbyB0aGF0IHRoZSB0aW1lXG4gICAgLy8gaXMgbm93IGJlZm9yZSB0aGUgc3RhcnRUaW1lIG9mIHRoZSBydW5uZXIuIFRoYXQgaXMgd2h5IHdlIG5lZWQgdG8gc2V0XG4gICAgLy8gdGhlIHJ1bm5lciB0byBwb3NpdGlvbiAwXG5cbiAgICAvLyBGSVhNRTpcbiAgICAvLyBIb3dldmVyLCByZXNldHRpbmcgaW4gaW5zZXJ0aW9uIG9yZGVyIGxlYWRzIHRvIGJ1Z3MuIENvbnNpZGVyaW5nIHRoZSBjYXNlLFxuICAgIC8vIHdoZXJlIDIgcnVubmVycyBjaGFuZ2UgdGhlIHNhbWUgYXR0cmlidXRlIGJ1dCBpbiBkaWZmZXJlbnQgdGltZXMsXG4gICAgLy8gcmVzZXR0aW5nIGJvdGggb2YgdGhlbSB3aWxsIGxlYWQgdG8gdGhlIGNhc2Ugd2hlcmUgdGhlIGxhdGVyIGRlZmluZWRcbiAgICAvLyBydW5uZXIgYWx3YXlzIHdpbnMgdGhlIHJlc2V0IGV2ZW4gaWYgdGhlIG90aGVyIHJ1bm5lciBzdGFydGVkIGVhcmxpZXJcbiAgICAvLyBhbmQgdGhlcmVmb3JlIHNob3VsZCB3aW4gdGhlIGF0dHJpYnV0ZSBiYXR0bGVcbiAgICAvLyB0aGlzIGNhbiBiZSBzb2x2ZWQgYnkgcmVzZXR0aW5nIHRoZW0gYmFja3dhcmRzXG4gICAgZm9yIChsZXQgayA9IHRoaXMuX3J1bm5lcnMubGVuZ3RoOyBrLS07ICkge1xuICAgICAgLy8gR2V0IGFuZCBydW4gdGhlIGN1cnJlbnQgcnVubmVyIGFuZCBpZ25vcmUgaXQgaWYgaXRzIGluYWN0aXZlXG4gICAgICBjb25zdCBydW5uZXJJbmZvID0gdGhpcy5fcnVubmVyc1trXVxuICAgICAgY29uc3QgcnVubmVyID0gcnVubmVySW5mby5ydW5uZXJcblxuICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UgZ2l2ZSB0aGUgYWN0dWFsIGRpZmZlcmVuY2VcbiAgICAgIC8vIGJldHdlZW4gcnVubmVyIHN0YXJ0IHRpbWUgYW5kIG5vd1xuICAgICAgY29uc3QgZHRUb1N0YXJ0ID0gdGhpcy5fdGltZSAtIHJ1bm5lckluZm8uc3RhcnRcblxuICAgICAgLy8gRG9udCBydW4gcnVubmVyIGlmIG5vdCBzdGFydGVkIHlldFxuICAgICAgLy8gYW5kIHRyeSB0byByZXNldCBpdFxuICAgICAgaWYgKGR0VG9TdGFydCA8PSAwKSB7XG4gICAgICAgIHJ1bm5lci5yZXNldCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUnVuIGFsbCBvZiB0aGUgcnVubmVycyBkaXJlY3RseVxuICAgIGxldCBydW5uZXJzTGVmdCA9IGZhbHNlXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuX3J1bm5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIC8vIEdldCBhbmQgcnVuIHRoZSBjdXJyZW50IHJ1bm5lciBhbmQgaWdub3JlIGl0IGlmIGl0cyBpbmFjdGl2ZVxuICAgICAgY29uc3QgcnVubmVySW5mbyA9IHRoaXMuX3J1bm5lcnNbaV1cbiAgICAgIGNvbnN0IHJ1bm5lciA9IHJ1bm5lckluZm8ucnVubmVyXG4gICAgICBsZXQgZHQgPSBkdFRpbWVcblxuICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UgZ2l2ZSB0aGUgYWN0dWFsIGRpZmZlcmVuY2VcbiAgICAgIC8vIGJldHdlZW4gcnVubmVyIHN0YXJ0IHRpbWUgYW5kIG5vd1xuICAgICAgY29uc3QgZHRUb1N0YXJ0ID0gdGhpcy5fdGltZSAtIHJ1bm5lckluZm8uc3RhcnRcblxuICAgICAgLy8gRG9udCBydW4gcnVubmVyIGlmIG5vdCBzdGFydGVkIHlldFxuICAgICAgaWYgKGR0VG9TdGFydCA8PSAwKSB7XG4gICAgICAgIHJ1bm5lcnNMZWZ0ID0gdHJ1ZVxuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmIChkdFRvU3RhcnQgPCBkdCkge1xuICAgICAgICAvLyBBZGp1c3QgZHQgdG8gbWFrZSBzdXJlIHRoYXQgYW5pbWF0aW9uIGlzIG9uIHBvaW50XG4gICAgICAgIGR0ID0gZHRUb1N0YXJ0XG4gICAgICB9XG5cbiAgICAgIGlmICghcnVubmVyLmFjdGl2ZSgpKSBjb250aW51ZVxuXG4gICAgICAvLyBJZiB0aGlzIHJ1bm5lciBpcyBzdGlsbCBnb2luZywgc2lnbmFsIHRoYXQgd2UgbmVlZCBhbm90aGVyIGFuaW1hdGlvblxuICAgICAgLy8gZnJhbWUsIG90aGVyd2lzZSwgcmVtb3ZlIHRoZSBjb21wbGV0ZWQgcnVubmVyXG4gICAgICBjb25zdCBmaW5pc2hlZCA9IHJ1bm5lci5zdGVwKGR0KS5kb25lXG4gICAgICBpZiAoIWZpbmlzaGVkKSB7XG4gICAgICAgIHJ1bm5lcnNMZWZ0ID0gdHJ1ZVxuICAgICAgICAvLyBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmIChydW5uZXJJbmZvLnBlcnNpc3QgIT09IHRydWUpIHtcbiAgICAgICAgLy8gcnVubmVyIGlzIGZpbmlzaGVkLiBBbmQgcnVubmVyIG1pZ2h0IGdldCByZW1vdmVkXG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSBydW5uZXIuZHVyYXRpb24oKSAtIHJ1bm5lci50aW1lKCkgKyB0aGlzLl90aW1lXG5cbiAgICAgICAgaWYgKGVuZFRpbWUgKyBydW5uZXJJbmZvLnBlcnNpc3QgPCB0aGlzLl90aW1lKSB7XG4gICAgICAgICAgLy8gRGVsZXRlIHJ1bm5lciBhbmQgY29ycmVjdCBpbmRleFxuICAgICAgICAgIHJ1bm5lci51bnNjaGVkdWxlKClcbiAgICAgICAgICAtLWlcbiAgICAgICAgICAtLWxlblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQmFzaWNhbGx5OiB3ZSBjb250aW51ZSB3aGVuIHRoZXJlIGFyZSBydW5uZXJzIHJpZ2h0IGZyb20gdXMgaW4gdGltZVxuICAgIC8vIHdoZW4gLS0+LCBhbmQgd2hlbiBydW5uZXJzIGFyZSBsZWZ0IGZyb20gdXMgd2hlbiA8LS1cbiAgICBpZiAoXG4gICAgICAocnVubmVyc0xlZnQgJiYgISh0aGlzLl9zcGVlZCA8IDAgJiYgdGhpcy5fdGltZSA9PT0gMCkpIHx8XG4gICAgICAodGhpcy5fcnVubmVySWRzLmxlbmd0aCAmJiB0aGlzLl9zcGVlZCA8IDAgJiYgdGhpcy5fdGltZSA+IDApXG4gICAgKSB7XG4gICAgICB0aGlzLl9jb250aW51ZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGF1c2UoKVxuICAgICAgdGhpcy5maXJlKCdmaW5pc2hlZCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRlcm1pbmF0ZSgpIHtcbiAgICAvLyBjbGVhbnVwIG1lbW9yeVxuXG4gICAgLy8gU3RvcmUgdGhlIHRpbWluZyB2YXJpYWJsZXNcbiAgICB0aGlzLl9zdGFydFRpbWUgPSAwXG4gICAgdGhpcy5fc3BlZWQgPSAxLjBcblxuICAgIC8vIERldGVybWluZXMgaG93IGxvbmcgYSBydW5uZXIgaXMgaG9sZCBpbiBtZW1vcnkuIENhbiBiZSBhIGR0IG9yIHRydWUvZmFsc2VcbiAgICB0aGlzLl9wZXJzaXN0ID0gMFxuXG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgcnVubmluZyBhbmltYXRpb25zIGFuZCB0aGVpciBzdGFydGluZyBwYXJhbWV0ZXJzXG4gICAgdGhpcy5fbmV4dEZyYW1lID0gbnVsbFxuICAgIHRoaXMuX3BhdXNlZCA9IHRydWVcbiAgICB0aGlzLl9ydW5uZXJzID0gW11cbiAgICB0aGlzLl9ydW5uZXJJZHMgPSBbXVxuICAgIHRoaXMuX2xhc3RSdW5uZXJJZCA9IC0xXG4gICAgdGhpcy5fdGltZSA9IDBcbiAgICB0aGlzLl9sYXN0U291cmNlVGltZSA9IDBcbiAgICB0aGlzLl9sYXN0U3RlcFRpbWUgPSAwXG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBzdGVwIGlzIGFsd2F5cyBjYWxsZWQgaW4gY2xhc3MgY29udGV4dFxuICAgIHRoaXMuX3N0ZXAgPSB0aGlzLl9zdGVwRm4uYmluZCh0aGlzLCBmYWxzZSlcbiAgICB0aGlzLl9zdGVwSW1tZWRpYXRlID0gdGhpcy5fc3RlcEZuLmJpbmQodGhpcywgdHJ1ZSlcbiAgfVxufVxuXG5yZWdpc3Rlck1ldGhvZHMoe1xuICBFbGVtZW50OiB7XG4gICAgdGltZWxpbmU6IGZ1bmN0aW9uICh0aW1lbGluZSkge1xuICAgICAgaWYgKHRpbWVsaW5lID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fdGltZWxpbmUgPSB0aGlzLl90aW1lbGluZSB8fCBuZXcgVGltZWxpbmUoKVxuICAgICAgICByZXR1cm4gdGhpcy5fdGltZWxpbmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3RpbWVsaW5lID0gdGltZWxpbmVcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pXG4iLCJpbXBvcnQgeyBDb250cm9sbGVyLCBFYXNlLCBTdGVwcGVyIH0gZnJvbSAnLi9Db250cm9sbGVyLmpzJ1xuaW1wb3J0IHsgZXh0ZW5kLCByZWdpc3RlciB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5pbXBvcnQgeyBmcm9tLCB0byB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9ncmFkaWVudGVkLmpzJ1xuaW1wb3J0IHsgZ2V0T3JpZ2luIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMuanMnXG5pbXBvcnQgeyBub29wLCB0aW1lbGluZSB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9kZWZhdWx0cy5qcydcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgeyByeCwgcnkgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvY2lyY2xlZC5qcydcbmltcG9ydCBBbmltYXRvciBmcm9tICcuL0FuaW1hdG9yLmpzJ1xuaW1wb3J0IEJveCBmcm9tICcuLi90eXBlcy9Cb3guanMnXG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnLi4vdHlwZXMvRXZlbnRUYXJnZXQuanMnXG5pbXBvcnQgTWF0cml4IGZyb20gJy4uL3R5cGVzL01hdHJpeC5qcydcbmltcG9ydCBNb3JwaGFibGUsIHsgVHJhbnNmb3JtQmFnLCBPYmplY3RCYWcgfSBmcm9tICcuL01vcnBoYWJsZS5qcydcbmltcG9ydCBQb2ludCBmcm9tICcuLi90eXBlcy9Qb2ludC5qcydcbmltcG9ydCBTVkdOdW1iZXIgZnJvbSAnLi4vdHlwZXMvU1ZHTnVtYmVyLmpzJ1xuaW1wb3J0IFRpbWVsaW5lIGZyb20gJy4vVGltZWxpbmUuanMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJ1bm5lciBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKClcblxuICAgIC8vIFN0b3JlIGEgdW5pcXVlIGlkIG9uIHRoZSBydW5uZXIsIHNvIHRoYXQgd2UgY2FuIGlkZW50aWZ5IGl0IGxhdGVyXG4gICAgdGhpcy5pZCA9IFJ1bm5lci5pZCsrXG5cbiAgICAvLyBFbnN1cmUgYSBkZWZhdWx0IHZhbHVlXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPT0gbnVsbCA/IHRpbWVsaW5lLmR1cmF0aW9uIDogb3B0aW9uc1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgZ2V0IGEgY29udHJvbGxlclxuICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBDb250cm9sbGVyKG9wdGlvbnMpIDogb3B0aW9uc1xuXG4gICAgLy8gRGVjbGFyZSBhbGwgb2YgdGhlIHZhcmlhYmxlc1xuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsXG4gICAgdGhpcy5fdGltZWxpbmUgPSBudWxsXG4gICAgdGhpcy5kb25lID0gZmFsc2VcbiAgICB0aGlzLl9xdWV1ZSA9IFtdXG5cbiAgICAvLyBXb3JrIG91dCB0aGUgc3RlcHBlciBhbmQgdGhlIGR1cmF0aW9uXG4gICAgdGhpcy5fZHVyYXRpb24gPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicgJiYgb3B0aW9uc1xuICAgIHRoaXMuX2lzRGVjbGFyYXRpdmUgPSBvcHRpb25zIGluc3RhbmNlb2YgQ29udHJvbGxlclxuICAgIHRoaXMuX3N0ZXBwZXIgPSB0aGlzLl9pc0RlY2xhcmF0aXZlID8gb3B0aW9ucyA6IG5ldyBFYXNlKClcblxuICAgIC8vIFdlIGNvcHkgdGhlIGN1cnJlbnQgdmFsdWVzIGZyb20gdGhlIHRpbWVsaW5lIGJlY2F1c2UgdGhleSBjYW4gY2hhbmdlXG4gICAgdGhpcy5faGlzdG9yeSA9IHt9XG5cbiAgICAvLyBTdG9yZSB0aGUgc3RhdGUgb2YgdGhlIHJ1bm5lclxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWVcbiAgICB0aGlzLl90aW1lID0gMFxuICAgIHRoaXMuX2xhc3RUaW1lID0gMFxuXG4gICAgLy8gQXQgY3JlYXRpb24sIHRoZSBydW5uZXIgaXMgaW4gcmVzZXQgc3RhdGVcbiAgICB0aGlzLl9yZXNldGVkID0gdHJ1ZVxuXG4gICAgLy8gU2F2ZSB0cmFuc2Zvcm1zIGFwcGxpZWQgdG8gdGhpcyBydW5uZXJcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBuZXcgTWF0cml4KClcbiAgICB0aGlzLnRyYW5zZm9ybUlkID0gMVxuXG4gICAgLy8gTG9vcGluZyB2YXJpYWJsZXNcbiAgICB0aGlzLl9oYXZlUmV2ZXJzZWQgPSBmYWxzZVxuICAgIHRoaXMuX3JldmVyc2UgPSBmYWxzZVxuICAgIHRoaXMuX2xvb3BzRG9uZSA9IDBcbiAgICB0aGlzLl9zd2luZyA9IGZhbHNlXG4gICAgdGhpcy5fd2FpdCA9IDBcbiAgICB0aGlzLl90aW1lcyA9IDFcblxuICAgIHRoaXMuX2ZyYW1lSWQgPSBudWxsXG5cbiAgICAvLyBTdG9yZXMgaG93IGxvbmcgYSBydW5uZXIgaXMgc3RvcmVkIGFmdGVyIGJlaW5nIGRvbmVcbiAgICB0aGlzLl9wZXJzaXN0ID0gdGhpcy5faXNEZWNsYXJhdGl2ZSA/IHRydWUgOiBudWxsXG4gIH1cblxuICBzdGF0aWMgc2FuaXRpc2UoZHVyYXRpb24sIGRlbGF5LCB3aGVuKSB7XG4gICAgLy8gSW5pdGlhbGlzZSB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG4gICAgbGV0IHRpbWVzID0gMVxuICAgIGxldCBzd2luZyA9IGZhbHNlXG4gICAgbGV0IHdhaXQgPSAwXG4gICAgZHVyYXRpb24gPSBkdXJhdGlvbiA/PyB0aW1lbGluZS5kdXJhdGlvblxuICAgIGRlbGF5ID0gZGVsYXkgPz8gdGltZWxpbmUuZGVsYXlcbiAgICB3aGVuID0gd2hlbiB8fCAnbGFzdCdcblxuICAgIC8vIElmIHdlIGhhdmUgYW4gb2JqZWN0LCB1bnBhY2sgdGhlIHZhbHVlc1xuICAgIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmICEoZHVyYXRpb24gaW5zdGFuY2VvZiBTdGVwcGVyKSkge1xuICAgICAgZGVsYXkgPSBkdXJhdGlvbi5kZWxheSA/PyBkZWxheVxuICAgICAgd2hlbiA9IGR1cmF0aW9uLndoZW4gPz8gd2hlblxuICAgICAgc3dpbmcgPSBkdXJhdGlvbi5zd2luZyB8fCBzd2luZ1xuICAgICAgdGltZXMgPSBkdXJhdGlvbi50aW1lcyA/PyB0aW1lc1xuICAgICAgd2FpdCA9IGR1cmF0aW9uLndhaXQgPz8gd2FpdFxuICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbi5kdXJhdGlvbiA/PyB0aW1lbGluZS5kdXJhdGlvblxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICBkZWxheTogZGVsYXksXG4gICAgICBzd2luZzogc3dpbmcsXG4gICAgICB0aW1lczogdGltZXMsXG4gICAgICB3YWl0OiB3YWl0LFxuICAgICAgd2hlbjogd2hlblxuICAgIH1cbiAgfVxuXG4gIGFjdGl2ZShlbmFibGVkKSB7XG4gICAgaWYgKGVuYWJsZWQgPT0gbnVsbCkgcmV0dXJuIHRoaXMuZW5hYmxlZFxuICAgIHRoaXMuZW5hYmxlZCA9IGVuYWJsZWRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLypcbiAgUHJpdmF0ZSBNZXRob2RzXG4gID09PT09PT09PT09PT09PVxuICBNZXRob2RzIHRoYXQgc2hvdWxkbid0IGJlIHVzZWQgZXh0ZXJuYWxseVxuICAqL1xuICBhZGRUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgdGhpcy50cmFuc2Zvcm1zLmxtdWx0aXBseU8odHJhbnNmb3JtKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBhZnRlcihmbikge1xuICAgIHJldHVybiB0aGlzLm9uKCdmaW5pc2hlZCcsIGZuKVxuICB9XG5cbiAgYW5pbWF0ZShkdXJhdGlvbiwgZGVsYXksIHdoZW4pIHtcbiAgICBjb25zdCBvID0gUnVubmVyLnNhbml0aXNlKGR1cmF0aW9uLCBkZWxheSwgd2hlbilcbiAgICBjb25zdCBydW5uZXIgPSBuZXcgUnVubmVyKG8uZHVyYXRpb24pXG4gICAgaWYgKHRoaXMuX3RpbWVsaW5lKSBydW5uZXIudGltZWxpbmUodGhpcy5fdGltZWxpbmUpXG4gICAgaWYgKHRoaXMuX2VsZW1lbnQpIHJ1bm5lci5lbGVtZW50KHRoaXMuX2VsZW1lbnQpXG4gICAgcmV0dXJuIHJ1bm5lci5sb29wKG8pLnNjaGVkdWxlKG8uZGVsYXksIG8ud2hlbilcbiAgfVxuXG4gIGNsZWFyVHJhbnNmb3JtKCkge1xuICAgIHRoaXMudHJhbnNmb3JtcyA9IG5ldyBNYXRyaXgoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBUT0RPOiBLZWVwIHRyYWNrIG9mIGFsbCB0cmFuc2Zvcm1hdGlvbnMgc28gdGhhdCBkZWxldGlvbiBpcyBmYXN0ZXJcbiAgY2xlYXJUcmFuc2Zvcm1zRnJvbVF1ZXVlKCkge1xuICAgIGlmIChcbiAgICAgICF0aGlzLmRvbmUgfHxcbiAgICAgICF0aGlzLl90aW1lbGluZSB8fFxuICAgICAgIXRoaXMuX3RpbWVsaW5lLl9ydW5uZXJJZHMuaW5jbHVkZXModGhpcy5pZClcbiAgICApIHtcbiAgICAgIHRoaXMuX3F1ZXVlID0gdGhpcy5fcXVldWUuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgIHJldHVybiAhaXRlbS5pc1RyYW5zZm9ybVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBkZWxheShkZWxheSkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdGUoMCwgZGVsYXkpXG4gIH1cblxuICBkdXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZXMgKiAodGhpcy5fd2FpdCArIHRoaXMuX2R1cmF0aW9uKSAtIHRoaXMuX3dhaXRcbiAgfVxuXG4gIGR1cmluZyhmbikge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlKG51bGwsIGZuKVxuICB9XG5cbiAgZWFzZShmbikge1xuICAgIHRoaXMuX3N0ZXBwZXIgPSBuZXcgRWFzZShmbilcbiAgICByZXR1cm4gdGhpc1xuICB9XG4gIC8qXG4gIFJ1bm5lciBEZWZpbml0aW9uc1xuICA9PT09PT09PT09PT09PT09PT1cbiAgVGhlc2UgbWV0aG9kcyBoZWxwIHVzIGRlZmluZSB0aGUgcnVudGltZSBiZWhhdmlvdXIgb2YgdGhlIFJ1bm5lciBvciB0aGV5XG4gIGhlbHAgdXMgbWFrZSBuZXcgcnVubmVycyBmcm9tIHRoZSBjdXJyZW50IHJ1bm5lclxuICAqL1xuXG4gIGVsZW1lbnQoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHJldHVybiB0aGlzLl9lbGVtZW50XG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnRcbiAgICBlbGVtZW50Ll9wcmVwYXJlUnVubmVyKClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZmluaXNoKCkge1xuICAgIHJldHVybiB0aGlzLnN0ZXAoSW5maW5pdHkpXG4gIH1cblxuICBsb29wKHRpbWVzLCBzd2luZywgd2FpdCkge1xuICAgIC8vIERlYWwgd2l0aCB0aGUgdXNlciBwYXNzaW5nIGluIGFuIG9iamVjdFxuICAgIGlmICh0eXBlb2YgdGltZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICBzd2luZyA9IHRpbWVzLnN3aW5nXG4gICAgICB3YWl0ID0gdGltZXMud2FpdFxuICAgICAgdGltZXMgPSB0aW1lcy50aW1lc1xuICAgIH1cblxuICAgIC8vIFNhbml0aXNlIHRoZSB2YWx1ZXMgYW5kIHN0b3JlIHRoZW1cbiAgICB0aGlzLl90aW1lcyA9IHRpbWVzIHx8IEluZmluaXR5XG4gICAgdGhpcy5fc3dpbmcgPSBzd2luZyB8fCBmYWxzZVxuICAgIHRoaXMuX3dhaXQgPSB3YWl0IHx8IDBcblxuICAgIC8vIEFsbG93IHRydWUgdG8gYmUgcGFzc2VkXG4gICAgaWYgKHRoaXMuX3RpbWVzID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl90aW1lcyA9IEluZmluaXR5XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGxvb3BzKHApIHtcbiAgICBjb25zdCBsb29wRHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3dhaXRcbiAgICBpZiAocCA9PSBudWxsKSB7XG4gICAgICBjb25zdCBsb29wc0RvbmUgPSBNYXRoLmZsb29yKHRoaXMuX3RpbWUgLyBsb29wRHVyYXRpb24pXG4gICAgICBjb25zdCByZWxhdGl2ZVRpbWUgPSB0aGlzLl90aW1lIC0gbG9vcHNEb25lICogbG9vcER1cmF0aW9uXG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHJlbGF0aXZlVGltZSAvIHRoaXMuX2R1cmF0aW9uXG4gICAgICByZXR1cm4gTWF0aC5taW4obG9vcHNEb25lICsgcG9zaXRpb24sIHRoaXMuX3RpbWVzKVxuICAgIH1cbiAgICBjb25zdCB3aG9sZSA9IE1hdGguZmxvb3IocClcbiAgICBjb25zdCBwYXJ0aWFsID0gcCAlIDFcbiAgICBjb25zdCB0aW1lID0gbG9vcER1cmF0aW9uICogd2hvbGUgKyB0aGlzLl9kdXJhdGlvbiAqIHBhcnRpYWxcbiAgICByZXR1cm4gdGhpcy50aW1lKHRpbWUpXG4gIH1cblxuICBwZXJzaXN0KGR0T3JGb3JldmVyKSB7XG4gICAgaWYgKGR0T3JGb3JldmVyID09IG51bGwpIHJldHVybiB0aGlzLl9wZXJzaXN0XG4gICAgdGhpcy5fcGVyc2lzdCA9IGR0T3JGb3JldmVyXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHBvc2l0aW9uKHApIHtcbiAgICAvLyBHZXQgYWxsIG9mIHRoZSB2YXJpYWJsZXMgd2UgbmVlZFxuICAgIGNvbnN0IHggPSB0aGlzLl90aW1lXG4gICAgY29uc3QgZCA9IHRoaXMuX2R1cmF0aW9uXG4gICAgY29uc3QgdyA9IHRoaXMuX3dhaXRcbiAgICBjb25zdCB0ID0gdGhpcy5fdGltZXNcbiAgICBjb25zdCBzID0gdGhpcy5fc3dpbmdcbiAgICBjb25zdCByID0gdGhpcy5fcmV2ZXJzZVxuICAgIGxldCBwb3NpdGlvblxuXG4gICAgaWYgKHAgPT0gbnVsbCkge1xuICAgICAgLypcbiAgICAgIFRoaXMgZnVuY3Rpb24gY29udmVydHMgYSB0aW1lIHRvIGEgcG9zaXRpb24gaW4gdGhlIHJhbmdlIFswLCAxXVxuICAgICAgVGhlIGZ1bGwgZXhwbGFuYXRpb24gY2FuIGJlIGZvdW5kIGluIHRoaXMgZGVzbW9zIGRlbW9uc3RyYXRpb25cbiAgICAgICAgaHR0cHM6Ly93d3cuZGVzbW9zLmNvbS9jYWxjdWxhdG9yL3U0ZmJhdmdjaGVcbiAgICAgIFRoZSBsb2dpYyBpcyBzbGlnaHRseSBzaW1wbGlmaWVkIGhlcmUgYmVjYXVzZSB3ZSBjYW4gdXNlIGJvb2xlYW5zXG4gICAgICAqL1xuXG4gICAgICAvLyBGaWd1cmUgb3V0IHRoZSB2YWx1ZSB3aXRob3V0IHRoaW5raW5nIGFib3V0IHRoZSBzdGFydCBvciBlbmQgdGltZVxuICAgICAgY29uc3QgZiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGNvbnN0IHN3aW5naW5nID0gcyAqIE1hdGguZmxvb3IoKHggJSAoMiAqICh3ICsgZCkpKSAvICh3ICsgZCkpXG4gICAgICAgIGNvbnN0IGJhY2t3YXJkcyA9IChzd2luZ2luZyAmJiAhcikgfHwgKCFzd2luZ2luZyAmJiByKVxuICAgICAgICBjb25zdCB1bmNsaXBlZCA9XG4gICAgICAgICAgKE1hdGgucG93KC0xLCBiYWNrd2FyZHMpICogKHggJSAodyArIGQpKSkgLyBkICsgYmFja3dhcmRzXG4gICAgICAgIGNvbnN0IGNsaXBwZWQgPSBNYXRoLm1heChNYXRoLm1pbih1bmNsaXBlZCwgMSksIDApXG4gICAgICAgIHJldHVybiBjbGlwcGVkXG4gICAgICB9XG5cbiAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIHZhbHVlIGJ5IGluY29ycG9yYXRpbmcgdGhlIHN0YXJ0IHRpbWVcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSB0ICogKHcgKyBkKSAtIHdcbiAgICAgIHBvc2l0aW9uID1cbiAgICAgICAgeCA8PSAwXG4gICAgICAgICAgPyBNYXRoLnJvdW5kKGYoMWUtNSkpXG4gICAgICAgICAgOiB4IDwgZW5kVGltZVxuICAgICAgICAgICAgPyBmKHgpXG4gICAgICAgICAgICA6IE1hdGgucm91bmQoZihlbmRUaW1lIC0gMWUtNSkpXG4gICAgICByZXR1cm4gcG9zaXRpb25cbiAgICB9XG5cbiAgICAvLyBXb3JrIG91dCB0aGUgbG9vcHMgZG9uZSBhbmQgYWRkIHRoZSBwb3NpdGlvbiB0byB0aGUgbG9vcHMgZG9uZVxuICAgIGNvbnN0IGxvb3BzRG9uZSA9IE1hdGguZmxvb3IodGhpcy5sb29wcygpKVxuICAgIGNvbnN0IHN3aW5nRm9yd2FyZCA9IHMgJiYgbG9vcHNEb25lICUgMiA9PT0gMFxuICAgIGNvbnN0IGZvcndhcmRzID0gKHN3aW5nRm9yd2FyZCAmJiAhcikgfHwgKHIgJiYgc3dpbmdGb3J3YXJkKVxuICAgIHBvc2l0aW9uID0gbG9vcHNEb25lICsgKGZvcndhcmRzID8gcCA6IDEgLSBwKVxuICAgIHJldHVybiB0aGlzLmxvb3BzKHBvc2l0aW9uKVxuICB9XG5cbiAgcHJvZ3Jlc3MocCkge1xuICAgIGlmIChwID09IG51bGwpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbigxLCB0aGlzLl90aW1lIC8gdGhpcy5kdXJhdGlvbigpKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy50aW1lKHAgKiB0aGlzLmR1cmF0aW9uKCkpXG4gIH1cblxuICAvKlxuICBCYXNpYyBGdW5jdGlvbmFsaXR5XG4gID09PT09PT09PT09PT09PT09PT1cbiAgVGhlc2UgbWV0aG9kcyBhbGxvdyB1cyB0byBhdHRhY2ggYmFzaWMgZnVuY3Rpb25zIHRvIHRoZSBydW5uZXIgZGlyZWN0bHlcbiAgKi9cbiAgcXVldWUoaW5pdEZuLCBydW5GbiwgcmV0YXJnZXRGbiwgaXNUcmFuc2Zvcm0pIHtcbiAgICB0aGlzLl9xdWV1ZS5wdXNoKHtcbiAgICAgIGluaXRpYWxpc2VyOiBpbml0Rm4gfHwgbm9vcCxcbiAgICAgIHJ1bm5lcjogcnVuRm4gfHwgbm9vcCxcbiAgICAgIHJldGFyZ2V0OiByZXRhcmdldEZuLFxuICAgICAgaXNUcmFuc2Zvcm06IGlzVHJhbnNmb3JtLFxuICAgICAgaW5pdGlhbGlzZWQ6IGZhbHNlLFxuICAgICAgZmluaXNoZWQ6IGZhbHNlXG4gICAgfSlcbiAgICBjb25zdCB0aW1lbGluZSA9IHRoaXMudGltZWxpbmUoKVxuICAgIHRpbWVsaW5lICYmIHRoaXMudGltZWxpbmUoKS5fY29udGludWUoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByZXNldCgpIHtcbiAgICBpZiAodGhpcy5fcmVzZXRlZCkgcmV0dXJuIHRoaXNcbiAgICB0aGlzLnRpbWUoMClcbiAgICB0aGlzLl9yZXNldGVkID0gdHJ1ZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByZXZlcnNlKHJldmVyc2UpIHtcbiAgICB0aGlzLl9yZXZlcnNlID0gcmV2ZXJzZSA9PSBudWxsID8gIXRoaXMuX3JldmVyc2UgOiByZXZlcnNlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHNjaGVkdWxlKHRpbWVsaW5lLCBkZWxheSwgd2hlbikge1xuICAgIC8vIFRoZSB1c2VyIGRvZXNuJ3QgbmVlZCB0byBwYXNzIGEgdGltZWxpbmUgaWYgd2UgYWxyZWFkeSBoYXZlIG9uZVxuICAgIGlmICghKHRpbWVsaW5lIGluc3RhbmNlb2YgVGltZWxpbmUpKSB7XG4gICAgICB3aGVuID0gZGVsYXlcbiAgICAgIGRlbGF5ID0gdGltZWxpbmVcbiAgICAgIHRpbWVsaW5lID0gdGhpcy50aW1lbGluZSgpXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gdGltZWxpbmUsIHllbGwgYXQgdGhlIHVzZXIuLi5cbiAgICBpZiAoIXRpbWVsaW5lKSB7XG4gICAgICB0aHJvdyBFcnJvcignUnVubmVyIGNhbm5vdCBiZSBzY2hlZHVsZWQgd2l0aG91dCB0aW1lbGluZScpXG4gICAgfVxuXG4gICAgLy8gU2NoZWR1bGUgdGhlIHJ1bm5lciBvbiB0aGUgdGltZWxpbmUgcHJvdmlkZWRcbiAgICB0aW1lbGluZS5zY2hlZHVsZSh0aGlzLCBkZWxheSwgd2hlbilcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RlcChkdCkge1xuICAgIC8vIElmIHdlIGFyZSBpbmFjdGl2ZSwgdGhpcyBzdGVwcGVyIGp1c3QgZ2V0cyBza2lwcGVkXG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybiB0aGlzXG5cbiAgICAvLyBVcGRhdGUgdGhlIHRpbWUgYW5kIGdldCB0aGUgbmV3IHBvc2l0aW9uXG4gICAgZHQgPSBkdCA9PSBudWxsID8gMTYgOiBkdFxuICAgIHRoaXMuX3RpbWUgKz0gZHRcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb24oKVxuXG4gICAgLy8gRmlndXJlIG91dCBpZiB3ZSBuZWVkIHRvIHJ1biB0aGUgc3RlcHBlciBpbiB0aGlzIGZyYW1lXG4gICAgY29uc3QgcnVubmluZyA9IHRoaXMuX2xhc3RQb3NpdGlvbiAhPT0gcG9zaXRpb24gJiYgdGhpcy5fdGltZSA+PSAwXG4gICAgdGhpcy5fbGFzdFBvc2l0aW9uID0gcG9zaXRpb25cblxuICAgIC8vIEZpZ3VyZSBvdXQgaWYgd2UganVzdCBzdGFydGVkXG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uKClcbiAgICBjb25zdCBqdXN0U3RhcnRlZCA9IHRoaXMuX2xhc3RUaW1lIDw9IDAgJiYgdGhpcy5fdGltZSA+IDBcbiAgICBjb25zdCBqdXN0RmluaXNoZWQgPSB0aGlzLl9sYXN0VGltZSA8IGR1cmF0aW9uICYmIHRoaXMuX3RpbWUgPj0gZHVyYXRpb25cblxuICAgIHRoaXMuX2xhc3RUaW1lID0gdGhpcy5fdGltZVxuICAgIGlmIChqdXN0U3RhcnRlZCkge1xuICAgICAgdGhpcy5maXJlKCdzdGFydCcsIHRoaXMpXG4gICAgfVxuXG4gICAgLy8gV29yayBvdXQgaWYgdGhlIHJ1bm5lciBpcyBmaW5pc2hlZCBzZXQgdGhlIGRvbmUgZmxhZyBoZXJlIHNvIGFuaW1hdGlvbnNcbiAgICAvLyBrbm93LCB0aGF0IHRoZXkgYXJlIHJ1bm5pbmcgaW4gdGhlIGxhc3Qgc3RlcCAodGhpcyBpcyBnb29kIGZvclxuICAgIC8vIHRyYW5zZm9ybWF0aW9ucyB3aGljaCBjYW4gYmUgbWVyZ2VkKVxuICAgIGNvbnN0IGRlY2xhcmF0aXZlID0gdGhpcy5faXNEZWNsYXJhdGl2ZVxuICAgIHRoaXMuZG9uZSA9ICFkZWNsYXJhdGl2ZSAmJiAhanVzdEZpbmlzaGVkICYmIHRoaXMuX3RpbWUgPj0gZHVyYXRpb25cblxuICAgIC8vIFJ1bm5lciBpcyBydW5uaW5nLiBTbyBpdHMgbm90IGluIHJlc2V0IHN0YXRlIGFueW1vcmVcbiAgICB0aGlzLl9yZXNldGVkID0gZmFsc2VcblxuICAgIGxldCBjb252ZXJnZWQgPSBmYWxzZVxuICAgIC8vIENhbGwgaW5pdGlhbGlzZSBhbmQgdGhlIHJ1biBmdW5jdGlvblxuICAgIGlmIChydW5uaW5nIHx8IGRlY2xhcmF0aXZlKSB7XG4gICAgICB0aGlzLl9pbml0aWFsaXNlKHJ1bm5pbmcpXG5cbiAgICAgIC8vIGNsZWFyIHRoZSB0cmFuc2Zvcm1zIG9uIHRoaXMgcnVubmVyIHNvIHRoZXkgZG9udCBnZXQgYWRkZWQgYWdhaW4gYW5kIGFnYWluXG4gICAgICB0aGlzLnRyYW5zZm9ybXMgPSBuZXcgTWF0cml4KClcbiAgICAgIGNvbnZlcmdlZCA9IHRoaXMuX3J1bihkZWNsYXJhdGl2ZSA/IGR0IDogcG9zaXRpb24pXG5cbiAgICAgIHRoaXMuZmlyZSgnc3RlcCcsIHRoaXMpXG4gICAgfVxuICAgIC8vIGNvcnJlY3QgdGhlIGRvbmUgZmxhZyBoZXJlXG4gICAgLy8gZGVjbGFyYXRpdmUgYW5pbWF0aW9ucyBpdHNlbGYga25vdyB3aGVuIHRoZXkgY29udmVyZ2VkXG4gICAgdGhpcy5kb25lID0gdGhpcy5kb25lIHx8IChjb252ZXJnZWQgJiYgZGVjbGFyYXRpdmUpXG4gICAgaWYgKGp1c3RGaW5pc2hlZCkge1xuICAgICAgdGhpcy5maXJlKCdmaW5pc2hlZCcsIHRoaXMpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKlxuICBSdW5uZXIgYW5pbWF0aW9uIG1ldGhvZHNcbiAgPT09PT09PT09PT09PT09PT09PT09PT09XG4gIENvbnRyb2wgaG93IHRoZSBhbmltYXRpb24gcGxheXNcbiAgKi9cbiAgdGltZSh0aW1lKSB7XG4gICAgaWYgKHRpbWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RpbWVcbiAgICB9XG4gICAgY29uc3QgZHQgPSB0aW1lIC0gdGhpcy5fdGltZVxuICAgIHRoaXMuc3RlcChkdClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdGltZWxpbmUodGltZWxpbmUpIHtcbiAgICAvLyBjaGVjayBleHBsaWNpdGx5IGZvciB1bmRlZmluZWQgc28gd2UgY2FuIHNldCB0aGUgdGltZWxpbmUgdG8gbnVsbFxuICAgIGlmICh0eXBlb2YgdGltZWxpbmUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdGhpcy5fdGltZWxpbmVcbiAgICB0aGlzLl90aW1lbGluZSA9IHRpbWVsaW5lXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHVuc2NoZWR1bGUoKSB7XG4gICAgY29uc3QgdGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lKClcbiAgICB0aW1lbGluZSAmJiB0aW1lbGluZS51bnNjaGVkdWxlKHRoaXMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIFJ1biBlYWNoIGluaXRpYWxpc2UgZnVuY3Rpb24gaW4gdGhlIHJ1bm5lciBpZiByZXF1aXJlZFxuICBfaW5pdGlhbGlzZShydW5uaW5nKSB7XG4gICAgLy8gSWYgd2UgYXJlbid0IHJ1bm5pbmcsIHdlIHNob3VsZG4ndCBpbml0aWFsaXNlIHdoZW4gbm90IGRlY2xhcmF0aXZlXG4gICAgaWYgKCFydW5uaW5nICYmICF0aGlzLl9pc0RlY2xhcmF0aXZlKSByZXR1cm5cblxuICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgb2YgdGhlIGluaXRpYWxpc2Vyc1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGluaXRpYWxpc2VyXG4gICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5fcXVldWVbaV1cblxuICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgd2UgbmVlZCB0byBpbml0aWFsaXNlXG4gICAgICBjb25zdCBuZWVkc0l0ID0gdGhpcy5faXNEZWNsYXJhdGl2ZSB8fCAoIWN1cnJlbnQuaW5pdGlhbGlzZWQgJiYgcnVubmluZylcbiAgICAgIHJ1bm5pbmcgPSAhY3VycmVudC5maW5pc2hlZFxuXG4gICAgICAvLyBDYWxsIHRoZSBpbml0aWFsaXNlciBpZiB3ZSBuZWVkIHRvXG4gICAgICBpZiAobmVlZHNJdCAmJiBydW5uaW5nKSB7XG4gICAgICAgIGN1cnJlbnQuaW5pdGlhbGlzZXIuY2FsbCh0aGlzKVxuICAgICAgICBjdXJyZW50LmluaXRpYWxpc2VkID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNhdmUgYSBtb3JwaGVyIHRvIHRoZSBtb3JwaGVyIGxpc3Qgc28gdGhhdCB3ZSBjYW4gcmV0YXJnZXQgaXQgbGF0ZXJcbiAgX3JlbWVtYmVyTW9ycGhlcihtZXRob2QsIG1vcnBoZXIpIHtcbiAgICB0aGlzLl9oaXN0b3J5W21ldGhvZF0gPSB7XG4gICAgICBtb3JwaGVyOiBtb3JwaGVyLFxuICAgICAgY2FsbGVyOiB0aGlzLl9xdWV1ZVt0aGlzLl9xdWV1ZS5sZW5ndGggLSAxXVxuICAgIH1cblxuICAgIC8vIFdlIGhhdmUgdG8gcmVzdW1lIHRoZSB0aW1lbGluZSBpbiBjYXNlIGEgY29udHJvbGxlclxuICAgIC8vIGlzIGFscmVhZHkgZG9uZSB3aXRob3V0IGJlaW5nIGV2ZXIgcnVuXG4gICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gZS5nLiB0aGlzIGlzIGRvbmU6XG4gICAgLy8gICAgYW5pbSA9IGVsLmFuaW1hdGUobmV3IFNWRy5TcHJpbmcpXG4gICAgLy8gYW5kIGxhdGVyXG4gICAgLy8gICAgYW5pbS5tb3ZlKC4uLilcbiAgICBpZiAodGhpcy5faXNEZWNsYXJhdGl2ZSkge1xuICAgICAgY29uc3QgdGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lKClcbiAgICAgIHRpbWVsaW5lICYmIHRpbWVsaW5lLnBsYXkoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFRyeSB0byBzZXQgdGhlIHRhcmdldCBmb3IgYSBtb3JwaGVyIGlmIHRoZSBtb3JwaGVyIGV4aXN0cywgb3RoZXJ3aXNlXG4gIC8vIFJ1biBlYWNoIHJ1biBmdW5jdGlvbiBmb3IgdGhlIHBvc2l0aW9uIG9yIGR0IGdpdmVuXG4gIF9ydW4ocG9zaXRpb25PckR0KSB7XG4gICAgLy8gUnVuIGFsbCBvZiB0aGUgX3F1ZXVlIGRpcmVjdGx5XG4gICAgbGV0IGFsbGZpbmlzaGVkID0gdHJ1ZVxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGZ1bmN0aW9uIHRvIHJ1blxuICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuX3F1ZXVlW2ldXG5cbiAgICAgIC8vIFJ1biB0aGUgZnVuY3Rpb24gaWYgaXRzIG5vdCBmaW5pc2hlZCwgd2Uga2VlcCB0cmFjayBvZiB0aGUgZmluaXNoZWRcbiAgICAgIC8vIGZsYWcgZm9yIHRoZSBzYWtlIG9mIGRlY2xhcmF0aXZlIF9xdWV1ZVxuICAgICAgY29uc3QgY29udmVyZ2VkID0gY3VycmVudC5ydW5uZXIuY2FsbCh0aGlzLCBwb3NpdGlvbk9yRHQpXG4gICAgICBjdXJyZW50LmZpbmlzaGVkID0gY3VycmVudC5maW5pc2hlZCB8fCBjb252ZXJnZWQgPT09IHRydWVcbiAgICAgIGFsbGZpbmlzaGVkID0gYWxsZmluaXNoZWQgJiYgY3VycmVudC5maW5pc2hlZFxuICAgIH1cblxuICAgIC8vIFdlIHJlcG9ydCB3aGVuIGFsbCBvZiB0aGUgY29uc3RydWN0b3JzIGFyZSBmaW5pc2hlZFxuICAgIHJldHVybiBhbGxmaW5pc2hlZFxuICB9XG5cbiAgLy8gZG8gbm90aGluZyBhbmQgcmV0dXJuIGZhbHNlXG4gIF90cnlSZXRhcmdldChtZXRob2QsIHRhcmdldCwgZXh0cmEpIHtcbiAgICBpZiAodGhpcy5faGlzdG9yeVttZXRob2RdKSB7XG4gICAgICAvLyBpZiB0aGUgbGFzdCBtZXRob2Qgd2Fzbid0IGV2ZW4gaW5pdGlhbGlzZWQsIHRocm93IGl0IGF3YXlcbiAgICAgIGlmICghdGhpcy5faGlzdG9yeVttZXRob2RdLmNhbGxlci5pbml0aWFsaXNlZCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3F1ZXVlLmluZGV4T2YodGhpcy5faGlzdG9yeVttZXRob2RdLmNhbGxlcilcbiAgICAgICAgdGhpcy5fcXVldWUuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgLy8gZm9yIHRoZSBjYXNlIG9mIHRyYW5zZm9ybWF0aW9ucywgd2UgdXNlIHRoZSBzcGVjaWFsIHJldGFyZ2V0IGZ1bmN0aW9uXG4gICAgICAvLyB3aGljaCBoYXMgYWNjZXNzIHRvIHRoZSBvdXRlciBzY29wZVxuICAgICAgaWYgKHRoaXMuX2hpc3RvcnlbbWV0aG9kXS5jYWxsZXIucmV0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5faGlzdG9yeVttZXRob2RdLmNhbGxlci5yZXRhcmdldC5jYWxsKHRoaXMsIHRhcmdldCwgZXh0cmEpXG4gICAgICAgIC8vIGZvciBldmVyeXRoaW5nIGVsc2UgYSBzaW1wbGUgbW9ycGhlciBjaGFuZ2UgaXMgc3VmZmljaWVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faGlzdG9yeVttZXRob2RdLm1vcnBoZXIudG8odGFyZ2V0KVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9oaXN0b3J5W21ldGhvZF0uY2FsbGVyLmZpbmlzaGVkID0gZmFsc2VcbiAgICAgIGNvbnN0IHRpbWVsaW5lID0gdGhpcy50aW1lbGluZSgpXG4gICAgICB0aW1lbGluZSAmJiB0aW1lbGluZS5wbGF5KClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cblJ1bm5lci5pZCA9IDBcblxuZXhwb3J0IGNsYXNzIEZha2VSdW5uZXIge1xuICBjb25zdHJ1Y3Rvcih0cmFuc2Zvcm1zID0gbmV3IE1hdHJpeCgpLCBpZCA9IC0xLCBkb25lID0gdHJ1ZSkge1xuICAgIHRoaXMudHJhbnNmb3JtcyA9IHRyYW5zZm9ybXNcbiAgICB0aGlzLmlkID0gaWRcbiAgICB0aGlzLmRvbmUgPSBkb25lXG4gIH1cblxuICBjbGVhclRyYW5zZm9ybXNGcm9tUXVldWUoKSB7fVxufVxuXG5leHRlbmQoW1J1bm5lciwgRmFrZVJ1bm5lcl0sIHtcbiAgbWVyZ2VXaXRoKHJ1bm5lcikge1xuICAgIHJldHVybiBuZXcgRmFrZVJ1bm5lcihcbiAgICAgIHJ1bm5lci50cmFuc2Zvcm1zLmxtdWx0aXBseSh0aGlzLnRyYW5zZm9ybXMpLFxuICAgICAgcnVubmVyLmlkXG4gICAgKVxuICB9XG59KVxuXG4vLyBGYWtlUnVubmVyLmVtcHR5UnVubmVyID0gbmV3IEZha2VSdW5uZXIoKVxuXG5jb25zdCBsbXVsdGlwbHkgPSAobGFzdCwgY3VycikgPT4gbGFzdC5sbXVsdGlwbHlPKGN1cnIpXG5jb25zdCBnZXRSdW5uZXJUcmFuc2Zvcm0gPSAocnVubmVyKSA9PiBydW5uZXIudHJhbnNmb3Jtc1xuXG5mdW5jdGlvbiBtZXJnZVRyYW5zZm9ybXMoKSB7XG4gIC8vIEZpbmQgdGhlIG1hdHJpeCB0byBhcHBseSB0byB0aGUgZWxlbWVudCBhbmQgYXBwbHkgaXRcbiAgY29uc3QgcnVubmVycyA9IHRoaXMuX3RyYW5zZm9ybWF0aW9uUnVubmVycy5ydW5uZXJzXG4gIGNvbnN0IG5ldFRyYW5zZm9ybSA9IHJ1bm5lcnNcbiAgICAubWFwKGdldFJ1bm5lclRyYW5zZm9ybSlcbiAgICAucmVkdWNlKGxtdWx0aXBseSwgbmV3IE1hdHJpeCgpKVxuXG4gIHRoaXMudHJhbnNmb3JtKG5ldFRyYW5zZm9ybSlcblxuICB0aGlzLl90cmFuc2Zvcm1hdGlvblJ1bm5lcnMubWVyZ2UoKVxuXG4gIGlmICh0aGlzLl90cmFuc2Zvcm1hdGlvblJ1bm5lcnMubGVuZ3RoKCkgPT09IDEpIHtcbiAgICB0aGlzLl9mcmFtZUlkID0gbnVsbFxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSdW5uZXJBcnJheSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucnVubmVycyA9IFtdXG4gICAgdGhpcy5pZHMgPSBbXVxuICB9XG5cbiAgYWRkKHJ1bm5lcikge1xuICAgIGlmICh0aGlzLnJ1bm5lcnMuaW5jbHVkZXMocnVubmVyKSkgcmV0dXJuXG4gICAgY29uc3QgaWQgPSBydW5uZXIuaWQgKyAxXG5cbiAgICB0aGlzLnJ1bm5lcnMucHVzaChydW5uZXIpXG4gICAgdGhpcy5pZHMucHVzaChpZClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBjbGVhckJlZm9yZShpZCkge1xuICAgIGNvbnN0IGRlbGV0ZUNudCA9IHRoaXMuaWRzLmluZGV4T2YoaWQgKyAxKSB8fCAxXG4gICAgdGhpcy5pZHMuc3BsaWNlKDAsIGRlbGV0ZUNudCwgMClcbiAgICB0aGlzLnJ1bm5lcnNcbiAgICAgIC5zcGxpY2UoMCwgZGVsZXRlQ250LCBuZXcgRmFrZVJ1bm5lcigpKVxuICAgICAgLmZvckVhY2goKHIpID0+IHIuY2xlYXJUcmFuc2Zvcm1zRnJvbVF1ZXVlKCkpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGVkaXQoaWQsIG5ld1J1bm5lcikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pZHMuaW5kZXhPZihpZCArIDEpXG4gICAgdGhpcy5pZHMuc3BsaWNlKGluZGV4LCAxLCBpZCArIDEpXG4gICAgdGhpcy5ydW5uZXJzLnNwbGljZShpbmRleCwgMSwgbmV3UnVubmVyKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXRCeUlEKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMucnVubmVyc1t0aGlzLmlkcy5pbmRleE9mKGlkICsgMSldXG4gIH1cblxuICBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWRzLmxlbmd0aFxuICB9XG5cbiAgbWVyZ2UoKSB7XG4gICAgbGV0IGxhc3RSdW5uZXIgPSBudWxsXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJ1bm5lcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHJ1bm5lciA9IHRoaXMucnVubmVyc1tpXVxuXG4gICAgICBjb25zdCBjb25kaXRpb24gPVxuICAgICAgICBsYXN0UnVubmVyICYmXG4gICAgICAgIHJ1bm5lci5kb25lICYmXG4gICAgICAgIGxhc3RSdW5uZXIuZG9uZSAmJlxuICAgICAgICAvLyBkb24ndCBtZXJnZSBydW5uZXIgd2hlbiBwZXJzaXN0ZWQgb24gdGltZWxpbmVcbiAgICAgICAgKCFydW5uZXIuX3RpbWVsaW5lIHx8XG4gICAgICAgICAgIXJ1bm5lci5fdGltZWxpbmUuX3J1bm5lcklkcy5pbmNsdWRlcyhydW5uZXIuaWQpKSAmJlxuICAgICAgICAoIWxhc3RSdW5uZXIuX3RpbWVsaW5lIHx8XG4gICAgICAgICAgIWxhc3RSdW5uZXIuX3RpbWVsaW5lLl9ydW5uZXJJZHMuaW5jbHVkZXMobGFzdFJ1bm5lci5pZCkpXG5cbiAgICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgICAgLy8gdGhlICsxIGhhcHBlbnMgaW4gdGhlIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMucmVtb3ZlKHJ1bm5lci5pZClcbiAgICAgICAgY29uc3QgbmV3UnVubmVyID0gcnVubmVyLm1lcmdlV2l0aChsYXN0UnVubmVyKVxuICAgICAgICB0aGlzLmVkaXQobGFzdFJ1bm5lci5pZCwgbmV3UnVubmVyKVxuICAgICAgICBsYXN0UnVubmVyID0gbmV3UnVubmVyXG4gICAgICAgIC0taVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdFJ1bm5lciA9IHJ1bm5lclxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByZW1vdmUoaWQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuaWRzLmluZGV4T2YoaWQgKyAxKVxuICAgIHRoaXMuaWRzLnNwbGljZShpbmRleCwgMSlcbiAgICB0aGlzLnJ1bm5lcnMuc3BsaWNlKGluZGV4LCAxKVxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxucmVnaXN0ZXJNZXRob2RzKHtcbiAgRWxlbWVudDoge1xuICAgIGFuaW1hdGUoZHVyYXRpb24sIGRlbGF5LCB3aGVuKSB7XG4gICAgICBjb25zdCBvID0gUnVubmVyLnNhbml0aXNlKGR1cmF0aW9uLCBkZWxheSwgd2hlbilcbiAgICAgIGNvbnN0IHRpbWVsaW5lID0gdGhpcy50aW1lbGluZSgpXG4gICAgICByZXR1cm4gbmV3IFJ1bm5lcihvLmR1cmF0aW9uKVxuICAgICAgICAubG9vcChvKVxuICAgICAgICAuZWxlbWVudCh0aGlzKVxuICAgICAgICAudGltZWxpbmUodGltZWxpbmUucGxheSgpKVxuICAgICAgICAuc2NoZWR1bGUoby5kZWxheSwgby53aGVuKVxuICAgIH0sXG5cbiAgICBkZWxheShieSwgd2hlbikge1xuICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSgwLCBieSwgd2hlbilcbiAgICB9LFxuXG4gICAgLy8gdGhpcyBmdW5jdGlvbiBzZWFyY2hlcyBmb3IgYWxsIHJ1bm5lcnMgb24gdGhlIGVsZW1lbnQgYW5kIGRlbGV0ZXMgdGhlIG9uZXNcbiAgICAvLyB3aGljaCBydW4gYmVmb3JlIHRoZSBjdXJyZW50IG9uZS4gVGhpcyBpcyBiZWNhdXNlIGFic29sdXRlIHRyYW5zZm9ybWF0aW9uc1xuICAgIC8vIG92ZXJ3cml0ZSBhbnl0aGluZyBhbnl3YXkgc28gdGhlcmUgaXMgbm8gbmVlZCB0byB3YXN0ZSB0aW1lIGNvbXB1dGluZ1xuICAgIC8vIG90aGVyIHJ1bm5lcnNcbiAgICBfY2xlYXJUcmFuc2Zvcm1SdW5uZXJzQmVmb3JlKGN1cnJlbnRSdW5uZXIpIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybWF0aW9uUnVubmVycy5jbGVhckJlZm9yZShjdXJyZW50UnVubmVyLmlkKVxuICAgIH0sXG5cbiAgICBfY3VycmVudFRyYW5zZm9ybShjdXJyZW50KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1hdGlvblJ1bm5lcnMucnVubmVyc1xuICAgICAgICAgIC8vIHdlIG5lZWQgdGhlIGVxdWFsIHNpZ24gaGVyZSB0byBtYWtlIHN1cmUsIHRoYXQgYWxzbyB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgICAvLyBvbiB0aGUgc2FtZSBydW5uZXIgd2hpY2ggZXhlY3V0ZSBiZWZvcmUgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gYXJlXG4gICAgICAgICAgLy8gdGFrZW4gaW50byBhY2NvdW50XG4gICAgICAgICAgLmZpbHRlcigocnVubmVyKSA9PiBydW5uZXIuaWQgPD0gY3VycmVudC5pZClcbiAgICAgICAgICAubWFwKGdldFJ1bm5lclRyYW5zZm9ybSlcbiAgICAgICAgICAucmVkdWNlKGxtdWx0aXBseSwgbmV3IE1hdHJpeCgpKVxuICAgICAgKVxuICAgIH0sXG5cbiAgICBfYWRkUnVubmVyKHJ1bm5lcikge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtYXRpb25SdW5uZXJzLmFkZChydW5uZXIpXG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBydW5uZXIgbWVyZ2UgaXMgZXhlY3V0ZWQgYXQgdGhlIHZlcnkgZW5kIG9mXG4gICAgICAvLyBhbGwgQW5pbWF0b3IgZnVuY3Rpb25zLiBUaGF0IGlzIHdoeSB3ZSB1c2UgaW1tZWRpYXRlIGhlcmUgdG8gZXhlY3V0ZVxuICAgICAgLy8gdGhlIG1lcmdlIHJpZ2h0IGFmdGVyIGFsbCBmcmFtZXMgYXJlIHJ1blxuICAgICAgQW5pbWF0b3IuY2FuY2VsSW1tZWRpYXRlKHRoaXMuX2ZyYW1lSWQpXG4gICAgICB0aGlzLl9mcmFtZUlkID0gQW5pbWF0b3IuaW1tZWRpYXRlKG1lcmdlVHJhbnNmb3Jtcy5iaW5kKHRoaXMpKVxuICAgIH0sXG5cbiAgICBfcHJlcGFyZVJ1bm5lcigpIHtcbiAgICAgIGlmICh0aGlzLl9mcmFtZUlkID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtYXRpb25SdW5uZXJzID0gbmV3IFJ1bm5lckFycmF5KCkuYWRkKFxuICAgICAgICAgIG5ldyBGYWtlUnVubmVyKG5ldyBNYXRyaXgodGhpcykpXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pXG5cbi8vIFdpbGwgb3V0cHV0IHRoZSBlbGVtZW50cyBmcm9tIGFycmF5IEEgdGhhdCBhcmUgbm90IGluIHRoZSBhcnJheSBCXG5jb25zdCBkaWZmZXJlbmNlID0gKGEsIGIpID0+IGEuZmlsdGVyKCh4KSA9PiAhYi5pbmNsdWRlcyh4KSlcblxuZXh0ZW5kKFJ1bm5lciwge1xuICBhdHRyKGEsIHYpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZUF0dHIoJ2F0dHInLCBhLCB2KVxuICB9LFxuXG4gIC8vIEFkZCBhbmltYXRhYmxlIHN0eWxlc1xuICBjc3Mocywgdikge1xuICAgIHJldHVybiB0aGlzLnN0eWxlQXR0cignY3NzJywgcywgdilcbiAgfSxcblxuICBzdHlsZUF0dHIodHlwZSwgbmFtZU9yQXR0cnMsIHZhbCkge1xuICAgIGlmICh0eXBlb2YgbmFtZU9yQXR0cnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHlsZUF0dHIodHlwZSwgeyBbbmFtZU9yQXR0cnNdOiB2YWwgfSlcbiAgICB9XG5cbiAgICBsZXQgYXR0cnMgPSBuYW1lT3JBdHRyc1xuICAgIGlmICh0aGlzLl90cnlSZXRhcmdldCh0eXBlLCBhdHRycykpIHJldHVybiB0aGlzXG5cbiAgICBsZXQgbW9ycGhlciA9IG5ldyBNb3JwaGFibGUodGhpcy5fc3RlcHBlcikudG8oYXR0cnMpXG4gICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhhdHRycylcblxuICAgIHRoaXMucXVldWUoXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1vcnBoZXIgPSBtb3JwaGVyLmZyb20odGhpcy5lbGVtZW50KClbdHlwZV0oa2V5cykpXG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB0aGlzLmVsZW1lbnQoKVt0eXBlXShtb3JwaGVyLmF0KHBvcykudmFsdWVPZigpKVxuICAgICAgICByZXR1cm4gbW9ycGhlci5kb25lKClcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiAobmV3VG9BdHRycykge1xuICAgICAgICAvLyBDaGVjayBpZiBhbnkgbmV3IGtleXMgd2VyZSBhZGRlZFxuICAgICAgICBjb25zdCBuZXdLZXlzID0gT2JqZWN0LmtleXMobmV3VG9BdHRycylcbiAgICAgICAgY29uc3QgZGlmZmVyZW5jZXMgPSBkaWZmZXJlbmNlKG5ld0tleXMsIGtleXMpXG5cbiAgICAgICAgLy8gSWYgdGhlaXIgYXJlIG5ldyBrZXlzLCBpbml0aWFsaXplIHRoZW0gYW5kIGFkZCB0aGVtIHRvIG1vcnBoZXJcbiAgICAgICAgaWYgKGRpZmZlcmVuY2VzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIEdldCB0aGUgdmFsdWVzXG4gICAgICAgICAgY29uc3QgYWRkZWRGcm9tQXR0cnMgPSB0aGlzLmVsZW1lbnQoKVt0eXBlXShkaWZmZXJlbmNlcylcblxuICAgICAgICAgIC8vIEdldCB0aGUgYWxyZWFkeSBpbml0aWFsaXplZCB2YWx1ZXNcbiAgICAgICAgICBjb25zdCBvbGRGcm9tQXR0cnMgPSBuZXcgT2JqZWN0QmFnKG1vcnBoZXIuZnJvbSgpKS52YWx1ZU9mKClcblxuICAgICAgICAgIC8vIE1lcmdlIG9sZCBhbmQgbmV3XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihvbGRGcm9tQXR0cnMsIGFkZGVkRnJvbUF0dHJzKVxuICAgICAgICAgIG1vcnBoZXIuZnJvbShvbGRGcm9tQXR0cnMpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgdGhlIG9iamVjdCBmcm9tIHRoZSBtb3JwaGVyXG4gICAgICAgIGNvbnN0IG9sZFRvQXR0cnMgPSBuZXcgT2JqZWN0QmFnKG1vcnBoZXIudG8oKSkudmFsdWVPZigpXG5cbiAgICAgICAgLy8gTWVyZ2UgaW4gbmV3IGF0dHJpYnV0ZXNcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvbGRUb0F0dHJzLCBuZXdUb0F0dHJzKVxuXG4gICAgICAgIC8vIENoYW5nZSBtb3JwaGVyIHRhcmdldFxuICAgICAgICBtb3JwaGVyLnRvKG9sZFRvQXR0cnMpXG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2Ugc2F2ZSB0aGUgd29yayB3ZSBkaWQgc28gd2UgZG9uJ3QgbmVlZCBpdCB0byBkbyBhZ2FpblxuICAgICAgICBrZXlzID0gbmV3S2V5c1xuICAgICAgICBhdHRycyA9IG5ld1RvQXR0cnNcbiAgICAgIH1cbiAgICApXG5cbiAgICB0aGlzLl9yZW1lbWJlck1vcnBoZXIodHlwZSwgbW9ycGhlcilcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuXG4gIHpvb20obGV2ZWwsIHBvaW50KSB7XG4gICAgaWYgKHRoaXMuX3RyeVJldGFyZ2V0KCd6b29tJywgbGV2ZWwsIHBvaW50KSkgcmV0dXJuIHRoaXNcblxuICAgIGxldCBtb3JwaGVyID0gbmV3IE1vcnBoYWJsZSh0aGlzLl9zdGVwcGVyKS50byhuZXcgU1ZHTnVtYmVyKGxldmVsKSlcblxuICAgIHRoaXMucXVldWUoXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1vcnBoZXIgPSBtb3JwaGVyLmZyb20odGhpcy5lbGVtZW50KCkuem9vbSgpKVxuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50KCkuem9vbShtb3JwaGVyLmF0KHBvcyksIHBvaW50KVxuICAgICAgICByZXR1cm4gbW9ycGhlci5kb25lKClcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiAobmV3TGV2ZWwsIG5ld1BvaW50KSB7XG4gICAgICAgIHBvaW50ID0gbmV3UG9pbnRcbiAgICAgICAgbW9ycGhlci50byhuZXdMZXZlbClcbiAgICAgIH1cbiAgICApXG5cbiAgICB0aGlzLl9yZW1lbWJlck1vcnBoZXIoJ3pvb20nLCBtb3JwaGVyKVxuICAgIHJldHVybiB0aGlzXG4gIH0sXG5cbiAgLyoqXG4gICAqKiBhYnNvbHV0ZSB0cmFuc2Zvcm1hdGlvbnNcbiAgICoqL1xuXG4gIC8vXG4gIC8vIE0gdiAtLS0tLXwtLS0tLShEIE0gdiA9IEYgdiktLS0tLS18LS0tLS0+ICBUIHZcbiAgLy9cbiAgLy8gMS4gZGVmaW5lIHRoZSBmaW5hbCBzdGF0ZSAoVCkgYW5kIGRlY29tcG9zZSBpdCAob25jZSlcbiAgLy8gICAgdCA9IFt0eCwgdHksIHRoZSwgbGFtLCBzeSwgc3hdXG4gIC8vIDIuIG9uIGV2ZXJ5IGZyYW1lOiBwdWxsIHRoZSBjdXJyZW50IHN0YXRlIG9mIGFsbCBwcmV2aW91cyB0cmFuc2Zvcm1zXG4gIC8vICAgIChNIC0gbSBjYW4gY2hhbmdlKVxuICAvLyAgIGFuZCB0aGVuIHdyaXRlIHRoaXMgYXMgbSA9IFt0eDAsIHR5MCwgdGhlMCwgbGFtMCwgc3kwLCBzeDBdXG4gIC8vIDMuIEZpbmQgdGhlIGludGVycG9sYXRlZCBtYXRyaXggRihwb3MpID0gbSArIHBvcyAqICh0IC0gbSlcbiAgLy8gICAtIE5vdGUgRigwKSA9IE1cbiAgLy8gICAtIE5vdGUgRigxKSA9IFRcbiAgLy8gNC4gTm93IHlvdSBnZXQgdGhlIGRlbHRhIG1hdHJpeCBhcyBhIHJlc3VsdDogRCA9IEYgKiBpbnYoTSlcblxuICB0cmFuc2Zvcm0odHJhbnNmb3JtcywgcmVsYXRpdmUsIGFmZmluZSkge1xuICAgIC8vIElmIHdlIGhhdmUgYSBkZWNsYXJhdGl2ZSBmdW5jdGlvbiwgd2Ugc2hvdWxkIHJldGFyZ2V0IGl0IGlmIHBvc3NpYmxlXG4gICAgcmVsYXRpdmUgPSB0cmFuc2Zvcm1zLnJlbGF0aXZlIHx8IHJlbGF0aXZlXG4gICAgaWYgKFxuICAgICAgdGhpcy5faXNEZWNsYXJhdGl2ZSAmJlxuICAgICAgIXJlbGF0aXZlICYmXG4gICAgICB0aGlzLl90cnlSZXRhcmdldCgndHJhbnNmb3JtJywgdHJhbnNmb3JtcylcbiAgICApIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gUGFyc2UgdGhlIHBhcmFtZXRlcnNcbiAgICBjb25zdCBpc01hdHJpeCA9IE1hdHJpeC5pc01hdHJpeExpa2UodHJhbnNmb3JtcylcbiAgICBhZmZpbmUgPVxuICAgICAgdHJhbnNmb3Jtcy5hZmZpbmUgIT0gbnVsbFxuICAgICAgICA/IHRyYW5zZm9ybXMuYWZmaW5lXG4gICAgICAgIDogYWZmaW5lICE9IG51bGxcbiAgICAgICAgICA/IGFmZmluZVxuICAgICAgICAgIDogIWlzTWF0cml4XG5cbiAgICAvLyBDcmVhdGUgYSBtb3JwaGVyIGFuZCBzZXQgaXRzIHR5cGVcbiAgICBjb25zdCBtb3JwaGVyID0gbmV3IE1vcnBoYWJsZSh0aGlzLl9zdGVwcGVyKS50eXBlKFxuICAgICAgYWZmaW5lID8gVHJhbnNmb3JtQmFnIDogTWF0cml4XG4gICAgKVxuXG4gICAgbGV0IG9yaWdpblxuICAgIGxldCBlbGVtZW50XG4gICAgbGV0IGN1cnJlbnRcbiAgICBsZXQgY3VycmVudEFuZ2xlXG4gICAgbGV0IHN0YXJ0VHJhbnNmb3JtXG5cbiAgICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBlbGVtZW50IGFuZCBvcmlnaW4gaXMgZGVmaW5lZFxuICAgICAgZWxlbWVudCA9IGVsZW1lbnQgfHwgdGhpcy5lbGVtZW50KClcbiAgICAgIG9yaWdpbiA9IG9yaWdpbiB8fCBnZXRPcmlnaW4odHJhbnNmb3JtcywgZWxlbWVudClcblxuICAgICAgc3RhcnRUcmFuc2Zvcm0gPSBuZXcgTWF0cml4KHJlbGF0aXZlID8gdW5kZWZpbmVkIDogZWxlbWVudClcblxuICAgICAgLy8gYWRkIHRoZSBydW5uZXIgdG8gdGhlIGVsZW1lbnQgc28gaXQgY2FuIG1lcmdlIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgZWxlbWVudC5fYWRkUnVubmVyKHRoaXMpXG5cbiAgICAgIC8vIERlYWN0aXZhdGUgYWxsIHRyYW5zZm9ybXMgdGhhdCBoYXZlIHJ1biBzbyBmYXIgaWYgd2UgYXJlIGFic29sdXRlXG4gICAgICBpZiAoIXJlbGF0aXZlKSB7XG4gICAgICAgIGVsZW1lbnQuX2NsZWFyVHJhbnNmb3JtUnVubmVyc0JlZm9yZSh0aGlzKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bihwb3MpIHtcbiAgICAgIC8vIGNsZWFyIGFsbCBvdGhlciB0cmFuc2Zvcm1zIGJlZm9yZSB0aGlzIGluIGNhc2Ugc29tZXRoaW5nIGlzIHNhdmVkXG4gICAgICAvLyBvbiB0aGlzIHJ1bm5lci4gV2UgYXJlIGFic29sdXRlLiBXZSBkb250IG5lZWQgdGhlc2UhXG4gICAgICBpZiAoIXJlbGF0aXZlKSB0aGlzLmNsZWFyVHJhbnNmb3JtKClcblxuICAgICAgY29uc3QgeyB4LCB5IH0gPSBuZXcgUG9pbnQob3JpZ2luKS50cmFuc2Zvcm0oXG4gICAgICAgIGVsZW1lbnQuX2N1cnJlbnRUcmFuc2Zvcm0odGhpcylcbiAgICAgIClcblxuICAgICAgbGV0IHRhcmdldCA9IG5ldyBNYXRyaXgoeyAuLi50cmFuc2Zvcm1zLCBvcmlnaW46IFt4LCB5XSB9KVxuICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5faXNEZWNsYXJhdGl2ZSAmJiBjdXJyZW50ID8gY3VycmVudCA6IHN0YXJ0VHJhbnNmb3JtXG5cbiAgICAgIGlmIChhZmZpbmUpIHtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LmRlY29tcG9zZSh4LCB5KVxuICAgICAgICBzdGFydCA9IHN0YXJ0LmRlY29tcG9zZSh4LCB5KVxuXG4gICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBhbmQgdGFyZ2V0IGFuZ2xlIGFzIGl0IHdhcyBzZXRcbiAgICAgICAgY29uc3QgclRhcmdldCA9IHRhcmdldC5yb3RhdGVcbiAgICAgICAgY29uc3QgckN1cnJlbnQgPSBzdGFydC5yb3RhdGVcblxuICAgICAgICAvLyBGaWd1cmUgb3V0IHRoZSBzaG9ydGVzdCBwYXRoIHRvIHJvdGF0ZSBkaXJlY3RseVxuICAgICAgICBjb25zdCBwb3NzaWJpbGl0aWVzID0gW3JUYXJnZXQgLSAzNjAsIHJUYXJnZXQsIHJUYXJnZXQgKyAzNjBdXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlcyA9IHBvc3NpYmlsaXRpZXMubWFwKChhKSA9PiBNYXRoLmFicyhhIC0gckN1cnJlbnQpKVxuICAgICAgICBjb25zdCBzaG9ydGVzdCA9IE1hdGgubWluKC4uLmRpc3RhbmNlcylcbiAgICAgICAgY29uc3QgaW5kZXggPSBkaXN0YW5jZXMuaW5kZXhPZihzaG9ydGVzdClcbiAgICAgICAgdGFyZ2V0LnJvdGF0ZSA9IHBvc3NpYmlsaXRpZXNbaW5kZXhdXG4gICAgICB9XG5cbiAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAvLyB3ZSBoYXZlIHRvIGJlIGNhcmVmdWwgaGVyZSBub3QgdG8gb3ZlcndyaXRlIHRoZSByb3RhdGlvblxuICAgICAgICAvLyB3aXRoIHRoZSByb3RhdGUgbWV0aG9kIG9mIE1hdHJpeFxuICAgICAgICBpZiAoIWlzTWF0cml4KSB7XG4gICAgICAgICAgdGFyZ2V0LnJvdGF0ZSA9IHRyYW5zZm9ybXMucm90YXRlIHx8IDBcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faXNEZWNsYXJhdGl2ZSAmJiBjdXJyZW50QW5nbGUpIHtcbiAgICAgICAgICBzdGFydC5yb3RhdGUgPSBjdXJyZW50QW5nbGVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtb3JwaGVyLmZyb20oc3RhcnQpXG4gICAgICBtb3JwaGVyLnRvKHRhcmdldClcblxuICAgICAgY29uc3QgYWZmaW5lUGFyYW1ldGVycyA9IG1vcnBoZXIuYXQocG9zKVxuICAgICAgY3VycmVudEFuZ2xlID0gYWZmaW5lUGFyYW1ldGVycy5yb3RhdGVcbiAgICAgIGN1cnJlbnQgPSBuZXcgTWF0cml4KGFmZmluZVBhcmFtZXRlcnMpXG5cbiAgICAgIHRoaXMuYWRkVHJhbnNmb3JtKGN1cnJlbnQpXG4gICAgICBlbGVtZW50Ll9hZGRSdW5uZXIodGhpcylcbiAgICAgIHJldHVybiBtb3JwaGVyLmRvbmUoKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJldGFyZ2V0KG5ld1RyYW5zZm9ybXMpIHtcbiAgICAgIC8vIG9ubHkgZ2V0IGEgbmV3IG9yaWdpbiBpZiBpdCBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGNhbGxcbiAgICAgIGlmIChcbiAgICAgICAgKG5ld1RyYW5zZm9ybXMub3JpZ2luIHx8ICdjZW50ZXInKS50b1N0cmluZygpICE9PVxuICAgICAgICAodHJhbnNmb3Jtcy5vcmlnaW4gfHwgJ2NlbnRlcicpLnRvU3RyaW5nKClcbiAgICAgICkge1xuICAgICAgICBvcmlnaW4gPSBnZXRPcmlnaW4obmV3VHJhbnNmb3JtcywgZWxlbWVudClcbiAgICAgIH1cblxuICAgICAgLy8gb3ZlcndyaXRlIHRoZSBvbGQgdHJhbnNmb3JtYXRpb25zIHdpdGggdGhlIG5ldyBvbmVzXG4gICAgICB0cmFuc2Zvcm1zID0geyAuLi5uZXdUcmFuc2Zvcm1zLCBvcmlnaW4gfVxuICAgIH1cblxuICAgIHRoaXMucXVldWUoc2V0dXAsIHJ1biwgcmV0YXJnZXQsIHRydWUpXG4gICAgdGhpcy5faXNEZWNsYXJhdGl2ZSAmJiB0aGlzLl9yZW1lbWJlck1vcnBoZXIoJ3RyYW5zZm9ybScsIG1vcnBoZXIpXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcblxuICAvLyBBbmltYXRhYmxlIHgtYXhpc1xuICB4KHgpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVldWVOdW1iZXIoJ3gnLCB4KVxuICB9LFxuXG4gIC8vIEFuaW1hdGFibGUgeS1heGlzXG4gIHkoeSkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlcigneScsIHkpXG4gIH0sXG5cbiAgYXgoeCkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlcignYXgnLCB4KVxuICB9LFxuXG4gIGF5KHkpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVldWVOdW1iZXIoJ2F5JywgeSlcbiAgfSxcblxuICBkeCh4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlckRlbHRhKCd4JywgeClcbiAgfSxcblxuICBkeSh5ID0gMCkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlckRlbHRhKCd5JywgeSlcbiAgfSxcblxuICBkbW92ZSh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuZHgoeCkuZHkoeSlcbiAgfSxcblxuICBfcXVldWVOdW1iZXJEZWx0YShtZXRob2QsIHRvKSB7XG4gICAgdG8gPSBuZXcgU1ZHTnVtYmVyKHRvKVxuXG4gICAgLy8gVHJ5IHRvIGNoYW5nZSB0aGUgdGFyZ2V0IGlmIHdlIGhhdmUgdGhpcyBtZXRob2QgYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgaWYgKHRoaXMuX3RyeVJldGFyZ2V0KG1ldGhvZCwgdG8pKSByZXR1cm4gdGhpc1xuXG4gICAgLy8gTWFrZSBhIG1vcnBoZXIgYW5kIHF1ZXVlIHRoZSBhbmltYXRpb25cbiAgICBjb25zdCBtb3JwaGVyID0gbmV3IE1vcnBoYWJsZSh0aGlzLl9zdGVwcGVyKS50byh0bylcbiAgICBsZXQgZnJvbSA9IG51bGxcbiAgICB0aGlzLnF1ZXVlKFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBmcm9tID0gdGhpcy5lbGVtZW50KClbbWV0aG9kXSgpXG4gICAgICAgIG1vcnBoZXIuZnJvbShmcm9tKVxuICAgICAgICBtb3JwaGVyLnRvKGZyb20gKyB0bylcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCgpW21ldGhvZF0obW9ycGhlci5hdChwb3MpKVxuICAgICAgICByZXR1cm4gbW9ycGhlci5kb25lKClcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiAobmV3VG8pIHtcbiAgICAgICAgbW9ycGhlci50byhmcm9tICsgbmV3IFNWR051bWJlcihuZXdUbykpXG4gICAgICB9XG4gICAgKVxuXG4gICAgLy8gUmVnaXN0ZXIgdGhlIG1vcnBoZXIgc28gdGhhdCBpZiBpdCBpcyBjaGFuZ2VkIGFnYWluLCB3ZSBjYW4gcmV0YXJnZXQgaXRcbiAgICB0aGlzLl9yZW1lbWJlck1vcnBoZXIobWV0aG9kLCBtb3JwaGVyKVxuICAgIHJldHVybiB0aGlzXG4gIH0sXG5cbiAgX3F1ZXVlT2JqZWN0KG1ldGhvZCwgdG8pIHtcbiAgICAvLyBUcnkgdG8gY2hhbmdlIHRoZSB0YXJnZXQgaWYgd2UgaGF2ZSB0aGlzIG1ldGhvZCBhbHJlYWR5IHJlZ2lzdGVyZWRcbiAgICBpZiAodGhpcy5fdHJ5UmV0YXJnZXQobWV0aG9kLCB0bykpIHJldHVybiB0aGlzXG5cbiAgICAvLyBNYWtlIGEgbW9ycGhlciBhbmQgcXVldWUgdGhlIGFuaW1hdGlvblxuICAgIGNvbnN0IG1vcnBoZXIgPSBuZXcgTW9ycGhhYmxlKHRoaXMuX3N0ZXBwZXIpLnRvKHRvKVxuICAgIHRoaXMucXVldWUoXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1vcnBoZXIuZnJvbSh0aGlzLmVsZW1lbnQoKVttZXRob2RdKCkpXG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB0aGlzLmVsZW1lbnQoKVttZXRob2RdKG1vcnBoZXIuYXQocG9zKSlcbiAgICAgICAgcmV0dXJuIG1vcnBoZXIuZG9uZSgpXG4gICAgICB9XG4gICAgKVxuXG4gICAgLy8gUmVnaXN0ZXIgdGhlIG1vcnBoZXIgc28gdGhhdCBpZiBpdCBpcyBjaGFuZ2VkIGFnYWluLCB3ZSBjYW4gcmV0YXJnZXQgaXRcbiAgICB0aGlzLl9yZW1lbWJlck1vcnBoZXIobWV0aG9kLCBtb3JwaGVyKVxuICAgIHJldHVybiB0aGlzXG4gIH0sXG5cbiAgX3F1ZXVlTnVtYmVyKG1ldGhvZCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVldWVPYmplY3QobWV0aG9kLCBuZXcgU1ZHTnVtYmVyKHZhbHVlKSlcbiAgfSxcblxuICAvLyBBbmltYXRhYmxlIGNlbnRlciB4LWF4aXNcbiAgY3goeCkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlcignY3gnLCB4KVxuICB9LFxuXG4gIC8vIEFuaW1hdGFibGUgY2VudGVyIHktYXhpc1xuICBjeSh5KSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlTnVtYmVyKCdjeScsIHkpXG4gIH0sXG5cbiAgLy8gQWRkIGFuaW1hdGFibGUgbW92ZVxuICBtb3ZlKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy54KHgpLnkoeSlcbiAgfSxcblxuICBhbW92ZSh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuYXgoeCkuYXkoeSlcbiAgfSxcblxuICAvLyBBZGQgYW5pbWF0YWJsZSBjZW50ZXJcbiAgY2VudGVyKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5jeCh4KS5jeSh5KVxuICB9LFxuXG4gIC8vIEFkZCBhbmltYXRhYmxlIHNpemVcbiAgc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgLy8gYW5pbWF0ZSBiYm94IGJhc2VkIHNpemUgZm9yIGFsbCBvdGhlciBlbGVtZW50c1xuICAgIGxldCBib3hcblxuICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgYm94ID0gdGhpcy5fZWxlbWVudC5iYm94KClcbiAgICB9XG5cbiAgICBpZiAoIXdpZHRoKSB7XG4gICAgICB3aWR0aCA9IChib3gud2lkdGggLyBib3guaGVpZ2h0KSAqIGhlaWdodFxuICAgIH1cblxuICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSAoYm94LmhlaWdodCAvIGJveC53aWR0aCkgKiB3aWR0aFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLndpZHRoKHdpZHRoKS5oZWlnaHQoaGVpZ2h0KVxuICB9LFxuXG4gIC8vIEFkZCBhbmltYXRhYmxlIHdpZHRoXG4gIHdpZHRoKHdpZHRoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlTnVtYmVyKCd3aWR0aCcsIHdpZHRoKVxuICB9LFxuXG4gIC8vIEFkZCBhbmltYXRhYmxlIGhlaWdodFxuICBoZWlnaHQoaGVpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlTnVtYmVyKCdoZWlnaHQnLCBoZWlnaHQpXG4gIH0sXG5cbiAgLy8gQWRkIGFuaW1hdGFibGUgcGxvdFxuICBwbG90KGEsIGIsIGMsIGQpIHtcbiAgICAvLyBMaW5lcyBjYW4gYmUgcGxvdHRlZCB3aXRoIDQgYXJndW1lbnRzXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBsb3QoW2EsIGIsIGMsIGRdKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl90cnlSZXRhcmdldCgncGxvdCcsIGEpKSByZXR1cm4gdGhpc1xuXG4gICAgY29uc3QgbW9ycGhlciA9IG5ldyBNb3JwaGFibGUodGhpcy5fc3RlcHBlcilcbiAgICAgIC50eXBlKHRoaXMuX2VsZW1lbnQuTW9ycGhBcnJheSlcbiAgICAgIC50byhhKVxuXG4gICAgdGhpcy5xdWV1ZShcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbW9ycGhlci5mcm9tKHRoaXMuX2VsZW1lbnQuYXJyYXkoKSlcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQucGxvdChtb3JwaGVyLmF0KHBvcykpXG4gICAgICAgIHJldHVybiBtb3JwaGVyLmRvbmUoKVxuICAgICAgfVxuICAgIClcblxuICAgIHRoaXMuX3JlbWVtYmVyTW9ycGhlcigncGxvdCcsIG1vcnBoZXIpXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcblxuICAvLyBBZGQgbGVhZGluZyBtZXRob2RcbiAgbGVhZGluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlcignbGVhZGluZycsIHZhbHVlKVxuICB9LFxuXG4gIC8vIEFkZCBhbmltYXRhYmxlIHZpZXdib3hcbiAgdmlld2JveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlT2JqZWN0KCd2aWV3Ym94JywgbmV3IEJveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSlcbiAgfSxcblxuICB1cGRhdGUobykge1xuICAgIGlmICh0eXBlb2YgbyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSh7XG4gICAgICAgIG9mZnNldDogYXJndW1lbnRzWzBdLFxuICAgICAgICBjb2xvcjogYXJndW1lbnRzWzFdLFxuICAgICAgICBvcGFjaXR5OiBhcmd1bWVudHNbMl1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKG8ub3BhY2l0eSAhPSBudWxsKSB0aGlzLmF0dHIoJ3N0b3Atb3BhY2l0eScsIG8ub3BhY2l0eSlcbiAgICBpZiAoby5jb2xvciAhPSBudWxsKSB0aGlzLmF0dHIoJ3N0b3AtY29sb3InLCBvLmNvbG9yKVxuICAgIGlmIChvLm9mZnNldCAhPSBudWxsKSB0aGlzLmF0dHIoJ29mZnNldCcsIG8ub2Zmc2V0KVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufSlcblxuZXh0ZW5kKFJ1bm5lciwgeyByeCwgcnksIGZyb20sIHRvIH0pXG5yZWdpc3RlcihSdW5uZXIsICdSdW5uZXInKVxuIiwiaW1wb3J0IHtcbiAgYWRvcHQsXG4gIG5vZGVPck5ldyxcbiAgcmVnaXN0ZXIsXG4gIHdyYXBXaXRoQXR0ckNoZWNrXG59IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5pbXBvcnQgeyBzdmcsIHhsaW5rLCB4bWxucyB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9uYW1lc3BhY2VzLmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9Db250YWluZXIuanMnXG5pbXBvcnQgRGVmcyBmcm9tICcuL0RlZnMuanMnXG5pbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vdXRpbHMvd2luZG93LmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdmcgZXh0ZW5kcyBDb250YWluZXIge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ3N2ZycsIG5vZGUpLCBhdHRycylcbiAgICB0aGlzLm5hbWVzcGFjZSgpXG4gIH1cblxuICAvLyBDcmVhdGVzIGFuZCByZXR1cm5zIGRlZnMgZWxlbWVudFxuICBkZWZzKCkge1xuICAgIGlmICghdGhpcy5pc1Jvb3QoKSkgcmV0dXJuIHRoaXMucm9vdCgpLmRlZnMoKVxuXG4gICAgcmV0dXJuIGFkb3B0KHRoaXMubm9kZS5xdWVyeVNlbGVjdG9yKCdkZWZzJykpIHx8IHRoaXMucHV0KG5ldyBEZWZzKCkpXG4gIH1cblxuICBpc1Jvb3QoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICF0aGlzLm5vZGUucGFyZW50Tm9kZSB8fFxuICAgICAgKCEodGhpcy5ub2RlLnBhcmVudE5vZGUgaW5zdGFuY2VvZiBnbG9iYWxzLndpbmRvdy5TVkdFbGVtZW50KSAmJlxuICAgICAgICB0aGlzLm5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZSAhPT0gJyNkb2N1bWVudC1mcmFnbWVudCcpXG4gICAgKVxuICB9XG5cbiAgLy8gQWRkIG5hbWVzcGFjZXNcbiAgbmFtZXNwYWNlKCkge1xuICAgIGlmICghdGhpcy5pc1Jvb3QoKSkgcmV0dXJuIHRoaXMucm9vdCgpLm5hbWVzcGFjZSgpXG4gICAgcmV0dXJuIHRoaXMuYXR0cih7IHhtbG5zOiBzdmcsIHZlcnNpb246ICcxLjEnIH0pLmF0dHIoXG4gICAgICAneG1sbnM6eGxpbmsnLFxuICAgICAgeGxpbmssXG4gICAgICB4bWxuc1xuICAgIClcbiAgfVxuXG4gIHJlbW92ZU5hbWVzcGFjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKHsgeG1sbnM6IG51bGwsIHZlcnNpb246IG51bGwgfSlcbiAgICAgIC5hdHRyKCd4bWxuczp4bGluaycsIG51bGwsIHhtbG5zKVxuICAgICAgLmF0dHIoJ3htbG5zOnN2Z2pzJywgbnVsbCwgeG1sbnMpXG4gIH1cblxuICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgcm9vdCBzdmdcbiAgLy8gSWYgbm90LCBjYWxsIHJvb3QoKSBmcm9tIHRoaXMgZWxlbWVudFxuICByb290KCkge1xuICAgIGlmICh0aGlzLmlzUm9vdCgpKSByZXR1cm4gdGhpc1xuICAgIHJldHVybiBzdXBlci5yb290KClcbiAgfVxufVxuXG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgbmVzdGVkIHN2ZyBkb2N1bWVudFxuICAgIG5lc3RlZDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTdmcoKSlcbiAgICB9KVxuICB9XG59KVxuXG5yZWdpc3RlcihTdmcsICdTdmcnLCB0cnVlKVxuIiwiaW1wb3J0IHsgbm9kZU9yTmV3LCByZWdpc3Rlciwgd3JhcFdpdGhBdHRyQ2hlY2sgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9Db250YWluZXIuanMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN5bWJvbCBleHRlbmRzIENvbnRhaW5lciB7XG4gIC8vIEluaXRpYWxpemUgbm9kZVxuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ3N5bWJvbCcsIG5vZGUpLCBhdHRycylcbiAgfVxufVxuXG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICBzeW1ib2w6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU3ltYm9sKCkpXG4gICAgfSlcbiAgfVxufSlcblxucmVnaXN0ZXIoU3ltYm9sLCAnU3ltYm9sJylcbiIsImltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi8uLi91dGlscy93aW5kb3cuanMnXG5cbi8vIENyZWF0ZSBwbGFpbiB0ZXh0IG5vZGVcbmV4cG9ydCBmdW5jdGlvbiBwbGFpbih0ZXh0KSB7XG4gIC8vIGNsZWFyIGlmIGJ1aWxkIG1vZGUgaXMgZGlzYWJsZWRcbiAgaWYgKHRoaXMuX2J1aWxkID09PSBmYWxzZSkge1xuICAgIHRoaXMuY2xlYXIoKVxuICB9XG5cbiAgLy8gY3JlYXRlIHRleHQgbm9kZVxuICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoZ2xvYmFscy5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSlcblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBHZXQgbGVuZ3RoIG9mIHRleHQgZWxlbWVudFxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKVxufVxuXG4vLyBNb3ZlIG92ZXIgeC1heGlzXG4vLyBUZXh0IGlzIG1vdmVkIGJ5IGl0cyBib3VuZGluZyBib3hcbi8vIHRleHQtYW5jaG9yIGRvZXMgTk9UIG1hdHRlclxuZXhwb3J0IGZ1bmN0aW9uIHgoeCwgYm94ID0gdGhpcy5iYm94KCkpIHtcbiAgaWYgKHggPT0gbnVsbCkge1xuICAgIHJldHVybiBib3gueFxuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXR0cigneCcsIHRoaXMuYXR0cigneCcpICsgeCAtIGJveC54KVxufVxuXG4vLyBNb3ZlIG92ZXIgeS1heGlzXG5leHBvcnQgZnVuY3Rpb24geSh5LCBib3ggPSB0aGlzLmJib3goKSkge1xuICBpZiAoeSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGJveC55XG4gIH1cblxuICByZXR1cm4gdGhpcy5hdHRyKCd5JywgdGhpcy5hdHRyKCd5JykgKyB5IC0gYm94LnkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb3ZlKHgsIHksIGJveCA9IHRoaXMuYmJveCgpKSB7XG4gIHJldHVybiB0aGlzLngoeCwgYm94KS55KHksIGJveClcbn1cblxuLy8gTW92ZSBjZW50ZXIgb3ZlciB4LWF4aXNcbmV4cG9ydCBmdW5jdGlvbiBjeCh4LCBib3ggPSB0aGlzLmJib3goKSkge1xuICBpZiAoeCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGJveC5jeFxuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXR0cigneCcsIHRoaXMuYXR0cigneCcpICsgeCAtIGJveC5jeClcbn1cblxuLy8gTW92ZSBjZW50ZXIgb3ZlciB5LWF4aXNcbmV4cG9ydCBmdW5jdGlvbiBjeSh5LCBib3ggPSB0aGlzLmJib3goKSkge1xuICBpZiAoeSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGJveC5jeVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXR0cigneScsIHRoaXMuYXR0cigneScpICsgeSAtIGJveC5jeSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNlbnRlcih4LCB5LCBib3ggPSB0aGlzLmJib3goKSkge1xuICByZXR1cm4gdGhpcy5jeCh4LCBib3gpLmN5KHksIGJveClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGF4KHgpIHtcbiAgcmV0dXJuIHRoaXMuYXR0cigneCcsIHgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBheSh5KSB7XG4gIHJldHVybiB0aGlzLmF0dHIoJ3knLCB5KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYW1vdmUoeCwgeSkge1xuICByZXR1cm4gdGhpcy5heCh4KS5heSh5KVxufVxuXG4vLyBFbmFibGUgLyBkaXNhYmxlIGJ1aWxkIG1vZGVcbmV4cG9ydCBmdW5jdGlvbiBidWlsZChidWlsZCkge1xuICB0aGlzLl9idWlsZCA9ICEhYnVpbGRcbiAgcmV0dXJuIHRoaXNcbn1cbiIsImltcG9ydCB7XG4gIGFkb3B0LFxuICBleHRlbmQsXG4gIG5vZGVPck5ldyxcbiAgcmVnaXN0ZXIsXG4gIHdyYXBXaXRoQXR0ckNoZWNrXG59IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xuaW1wb3J0IFNWR051bWJlciBmcm9tICcuLi90eXBlcy9TVkdOdW1iZXIuanMnXG5pbXBvcnQgU2hhcGUgZnJvbSAnLi9TaGFwZS5qcydcbmltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi91dGlscy93aW5kb3cuanMnXG5pbXBvcnQgKiBhcyB0ZXh0YWJsZSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvdGV4dGFibGUuanMnXG5pbXBvcnQgeyBpc0Rlc2NyaXB0aXZlLCB3cml0ZURhdGFUb0RvbSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0IGV4dGVuZHMgU2hhcGUge1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCd0ZXh0Jywgbm9kZSksIGF0dHJzKVxuXG4gICAgdGhpcy5kb20ubGVhZGluZyA9IHRoaXMuZG9tLmxlYWRpbmcgPz8gbmV3IFNWR051bWJlcigxLjMpIC8vIHN0b3JlIGxlYWRpbmcgdmFsdWUgZm9yIHJlYnVpbGRpbmdcbiAgICB0aGlzLl9yZWJ1aWxkID0gdHJ1ZSAvLyBlbmFibGUgYXV0b21hdGljIHVwZGF0aW5nIG9mIGR5IHZhbHVlc1xuICAgIHRoaXMuX2J1aWxkID0gZmFsc2UgLy8gZGlzYWJsZSBidWlsZCBtb2RlIGZvciBhZGRpbmcgbXVsdGlwbGUgbGluZXNcbiAgfVxuXG4gIC8vIFNldCAvIGdldCBsZWFkaW5nXG4gIGxlYWRpbmcodmFsdWUpIHtcbiAgICAvLyBhY3QgYXMgZ2V0dGVyXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvbS5sZWFkaW5nXG4gICAgfVxuXG4gICAgLy8gYWN0IGFzIHNldHRlclxuICAgIHRoaXMuZG9tLmxlYWRpbmcgPSBuZXcgU1ZHTnVtYmVyKHZhbHVlKVxuXG4gICAgcmV0dXJuIHRoaXMucmVidWlsZCgpXG4gIH1cblxuICAvLyBSZWJ1aWxkIGFwcGVhcmFuY2UgdHlwZVxuICByZWJ1aWxkKHJlYnVpbGQpIHtcbiAgICAvLyBzdG9yZSBuZXcgcmVidWlsZCBmbGFnIGlmIGdpdmVuXG4gICAgaWYgKHR5cGVvZiByZWJ1aWxkID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHRoaXMuX3JlYnVpbGQgPSByZWJ1aWxkXG4gICAgfVxuXG4gICAgLy8gZGVmaW5lIHBvc2l0aW9uIG9mIGFsbCBsaW5lc1xuICAgIGlmICh0aGlzLl9yZWJ1aWxkKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgICAgbGV0IGJsYW5rTGluZU9mZnNldCA9IDBcbiAgICAgIGNvbnN0IGxlYWRpbmcgPSB0aGlzLmRvbS5sZWFkaW5nXG5cbiAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICBpZiAoaXNEZXNjcmlwdGl2ZSh0aGlzLm5vZGUpKSByZXR1cm5cblxuICAgICAgICBjb25zdCBmb250U2l6ZSA9IGdsb2JhbHMud2luZG93XG4gICAgICAgICAgLmdldENvbXB1dGVkU3R5bGUodGhpcy5ub2RlKVxuICAgICAgICAgIC5nZXRQcm9wZXJ0eVZhbHVlKCdmb250LXNpemUnKVxuXG4gICAgICAgIGNvbnN0IGR5ID0gbGVhZGluZyAqIG5ldyBTVkdOdW1iZXIoZm9udFNpemUpXG5cbiAgICAgICAgaWYgKHRoaXMuZG9tLm5ld0xpbmVkKSB7XG4gICAgICAgICAgdGhpcy5hdHRyKCd4Jywgc2VsZi5hdHRyKCd4JykpXG5cbiAgICAgICAgICBpZiAodGhpcy50ZXh0KCkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBibGFua0xpbmVPZmZzZXQgKz0gZHlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hdHRyKCdkeScsIGkgPyBkeSArIGJsYW5rTGluZU9mZnNldCA6IDApXG4gICAgICAgICAgICBibGFua0xpbmVPZmZzZXQgPSAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICB0aGlzLmZpcmUoJ3JlYnVpbGQnKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBvdmVyd3JpdGUgbWV0aG9kIGZyb20gcGFyZW50IHRvIHNldCBkYXRhIHByb3Blcmx5XG4gIHNldERhdGEobykge1xuICAgIHRoaXMuZG9tID0gb1xuICAgIHRoaXMuZG9tLmxlYWRpbmcgPSBuZXcgU1ZHTnVtYmVyKG8ubGVhZGluZyB8fCAxLjMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHdyaXRlRGF0YVRvRG9tKCkge1xuICAgIHdyaXRlRGF0YVRvRG9tKHRoaXMsIHRoaXMuZG9tLCB7IGxlYWRpbmc6IDEuMyB9KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBTZXQgdGhlIHRleHQgY29udGVudFxuICB0ZXh0KHRleHQpIHtcbiAgICAvLyBhY3QgYXMgZ2V0dGVyXG4gICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLm5vZGUuY2hpbGROb2Rlc1xuICAgICAgbGV0IGZpcnN0TGluZSA9IDBcbiAgICAgIHRleHQgPSAnJ1xuXG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgLy8gc2tpcCB0ZXh0UGF0aHMgLSB0aGV5IGFyZSBubyBsaW5lc1xuICAgICAgICBpZiAoY2hpbGRyZW5baV0ubm9kZU5hbWUgPT09ICd0ZXh0UGF0aCcgfHwgaXNEZXNjcmlwdGl2ZShjaGlsZHJlbltpXSkpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkgZmlyc3RMaW5lID0gaSArIDFcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIG5ld2xpbmUgaWYgaXRzIG5vdCB0aGUgZmlyc3QgY2hpbGQgYW5kIG5ld0xpbmVkIGlzIHNldCB0byB0cnVlXG4gICAgICAgIGlmIChcbiAgICAgICAgICBpICE9PSBmaXJzdExpbmUgJiZcbiAgICAgICAgICBjaGlsZHJlbltpXS5ub2RlVHlwZSAhPT0gMyAmJlxuICAgICAgICAgIGFkb3B0KGNoaWxkcmVuW2ldKS5kb20ubmV3TGluZWQgPT09IHRydWVcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGV4dCArPSAnXFxuJ1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGNvbnRlbnQgb2YgdGhpcyBub2RlXG4gICAgICAgIHRleHQgKz0gY2hpbGRyZW5baV0udGV4dENvbnRlbnRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRleHRcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgZXhpc3RpbmcgY29udGVudFxuICAgIHRoaXMuY2xlYXIoKS5idWlsZCh0cnVlKVxuXG4gICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBjYWxsIGJsb2NrXG4gICAgICB0ZXh0LmNhbGwodGhpcywgdGhpcylcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3RvcmUgdGV4dCBhbmQgbWFrZSBzdXJlIHRleHQgaXMgbm90IGJsYW5rXG4gICAgICB0ZXh0ID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpXG5cbiAgICAgIC8vIGJ1aWxkIG5ldyBsaW5lc1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gdGV4dC5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgIHRoaXMubmV3TGluZSh0ZXh0W2pdKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRpc2FibGUgYnVpbGQgbW9kZSBhbmQgcmVidWlsZCBsaW5lc1xuICAgIHJldHVybiB0aGlzLmJ1aWxkKGZhbHNlKS5yZWJ1aWxkKClcbiAgfVxufVxuXG5leHRlbmQoVGV4dCwgdGV4dGFibGUpXG5cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIC8vIENyZWF0ZSB0ZXh0IGVsZW1lbnRcbiAgICB0ZXh0OiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAodGV4dCA9ICcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFRleHQoKSkudGV4dCh0ZXh0KVxuICAgIH0pLFxuXG4gICAgLy8gQ3JlYXRlIHBsYWluIHRleHQgZWxlbWVudFxuICAgIHBsYWluOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAodGV4dCA9ICcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFRleHQoKSkucGxhaW4odGV4dClcbiAgICB9KVxuICB9XG59KVxuXG5yZWdpc3RlcihUZXh0LCAnVGV4dCcpXG4iLCJpbXBvcnQge1xuICBleHRlbmQsXG4gIG5vZGVPck5ldyxcbiAgcmVnaXN0ZXIsXG4gIHdyYXBXaXRoQXR0ckNoZWNrXG59IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5pbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vdXRpbHMvd2luZG93LmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcbmltcG9ydCBTVkdOdW1iZXIgZnJvbSAnLi4vdHlwZXMvU1ZHTnVtYmVyLmpzJ1xuaW1wb3J0IFNoYXBlIGZyb20gJy4vU2hhcGUuanMnXG5pbXBvcnQgVGV4dCBmcm9tICcuL1RleHQuanMnXG5pbXBvcnQgKiBhcyB0ZXh0YWJsZSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvdGV4dGFibGUuanMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRzcGFuIGV4dGVuZHMgU2hhcGUge1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCd0c3BhbicsIG5vZGUpLCBhdHRycylcbiAgICB0aGlzLl9idWlsZCA9IGZhbHNlIC8vIGRpc2FibGUgYnVpbGQgbW9kZSBmb3IgYWRkaW5nIG11bHRpcGxlIGxpbmVzXG4gIH1cblxuICAvLyBTaG9ydGN1dCBkeFxuICBkeChkeCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ2R4JywgZHgpXG4gIH1cblxuICAvLyBTaG9ydGN1dCBkeVxuICBkeShkeSkge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ2R5JywgZHkpXG4gIH1cblxuICAvLyBDcmVhdGUgbmV3IGxpbmVcbiAgbmV3TGluZSgpIHtcbiAgICAvLyBtYXJrIG5ldyBsaW5lXG4gICAgdGhpcy5kb20ubmV3TGluZWQgPSB0cnVlXG5cbiAgICAvLyBmZXRjaCBwYXJlbnRcbiAgICBjb25zdCB0ZXh0ID0gdGhpcy5wYXJlbnQoKVxuXG4gICAgLy8gZWFybHkgcmV0dXJuIGluIGNhc2Ugd2UgYXJlIG5vdCBpbiBhIHRleHQgZWxlbWVudFxuICAgIGlmICghKHRleHQgaW5zdGFuY2VvZiBUZXh0KSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBjb25zdCBpID0gdGV4dC5pbmRleCh0aGlzKVxuXG4gICAgY29uc3QgZm9udFNpemUgPSBnbG9iYWxzLndpbmRvd1xuICAgICAgLmdldENvbXB1dGVkU3R5bGUodGhpcy5ub2RlKVxuICAgICAgLmdldFByb3BlcnR5VmFsdWUoJ2ZvbnQtc2l6ZScpXG4gICAgY29uc3QgZHkgPSB0ZXh0LmRvbS5sZWFkaW5nICogbmV3IFNWR051bWJlcihmb250U2l6ZSlcblxuICAgIC8vIGFwcGx5IG5ldyBwb3NpdGlvblxuICAgIHJldHVybiB0aGlzLmR5KGkgPyBkeSA6IDApLmF0dHIoJ3gnLCB0ZXh0LngoKSlcbiAgfVxuXG4gIC8vIFNldCB0ZXh0IGNvbnRlbnRcbiAgdGV4dCh0ZXh0KSB7XG4gICAgaWYgKHRleHQgPT0gbnVsbClcbiAgICAgIHJldHVybiB0aGlzLm5vZGUudGV4dENvbnRlbnQgKyAodGhpcy5kb20ubmV3TGluZWQgPyAnXFxuJyA6ICcnKVxuXG4gICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmNsZWFyKCkuYnVpbGQodHJ1ZSlcbiAgICAgIHRleHQuY2FsbCh0aGlzLCB0aGlzKVxuICAgICAgdGhpcy5idWlsZChmYWxzZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGFpbih0ZXh0KVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxuZXh0ZW5kKFRzcGFuLCB0ZXh0YWJsZSlcblxucmVnaXN0ZXJNZXRob2RzKHtcbiAgVHNwYW46IHtcbiAgICB0c3Bhbjogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHRleHQgPSAnJykge1xuICAgICAgY29uc3QgdHNwYW4gPSBuZXcgVHNwYW4oKVxuXG4gICAgICAvLyBjbGVhciBpZiBidWlsZCBtb2RlIGlzIGRpc2FibGVkXG4gICAgICBpZiAoIXRoaXMuX2J1aWxkKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKVxuICAgICAgfVxuXG4gICAgICAvLyBhZGQgbmV3IHRzcGFuXG4gICAgICByZXR1cm4gdGhpcy5wdXQodHNwYW4pLnRleHQodGV4dClcbiAgICB9KVxuICB9LFxuICBUZXh0OiB7XG4gICAgbmV3TGluZTogZnVuY3Rpb24gKHRleHQgPSAnJykge1xuICAgICAgcmV0dXJuIHRoaXMudHNwYW4odGV4dCkubmV3TGluZSgpXG4gICAgfVxuICB9XG59KVxuXG5yZWdpc3RlcihUc3BhbiwgJ1RzcGFuJylcbiIsImltcG9ydCB7IGN4LCBjeSwgaGVpZ2h0LCB3aWR0aCwgeCwgeSB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9jaXJjbGVkLmpzJ1xuaW1wb3J0IHtcbiAgZXh0ZW5kLFxuICBub2RlT3JOZXcsXG4gIHJlZ2lzdGVyLFxuICB3cmFwV2l0aEF0dHJDaGVja1xufSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcbmltcG9ydCBTVkdOdW1iZXIgZnJvbSAnLi4vdHlwZXMvU1ZHTnVtYmVyLmpzJ1xuaW1wb3J0IFNoYXBlIGZyb20gJy4vU2hhcGUuanMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENpcmNsZSBleHRlbmRzIFNoYXBlIHtcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCdjaXJjbGUnLCBub2RlKSwgYXR0cnMpXG4gIH1cblxuICByYWRpdXMocikge1xuICAgIHJldHVybiB0aGlzLmF0dHIoJ3InLCByKVxuICB9XG5cbiAgLy8gUmFkaXVzIHggdmFsdWVcbiAgcngocngpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdyJywgcngpXG4gIH1cblxuICAvLyBBbGlhcyByYWRpdXMgeCB2YWx1ZVxuICByeShyeSkge1xuICAgIHJldHVybiB0aGlzLnJ4KHJ5KVxuICB9XG5cbiAgc2l6ZShzaXplKSB7XG4gICAgcmV0dXJuIHRoaXMucmFkaXVzKG5ldyBTVkdOdW1iZXIoc2l6ZSkuZGl2aWRlKDIpKVxuICB9XG59XG5cbmV4dGVuZChDaXJjbGUsIHsgeCwgeSwgY3gsIGN5LCB3aWR0aCwgaGVpZ2h0IH0pXG5cbnJlZ2lzdGVyTWV0aG9kcyh7XG4gIENvbnRhaW5lcjoge1xuICAgIC8vIENyZWF0ZSBjaXJjbGUgZWxlbWVudFxuICAgIGNpcmNsZTogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHNpemUgPSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IENpcmNsZSgpKS5zaXplKHNpemUpLm1vdmUoMCwgMClcbiAgICB9KVxuICB9XG59KVxuXG5yZWdpc3RlcihDaXJjbGUsICdDaXJjbGUnKVxuIiwiaW1wb3J0IHsgbm9kZU9yTmV3LCByZWdpc3Rlciwgd3JhcFdpdGhBdHRyQ2hlY2sgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9Db250YWluZXIuanMnXG5pbXBvcnQgYmFzZUZpbmQgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3NlbGVjdG9yLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDbGlwUGF0aCBleHRlbmRzIENvbnRhaW5lciB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygnY2xpcFBhdGgnLCBub2RlKSwgYXR0cnMpXG4gIH1cblxuICAvLyBVbmNsaXAgYWxsIGNsaXBwZWQgZWxlbWVudHMgYW5kIHJlbW92ZSBpdHNlbGZcbiAgcmVtb3ZlKCkge1xuICAgIC8vIHVuY2xpcCBhbGwgdGFyZ2V0c1xuICAgIHRoaXMudGFyZ2V0cygpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICBlbC51bmNsaXAoKVxuICAgIH0pXG5cbiAgICAvLyByZW1vdmUgY2xpcFBhdGggZnJvbSBwYXJlbnRcbiAgICByZXR1cm4gc3VwZXIucmVtb3ZlKClcbiAgfVxuXG4gIHRhcmdldHMoKSB7XG4gICAgcmV0dXJuIGJhc2VGaW5kKCdzdmcgW2NsaXAtcGF0aCo9JyArIHRoaXMuaWQoKSArICddJylcbiAgfVxufVxuXG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgY2xpcHBpbmcgZWxlbWVudFxuICAgIGNsaXA6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5wdXQobmV3IENsaXBQYXRoKCkpXG4gICAgfSlcbiAgfSxcbiAgRWxlbWVudDoge1xuICAgIC8vIERpc3RyaWJ1dGUgY2xpcFBhdGggdG8gc3ZnIGVsZW1lbnRcbiAgICBjbGlwcGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlKCdjbGlwLXBhdGgnKVxuICAgIH0sXG5cbiAgICBjbGlwV2l0aChlbGVtZW50KSB7XG4gICAgICAvLyB1c2UgZ2l2ZW4gY2xpcCBvciBjcmVhdGUgYSBuZXcgb25lXG4gICAgICBjb25zdCBjbGlwcGVyID1cbiAgICAgICAgZWxlbWVudCBpbnN0YW5jZW9mIENsaXBQYXRoXG4gICAgICAgICAgPyBlbGVtZW50XG4gICAgICAgICAgOiB0aGlzLnBhcmVudCgpLmNsaXAoKS5hZGQoZWxlbWVudClcblxuICAgICAgLy8gYXBwbHkgbWFza1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cignY2xpcC1wYXRoJywgJ3VybCgjJyArIGNsaXBwZXIuaWQoKSArICcpJylcbiAgICB9LFxuXG4gICAgLy8gVW5jbGlwIGVsZW1lbnRcbiAgICB1bmNsaXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdjbGlwLXBhdGgnLCBudWxsKVxuICAgIH1cbiAgfVxufSlcblxucmVnaXN0ZXIoQ2xpcFBhdGgsICdDbGlwUGF0aCcpXG4iLCJpbXBvcnQgeyBub2RlT3JOZXcsIHJlZ2lzdGVyLCB3cmFwV2l0aEF0dHJDaGVjayB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xuaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9FbGVtZW50LmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb3JlaWduT2JqZWN0IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygnZm9yZWlnbk9iamVjdCcsIG5vZGUpLCBhdHRycylcbiAgfVxufVxuXG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICBmb3JlaWduT2JqZWN0OiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBGb3JlaWduT2JqZWN0KCkpLnNpemUod2lkdGgsIGhlaWdodClcbiAgICB9KVxuICB9XG59KVxuXG5yZWdpc3RlcihGb3JlaWduT2JqZWN0LCAnRm9yZWlnbk9iamVjdCcpXG4iLCJpbXBvcnQgTWF0cml4IGZyb20gJy4uLy4uL3R5cGVzL01hdHJpeC5qcydcbmltcG9ydCBQb2ludCBmcm9tICcuLi8uLi90eXBlcy9Qb2ludC5qcydcbmltcG9ydCBCb3ggZnJvbSAnLi4vLi4vdHlwZXMvQm94LmpzJ1xuaW1wb3J0IHsgcHJvcG9ydGlvbmFsU2l6ZSB9IGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzLmpzJ1xuaW1wb3J0IHsgZ2V0V2luZG93IH0gZnJvbSAnLi4vLi4vdXRpbHMvd2luZG93LmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZG1vdmUoZHgsIGR5KSB7XG4gIHRoaXMuY2hpbGRyZW4oKS5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgIGxldCBiYm94XG5cbiAgICAvLyBXZSBoYXZlIHRvIHdyYXAgdGhpcyBmb3IgZWxlbWVudHMgdGhhdCBkb250IGhhdmUgYSBiYm94XG4gICAgLy8gZS5nLiB0aXRsZSBhbmQgb3RoZXIgZGVzY3JpcHRpdmUgZWxlbWVudHNcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IHRoZSBjaGlsZHMgYmJveFxuICAgICAgLy8gQnVnOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xOTA1MDM5XG4gICAgICAvLyBCZWNhdXNlIGJib3ggZm9yIG5lc3RlZCBzdmdzIHJldHVybnMgdGhlIGNvbnRlbnRzIGJib3ggaW4gdGhlIGNvb3JkaW5hdGUgc3BhY2Ugb2YgdGhlIHN2ZyBpdHNlbGYgKHdlaXJkISksIHdlIGNhbnQgdXNlIGJib3ggZm9yIHN2Z3NcbiAgICAgIC8vIFRoZXJlZm9yZSB3ZSBoYXZlIHRvIHVzZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QuIEJ1dCBUSEFUIGlzIGJyb2tlbiAoYXMgZXhwbGFpbmVkIGluIHRoZSBidWcpLlxuICAgICAgLy8gRnVubmlseSBlbm91Z2ggdGhlIGJyb2tlbiBiZWhhdmlvciB3b3VsZCB3b3JrIGZvciB1cyBidXQgdGhhdCBicmVha3MgaXQgaW4gY2hyb21lXG4gICAgICAvLyBTbyB3ZSBoYXZlIHRvIHJlcGxpY2F0ZSB0aGUgYnJva2VuIGJlaGF2aW9yIG9mIEZGIGJ5IGp1c3QgcmVhZGluZyB0aGUgYXR0cmlidXRlcyBvZiB0aGUgc3ZnIGl0c2VsZlxuICAgICAgYmJveCA9XG4gICAgICAgIGNoaWxkLm5vZGUgaW5zdGFuY2VvZiBnZXRXaW5kb3coKS5TVkdTVkdFbGVtZW50XG4gICAgICAgICAgPyBuZXcgQm94KGNoaWxkLmF0dHIoWyd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0J10pKVxuICAgICAgICAgIDogY2hpbGQuYmJveCgpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gR2V0IGNoaWxkcyBtYXRyaXhcbiAgICBjb25zdCBtID0gbmV3IE1hdHJpeChjaGlsZClcbiAgICAvLyBUcmFuc2xhdGUgY2hpbGRzIG1hdHJpeCBieSBhbW91bnQgYW5kXG4gICAgLy8gdHJhbnNmb3JtIGl0IGJhY2sgaW50byBwYXJlbnRzIHNwYWNlXG4gICAgY29uc3QgbWF0cml4ID0gbS50cmFuc2xhdGUoZHgsIGR5KS50cmFuc2Zvcm0obS5pbnZlcnNlKCkpXG4gICAgLy8gQ2FsY3VsYXRlIG5ldyB4IGFuZCB5IGZyb20gb2xkIGJveFxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoYmJveC54LCBiYm94LnkpLnRyYW5zZm9ybShtYXRyaXgpXG4gICAgLy8gTW92ZSBlbGVtZW50XG4gICAgY2hpbGQubW92ZShwLngsIHAueSlcbiAgfSlcblxuICByZXR1cm4gdGhpc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZHgoZHgpIHtcbiAgcmV0dXJuIHRoaXMuZG1vdmUoZHgsIDApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkeShkeSkge1xuICByZXR1cm4gdGhpcy5kbW92ZSgwLCBkeSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhlaWdodChoZWlnaHQsIGJveCA9IHRoaXMuYmJveCgpKSB7XG4gIGlmIChoZWlnaHQgPT0gbnVsbCkgcmV0dXJuIGJveC5oZWlnaHRcbiAgcmV0dXJuIHRoaXMuc2l6ZShib3gud2lkdGgsIGhlaWdodCwgYm94KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbW92ZSh4ID0gMCwgeSA9IDAsIGJveCA9IHRoaXMuYmJveCgpKSB7XG4gIGNvbnN0IGR4ID0geCAtIGJveC54XG4gIGNvbnN0IGR5ID0geSAtIGJveC55XG5cbiAgcmV0dXJuIHRoaXMuZG1vdmUoZHgsIGR5KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2l6ZSh3aWR0aCwgaGVpZ2h0LCBib3ggPSB0aGlzLmJib3goKSkge1xuICBjb25zdCBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0LCBib3gpXG4gIGNvbnN0IHNjYWxlWCA9IHAud2lkdGggLyBib3gud2lkdGhcbiAgY29uc3Qgc2NhbGVZID0gcC5oZWlnaHQgLyBib3guaGVpZ2h0XG5cbiAgdGhpcy5jaGlsZHJlbigpLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgY29uc3QgbyA9IG5ldyBQb2ludChib3gpLnRyYW5zZm9ybShuZXcgTWF0cml4KGNoaWxkKS5pbnZlcnNlKCkpXG4gICAgY2hpbGQuc2NhbGUoc2NhbGVYLCBzY2FsZVksIG8ueCwgby55KVxuICB9KVxuXG4gIHJldHVybiB0aGlzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aWR0aCh3aWR0aCwgYm94ID0gdGhpcy5iYm94KCkpIHtcbiAgaWYgKHdpZHRoID09IG51bGwpIHJldHVybiBib3gud2lkdGhcbiAgcmV0dXJuIHRoaXMuc2l6ZSh3aWR0aCwgYm94LmhlaWdodCwgYm94KVxufVxuXG5leHBvcnQgZnVuY3Rpb24geCh4LCBib3ggPSB0aGlzLmJib3goKSkge1xuICBpZiAoeCA9PSBudWxsKSByZXR1cm4gYm94LnhcbiAgcmV0dXJuIHRoaXMubW92ZSh4LCBib3gueSwgYm94KVxufVxuXG5leHBvcnQgZnVuY3Rpb24geSh5LCBib3ggPSB0aGlzLmJib3goKSkge1xuICBpZiAoeSA9PSBudWxsKSByZXR1cm4gYm94LnlcbiAgcmV0dXJuIHRoaXMubW92ZShib3gueCwgeSwgYm94KVxufVxuIiwiaW1wb3J0IHtcbiAgbm9kZU9yTmV3LFxuICByZWdpc3RlcixcbiAgd3JhcFdpdGhBdHRyQ2hlY2ssXG4gIGV4dGVuZFxufSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9Db250YWluZXIuanMnXG5pbXBvcnQgKiBhcyBjb250YWluZXJHZW9tZXRyeSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvY29udGFpbmVyR2VvbWV0cnkuanMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEcgZXh0ZW5kcyBDb250YWluZXIge1xuICBjb25zdHJ1Y3Rvcihub2RlLCBhdHRycyA9IG5vZGUpIHtcbiAgICBzdXBlcihub2RlT3JOZXcoJ2cnLCBub2RlKSwgYXR0cnMpXG4gIH1cbn1cblxuZXh0ZW5kKEcsIGNvbnRhaW5lckdlb21ldHJ5KVxuXG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgYSBncm91cCBlbGVtZW50XG4gICAgZ3JvdXA6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgRygpKVxuICAgIH0pXG4gIH1cbn0pXG5cbnJlZ2lzdGVyKEcsICdHJylcbiIsImltcG9ydCB7XG4gIG5vZGVPck5ldyxcbiAgcmVnaXN0ZXIsXG4gIHdyYXBXaXRoQXR0ckNoZWNrLFxuICBleHRlbmRcbn0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgeyB4bGluayB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9uYW1lc3BhY2VzLmpzJ1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL0NvbnRhaW5lci5qcydcbmltcG9ydCAqIGFzIGNvbnRhaW5lckdlb21ldHJ5IGZyb20gJy4uL21vZHVsZXMvY29yZS9jb250YWluZXJHZW9tZXRyeS5qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQSBleHRlbmRzIENvbnRhaW5lciB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygnYScsIG5vZGUpLCBhdHRycylcbiAgfVxuXG4gIC8vIExpbmsgdGFyZ2V0IGF0dHJpYnV0ZVxuICB0YXJnZXQodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cigndGFyZ2V0JywgdGFyZ2V0KVxuICB9XG5cbiAgLy8gTGluayB1cmxcbiAgdG8odXJsKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cignaHJlZicsIHVybCwgeGxpbmspXG4gIH1cbn1cblxuZXh0ZW5kKEEsIGNvbnRhaW5lckdlb21ldHJ5KVxuXG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgYSBoeXBlcmxpbmsgZWxlbWVudFxuICAgIGxpbms6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgQSgpKS50byh1cmwpXG4gICAgfSlcbiAgfSxcbiAgRWxlbWVudDoge1xuICAgIHVubGluaygpIHtcbiAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmxpbmtlcigpXG5cbiAgICAgIGlmICghbGluaykgcmV0dXJuIHRoaXNcblxuICAgICAgY29uc3QgcGFyZW50ID0gbGluay5wYXJlbnQoKVxuXG4gICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmUoKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmRleCA9IHBhcmVudC5pbmRleChsaW5rKVxuICAgICAgcGFyZW50LmFkZCh0aGlzLCBpbmRleClcblxuICAgICAgbGluay5yZW1vdmUoKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIGxpbmtUbyh1cmwpIHtcbiAgICAgIC8vIHJldXNlIG9sZCBsaW5rIGlmIHBvc3NpYmxlXG4gICAgICBsZXQgbGluayA9IHRoaXMubGlua2VyKClcblxuICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgIGxpbmsgPSBuZXcgQSgpXG4gICAgICAgIHRoaXMud3JhcChsaW5rKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB1cmwuY2FsbChsaW5rLCBsaW5rKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluay50byh1cmwpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgICBsaW5rZXIoKSB7XG4gICAgICBjb25zdCBsaW5rID0gdGhpcy5wYXJlbnQoKVxuICAgICAgaWYgKGxpbmsgJiYgbGluay5ub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuICAgICAgICByZXR1cm4gbGlua1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxufSlcblxucmVnaXN0ZXIoQSwgJ0EnKVxuIiwiaW1wb3J0IHsgbm9kZU9yTmV3LCByZWdpc3Rlciwgd3JhcFdpdGhBdHRyQ2hlY2sgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9Db250YWluZXIuanMnXG5pbXBvcnQgYmFzZUZpbmQgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3NlbGVjdG9yLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXNrIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygnbWFzaycsIG5vZGUpLCBhdHRycylcbiAgfVxuXG4gIC8vIFVubWFzayBhbGwgbWFza2VkIGVsZW1lbnRzIGFuZCByZW1vdmUgaXRzZWxmXG4gIHJlbW92ZSgpIHtcbiAgICAvLyB1bm1hc2sgYWxsIHRhcmdldHNcbiAgICB0aGlzLnRhcmdldHMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgZWwudW5tYXNrKClcbiAgICB9KVxuXG4gICAgLy8gcmVtb3ZlIG1hc2sgZnJvbSBwYXJlbnRcbiAgICByZXR1cm4gc3VwZXIucmVtb3ZlKClcbiAgfVxuXG4gIHRhcmdldHMoKSB7XG4gICAgcmV0dXJuIGJhc2VGaW5kKCdzdmcgW21hc2sqPScgKyB0aGlzLmlkKCkgKyAnXScpXG4gIH1cbn1cblxucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgbWFzazogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLnB1dChuZXcgTWFzaygpKVxuICAgIH0pXG4gIH0sXG4gIEVsZW1lbnQ6IHtcbiAgICAvLyBEaXN0cmlidXRlIG1hc2sgdG8gc3ZnIGVsZW1lbnRcbiAgICBtYXNrZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2UoJ21hc2snKVxuICAgIH0sXG5cbiAgICBtYXNrV2l0aChlbGVtZW50KSB7XG4gICAgICAvLyB1c2UgZ2l2ZW4gbWFzayBvciBjcmVhdGUgYSBuZXcgb25lXG4gICAgICBjb25zdCBtYXNrZXIgPVxuICAgICAgICBlbGVtZW50IGluc3RhbmNlb2YgTWFzayA/IGVsZW1lbnQgOiB0aGlzLnBhcmVudCgpLm1hc2soKS5hZGQoZWxlbWVudClcblxuICAgICAgLy8gYXBwbHkgbWFza1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cignbWFzaycsICd1cmwoIycgKyBtYXNrZXIuaWQoKSArICcpJylcbiAgICB9LFxuXG4gICAgLy8gVW5tYXNrIGVsZW1lbnRcbiAgICB1bm1hc2soKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdtYXNrJywgbnVsbClcbiAgICB9XG4gIH1cbn0pXG5cbnJlZ2lzdGVyKE1hc2ssICdNYXNrJylcbiIsImltcG9ydCB7IG5vZGVPck5ldywgcmVnaXN0ZXIgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9FbGVtZW50LmpzJ1xuaW1wb3J0IFNWR051bWJlciBmcm9tICcuLi90eXBlcy9TVkdOdW1iZXIuanMnXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdG9wIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygnc3RvcCcsIG5vZGUpLCBhdHRycylcbiAgfVxuXG4gIC8vIGFkZCBjb2xvciBzdG9wc1xuICB1cGRhdGUobykge1xuICAgIGlmICh0eXBlb2YgbyA9PT0gJ251bWJlcicgfHwgbyBpbnN0YW5jZW9mIFNWR051bWJlcikge1xuICAgICAgbyA9IHtcbiAgICAgICAgb2Zmc2V0OiBhcmd1bWVudHNbMF0sXG4gICAgICAgIGNvbG9yOiBhcmd1bWVudHNbMV0sXG4gICAgICAgIG9wYWNpdHk6IGFyZ3VtZW50c1syXVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNldCBhdHRyaWJ1dGVzXG4gICAgaWYgKG8ub3BhY2l0eSAhPSBudWxsKSB0aGlzLmF0dHIoJ3N0b3Atb3BhY2l0eScsIG8ub3BhY2l0eSlcbiAgICBpZiAoby5jb2xvciAhPSBudWxsKSB0aGlzLmF0dHIoJ3N0b3AtY29sb3InLCBvLmNvbG9yKVxuICAgIGlmIChvLm9mZnNldCAhPSBudWxsKSB0aGlzLmF0dHIoJ29mZnNldCcsIG5ldyBTVkdOdW1iZXIoby5vZmZzZXQpKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5yZWdpc3Rlck1ldGhvZHMoe1xuICBHcmFkaWVudDoge1xuICAgIC8vIEFkZCBhIGNvbG9yIHN0b3BcbiAgICBzdG9wOiBmdW5jdGlvbiAob2Zmc2V0LCBjb2xvciwgb3BhY2l0eSkge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTdG9wKCkpLnVwZGF0ZShvZmZzZXQsIGNvbG9yLCBvcGFjaXR5KVxuICAgIH1cbiAgfVxufSlcblxucmVnaXN0ZXIoU3RvcCwgJ1N0b3AnKVxuIiwiaW1wb3J0IHsgbm9kZU9yTmV3LCByZWdpc3RlciB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xuaW1wb3J0IHsgdW5DYW1lbENhc2UgfSBmcm9tICcuLi91dGlscy91dGlscy5qcydcbmltcG9ydCBFbGVtZW50IGZyb20gJy4vRWxlbWVudC5qcydcblxuZnVuY3Rpb24gY3NzUnVsZShzZWxlY3RvciwgcnVsZSkge1xuICBpZiAoIXNlbGVjdG9yKSByZXR1cm4gJydcbiAgaWYgKCFydWxlKSByZXR1cm4gc2VsZWN0b3JcblxuICBsZXQgcmV0ID0gc2VsZWN0b3IgKyAneydcblxuICBmb3IgKGNvbnN0IGkgaW4gcnVsZSkge1xuICAgIHJldCArPSB1bkNhbWVsQ2FzZShpKSArICc6JyArIHJ1bGVbaV0gKyAnOydcbiAgfVxuXG4gIHJldCArPSAnfSdcblxuICByZXR1cm4gcmV0XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0eWxlIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygnc3R5bGUnLCBub2RlKSwgYXR0cnMpXG4gIH1cblxuICBhZGRUZXh0KHcgPSAnJykge1xuICAgIHRoaXMubm9kZS50ZXh0Q29udGVudCArPSB3XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGZvbnQobmFtZSwgc3JjLCBwYXJhbXMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLnJ1bGUoJ0Bmb250LWZhY2UnLCB7XG4gICAgICBmb250RmFtaWx5OiBuYW1lLFxuICAgICAgc3JjOiBzcmMsXG4gICAgICAuLi5wYXJhbXNcbiAgICB9KVxuICB9XG5cbiAgcnVsZShzZWxlY3Rvciwgb2JqKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkVGV4dChjc3NSdWxlKHNlbGVjdG9yLCBvYmopKVxuICB9XG59XG5cbnJlZ2lzdGVyTWV0aG9kcygnRG9tJywge1xuICBzdHlsZShzZWxlY3Rvciwgb2JqKSB7XG4gICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTdHlsZSgpKS5ydWxlKHNlbGVjdG9yLCBvYmopXG4gIH0sXG4gIGZvbnRmYWNlKG5hbWUsIHNyYywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTdHlsZSgpKS5mb250KG5hbWUsIHNyYywgcGFyYW1zKVxuICB9XG59KVxuXG5yZWdpc3RlcihTdHlsZSwgJ1N0eWxlJylcbiIsImltcG9ydCB7IG5vZGVPck5ldywgcmVnaXN0ZXIsIHdyYXBXaXRoQXR0ckNoZWNrIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgeyB4bGluayB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9uYW1lc3BhY2VzLmpzJ1xuaW1wb3J0IFBhdGggZnJvbSAnLi9QYXRoLmpzJ1xuaW1wb3J0IFBhdGhBcnJheSBmcm9tICcuLi90eXBlcy9QYXRoQXJyYXkuanMnXG5pbXBvcnQgVGV4dCBmcm9tICcuL1RleHQuanMnXG5pbXBvcnQgYmFzZUZpbmQgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3NlbGVjdG9yLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0UGF0aCBleHRlbmRzIFRleHQge1xuICAvLyBJbml0aWFsaXplIG5vZGVcbiAgY29uc3RydWN0b3Iobm9kZSwgYXR0cnMgPSBub2RlKSB7XG4gICAgc3VwZXIobm9kZU9yTmV3KCd0ZXh0UGF0aCcsIG5vZGUpLCBhdHRycylcbiAgfVxuXG4gIC8vIHJldHVybiB0aGUgYXJyYXkgb2YgdGhlIHBhdGggdHJhY2sgZWxlbWVudFxuICBhcnJheSgpIHtcbiAgICBjb25zdCB0cmFjayA9IHRoaXMudHJhY2soKVxuXG4gICAgcmV0dXJuIHRyYWNrID8gdHJhY2suYXJyYXkoKSA6IG51bGxcbiAgfVxuXG4gIC8vIFBsb3QgcGF0aCBpZiBhbnlcbiAgcGxvdChkKSB7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrKClcbiAgICBsZXQgcGF0aEFycmF5ID0gbnVsbFxuXG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICBwYXRoQXJyYXkgPSB0cmFjay5wbG90KGQpXG4gICAgfVxuXG4gICAgcmV0dXJuIGQgPT0gbnVsbCA/IHBhdGhBcnJheSA6IHRoaXNcbiAgfVxuXG4gIC8vIEdldCB0aGUgcGF0aCBlbGVtZW50XG4gIHRyYWNrKCkge1xuICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZSgnaHJlZicpXG4gIH1cbn1cblxucmVnaXN0ZXJNZXRob2RzKHtcbiAgQ29udGFpbmVyOiB7XG4gICAgdGV4dFBhdGg6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh0ZXh0LCBwYXRoKSB7XG4gICAgICAvLyBDb252ZXJ0IHRleHQgdG8gaW5zdGFuY2UgaWYgbmVlZGVkXG4gICAgICBpZiAoISh0ZXh0IGluc3RhbmNlb2YgVGV4dCkpIHtcbiAgICAgICAgdGV4dCA9IHRoaXMudGV4dCh0ZXh0KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGV4dC5wYXRoKHBhdGgpXG4gICAgfSlcbiAgfSxcbiAgVGV4dDoge1xuICAgIC8vIENyZWF0ZSBwYXRoIGZvciB0ZXh0IHRvIHJ1biBvblxuICAgIHBhdGg6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh0cmFjaywgaW1wb3J0Tm9kZXMgPSB0cnVlKSB7XG4gICAgICBjb25zdCB0ZXh0UGF0aCA9IG5ldyBUZXh0UGF0aCgpXG5cbiAgICAgIC8vIGlmIHRyYWNrIGlzIGEgcGF0aCwgcmV1c2UgaXRcbiAgICAgIGlmICghKHRyYWNrIGluc3RhbmNlb2YgUGF0aCkpIHtcbiAgICAgICAgLy8gY3JlYXRlIHBhdGggZWxlbWVudFxuICAgICAgICB0cmFjayA9IHRoaXMuZGVmcygpLnBhdGgodHJhY2spXG4gICAgICB9XG5cbiAgICAgIC8vIGxpbmsgdGV4dFBhdGggdG8gcGF0aCBhbmQgYWRkIGNvbnRlbnRcbiAgICAgIHRleHRQYXRoLmF0dHIoJ2hyZWYnLCAnIycgKyB0cmFjaywgeGxpbmspXG5cbiAgICAgIC8vIFRyYW5zcGxhbnQgYWxsIG5vZGVzIGZyb20gdGV4dCB0byB0ZXh0UGF0aFxuICAgICAgbGV0IG5vZGVcbiAgICAgIGlmIChpbXBvcnROb2Rlcykge1xuICAgICAgICB3aGlsZSAoKG5vZGUgPSB0aGlzLm5vZGUuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICB0ZXh0UGF0aC5ub2RlLmFwcGVuZENoaWxkKG5vZGUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gYWRkIHRleHRQYXRoIGVsZW1lbnQgYXMgY2hpbGQgbm9kZSBhbmQgcmV0dXJuIHRleHRQYXRoXG4gICAgICByZXR1cm4gdGhpcy5wdXQodGV4dFBhdGgpXG4gICAgfSksXG5cbiAgICAvLyBHZXQgdGhlIHRleHRQYXRoIGNoaWxkcmVuXG4gICAgdGV4dFBhdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kT25lKCd0ZXh0UGF0aCcpXG4gICAgfVxuICB9LFxuICBQYXRoOiB7XG4gICAgLy8gY3JlYXRlcyBhIHRleHRQYXRoIGZyb20gdGhpcyBwYXRoXG4gICAgdGV4dDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgIC8vIENvbnZlcnQgdGV4dCB0byBpbnN0YW5jZSBpZiBuZWVkZWRcbiAgICAgIGlmICghKHRleHQgaW5zdGFuY2VvZiBUZXh0KSkge1xuICAgICAgICB0ZXh0ID0gbmV3IFRleHQoKS5hZGRUbyh0aGlzLnBhcmVudCgpKS50ZXh0KHRleHQpXG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSB0ZXh0UGF0aCBmcm9tIHRleHQgYW5kIHBhdGggYW5kIHJldHVyblxuICAgICAgcmV0dXJuIHRleHQucGF0aCh0aGlzKVxuICAgIH0pLFxuXG4gICAgdGFyZ2V0cygpIHtcbiAgICAgIHJldHVybiBiYXNlRmluZCgnc3ZnIHRleHRQYXRoJykuZmlsdGVyKChub2RlKSA9PiB7XG4gICAgICAgIHJldHVybiAobm9kZS5hdHRyKCdocmVmJykgfHwgJycpLmluY2x1ZGVzKHRoaXMuaWQoKSlcbiAgICAgIH0pXG5cbiAgICAgIC8vIERvZXMgbm90IHdvcmsgaW4gSUUxMS4gVXNlIHdoZW4gSUUgc3VwcG9ydCBpcyBkcm9wcGVkXG4gICAgICAvLyByZXR1cm4gYmFzZUZpbmQoJ3N2ZyB0ZXh0UGF0aFsqfGhyZWYqPScgKyB0aGlzLmlkKCkgKyAnXScpXG4gICAgfVxuICB9XG59KVxuXG5UZXh0UGF0aC5wcm90b3R5cGUuTW9ycGhBcnJheSA9IFBhdGhBcnJheVxucmVnaXN0ZXIoVGV4dFBhdGgsICdUZXh0UGF0aCcpXG4iLCJpbXBvcnQgeyBub2RlT3JOZXcsIHJlZ2lzdGVyLCB3cmFwV2l0aEF0dHJDaGVjayB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xuaW1wb3J0IHsgeGxpbmsgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvbmFtZXNwYWNlcy5qcydcbmltcG9ydCBTaGFwZSBmcm9tICcuL1NoYXBlLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVc2UgZXh0ZW5kcyBTaGFwZSB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGF0dHJzID0gbm9kZSkge1xuICAgIHN1cGVyKG5vZGVPck5ldygndXNlJywgbm9kZSksIGF0dHJzKVxuICB9XG5cbiAgLy8gVXNlIGVsZW1lbnQgYXMgYSByZWZlcmVuY2VcbiAgdXNlKGVsZW1lbnQsIGZpbGUpIHtcbiAgICAvLyBTZXQgbGluZWQgZWxlbWVudFxuICAgIHJldHVybiB0aGlzLmF0dHIoJ2hyZWYnLCAoZmlsZSB8fCAnJykgKyAnIycgKyBlbGVtZW50LCB4bGluaylcbiAgfVxufVxuXG5yZWdpc3Rlck1ldGhvZHMoe1xuICBDb250YWluZXI6IHtcbiAgICAvLyBDcmVhdGUgYSB1c2UgZWxlbWVudFxuICAgIHVzZTogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKGVsZW1lbnQsIGZpbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgVXNlKCkpLnVzZShlbGVtZW50LCBmaWxlKVxuICAgIH0pXG4gIH1cbn0pXG5cbnJlZ2lzdGVyKFVzZSwgJ1VzZScpXG4iLCIvKiBPcHRpb25hbCBNb2R1bGVzICovXG5pbXBvcnQgJy4vbW9kdWxlcy9vcHRpb25hbC9hcnJhbmdlLmpzJ1xuaW1wb3J0ICcuL21vZHVsZXMvb3B0aW9uYWwvY2xhc3MuanMnXG5pbXBvcnQgJy4vbW9kdWxlcy9vcHRpb25hbC9jc3MuanMnXG5pbXBvcnQgJy4vbW9kdWxlcy9vcHRpb25hbC9kYXRhLmpzJ1xuaW1wb3J0ICcuL21vZHVsZXMvb3B0aW9uYWwvbWVtb3J5LmpzJ1xuaW1wb3J0ICcuL21vZHVsZXMvb3B0aW9uYWwvc3VnYXIuanMnXG5pbXBvcnQgJy4vbW9kdWxlcy9vcHRpb25hbC90cmFuc2Zvcm0uanMnXG5cbmltcG9ydCB7IGV4dGVuZCwgbWFrZUluc3RhbmNlIH0gZnJvbSAnLi91dGlscy9hZG9wdGVyLmpzJ1xuaW1wb3J0IHsgZ2V0TWV0aG9kTmFtZXMsIGdldE1ldGhvZHNGb3IgfSBmcm9tICcuL3V0aWxzL21ldGhvZHMuanMnXG5pbXBvcnQgQm94IGZyb20gJy4vdHlwZXMvQm94LmpzJ1xuaW1wb3J0IENvbG9yIGZyb20gJy4vdHlwZXMvQ29sb3IuanMnXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vZWxlbWVudHMvQ29udGFpbmVyLmpzJ1xuaW1wb3J0IERlZnMgZnJvbSAnLi9lbGVtZW50cy9EZWZzLmpzJ1xuaW1wb3J0IERvbSBmcm9tICcuL2VsZW1lbnRzL0RvbS5qcydcbmltcG9ydCBFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvRWxlbWVudC5qcydcbmltcG9ydCBFbGxpcHNlIGZyb20gJy4vZWxlbWVudHMvRWxsaXBzZS5qcydcbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuL3R5cGVzL0V2ZW50VGFyZ2V0LmpzJ1xuaW1wb3J0IEZyYWdtZW50IGZyb20gJy4vZWxlbWVudHMvRnJhZ21lbnQuanMnXG5pbXBvcnQgR3JhZGllbnQgZnJvbSAnLi9lbGVtZW50cy9HcmFkaWVudC5qcydcbmltcG9ydCBJbWFnZSBmcm9tICcuL2VsZW1lbnRzL0ltYWdlLmpzJ1xuaW1wb3J0IExpbmUgZnJvbSAnLi9lbGVtZW50cy9MaW5lLmpzJ1xuaW1wb3J0IExpc3QgZnJvbSAnLi90eXBlcy9MaXN0LmpzJ1xuaW1wb3J0IE1hcmtlciBmcm9tICcuL2VsZW1lbnRzL01hcmtlci5qcydcbmltcG9ydCBNYXRyaXggZnJvbSAnLi90eXBlcy9NYXRyaXguanMnXG5pbXBvcnQgTW9ycGhhYmxlLCB7XG4gIE5vbk1vcnBoYWJsZSxcbiAgT2JqZWN0QmFnLFxuICBUcmFuc2Zvcm1CYWcsXG4gIG1ha2VNb3JwaGFibGUsXG4gIHJlZ2lzdGVyTW9ycGhhYmxlVHlwZVxufSBmcm9tICcuL2FuaW1hdGlvbi9Nb3JwaGFibGUuanMnXG5pbXBvcnQgUGF0aCBmcm9tICcuL2VsZW1lbnRzL1BhdGguanMnXG5pbXBvcnQgUGF0aEFycmF5IGZyb20gJy4vdHlwZXMvUGF0aEFycmF5LmpzJ1xuaW1wb3J0IFBhdHRlcm4gZnJvbSAnLi9lbGVtZW50cy9QYXR0ZXJuLmpzJ1xuaW1wb3J0IFBvaW50QXJyYXkgZnJvbSAnLi90eXBlcy9Qb2ludEFycmF5LmpzJ1xuaW1wb3J0IFBvaW50IGZyb20gJy4vdHlwZXMvUG9pbnQuanMnXG5pbXBvcnQgUG9seWdvbiBmcm9tICcuL2VsZW1lbnRzL1BvbHlnb24uanMnXG5pbXBvcnQgUG9seWxpbmUgZnJvbSAnLi9lbGVtZW50cy9Qb2x5bGluZS5qcydcbmltcG9ydCBSZWN0IGZyb20gJy4vZWxlbWVudHMvUmVjdC5qcydcbmltcG9ydCBSdW5uZXIgZnJvbSAnLi9hbmltYXRpb24vUnVubmVyLmpzJ1xuaW1wb3J0IFNWR0FycmF5IGZyb20gJy4vdHlwZXMvU1ZHQXJyYXkuanMnXG5pbXBvcnQgU1ZHTnVtYmVyIGZyb20gJy4vdHlwZXMvU1ZHTnVtYmVyLmpzJ1xuaW1wb3J0IFNoYXBlIGZyb20gJy4vZWxlbWVudHMvU2hhcGUuanMnXG5pbXBvcnQgU3ZnIGZyb20gJy4vZWxlbWVudHMvU3ZnLmpzJ1xuaW1wb3J0IFN5bWJvbCBmcm9tICcuL2VsZW1lbnRzL1N5bWJvbC5qcydcbmltcG9ydCBUZXh0IGZyb20gJy4vZWxlbWVudHMvVGV4dC5qcydcbmltcG9ydCBUc3BhbiBmcm9tICcuL2VsZW1lbnRzL1RzcGFuLmpzJ1xuaW1wb3J0ICogYXMgZGVmYXVsdHMgZnJvbSAnLi9tb2R1bGVzL2NvcmUvZGVmYXVsdHMuanMnXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzL3V0aWxzLmpzJ1xuaW1wb3J0ICogYXMgbmFtZXNwYWNlcyBmcm9tICcuL21vZHVsZXMvY29yZS9uYW1lc3BhY2VzLmpzJ1xuaW1wb3J0ICogYXMgcmVnZXggZnJvbSAnLi9tb2R1bGVzL2NvcmUvcmVnZXguanMnXG5cbmV4cG9ydCB7XG4gIE1vcnBoYWJsZSxcbiAgcmVnaXN0ZXJNb3JwaGFibGVUeXBlLFxuICBtYWtlTW9ycGhhYmxlLFxuICBUcmFuc2Zvcm1CYWcsXG4gIE9iamVjdEJhZyxcbiAgTm9uTW9ycGhhYmxlXG59XG5cbmV4cG9ydCB7IGRlZmF1bHRzLCB1dGlscywgbmFtZXNwYWNlcywgcmVnZXggfVxuZXhwb3J0IGNvbnN0IFNWRyA9IG1ha2VJbnN0YW5jZVxuZXhwb3J0IHsgZGVmYXVsdCBhcyBwYXJzZXIgfSBmcm9tICcuL21vZHVsZXMvY29yZS9wYXJzZXIuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIGZpbmQgfSBmcm9tICcuL21vZHVsZXMvY29yZS9zZWxlY3Rvci5qcydcbmV4cG9ydCAqIGZyb20gJy4vbW9kdWxlcy9jb3JlL2V2ZW50LmpzJ1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9hZG9wdGVyLmpzJ1xuZXhwb3J0IHtcbiAgZ2V0V2luZG93LFxuICByZWdpc3RlcldpbmRvdyxcbiAgcmVzdG9yZVdpbmRvdyxcbiAgc2F2ZVdpbmRvdyxcbiAgd2l0aFdpbmRvd1xufSBmcm9tICcuL3V0aWxzL3dpbmRvdy5qcydcblxuLyogQW5pbWF0aW9uIE1vZHVsZXMgKi9cbmV4cG9ydCB7IGRlZmF1bHQgYXMgQW5pbWF0b3IgfSBmcm9tICcuL2FuaW1hdGlvbi9BbmltYXRvci5qcydcbmV4cG9ydCB7XG4gIENvbnRyb2xsZXIsXG4gIEVhc2UsXG4gIFBJRCxcbiAgU3ByaW5nLFxuICBlYXNpbmdcbn0gZnJvbSAnLi9hbmltYXRpb24vQ29udHJvbGxlci5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUXVldWUgfSBmcm9tICcuL2FuaW1hdGlvbi9RdWV1ZS5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUnVubmVyIH0gZnJvbSAnLi9hbmltYXRpb24vUnVubmVyLmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUaW1lbGluZSB9IGZyb20gJy4vYW5pbWF0aW9uL1RpbWVsaW5lLmpzJ1xuXG4vKiBUeXBlcyAqL1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBcnJheSB9IGZyb20gJy4vdHlwZXMvU1ZHQXJyYXkuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIEJveCB9IGZyb20gJy4vdHlwZXMvQm94LmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb2xvciB9IGZyb20gJy4vdHlwZXMvQ29sb3IuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIEV2ZW50VGFyZ2V0IH0gZnJvbSAnLi90eXBlcy9FdmVudFRhcmdldC5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWF0cml4IH0gZnJvbSAnLi90eXBlcy9NYXRyaXguanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIE51bWJlciB9IGZyb20gJy4vdHlwZXMvU1ZHTnVtYmVyLmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQYXRoQXJyYXkgfSBmcm9tICcuL3R5cGVzL1BhdGhBcnJheS5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUG9pbnQgfSBmcm9tICcuL3R5cGVzL1BvaW50LmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb2ludEFycmF5IH0gZnJvbSAnLi90eXBlcy9Qb2ludEFycmF5LmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaXN0IH0gZnJvbSAnLi90eXBlcy9MaXN0LmpzJ1xuXG4vKiBFbGVtZW50cyAqL1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDaXJjbGUgfSBmcm9tICcuL2VsZW1lbnRzL0NpcmNsZS5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2xpcFBhdGggfSBmcm9tICcuL2VsZW1lbnRzL0NsaXBQYXRoLmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb250YWluZXIgfSBmcm9tICcuL2VsZW1lbnRzL0NvbnRhaW5lci5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGVmcyB9IGZyb20gJy4vZWxlbWVudHMvRGVmcy5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRG9tIH0gZnJvbSAnLi9lbGVtZW50cy9Eb20uanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIEVsZW1lbnQgfSBmcm9tICcuL2VsZW1lbnRzL0VsZW1lbnQuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIEVsbGlwc2UgfSBmcm9tICcuL2VsZW1lbnRzL0VsbGlwc2UuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIEZvcmVpZ25PYmplY3QgfSBmcm9tICcuL2VsZW1lbnRzL0ZvcmVpZ25PYmplY3QuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIEZyYWdtZW50IH0gZnJvbSAnLi9lbGVtZW50cy9GcmFnbWVudC5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgR3JhZGllbnQgfSBmcm9tICcuL2VsZW1lbnRzL0dyYWRpZW50LmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBHIH0gZnJvbSAnLi9lbGVtZW50cy9HLmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBIH0gZnJvbSAnLi9lbGVtZW50cy9BLmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBJbWFnZSB9IGZyb20gJy4vZWxlbWVudHMvSW1hZ2UuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIExpbmUgfSBmcm9tICcuL2VsZW1lbnRzL0xpbmUuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIE1hcmtlciB9IGZyb20gJy4vZWxlbWVudHMvTWFya2VyLmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXNrIH0gZnJvbSAnLi9lbGVtZW50cy9NYXNrLmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQYXRoIH0gZnJvbSAnLi9lbGVtZW50cy9QYXRoLmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQYXR0ZXJuIH0gZnJvbSAnLi9lbGVtZW50cy9QYXR0ZXJuLmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb2x5Z29uIH0gZnJvbSAnLi9lbGVtZW50cy9Qb2x5Z29uLmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb2x5bGluZSB9IGZyb20gJy4vZWxlbWVudHMvUG9seWxpbmUuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIFJlY3QgfSBmcm9tICcuL2VsZW1lbnRzL1JlY3QuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNoYXBlIH0gZnJvbSAnLi9lbGVtZW50cy9TaGFwZS5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3RvcCB9IGZyb20gJy4vZWxlbWVudHMvU3RvcC5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3R5bGUgfSBmcm9tICcuL2VsZW1lbnRzL1N0eWxlLmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdmcgfSBmcm9tICcuL2VsZW1lbnRzL1N2Zy5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3ltYm9sIH0gZnJvbSAnLi9lbGVtZW50cy9TeW1ib2wuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIFRleHQgfSBmcm9tICcuL2VsZW1lbnRzL1RleHQuanMnXG5leHBvcnQgeyBkZWZhdWx0IGFzIFRleHRQYXRoIH0gZnJvbSAnLi9lbGVtZW50cy9UZXh0UGF0aC5qcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVHNwYW4gfSBmcm9tICcuL2VsZW1lbnRzL1RzcGFuLmpzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBVc2UgfSBmcm9tICcuL2VsZW1lbnRzL1VzZS5qcydcblxuZXh0ZW5kKFtTdmcsIFN5bWJvbCwgSW1hZ2UsIFBhdHRlcm4sIE1hcmtlcl0sIGdldE1ldGhvZHNGb3IoJ3ZpZXdib3gnKSlcblxuZXh0ZW5kKFtMaW5lLCBQb2x5bGluZSwgUG9seWdvbiwgUGF0aF0sIGdldE1ldGhvZHNGb3IoJ21hcmtlcicpKVxuXG5leHRlbmQoVGV4dCwgZ2V0TWV0aG9kc0ZvcignVGV4dCcpKVxuZXh0ZW5kKFBhdGgsIGdldE1ldGhvZHNGb3IoJ1BhdGgnKSlcblxuZXh0ZW5kKERlZnMsIGdldE1ldGhvZHNGb3IoJ0RlZnMnKSlcblxuZXh0ZW5kKFtUZXh0LCBUc3Bhbl0sIGdldE1ldGhvZHNGb3IoJ1RzcGFuJykpXG5cbmV4dGVuZChbUmVjdCwgRWxsaXBzZSwgR3JhZGllbnQsIFJ1bm5lcl0sIGdldE1ldGhvZHNGb3IoJ3JhZGl1cycpKVxuXG5leHRlbmQoRXZlbnRUYXJnZXQsIGdldE1ldGhvZHNGb3IoJ0V2ZW50VGFyZ2V0JykpXG5leHRlbmQoRG9tLCBnZXRNZXRob2RzRm9yKCdEb20nKSlcbmV4dGVuZChFbGVtZW50LCBnZXRNZXRob2RzRm9yKCdFbGVtZW50JykpXG5leHRlbmQoU2hhcGUsIGdldE1ldGhvZHNGb3IoJ1NoYXBlJykpXG5leHRlbmQoW0NvbnRhaW5lciwgRnJhZ21lbnRdLCBnZXRNZXRob2RzRm9yKCdDb250YWluZXInKSlcbmV4dGVuZChHcmFkaWVudCwgZ2V0TWV0aG9kc0ZvcignR3JhZGllbnQnKSlcblxuZXh0ZW5kKFJ1bm5lciwgZ2V0TWV0aG9kc0ZvcignUnVubmVyJykpXG5cbkxpc3QuZXh0ZW5kKGdldE1ldGhvZE5hbWVzKCkpXG5cbnJlZ2lzdGVyTW9ycGhhYmxlVHlwZShbXG4gIFNWR051bWJlcixcbiAgQ29sb3IsXG4gIEJveCxcbiAgTWF0cml4LFxuICBTVkdBcnJheSxcbiAgUG9pbnRBcnJheSxcbiAgUGF0aEFycmF5LFxuICBQb2ludFxuXSlcblxubWFrZU1vcnBoYWJsZSgpXG4iLCJpbXBvcnQgeyBDaXJjbGUsIEcsIFRleHQgfSBmcm9tIFwiQHN2Z2RvdGpzL3N2Zy5qc1wiO1xyXG5pbXBvcnQgeyBOQlNQIH0gZnJvbSBcIi4uLy4uL3NyYy9lbmdpbmVcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBUZXh0Q2lyY2xlIGV4dGVuZHMgRyB7XHJcbiAgJGNpcmNsZTogQ2lyY2xlIHwgbnVsbCA9IG51bGw7XHJcbiAgJHRleHQ6IFRleHQgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgaW5pdChcclxuICAgIHRleHQ6IHN0cmluZyxcclxuICAgIHg6IG51bWJlcixcclxuICAgIHk6IG51bWJlcixcclxuICAgIHNpemU6IG51bWJlcixcclxuICAgIHN0cm9rZVdpZHRoOiBudW1iZXJcclxuICApOiB0aGlzIHtcclxuICAgIHRoaXMuJGNpcmNsZSA9IHRoaXMuY2lyY2xlKHNpemUpXHJcbiAgICAgIC5zdHJva2UoeyB3aWR0aDogc3Ryb2tlV2lkdGggfSlcclxuICAgICAgLmNlbnRlcigwLCAwKTtcclxuICAgIHRoaXMuJHRleHQgPSB0aGlzLnRleHQodGV4dCkuY2VudGVyKDAsIDApO1xyXG4gICAgaWYgKHggJiYgeSkgdGhpcy5jZW50ZXIoeCwgeSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGdldFRleHQoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiB0aGlzLiR0ZXh0Py50ZXh0KCkgfHwgXCJcIjtcclxuICB9XHJcblxyXG4gIHNldFRleHQodGV4dDogc3RyaW5nIHwgbnVsbCk6IHRoaXMge1xyXG4gICAgaWYgKHRleHQgPT0gbnVsbCkgdGV4dCA9IFwiXCI7XHJcbiAgICB0ZXh0ID0gYCR7dGV4dH1gO1xyXG4gICAgLy8gTm9uLWJyZWFraW5nIHNwYWNlOiBXZSBuZWVkIHRvIGhhdmUgc29tZSB0ZXh0LCBvdGhlcndpc2UgdGhlIGNvb3JkaW5hdGVzIGFyZSByZXNldCB0byAoMCwgMClcclxuICAgIGlmICh0ZXh0ID09PSBcIlwiKSB0ZXh0ID0gTkJTUDtcclxuICAgIHRoaXMuJHRleHQ/LnRleHQodGV4dCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGdldFNpemUoKTogbnVtYmVyIHtcclxuICAgIGNvbnN0IHIgPSB0aGlzLmF0dHIoXCJyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiByID09PSBcIm51bWJlclwiKSByZXR1cm4gciAqIDI7XHJcbiAgICBpZiAodHlwZW9mIHIgPT09IFwic3RyaW5nXCIgJiYgIWlzTmFOKE51bWJlcihyKSkpIHJldHVybiBOdW1iZXIocikgKiAyO1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICBzZXRTaXplKGRpYW1ldGVyOiBudW1iZXIsIGFuaW1hdGlvbkR1cmF0aW9uOiBudW1iZXIgPSAwKTogdGhpcyB7XHJcbiAgICB0aGlzLmFuaW1hdGUoYW5pbWF0aW9uRHVyYXRpb24pLmF0dHIoXCJyXCIsIFN0cmluZyhkaWFtZXRlciAvIDIpKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRleHQoKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgZmluZCwgUGF0aCB9IGZyb20gXCJAc3ZnZG90anMvc3ZnLmpzXCI7XHJcbmltcG9ydCB7IENvbm5lY3Rpb24gfSBmcm9tIFwiLi9jb25uZWN0aW9uXCI7XHJcbmltcG9ydCB7IFRleHRDaXJjbGUgfSBmcm9tIFwiLi90ZXh0LWNpcmNsZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEdyYXBoTm9kZSBleHRlbmRzIFRleHRDaXJjbGUge1xyXG4gICRpbmNvbWluZzogUmVjb3JkPHN0cmluZywgQ29ubmVjdGlvbjxHcmFwaE5vZGU+IHwgbnVsbD4gPSB7fTtcclxuICAkb3V0Z29pbmc6IFJlY29yZDxzdHJpbmcsIENvbm5lY3Rpb248R3JhcGhOb2RlPiB8IG51bGw+ID0ge307XHJcbiAgJG51bGxhcnk6IFJlY29yZDxzdHJpbmcsIFBhdGggfCBudWxsPiA9IHt9O1xyXG5cclxuICBpbml0KFxyXG4gICAgdGV4dDogc3RyaW5nLFxyXG4gICAgeDogbnVtYmVyLFxyXG4gICAgeTogbnVtYmVyLFxyXG4gICAgc2l6ZTogbnVtYmVyLFxyXG4gICAgc3Ryb2tlV2lkdGg6IG51bWJlclxyXG4gICk6IHRoaXMge1xyXG4gICAgY29uc3QgYmdTaXplID0gMyAqIHNpemU7XHJcbiAgICB0aGlzLnJlY3QoYmdTaXplLCBiZ1NpemUpLmNlbnRlcigwLCAwKS5hZGRDbGFzcyhcImludmlzaWJsZVwiKTtcclxuICAgIHJldHVybiBzdXBlci5pbml0KHRleHQsIHgsIHksIHNpemUsIHN0cm9rZVdpZHRoKTtcclxuICB9XHJcblxyXG4gIGdldEJlbmQoa2V5OiB1bmtub3duKTogbnVtYmVyIHtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgZ2V0RGlyZWN0ZWQoa2V5OiB1bmtub3duKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGdldEluY29taW5nKGluS2V5OiBzdHJpbmcpOiBDb25uZWN0aW9uPEdyYXBoTm9kZT4gfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLiRpbmNvbWluZ1tpbktleV07XHJcbiAgfVxyXG5cclxuICBnZXRPdXRnb2luZyhvdXRLZXk6IHN0cmluZyk6IENvbm5lY3Rpb248R3JhcGhOb2RlPiB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuJG91dGdvaW5nW291dEtleV07XHJcbiAgfVxyXG5cclxuICBnZXRJbmNvbWluZ0VkZ2VzKCk6IENvbm5lY3Rpb248R3JhcGhOb2RlPltdIHtcclxuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuJGluY29taW5nKS5maWx0ZXIoKGUpID0+IGUgIT09IG51bGwpO1xyXG4gIH1cclxuXHJcbiAgZ2V0T3V0Z29pbmdFZGdlcygpOiBDb25uZWN0aW9uPEdyYXBoTm9kZT5bXSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLiRvdXRnb2luZykuZmlsdGVyKChlKSA9PiBlICE9PSBudWxsKTtcclxuICB9XHJcblxyXG4gIGdldFByZWRlY2Vzc29ycygpOiBHcmFwaE5vZGVbXSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLiRpbmNvbWluZylcclxuICAgICAgLm1hcCgoZSkgPT4gZT8uZ2V0U3RhcnQoKSlcclxuICAgICAgLmZpbHRlcigoZSkgPT4gZSAhPT0gdW5kZWZpbmVkICYmIGUgIT09IG51bGwpO1xyXG4gIH1cclxuXHJcbiAgZ2V0U3VjY2Vzc29ycygpOiBHcmFwaE5vZGVbXSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLiRvdXRnb2luZylcclxuICAgICAgLm1hcCgoZSkgPT4gZT8uZ2V0RW5kKCkpXHJcbiAgICAgIC5maWx0ZXIoKGUpID0+IGUgIT09IHVuZGVmaW5lZCAmJiBlICE9PSBudWxsKTtcclxuICB9XHJcblxyXG4gIGdldFByZWRlY2Vzc29yKGluS2V5OiBzdHJpbmcpOiBHcmFwaE5vZGUgfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLiRpbmNvbWluZ1tpbktleV0/LmdldFN0YXJ0KCkgfHwgbnVsbDtcclxuICB9XHJcblxyXG4gIGdldFN1Y2Nlc3NvcihvdXRLZXk6IHN0cmluZyk6IEdyYXBoTm9kZSB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuJG91dGdvaW5nW291dEtleV0/LmdldEVuZCgpIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICBzZXRQcmVkZWNlc3NvcihcclxuICAgIGluS2V5OiBzdHJpbmcsXHJcbiAgICBvdXRLZXk6IHN0cmluZyxcclxuICAgIHByZWRlY2Vzc29yOiBHcmFwaE5vZGUsXHJcbiAgICBzdHJva2VXaWR0aDogbnVtYmVyXHJcbiAgKTogdGhpcyB7XHJcbiAgICBwcmVkZWNlc3Nvci5zZXRTdWNjZXNzb3Iob3V0S2V5LCBpbktleSwgdGhpcywgc3Ryb2tlV2lkdGgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBzZXRTdWNjZXNzb3IoXHJcbiAgICBvdXRLZXk6IHN0cmluZyxcclxuICAgIGluS2V5OiBzdHJpbmcsXHJcbiAgICBzdWNjZXNzb3I6IEdyYXBoTm9kZSxcclxuICAgIHN0cm9rZVdpZHRoOiBudW1iZXJcclxuICApOiB0aGlzIHtcclxuICAgIGNvbnN0IG91dEVkZ2UgPSB0aGlzLiRvdXRnb2luZ1tvdXRLZXldO1xyXG4gICAgaWYgKG91dEVkZ2UpIHtcclxuICAgICAgY29uc3Qgb2xkU3VjY2Vzc29yID0gb3V0RWRnZS5nZXRFbmQoKTtcclxuICAgICAgY29uc3Qgb2xkSW5jb21pbmcgPSBvbGRTdWNjZXNzb3I/LiRpbmNvbWluZztcclxuICAgICAgZm9yIChjb25zdCBrIGluIG9sZEluY29taW5nKSB7XHJcbiAgICAgICAgaWYgKG9sZEluY29taW5nW2tdID09PSBvdXRFZGdlKSBkZWxldGUgb2xkSW5jb21pbmdba107XHJcbiAgICAgIH1cclxuICAgICAgb3V0RWRnZS5yZW1vdmUoKTtcclxuICAgIH1cclxuICAgIGlmIChzdWNjZXNzb3IpIHtcclxuICAgICAgY29uc3QgaW5FZGdlID0gc3VjY2Vzc29yLiRpbmNvbWluZ1tpbktleV07XHJcbiAgICAgIGlmIChpbkVkZ2UpIHtcclxuICAgICAgICBjb25zdCBvbGRQcmVkZWNlc3NvciA9IGluRWRnZS5nZXRTdGFydCgpO1xyXG4gICAgICAgIGNvbnN0IG9sZE91dGdvaW5nID0gb2xkUHJlZGVjZXNzb3I/LiRvdXRnb2luZztcclxuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gb2xkT3V0Z29pbmcpIHtcclxuICAgICAgICAgIGlmIChvbGRPdXRnb2luZ1trXSA9PT0gaW5FZGdlKSBkZWxldGUgb2xkT3V0Z29pbmdba107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluRWRnZS5yZW1vdmUoKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBlZGdlID0gdGhpcy5yb290KCkuY29ubmVjdGlvbihcclxuICAgICAgICB0aGlzLFxyXG4gICAgICAgIHN1Y2Nlc3NvcixcclxuICAgICAgICBzdHJva2VXaWR0aCxcclxuICAgICAgICB0aGlzLmdldEJlbmQob3V0S2V5KSxcclxuICAgICAgICB0aGlzLmdldERpcmVjdGVkKG91dEtleSlcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHRoaXMuJG91dGdvaW5nW291dEtleV0gPSBlZGdlO1xyXG4gICAgICBzdWNjZXNzb3IuJGluY29taW5nW2luS2V5XSA9IGVkZ2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkZWxldGUgdGhpcy4kb3V0Z29pbmdbb3V0S2V5XTtcclxuICAgIH1cclxuICAgIHRoaXMuX3VwZGF0ZU51bGxhcnkoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgX3VwZGF0ZU51bGxhcnkoKTogdm9pZCB7XHJcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgZmluZChcImdcIikpIHtcclxuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBHcmFwaE5vZGUpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGMgaW4gbm9kZS4kbnVsbGFyeSkge1xyXG4gICAgICAgICAgY29uc3Qgc2hvdyA9ICFub2RlLiRvdXRnb2luZ1tjXTtcclxuICAgICAgICAgIGlmIChzaG93KSBub2RlLiRudWxsYXJ5W2NdPy5yZW1vdmVDbGFzcyhcImludmlzaWJsZVwiKTtcclxuICAgICAgICAgIGVsc2Ugbm9kZS4kbnVsbGFyeVtjXT8uYWRkQ2xhc3MoXCJpbnZpc2libGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXRJbmNvbWluZ0hpZ2hsaWdodChpbktleTogc3RyaW5nLCBoaWdoOiBib29sZWFuIHwgbnVsbCk6IHRoaXMge1xyXG4gICAgdGhpcy5zZXRIaWdobGlnaHQoaGlnaCk7XHJcbiAgICB0aGlzLmdldEluY29taW5nKGluS2V5KT8uc2V0SGlnaGxpZ2h0KGhpZ2gpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBnZXRIaWdobGlnaHQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5oYXNDbGFzcyhcImhpZ2hsaWdodFwiKTtcclxuICB9XHJcbiAgc2V0T3V0Z29pbmdIaWdobGlnaHQob3V0S2V5OiBzdHJpbmcsIGhpZ2g6IGJvb2xlYW4gfCBudWxsKTogdGhpcyB7XHJcbiAgICB0aGlzLnNldEhpZ2hsaWdodChoaWdoKTtcclxuICAgIHRoaXMuZ2V0T3V0Z29pbmcob3V0S2V5KT8uc2V0SGlnaGxpZ2h0KGhpZ2gpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPOiBCZXR0ZXIgbmFtaW5nOiBSZW1vdmUgd2hhdD8gSXRzZWxmXHJcbiAgLy8gVE9ETzogUmVmYWN0b3IgdG8gdXNlIGZvcmVhY2ggbG9vcD9cclxuICByZW1vdmUoKTogdGhpcyB7XHJcbiAgICBmb3IgKGNvbnN0IG91dEtleSBpbiB0aGlzLiRvdXRnb2luZykge1xyXG4gICAgICBjb25zdCBvdXRFZGdlID0gdGhpcy4kb3V0Z29pbmdbb3V0S2V5XTtcclxuICAgICAgaWYgKCFvdXRFZGdlKSBjb250aW51ZTtcclxuICAgICAgY29uc3QgZW5kID0gb3V0RWRnZS5nZXRFbmQoKTtcclxuICAgICAgY29uc3QgaW5jb21pbmcgPSBlbmQ/LiRpbmNvbWluZztcclxuICAgICAgZm9yIChjb25zdCBpbktleSBpbiBpbmNvbWluZykge1xyXG4gICAgICAgIGlmIChvdXRFZGdlID09PSBpbmNvbWluZ1tpbktleV0pIHtcclxuICAgICAgICAgIGRlbGV0ZSBpbmNvbWluZ1tpbktleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG91dEVkZ2UucmVtb3ZlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgaW5LZXkgaW4gdGhpcy4kaW5jb21pbmcpIHtcclxuICAgICAgY29uc3QgaW5FZGdlID0gdGhpcy4kaW5jb21pbmdbaW5LZXldO1xyXG4gICAgICBpZiAoIWluRWRnZSkgY29udGludWU7XHJcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaW5FZGdlLmdldFN0YXJ0KCk7XHJcbiAgICAgIGNvbnN0IG91dGdvaW5nID0gc3RhcnQ/LiRvdXRnb2luZztcclxuICAgICAgZm9yIChjb25zdCBvdXRLZXkgaW4gb3V0Z29pbmcpIHtcclxuICAgICAgICBpZiAoaW5FZGdlID09PSBvdXRnb2luZ1tvdXRLZXldKSB7XHJcbiAgICAgICAgICBkZWxldGUgb3V0Z29pbmdbb3V0S2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5FZGdlLnJlbW92ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBzdXBlci5yZW1vdmUoKTtcclxuICAgIHRoaXMuX3VwZGF0ZU51bGxhcnkoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgc2V0Q2VudGVyKHg6IG51bWJlciwgeTogbnVtYmVyLCBhbmltYXRpb25EdXJhdGlvbjogbnVtYmVyID0gMCk6IHRoaXMge1xyXG4gICAgc3VwZXIuc2V0Q2VudGVyKHgsIHksIGFuaW1hdGlvbkR1cmF0aW9uKTtcclxuICAgIGZvciAoY29uc3QgZWRnZSBvZiB0aGlzLmdldE91dGdvaW5nRWRnZXMoKSkge1xyXG4gICAgICBlZGdlLnVwZGF0ZSh7IHgxOiB4LCB5MTogeSB9LCBhbmltYXRpb25EdXJhdGlvbik7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgdGhpcy5nZXRJbmNvbWluZ0VkZ2VzKCkpIHtcclxuICAgICAgZWRnZS51cGRhdGUoeyB4MjogeCwgeTI6IHkgfSwgYW5pbWF0aW9uRHVyYXRpb24pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBzZXRTaXplKHNpemU6IG51bWJlciwgYW5pbWF0aW9uRHVyYXRpb246IG51bWJlciA9IDApOiB0aGlzIHtcclxuICAgIHN1cGVyLnNldFNpemUoc2l6ZSwgYW5pbWF0aW9uRHVyYXRpb24pO1xyXG4gICAgZm9yIChjb25zdCBlZGdlIG9mIHRoaXMuZ2V0SW5jb21pbmdFZGdlcygpKSB7XHJcbiAgICAgIGVkZ2UudXBkYXRlKHsgcjI6IHNpemUgLyAyIH0sIGFuaW1hdGlvbkR1cmF0aW9uKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBQYXRoIH0gZnJvbSBcIkBzdmdkb3Rqcy9zdmcuanNcIjtcclxuaW1wb3J0IHsgQ29ubmVjdGlvbiB9IGZyb20gXCIuL2Nvbm5lY3Rpb25cIjtcclxuaW1wb3J0IHsgR3JhcGhOb2RlIH0gZnJvbSBcIi4vZ3JhcGgtbm9kZVwiO1xyXG5cclxudHlwZSBDaGlsZHJlbiA9IFwibGVmdFwiIHwgXCJyaWdodFwiO1xyXG5leHBvcnQgY2xhc3MgQmluYXJ5Tm9kZSBleHRlbmRzIEdyYXBoTm9kZSB7XHJcbiAgJGluY29taW5nOiB7IHBhcmVudDogQ29ubmVjdGlvbjxCaW5hcnlOb2RlPiB8IG51bGwgfSA9IHtcclxuICAgIHBhcmVudDogbnVsbCxcclxuICB9O1xyXG4gICRvdXRnb2luZzoge1xyXG4gICAgbGVmdDogQ29ubmVjdGlvbjxCaW5hcnlOb2RlPiB8IG51bGw7XHJcbiAgICByaWdodDogQ29ubmVjdGlvbjxCaW5hcnlOb2RlPiB8IG51bGw7XHJcbiAgfSA9IHtcclxuICAgIGxlZnQ6IG51bGwsXHJcbiAgICByaWdodDogbnVsbCxcclxuICB9O1xyXG4gICRudWxsYXJ5OiB7IGxlZnQ6IFBhdGggfCBudWxsOyByaWdodDogUGF0aCB8IG51bGwgfSA9IHtcclxuICAgIGxlZnQ6IG51bGwsXHJcbiAgICByaWdodDogbnVsbCxcclxuICB9O1xyXG4gICRlZGdlYmVuZHMgPSB7IGxlZnQ6IDAuMSwgcmlnaHQ6IC0wLjEgfTtcclxuICAkbGVmdFdpZHRoOiBudW1iZXIgPSAwO1xyXG4gICRyaWdodFdpZHRoOiBudW1iZXIgPSAwO1xyXG4gICR3aWR0aDogbnVtYmVyID0gMDtcclxuXHJcbiAgaW5pdChcclxuICAgIHRleHQ6IHN0cmluZyxcclxuICAgIHg6IG51bWJlcixcclxuICAgIHk6IG51bWJlcixcclxuICAgIHNpemU6IG51bWJlcixcclxuICAgIHN0cm9rZVdpZHRoOiBudW1iZXJcclxuICApOiB0aGlzIHtcclxuICAgIGNvbnN0IGQgPSBzaXplO1xyXG4gICAgY29uc3QgblggPSAwLjUgKiBkLFxyXG4gICAgICBuWSA9IDAuOCAqIGQsXHJcbiAgICAgIG5SID0gMiAqIHN0cm9rZVdpZHRoO1xyXG4gICAgY29uc3QgbnVsbHBhdGggPSAoczogbnVtYmVyKSA9PlxyXG4gICAgICBgTSAwLDAgTCAke3MgKiBuWH0sJHtuWX0gbSAke25SfSwwIGEgJHtuUn0sJHtuUn0gMCAxLDAgJHtcclxuICAgICAgICAtMiAqIG5SXHJcbiAgICAgIH0sMCBhICR7blJ9LCR7blJ9IDAgMSwwICR7MiAqIG5SfSwwYDtcclxuXHJcbiAgICB0aGlzLiRudWxsYXJ5LmxlZnQgPSB0aGlzLnBhdGgobnVsbHBhdGgoLTEpKVxyXG4gICAgICAuc3Ryb2tlKHsgd2lkdGg6IHN0cm9rZVdpZHRoIH0pXHJcbiAgICAgIC5hZGRDbGFzcyhcIm51bGxub2RlXCIpO1xyXG4gICAgdGhpcy4kbnVsbGFyeS5yaWdodCA9IHRoaXMucGF0aChudWxscGF0aCgxKSlcclxuICAgICAgLnN0cm9rZSh7IHdpZHRoOiBzdHJva2VXaWR0aCB9KVxyXG4gICAgICAuYWRkQ2xhc3MoXCJudWxsbm9kZVwiKTtcclxuICAgIHJldHVybiBzdXBlci5pbml0KHRleHQsIHgsIHksIHNpemUsIHN0cm9rZVdpZHRoKTtcclxuICB9XHJcblxyXG4gIGdldEJlbmQoYzogQ2hpbGRyZW4pOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuJGVkZ2ViZW5kc1tjXTtcclxuICB9XHJcblxyXG4gIGdldFBhcmVudCgpOiBCaW5hcnlOb2RlIHwgbnVsbCB7XHJcbiAgICByZXR1cm4gdGhpcy4kaW5jb21pbmcucGFyZW50Py5nZXRTdGFydCgpIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICBnZXRMZWZ0KCk6IEJpbmFyeU5vZGUgfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLiRvdXRnb2luZy5sZWZ0Py5nZXRFbmQoKSB8fCBudWxsO1xyXG4gIH1cclxuXHJcbiAgZ2V0UmlnaHQoKTogQmluYXJ5Tm9kZSB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuJG91dGdvaW5nLnJpZ2h0Py5nZXRFbmQoKSB8fCBudWxsO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q2hpbGQoYzogQ2hpbGRyZW4pOiBCaW5hcnlOb2RlIHwgbnVsbCB7XHJcbiAgICByZXR1cm4gdGhpcy4kb3V0Z29pbmdbY10/LmdldEVuZCgpIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICBnZXRTaWJsaW5nKCk6IEJpbmFyeU5vZGUgfCBudWxsIHtcclxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XHJcbiAgICBpZiAoIXBhcmVudCkgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gdGhpcyA9PT0gcGFyZW50LmdldExlZnQoKSA/IHBhcmVudC5nZXRSaWdodCgpIDogcGFyZW50LmdldExlZnQoKTtcclxuICB9XHJcblxyXG4gIGdldFBhcmVudEVkZ2UoKTogQ29ubmVjdGlvbjxCaW5hcnlOb2RlPiB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuJGluY29taW5nLnBhcmVudDtcclxuICB9XHJcblxyXG4gIGdldExlZnRFZGdlKCk6IENvbm5lY3Rpb248QmluYXJ5Tm9kZT4gfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLiRvdXRnb2luZy5sZWZ0O1xyXG4gIH1cclxuXHJcbiAgZ2V0UmlnaHRFZGdlKCk6IENvbm5lY3Rpb248QmluYXJ5Tm9kZT4gfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLiRvdXRnb2luZy5yaWdodDtcclxuICB9XHJcblxyXG4gIGdldENoaWxkRWRnZShjOiBDaGlsZHJlbik6IENvbm5lY3Rpb248QmluYXJ5Tm9kZT4gfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLiRvdXRnb2luZ1tjXTtcclxuICB9XHJcblxyXG4gIGlzTGVhZigpOiBib29sZWFuIHtcclxuICAgIHJldHVybiAhKHRoaXMuZ2V0TGVmdCgpIHx8IHRoaXMuZ2V0UmlnaHQoKSk7XHJcbiAgfVxyXG5cclxuICBpc0xlZnRDaGlsZCgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzID09PSB0aGlzLmdldFBhcmVudCgpPy5nZXRMZWZ0KCk7XHJcbiAgfVxyXG5cclxuICBpc1JpZ2h0Q2hpbGQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcyA9PT0gdGhpcy5nZXRQYXJlbnQoKT8uZ2V0UmlnaHQoKTtcclxuICB9XHJcblxyXG4gIGlzQ2hpbGQoYzogQ2hpbGRyZW4pOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzID09PSB0aGlzLmdldFBhcmVudCgpPy5nZXRDaGlsZChjKTtcclxuICB9XHJcblxyXG4gIHNldExlZnQoY2hpbGQ6IEJpbmFyeU5vZGUsIHN0cm9rZVdpZHRoOiBudW1iZXIpOiB0aGlzIHtcclxuICAgIHJldHVybiB0aGlzLnNldENoaWxkKFwibGVmdFwiLCBjaGlsZCwgc3Ryb2tlV2lkdGgpO1xyXG4gIH1cclxuXHJcbiAgc2V0UmlnaHQoY2hpbGQ6IEJpbmFyeU5vZGUsIHN0cm9rZVdpZHRoOiBudW1iZXIpOiB0aGlzIHtcclxuICAgIHJldHVybiB0aGlzLnNldENoaWxkKFwicmlnaHRcIiwgY2hpbGQsIHN0cm9rZVdpZHRoKTtcclxuICB9XHJcblxyXG4gIHNldENoaWxkKGM6IENoaWxkcmVuLCBjaGlsZDogQmluYXJ5Tm9kZSwgc3Ryb2tlV2lkdGg6IG51bWJlcik6IHRoaXMge1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0U3VjY2Vzc29yKGMsIFwicGFyZW50XCIsIGNoaWxkLCBzdHJva2VXaWR0aCk7XHJcbiAgfVxyXG5cclxuICBzZXRQYXJlbnRMZWZ0KHBhcmVudDogQmluYXJ5Tm9kZSwgc3Ryb2tlV2lkdGg6IG51bWJlcik6IHRoaXMge1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0UGFyZW50KFwibGVmdFwiLCBwYXJlbnQsIHN0cm9rZVdpZHRoKTtcclxuICB9XHJcblxyXG4gIHNldFBhcmVudFJpZ2h0KHBhcmVudDogQmluYXJ5Tm9kZSwgc3Ryb2tlV2lkdGg6IG51bWJlcik6IHRoaXMge1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0UGFyZW50KFwicmlnaHRcIiwgcGFyZW50LCBzdHJva2VXaWR0aCk7XHJcbiAgfVxyXG5cclxuICBzZXRQYXJlbnQoYzogQ2hpbGRyZW4sIHBhcmVudDogQmluYXJ5Tm9kZSwgc3Ryb2tlV2lkdGg6IG51bWJlcik6IHRoaXMge1xyXG4gICAgcGFyZW50LnNldENoaWxkKGMsIHRoaXMsIHN0cm9rZVdpZHRoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgc2V0UGFyZW50SGlnaGxpZ2h0KGhpZ2g6IGJvb2xlYW4gfCBudWxsKTogdGhpcyB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXRJbmNvbWluZ0hpZ2hsaWdodChcInBhcmVudFwiLCBoaWdoKTtcclxuICB9XHJcblxyXG4gIHNldFJpZ2h0SGlnaGxpZ2h0KGhpZ2g6IGJvb2xlYW4gfCBudWxsKTogdGhpcyB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXRDaGlsZEhpZ2hsaWdodChcInJpZ2h0XCIsIGhpZ2gpO1xyXG4gIH1cclxuXHJcbiAgc2V0TGVmdEhpZ2hsaWdodChoaWdoOiBib29sZWFuIHwgbnVsbCk6IHRoaXMge1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0Q2hpbGRIaWdobGlnaHQoXCJsZWZ0XCIsIGhpZ2gpO1xyXG4gIH1cclxuXHJcbiAgc2V0Q2hpbGRIaWdobGlnaHQoYzogQ2hpbGRyZW4sIGhpZ2g6IGJvb2xlYW4gfCBudWxsKTogdGhpcyB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXRPdXRnb2luZ0hpZ2hsaWdodChjLCBoaWdoKTtcclxuICB9XHJcblxyXG4gIGRlZXBTdHJpbmcoKTogc3RyaW5nIHtcclxuICAgIGxldCBzID0gXCJcIjtcclxuICAgIGlmICh0aGlzLmdldExlZnQoKSkgcyArPSBgKCR7dGhpcy5nZXRMZWZ0KCk/LmRlZXBTdHJpbmcoKX0pIGA7XHJcbiAgICBzICs9IHRoaXMuZ2V0VGV4dCgpO1xyXG4gICAgaWYgKHRoaXMuZ2V0UmlnaHQoKSkgcyArPSBgICgke3RoaXMuZ2V0UmlnaHQoKT8uZGVlcFN0cmluZygpfSlgO1xyXG4gICAgcmV0dXJuIHM7XHJcbiAgfVxyXG5cclxuICByZXNpemUoXHJcbiAgICBzdGFydFg6IG51bWJlcixcclxuICAgIHN0YXJ0WTogbnVtYmVyLFxyXG4gICAgc3ZnTWFyZ2luOiBudW1iZXIsXHJcbiAgICBub2RlU3BhY2luZzogbnVtYmVyLFxyXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IG51bWJlciA9IDBcclxuICApOiB0aGlzIHtcclxuICAgIHRoaXMuX3Jlc2l6ZVdpZHRocyhub2RlU3BhY2luZyk7XHJcbiAgICBjb25zdCBzdmdXaWR0aCA9IHRoaXMucm9vdCgpLnZpZXdib3goKS53aWR0aDtcclxuICAgIGlmIChzdGFydFggKyB0aGlzLiRyaWdodFdpZHRoID4gc3ZnV2lkdGggLSBzdmdNYXJnaW4pXHJcbiAgICAgIHN0YXJ0WCA9IHN2Z1dpZHRoIC0gdGhpcy4kcmlnaHRXaWR0aCAtIHN2Z01hcmdpbjtcclxuICAgIGlmIChzdGFydFggLSB0aGlzLiRsZWZ0V2lkdGggPCBzdmdNYXJnaW4pXHJcbiAgICAgIHN0YXJ0WCA9IHRoaXMuJGxlZnRXaWR0aCArIHN2Z01hcmdpbjtcclxuICAgIHRoaXMuX3NldE5ld1Bvc2l0aW9ucyhzdGFydFgsIHN0YXJ0WSwgbm9kZVNwYWNpbmcsIGFuaW1hdGlvbkR1cmF0aW9uKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gVE9ETzogTmFtaW5nIHNob3VsZCByZWZsZWN0IHRoYXQgbnVtYmVyIGlzIHJldHVybmVkXHJcbiAgX3Jlc2l6ZVdpZHRocyhub2RlU3BhY2luZzogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIGxldCB3aWR0aCA9IG5vZGVTcGFjaW5nO1xyXG4gICAgY29uc3QgbGVmdCA9IHRoaXMuZ2V0TGVmdCgpO1xyXG4gICAgaWYgKGxlZnQpIHdpZHRoICs9IGxlZnQuX3Jlc2l6ZVdpZHRocyhub2RlU3BhY2luZyk7XHJcbiAgICBjb25zdCByaWdodCA9IHRoaXMuZ2V0UmlnaHQoKTtcclxuICAgIGlmIChyaWdodCkgd2lkdGggKz0gcmlnaHQuX3Jlc2l6ZVdpZHRocyhub2RlU3BhY2luZyk7XHJcbiAgICB3aWR0aCA9IE1hdGgubWF4KHRoaXMuZ2V0U2l6ZSgpLCB3aWR0aCk7XHJcbiAgICBjb25zdCBsZWZ0V2lkdGggPSBsZWZ0Py4kbGVmdFdpZHRoIHx8IDA7XHJcbiAgICBjb25zdCByaWdodFdpZHRoID0gcmlnaHQ/LiRyaWdodFdpZHRoIHx8IDA7XHJcbiAgICBjb25zdCBtaWQgPSB3aWR0aCAtIGxlZnRXaWR0aCAtIHJpZ2h0V2lkdGg7XHJcbiAgICB0aGlzLiRsZWZ0V2lkdGggPSBtaWQgLyAyICsgbGVmdFdpZHRoO1xyXG4gICAgdGhpcy4kcmlnaHRXaWR0aCA9IG1pZCAvIDIgKyByaWdodFdpZHRoO1xyXG4gICAgdGhpcy4kd2lkdGggPSB3aWR0aDtcclxuICAgIHJldHVybiB3aWR0aDtcclxuICB9XHJcblxyXG4gIF9zZXROZXdQb3NpdGlvbnMoXHJcbiAgICB4OiBudW1iZXIsXHJcbiAgICB5OiBudW1iZXIsXHJcbiAgICBub2RlU3BhY2luZzogbnVtYmVyLFxyXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IG51bWJlciA9IDBcclxuICApOiB2b2lkIHtcclxuICAgIHRoaXMuc2V0Q2VudGVyKHgsIHksIGFuaW1hdGlvbkR1cmF0aW9uKTtcclxuICAgIGNvbnN0IHlTcGFjaW5nID0gbm9kZVNwYWNpbmc7XHJcbiAgICBjb25zdCBuZXh0WSA9IHkgKyB0aGlzLmdldFNpemUoKSArIHlTcGFjaW5nO1xyXG4gICAgY29uc3QgbGVmdCA9IHRoaXMuZ2V0TGVmdCgpO1xyXG4gICAgaWYgKGxlZnQpXHJcbiAgICAgIGxlZnQuX3NldE5ld1Bvc2l0aW9ucyhcclxuICAgICAgICB4IC0gdGhpcy4kbGVmdFdpZHRoICsgbGVmdC4kbGVmdFdpZHRoLFxyXG4gICAgICAgIG5leHRZLFxyXG4gICAgICAgIG5vZGVTcGFjaW5nLFxyXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uXHJcbiAgICAgICk7XHJcbiAgICBjb25zdCByaWdodCA9IHRoaXMuZ2V0UmlnaHQoKTtcclxuICAgIGlmIChyaWdodClcclxuICAgICAgcmlnaHQuX3NldE5ld1Bvc2l0aW9ucyhcclxuICAgICAgICB4ICsgdGhpcy4kcmlnaHRXaWR0aCAtIHJpZ2h0LiRyaWdodFdpZHRoLFxyXG4gICAgICAgIG5leHRZLFxyXG4gICAgICAgIG5vZGVTcGFjaW5nLFxyXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uXHJcbiAgICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPOiBOZXZlciB1c2VkPyB0aGlzLmdldEVkZ2VzIGRvZXMgbm90IGV4aXN0LlxyXG4gIHZhbGlkYXRlKCk6IHZvaWQge1xyXG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy4kaW5jb21pbmcucGFyZW50Py5nZXRTdGFydCgpO1xyXG4gICAgaWYgKHBhcmVudCkge1xyXG4gICAgICBwYXJlbnQuJGluY29taW5nO1xyXG4gICAgICBjb25zdCBjID0gdGhpcy5pc0xlZnRDaGlsZCgpID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCI7XHJcbiAgICAgIGlmIChwYXJlbnQuJG91dGdvaW5nW2NdPy5nZXRFbmQoKSAhPT0gdGhpcylcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiUGFyZW50IG1pc21hdGNoXCIpO1xyXG4gICAgICBsZXQgbiA9IDA7XHJcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVW5rbm93biBpZiBpdCBoYXMgZXZlciB3b3JrZWRcclxuICAgICAgZm9yIChjb25zdCBlZGdlIG9mIHRoaXMuZ2V0RWRnZXMoKSkge1xyXG4gICAgICAgIGlmIChlZGdlLmdldFN0YXJ0KCkgPT09IHBhcmVudCkge1xyXG4gICAgICAgICAgbisrO1xyXG4gICAgICAgICAgaWYgKGVkZ2UuZ2V0RW5kKCkgIT09IHRoaXMpIGNvbnNvbGUuZXJyb3IoXCJQYXJlbnQgZWRnZSBtaXNtYXRjaFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG4gIT09IDEpIGNvbnNvbGUuZXJyb3IoYFdyb25nIG46byBwYXJlbnQgZWRnZXMsICR7bn1gKTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgYyBvZiBbXCJsZWZ0XCIsIFwicmlnaHRcIl0pIHtcclxuICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLiRvdXRnb2luZ1tjIGFzIENoaWxkcmVuXT8uZ2V0RW5kKCk7XHJcbiAgICAgIGlmIChjaGlsZD8uJGluY29taW5nLnBhcmVudD8uZ2V0U3RhcnQoKSAhPT0gdGhpcylcclxuICAgICAgICBjb25zb2xlLmVycm9yKGAke2N9IGNoaWxkIG1pc21hdGNoYCk7XHJcbiAgICAgIGxldCBuID0gMDtcclxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBVbmtub3duIGlmIGl0IGhhcyBldmVyIHdvcmtlZFxyXG4gICAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgdGhpcy5nZXRFZGdlcygpKSB7XHJcbiAgICAgICAgaWYgKGVkZ2UuZ2V0RW5kKCkgPT09IGNoaWxkKSB7XHJcbiAgICAgICAgICBuKys7XHJcbiAgICAgICAgICBpZiAoZWRnZS5nZXRTdGFydCgpICE9PSB0aGlzKVxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGAke2N9IGNoaWxkIGVkZ2UgbWlzbWF0Y2hgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG4gIT09IDEpIGNvbnNvbGUuZXJyb3IoYFdyb25nIG46byAke2N9IGNoaWxkIGVkZ2VzLCAke259YCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IFRleHQgfSBmcm9tIFwiQHN2Z2RvdGpzL3N2Zy5qc1wiO1xyXG5pbXBvcnQgeyBCaW5hcnlOb2RlIH0gZnJvbSBcIi4vYmluYXJ5LW5vZGVcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBBVkxOb2RlIGV4dGVuZHMgQmluYXJ5Tm9kZSB7XHJcbiAgJGhlaWdodDogVGV4dCB8IG51bGwgPSBudWxsO1xyXG4gIGluaXQoXHJcbiAgICB0ZXh0OiBzdHJpbmcsXHJcbiAgICB4OiBudW1iZXIsXHJcbiAgICB5OiBudW1iZXIsXHJcbiAgICBzaXplOiBudW1iZXIsXHJcbiAgICBzdHJva2VXaWR0aDogbnVtYmVyXHJcbiAgKTogdGhpcyB7XHJcbiAgICBjb25zdCBkID0gc2l6ZTtcclxuICAgIHRoaXMuJGhlaWdodCA9IHRoaXMudGV4dChcIjFcIilcclxuICAgICAgLmNlbnRlcigtMC42ICogZCwgLTAuNSAqIGQpXHJcbiAgICAgIC5hZGRDbGFzcyhcImF2bGhlaWdodFwiKTtcclxuICAgIHJldHVybiBzdXBlci5pbml0KHRleHQsIHgsIHksIHNpemUsIHN0cm9rZVdpZHRoKTtcclxuICB9XHJcblxyXG4gIGdldEhlaWdodCgpOiBudW1iZXIge1xyXG4gICAgaWYgKHRoaXMuJGhlaWdodCkgcmV0dXJuIHBhcnNlSW50KHRoaXMuJGhlaWdodC50ZXh0KCkpO1xyXG4gICAgcmV0dXJuIDE7XHJcbiAgfVxyXG5cclxuICBzZXRIZWlnaHQoaGVpZ2h0OiBudW1iZXIpOiB0aGlzIHtcclxuICAgIHRoaXMuJGhlaWdodD8udGV4dChTdHJpbmcoaGVpZ2h0KSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHVwZGF0ZUhlaWdodFBvc2l0aW9uKCk6IHRoaXMge1xyXG4gICAgaWYgKCF0aGlzLiRoZWlnaHQpIHJldHVybiB0aGlzO1xyXG5cclxuICAgIGNvbnN0IGh4ID0gdGhpcy4kaGVpZ2h0LmN4KCk7XHJcbiAgICBjb25zdCBjeCA9IHRoaXMuY3goKTtcclxuXHJcbiAgICBpZiAodGhpcy5pc1JpZ2h0Q2hpbGQoKSAmJiBoeCAtIGN4IDwgMCkgdGhpcy4kaGVpZ2h0LmN4KDIgKiBjeCAtIGh4KTtcclxuICAgIGlmICh0aGlzLmlzTGVmdENoaWxkKCkgJiYgaHggLSBjeCA+IDApIHRoaXMuJGhlaWdodC5jeCgyICogY3ggLSBoeCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBnZXRIZWlnaHRIaWdobGlnaHQoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy4kaGVpZ2h0Py5nZXRIaWdobGlnaHQoKSB8fCBmYWxzZTtcclxuICB9XHJcblxyXG4gIHNldEhlaWdodEhpZ2hsaWdodChoaWdoOiBib29sZWFuIHwgbnVsbCk6IHRoaXMge1xyXG4gICAgdGhpcy4kaGVpZ2h0Py5zZXRIaWdobGlnaHQoaGlnaCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgRWxlbWVudCwgTWFya2VyLCBQYXRoIH0gZnJvbSBcIkBzdmdkb3Rqcy9zdmcuanNcIjtcclxuaW1wb3J0IHsgQlRyZWVOb2RlIH0gZnJvbSBcIi4vYnRyZWUtbm9kZVwiO1xyXG5pbXBvcnQgeyBUZXh0Q2lyY2xlIH0gZnJvbSBcIi4vdGV4dC1jaXJjbGVcIjtcclxuXHJcbnR5cGUgQ29ubmVjdGlvbkNvb3JkaW5hdGVzID0ge1xyXG4gIHgxOiBudW1iZXI7XHJcbiAgeTE6IG51bWJlcjtcclxuICB4MjogbnVtYmVyO1xyXG4gIHkyOiBudW1iZXI7XHJcbiAgcjI6IG51bWJlcjtcclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBDb25uZWN0aW9uPFQgZXh0ZW5kcyBUZXh0Q2lyY2xlIHwgQlRyZWVOb2RlPiBleHRlbmRzIFBhdGgge1xyXG4gICRjb29yZHM6IENvbm5lY3Rpb25Db29yZGluYXRlcyA9IHtcclxuICAgIHIyOiAwLFxyXG4gICAgeDE6IDAsXHJcbiAgICB4MjogMCxcclxuICAgIHkxOiAwLFxyXG4gICAgeTI6IDAsXHJcbiAgfTtcclxuICAkc3RhcnQ6IFQgfCBudWxsID0gbnVsbDtcclxuICAkZW5kOiBUIHwgbnVsbCA9IG51bGw7XHJcbiAgJGJlbmQ6IG51bWJlciA9IDA7XHJcblxyXG4gIGluaXQoXHJcbiAgICBzdGFydDogVCxcclxuICAgIGVuZDogVCxcclxuICAgIHN0cm9rZVdpZHRoOiBudW1iZXIsXHJcbiAgICBiZW5kOiBudW1iZXIgPSAwLFxyXG4gICAgZGlyZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZVxyXG4gICk6IHRoaXMge1xyXG4gICAgdGhpcy4kc3RhcnQgPSBzdGFydDtcclxuICAgIHRoaXMuJGVuZCA9IGVuZDtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcy4kY29vcmRzLCB7XHJcbiAgICAgIHgxOiBzdGFydC5jeCgpLFxyXG4gICAgICB5MTogc3RhcnQuY3koKSxcclxuICAgICAgeDI6IGVuZC5jeCgpLFxyXG4gICAgICB5MjogZW5kLmN5KCksXHJcbiAgICAgIHIyOiBlbmQuZ2V0U2l6ZSgpIC8gMixcclxuICAgIH0pO1xyXG4gICAgdGhpcy5zdHJva2UoeyB3aWR0aDogc3Ryb2tlV2lkdGggfSk7XHJcbiAgICB0aGlzLmJhY2soKTtcclxuICAgIHRoaXMuc2V0QmVuZChiZW5kKTtcclxuICAgIGlmIChkaXJlY3RlZCkgdGhpcy5fY3JlYXRlQXJyb3coKTtcclxuICAgIHRoaXMudXBkYXRlKHRoaXMuJGNvb3Jkcyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGdldEJlbmQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLiRiZW5kO1xyXG4gIH1cclxuXHJcbiAgc2V0QmVuZChiZW5kOiBudW1iZXIpOiB0aGlzIHtcclxuICAgIHRoaXMuJGJlbmQgPSBiZW5kO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBpc0RpcmVjdGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5yZWZlcmVuY2UoXCJtYXJrZXItZW5kXCIpKTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZShcclxuICAgIG5ld0Nvb3JkczogUGFydGlhbDxDb25uZWN0aW9uQ29vcmRpbmF0ZXM+LFxyXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IG51bWJlciA9IDBcclxuICApOiB0aGlzIHtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcy4kY29vcmRzLCBuZXdDb29yZHMpO1xyXG4gICAgKHRoaXMuZW5naW5lKCkuYW5pbWF0ZSh0aGlzLCBhbmltYXRpb25EdXJhdGlvbiA+IDApIGFzIHRoaXMpLnBsb3QoXHJcbiAgICAgIHRoaXMuX2dldFBhdGgoKVxyXG4gICAgKTtcclxuICAgIGlmICh0aGlzLmlzRGlyZWN0ZWQoKSkgdGhpcy5fcmVkcmF3QXJyb3coYW5pbWF0aW9uRHVyYXRpb24pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBfY3JlYXRlQXJyb3coKTogdm9pZCB7XHJcbiAgICB0aGlzLm1hcmtlcihcImVuZFwiLCA1LCA0LCBmdW5jdGlvbiAoYWRkKSB7XHJcbiAgICAgIGFkZC5wb2x5Z29uKFswLCAwLCA1LCAyLCAwLCA0XSkuYWRkQ2xhc3MoXCJmaWxsZWRcIik7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIF9yZWRyYXdBcnJvdyhhbmltYXRpb25EdXJhdGlvbjogbnVtYmVyID0gMCk6IHZvaWQge1xyXG4gICAgY29uc3QgbWFya2VyID0gdGhpcy5yZWZlcmVuY2UoXCJtYXJrZXItZW5kXCIpIGFzIE1hcmtlcjtcclxuICAgIGNvbnN0IHJhZGl1cyA9IHRoaXMuJGNvb3Jkcy5yMjtcclxuICAgIGNvbnN0IHN0cm9rZSA9IHRoaXMuYXR0cihcInN0cm9rZS13aWR0aFwiKTtcclxuICAgIHRoaXMuZW5naW5lKClcclxuICAgICAgLmFuaW1hdGUobWFya2VyLCBhbmltYXRpb25EdXJhdGlvbiA+IDApXHJcbiAgICAgIC5hdHRyKHsgcmVmWDogcmFkaXVzIC8gc3Ryb2tlICsgNSB9KTtcclxuICB9XHJcblxyXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gYCR7dGhpcy5nZXRTdGFydCgpfSAtLT4gJHt0aGlzLmdldEVuZCgpfWA7XHJcbiAgfVxyXG5cclxuICBnZXRTdGFydCgpOiBUIHwgbnVsbCB7XHJcbiAgICByZXR1cm4gdGhpcy4kc3RhcnQ7XHJcbiAgfVxyXG5cclxuICBnZXRFbmQoKTogVCB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuJGVuZDtcclxuICB9XHJcblxyXG4gIHNldFN0YXJ0KHN0YXJ0OiBULCBhbmltYXRpb25EdXJhdGlvbjogbnVtYmVyID0gMCk6IHRoaXMge1xyXG4gICAgaWYgKHN0YXJ0ID09PSB0aGlzLiRzdGFydCkgcmV0dXJuIHRoaXM7XHJcbiAgICB0aGlzLiRzdGFydCA9IHN0YXJ0O1xyXG4gICAgaWYgKHN0YXJ0KVxyXG4gICAgICB0aGlzLnVwZGF0ZSh7IHgxOiBzdGFydC5jeCgpLCB5MTogc3RhcnQuY3koKSB9LCBhbmltYXRpb25EdXJhdGlvbik7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHNldEVuZChlbmQ6IFQsIGFuaW1hdGlvbkR1cmF0aW9uOiBudW1iZXIgPSAwKTogdGhpcyB7XHJcbiAgICBpZiAoZW5kID09PSB0aGlzLiRlbmQpIHJldHVybiB0aGlzO1xyXG4gICAgdGhpcy4kZW5kID0gZW5kO1xyXG4gICAgaWYgKGVuZCkgdGhpcy51cGRhdGUoeyB4MjogZW5kLmN4KCksIHkyOiBlbmQuY3koKSB9LCBhbmltYXRpb25EdXJhdGlvbik7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHNldEhpZ2hsaWdodChoaWdoOiBib29sZWFuIHwgbnVsbCk6IHRoaXMge1xyXG4gICAgc3VwZXIuc2V0SGlnaGxpZ2h0KGhpZ2gpO1xyXG4gICAgY29uc3QgbWFya2VyID0gdGhpcy5yZWZlcmVuY2U8RWxlbWVudD4oXCJtYXJrZXItZW5kXCIpO1xyXG4gICAgaWYgKG1hcmtlcikgbWFya2VyLnNldEhpZ2hsaWdodChoaWdoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgX2dldFBhdGgoKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IEMgPSB0aGlzLiRjb29yZHM7XHJcbiAgICBjb25zdCB4Q29udHJvbCA9IChDLngxICsgQy54MikgLyAyICsgKEMueTEgLSBDLnkyKSAqIHRoaXMuZ2V0QmVuZCgpO1xyXG4gICAgY29uc3QgeUNvbnRyb2wgPSAoQy55MSArIEMueTIpIC8gMiArIChDLngyIC0gQy54MSkgKiB0aGlzLmdldEJlbmQoKTtcclxuICAgIHJldHVybiBgTSAke0MueDF9ICR7Qy55MX0gUSAke3hDb250cm9sfSAke3lDb250cm9sfSAke0MueDJ9ICR7Qy55Mn1gO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBCVHJlZU5vZGUgfSBmcm9tIFwiLi9idHJlZS1ub2RlXCI7XHJcbmltcG9ydCB7IENvbm5lY3Rpb24gfSBmcm9tIFwiLi9jb25uZWN0aW9uXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgQlRyZWVDb25uZWN0aW9uIGV4dGVuZHMgQ29ubmVjdGlvbjxCVHJlZU5vZGU+IHtcclxuICAkbWF4QmVuZCA9IDAuMTtcclxuICAkY29vcmRzOiB7XHJcbiAgICB4MTogbnVtYmVyO1xyXG4gICAgeDI6IG51bWJlcjtcclxuICAgIHkxOiBudW1iZXI7XHJcbiAgICB5MjogbnVtYmVyO1xyXG4gICAgcjI6IG51bWJlcjtcclxuICAgIG46IG51bWJlcjtcclxuICAgIGk6IG51bWJlcjtcclxuICB9ID0ge1xyXG4gICAgeDE6IDAsXHJcbiAgICB4MjogMCxcclxuICAgIHkxOiAwLFxyXG4gICAgeTI6IDAsXHJcbiAgICByMjogMCxcclxuICAgIG46IDAsXHJcbiAgICBpOiAwLFxyXG4gIH07XHJcblxyXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogU2VwYXJhdGUgQlRyZWVDb25uZWN0aW9uIGZyb20gQlNUQ29ubmVjdGlvbiBhbmQgaGF2ZSBib3RoIGV4dGVuZCBhIGJhc2UgY29ubmVjdGlvblxyXG4gIGluaXQoXHJcbiAgICBzdGFydDogQlRyZWVOb2RlLFxyXG4gICAgZW5kOiBCVHJlZU5vZGUsXHJcbiAgICBjaGlsZDogbnVtYmVyLFxyXG4gICAgbnVtQ2hpbGRyZW46IG51bWJlcixcclxuICAgIHN0cm9rZVdpZHRoOiBudW1iZXJcclxuICApOiB0aGlzIHtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcy4kY29vcmRzLCB7IGk6IGNoaWxkLCBuOiBudW1DaGlsZHJlbiB9KTtcclxuICAgIHJldHVybiBzdXBlci5pbml0KHN0YXJ0LCBlbmQsIHN0cm9rZVdpZHRoKTtcclxuICB9XHJcblxyXG4gIGdldEJlbmQoKTogbnVtYmVyIHtcclxuICAgIGlmICh0aGlzLiRjb29yZHMubiA8PSAxKSByZXR1cm4gMDtcclxuICAgIHJldHVybiB0aGlzLiRtYXhCZW5kICogKDEgLSAoMiAqIHRoaXMuJGNvb3Jkcy5pKSAvICh0aGlzLiRjb29yZHMubiAtIDEpKTtcclxuICB9XHJcblxyXG4gIF9nZXRQYXRoKCk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBDID0gdGhpcy4kY29vcmRzO1xyXG4gICAgbGV0IHgxID0gQy54MSArICgyICogQy5pIC0gQy5uICsgMSkgKiBDLnIyO1xyXG4gICAgY29uc3QgeTEgPSBDLnkxICsgQy5yMjtcclxuICAgIC8vIFRvIGNvbXBlbnNhdGUgZm9yIHRoZSByb3VuZGVkIGNvcm5lcnM6XHJcbiAgICBpZiAoQy5pID09PSAwKSB4MSArPSBDLnIyIC8gNDtcclxuICAgIGlmIChDLmkgPT09IEMubiAtIDEpIHgxIC09IEMucjIgLyA0O1xyXG4gICAgY29uc3QgeENvbnRyb2wgPSAoeDEgKyBDLngyKSAvIDIgKyAoeTEgLSBDLnkyKSAqIHRoaXMuZ2V0QmVuZCgpO1xyXG4gICAgY29uc3QgeUNvbnRyb2wgPSAoeTEgKyBDLnkyKSAvIDIgKyAoQy54MiAtIHgxKSAqIHRoaXMuZ2V0QmVuZCgpO1xyXG4gICAgcmV0dXJuIGBNICR7eDF9ICR7eTF9IFEgJHt4Q29udHJvbH0gJHt5Q29udHJvbH0gJHtDLngyfSAke0MueTJ9YDtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgRywgTGluZSwgUmVjdCwgVGV4dCB9IGZyb20gXCJAc3ZnZG90anMvc3ZnLmpzXCI7XHJcbmltcG9ydCB7IE5CU1AgfSBmcm9tIFwiLi4vLi4vc3JjL2VuZ2luZVwiO1xyXG5pbXBvcnQgeyBCVHJlZUNvbm5lY3Rpb24gfSBmcm9tIFwiLi9idHJlZS1jb25uZWN0aW9uXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgQlRyZWVOb2RlIGV4dGVuZHMgRyB7XHJcbiAgJHBhcmVudDogQlRyZWVDb25uZWN0aW9uIHwgbnVsbCA9IG51bGw7XHJcbiAgJGNoaWxkcmVuOiAoQlRyZWVDb25uZWN0aW9uIHwgbnVsbClbXSB8IG51bGwgPSBudWxsO1xyXG5cclxuICAkcmVjdDogUmVjdCB8IG51bGwgPSBudWxsO1xyXG4gICR2YWx1ZXM6IFRleHRbXSA9IFtdO1xyXG4gICRsaW5lczogTGluZVtdID0gW107XHJcbiAgJHJpZ2h0V2lkdGg6IG51bWJlciA9IDA7XHJcbiAgJGxlZnRXaWR0aDogbnVtYmVyID0gMDtcclxuICAkY2hpbGRXaWR0aHM6IG51bWJlciA9IDA7XHJcbiAgJHdpZHRoOiBudW1iZXIgPSAwO1xyXG5cclxuICBpbml0KFxyXG4gICAgbGVhZjogYm9vbGVhbixcclxuICAgIG52YWx1ZXM6IG51bWJlcixcclxuICAgIHg6IG51bWJlcixcclxuICAgIHk6IG51bWJlcixcclxuICAgIG9iamVjdFNpemU6IG51bWJlcixcclxuICAgIHN0cm9rZVdpZHRoOiBudW1iZXJcclxuICApOiB0aGlzIHtcclxuICAgIGlmIChudmFsdWVzIDwgMSkgdGhyb3cgbmV3IEVycm9yKFwiQlRyZWVOb2RlOiBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIHZhbHVlXCIpO1xyXG4gICAgdGhpcy4kY2hpbGRyZW4gPSBsZWFmID8gbnVsbCA6IEFycmF5KG52YWx1ZXMgKyAxKTtcclxuICAgIHRoaXMuc2V0TnVtVmFsdWVzKG52YWx1ZXMsIG9iamVjdFNpemUsIHN0cm9rZVdpZHRoKTtcclxuICAgIGlmICh4ICYmIHkpIHRoaXMuY2VudGVyKHgsIHkpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGBbJHt0aGlzLmdldFRleHRzKCkuam9pbihcIiB8IFwiKX1dYDtcclxuICB9XHJcblxyXG4gIG51bVZhbHVlcygpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuJHZhbHVlcy5sZW5ndGg7XHJcbiAgfVxyXG5cclxuICBudW1DaGlsZHJlbigpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuJGNoaWxkcmVuPy5sZW5ndGggfHwgMDtcclxuICB9XHJcblxyXG4gIGlzTGVhZigpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLiRjaGlsZHJlbiA9PT0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIFRPRE86IFVuZGVyc3RhbmQgdGhpcyBmdW5jdGlvbiBQUyBub3QgaW4gdXNlXHJcbiAgc2V0TGVhZihsZWFmOiBib29sZWFuLCBzdHJva2VXaWR0aDogbnVtYmVyKTogdGhpcyB7XHJcbiAgICBpZiAobGVhZiAmJiB0aGlzLiRjaGlsZHJlbikge1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5zZXRDaGlsZChpLCBudWxsLCBzdHJva2VXaWR0aCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy4kY2hpbGRyZW4gPSBudWxsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy4kY2hpbGRyZW4gPSBBcnJheSh0aGlzLm51bVZhbHVlcygpICsgMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGluc2VydFZhbHVlKFxyXG4gICAgaTogbnVtYmVyLFxyXG4gICAgdGV4dDogc3RyaW5nLFxyXG4gICAgb2JqZWN0U2l6ZTogbnVtYmVyLFxyXG4gICAgc3Ryb2tlV2lkdGg6IG51bWJlcixcclxuICAgIGxlZnRDaGlsZEluc2VydCA9IGZhbHNlXHJcbiAgKTogdGhpcyB7XHJcbiAgICBpZiAoaSA8IHRoaXMubnVtVmFsdWVzKCkpIHtcclxuICAgICAgY29uc3QgZHggPSAoaSAvIE1hdGgubWF4KDEsIHRoaXMubnVtVmFsdWVzKCkpIC0gMSkgKiBvYmplY3RTaXplO1xyXG4gICAgICB0aGlzLmRtb3ZlQ2VudGVyKGR4LCAwKTtcclxuICAgIH1cclxuICAgIHRoaXMuJHZhbHVlcy5zcGxpY2UoaSwgMCk7XHJcbiAgICB0aGlzLiRsaW5lcy5zcGxpY2UoaSwgMCk7XHJcbiAgICBpZiAoIXRoaXMuaXNMZWFmKCkpIHtcclxuICAgICAgY29uc3QgaiA9IGxlZnRDaGlsZEluc2VydCA/IGkgOiBpICsgMTtcclxuICAgICAgdGhpcy4kY2hpbGRyZW4/LnNwbGljZShqLCAwKTtcclxuICAgIH1cclxuICAgIHRoaXMuc2V0TnVtVmFsdWVzKHRoaXMubnVtVmFsdWVzKCksIG9iamVjdFNpemUsIHN0cm9rZVdpZHRoKTtcclxuICAgIHRoaXMuc2V0VGV4dChpLCB0ZXh0KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGRlbGV0ZVZhbHVlKFxyXG4gICAgaTogbnVtYmVyLFxyXG4gICAgb2JqZWN0U2l6ZTogbnVtYmVyLFxyXG4gICAgc3Ryb2tlV2lkdGg6IG51bWJlcixcclxuICAgIGxlZnRDaGlsZERlbGV0ZSA9IHRydWVcclxuICApOiB0aGlzIHtcclxuICAgIHRoaXMuJHZhbHVlc1tpXS5yZW1vdmUoKTtcclxuICAgIHRoaXMuJHZhbHVlcy5zcGxpY2UoaSwgMSk7XHJcbiAgICBjb25zdCBsID0gTWF0aC5tYXgoaSwgMSk7XHJcbiAgICB0aGlzLiRsaW5lc1tsXS5yZW1vdmUoKTtcclxuICAgIHRoaXMuJGxpbmVzLnNwbGljZShsLCAxKTtcclxuICAgIGlmICghdGhpcy5pc0xlYWYoKSkge1xyXG4gICAgICBjb25zdCBqID0gbGVmdENoaWxkRGVsZXRlID8gaSA6IGkgKyAxO1xyXG4gICAgICB0aGlzLnNldENoaWxkKGosIG51bGwsIHN0cm9rZVdpZHRoKTtcclxuICAgICAgdGhpcy4kY2hpbGRyZW4/LnNwbGljZShqLCAxKTtcclxuICAgIH1cclxuICAgIHRoaXMuc2V0TnVtVmFsdWVzKHRoaXMubnVtVmFsdWVzKCksIG9iamVjdFNpemUsIHN0cm9rZVdpZHRoKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHNldE51bVZhbHVlcyhudmFsdWVzOiBudW1iZXIsIG9iamVjdFNpemU6IG51bWJlciwgc3Ryb2tlV2lkdGg6IG51bWJlcik6IHRoaXMge1xyXG4gICAgd2hpbGUgKG52YWx1ZXMgPCB0aGlzLm51bVZhbHVlcygpKSB7XHJcbiAgICAgIGlmICghdGhpcy5pc0xlYWYoKSkge1xyXG4gICAgICAgIHRoaXMuc2V0Q2hpbGQodGhpcy4kY2hpbGRyZW4/Lmxlbmd0aCB8fCAwIC0gMSwgbnVsbCwgc3Ryb2tlV2lkdGgpO1xyXG4gICAgICAgIHRoaXMuJGNoaWxkcmVuPy5wb3AoKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLiR2YWx1ZXMucG9wKCk/LnJlbW92ZSgpO1xyXG4gICAgICB0aGlzLiRsaW5lcy5wb3AoKT8ucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdzAgPSBvYmplY3RTaXplLFxyXG4gICAgICBoID0gb2JqZWN0U2l6ZSxcclxuICAgICAgc3Ryb2tlID0gc3Ryb2tlV2lkdGg7XHJcbiAgICBpZiAoIXRoaXMuJHJlY3QpXHJcbiAgICAgIHRoaXMuJHJlY3QgPSB0aGlzLnJlY3QodzAgKiBudmFsdWVzLCBoKVxyXG4gICAgICAgIC5zdHJva2UoeyB3aWR0aDogc3Ryb2tlIH0pXHJcbiAgICAgICAgLmNlbnRlcigwLCAwKTtcclxuICAgIHRoaXMuJHJlY3Qud2lkdGgodzAgKiBNYXRoLm1heCgwLjUsIG52YWx1ZXMpKS5yYWRpdXMoaCAvIDQpO1xyXG4gICAgY29uc3QgY3ggPSB0aGlzLiRyZWN0LmN4KCksXHJcbiAgICAgIGN5ID0gdGhpcy4kcmVjdC5jeSgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudmFsdWVzOyBpKyspIHtcclxuICAgICAgaWYgKCF0aGlzLiR2YWx1ZXNbaV0pIHRoaXMuJHZhbHVlc1tpXSA9IHRoaXMudGV4dChOQlNQKTtcclxuICAgICAgdGhpcy4kdmFsdWVzW2ldLmNlbnRlcihjeCArIHcwICogKGkgLSBudmFsdWVzIC8gMiArIDAuNSksIGN5KTtcclxuICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgY29uc3QgZHggPSB3MCAqIChpIC0gbnZhbHVlcyAvIDIpLFxyXG4gICAgICAgICAgZHkgPSBoIC8gMjtcclxuICAgICAgICBpZiAoIXRoaXMuJGxpbmVzW2ldKVxyXG4gICAgICAgICAgdGhpcy4kbGluZXNbaV0gPSB0aGlzLmxpbmUoMCwgY3kgLSBkeSwgMCwgY3kgKyBkeSkuc3Ryb2tlKHtcclxuICAgICAgICAgICAgd2lkdGg6IHN0cm9rZSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuJGxpbmVzW2ldLmN4KGN4ICsgZHgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIXRoaXMuaXNMZWFmKCkgJiYgdGhpcy4kY2hpbGRyZW4pIHtcclxuICAgICAgY29uc3QgbiA9ICh0aGlzLiRjaGlsZHJlbi5sZW5ndGggPSBudmFsdWVzICsgMSk7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBpIGFuZCBuIG5vdCBvbiBiYXNlIG9iamVjdCBhbmQgY2FuIHRoZXJlZm9yIG5vdCBiZSBwYXNzZWQgaW5cclxuICAgICAgICB0aGlzLiRjaGlsZHJlbltpXT8udXBkYXRlKHsgaTogaSwgbjogbiB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q1goaTogbnVtYmVyLCBvYmplY3RTaXplOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuY3goKSArIG9iamVjdFNpemUgKiAoaSAtIHRoaXMubnVtVmFsdWVzKCkgLyAyICsgMC41KTtcclxuICB9XHJcblxyXG4gIGdldFdpZHRoKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuJHJlY3Q/LndpZHRoKCkpIHx8IDA7XHJcbiAgfVxyXG5cclxuICBnZXRIZWlnaHQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBOdW1iZXIodGhpcy4kcmVjdD8uaGVpZ2h0KCkpIHx8IDA7XHJcbiAgfVxyXG5cclxuICBnZXRTaXplKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRIZWlnaHQoKTtcclxuICB9XHJcblxyXG4gIGdldFRleHRzKCk6IHN0cmluZ1tdIHtcclxuICAgIHJldHVybiB0aGlzLiR2YWx1ZXMubWFwKCh0KSA9PiB0LnRleHQoKSk7XHJcbiAgfVxyXG5cclxuICBzZXRUZXh0cyh0ZXh0czogc3RyaW5nW10pOiB0aGlzIHtcclxuICAgIGlmICh0ZXh0cy5sZW5ndGggIT09IHRoaXMubnVtVmFsdWVzKCkpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgV3JvbmcgbnVtYmVyIG9mIHRleHRzOiAke3RleHRzLmxlbmd0aH0gIT0gJHt0aGlzLm51bVZhbHVlcygpfWBcclxuICAgICAgKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdGhpcy5zZXRUZXh0KGksIHRleHRzW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGdldFRleHQoYzogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgIHJldHVybiB0aGlzLiR2YWx1ZXNbY10udGV4dCgpO1xyXG4gIH1cclxuXHJcbiAgc2V0VGV4dChpOiBudW1iZXIsIHRleHQ6IHN0cmluZyk6IHRoaXMge1xyXG4gICAgaWYgKHRleHQgPT0gbnVsbCkgdGV4dCA9IFwiXCI7XHJcbiAgICB0ZXh0ID0gYCR7dGV4dH1gO1xyXG4gICAgLy8gTm9uLWJyZWFraW5nIHNwYWNlOiBXZSBuZWVkIHRvIGhhdmUgc29tZSB0ZXh0LCBvdGhlcndpc2UgdGhlIGNvb3JkaW5hdGVzIGFyZSByZXNldCB0byAoMCwgMClcclxuICAgIGlmICh0ZXh0ID09PSBcIlwiKSB0ZXh0ID0gTkJTUDtcclxuICAgIHRoaXMuJHZhbHVlc1tpXS50ZXh0KHRleHQpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBnZXRQYXJlbnQoKTogQlRyZWVOb2RlIHwgbnVsbCB7XHJcbiAgICByZXR1cm4gdGhpcy4kcGFyZW50Py5nZXRTdGFydCgpIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICBnZXRDaGlsZHJlbigpOiBCVHJlZU5vZGVbXSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICB0aGlzLiRjaGlsZHJlblxyXG4gICAgICAgID8ubWFwKChlKSA9PiBlPy5nZXRFbmQoKSlcclxuICAgICAgICAuZmlsdGVyKChlKSA9PiBlICE9PSBudWxsICYmIGUgIT09IHVuZGVmaW5lZCkgfHwgW11cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBnZXRDaGlsZChpOiBudW1iZXIpOiBCVHJlZU5vZGUgfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLiRjaGlsZHJlbj8uW2ldPy5nZXRFbmQoKSB8fCBudWxsO1xyXG4gIH1cclxuXHJcbiAgZ2V0TGVmdCgpOiBCVHJlZU5vZGUgfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLmdldENoaWxkKDApO1xyXG4gIH1cclxuXHJcbiAgZ2V0UmlnaHQoKTogQlRyZWVOb2RlIHwgbnVsbCB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRDaGlsZCh0aGlzLm51bUNoaWxkcmVuKCkgLSAxKTtcclxuICB9XHJcblxyXG4gIGlzQ2hpbGQoYzogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcyA9PT0gdGhpcy5nZXRQYXJlbnQoKT8uZ2V0Q2hpbGQoYyk7XHJcbiAgfVxyXG5cclxuICBnZXRQYXJlbnRJbmRleCgpOiBudW1iZXIgfCBudWxsIHtcclxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XHJcbiAgICBpZiAoIXBhcmVudCkgcmV0dXJuIG51bGw7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudC5udW1DaGlsZHJlbigpOyBpKyspIHtcclxuICAgICAgaWYgKHRoaXMgPT09IHBhcmVudC5nZXRDaGlsZChpKSkgcmV0dXJuIGk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGdldFBhcmVudEVkZ2UoKTogQlRyZWVDb25uZWN0aW9uIHwgbnVsbCB7XHJcbiAgICByZXR1cm4gdGhpcy4kcGFyZW50O1xyXG4gIH1cclxuXHJcbiAgZ2V0Q2hpbGRFZGdlKGk6IG51bWJlcik6IEJUcmVlQ29ubmVjdGlvbiB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuJGNoaWxkcmVuPy5baV0gfHwgbnVsbDtcclxuICB9XHJcblxyXG4gIHNldENoaWxkKGk6IG51bWJlciwgY2hpbGQ6IEJUcmVlTm9kZSB8IG51bGwsIHN0cm9rZVdpZHRoOiBudW1iZXIpOiB0aGlzIHtcclxuICAgIGlmICh0aGlzLiRjaGlsZHJlbj8uW2ldKSB7XHJcbiAgICAgIGNvbnN0IG9sZENoaWxkID0gdGhpcy4kY2hpbGRyZW5baV0uZ2V0RW5kKCkhO1xyXG4gICAgICBvbGRDaGlsZC4kcGFyZW50ID0gbnVsbDtcclxuICAgICAgdGhpcy4kY2hpbGRyZW5baV0ucmVtb3ZlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWNoaWxkKSB7XHJcbiAgICAgIGlmICh0aGlzLiRjaGlsZHJlbj8uW2ldKSB0aGlzLiRjaGlsZHJlbltpXSA9IG51bGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoY2hpbGQuJHBhcmVudCkge1xyXG4gICAgICAgIGNvbnN0IG9sZFBhcmVudCA9IGNoaWxkLiRwYXJlbnQuZ2V0U3RhcnQoKTtcclxuICAgICAgICBvbGRQYXJlbnQ/LiRjaGlsZHJlbj8uZm9yRWFjaCgob2xkUGFyZW50Q2hpbGQpID0+IHtcclxuICAgICAgICAgIGlmIChjaGlsZC4kcGFyZW50ID09PSBvbGRQYXJlbnRDaGlsZCkge1xyXG4gICAgICAgICAgICBvbGRQYXJlbnRDaGlsZCA9IG51bGw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2hpbGQuJHBhcmVudC5yZW1vdmUoKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBlZGdlID0gdGhpcy5yb290KCkuYlRyZWVDb25uZWN0aW9uKFxyXG4gICAgICAgIHRoaXMsXHJcbiAgICAgICAgY2hpbGQsXHJcbiAgICAgICAgaSxcclxuICAgICAgICB0aGlzLm51bUNoaWxkcmVuKCksXHJcbiAgICAgICAgc3Ryb2tlV2lkdGhcclxuICAgICAgKTtcclxuICAgICAgaWYgKHRoaXMuJGNoaWxkcmVuPy5baV0pIHRoaXMuJGNoaWxkcmVuW2ldID0gZWRnZTtcclxuICAgICAgY2hpbGQuJHBhcmVudCA9IGVkZ2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHNldFBhcmVudChjOiBudW1iZXIsIHBhcmVudDogQlRyZWVOb2RlLCBzdHJva2VXaWR0aDogbnVtYmVyKTogdGhpcyB7XHJcbiAgICBwYXJlbnQuc2V0Q2hpbGQoYywgdGhpcywgc3Ryb2tlV2lkdGgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBzZXRQYXJlbnRIaWdobGlnaHQoaGlnaDogYm9vbGVhbiB8IG51bGwpOiB0aGlzIHtcclxuICAgIHRoaXMuc2V0SGlnaGxpZ2h0KGhpZ2gpO1xyXG4gICAgdGhpcy5nZXRQYXJlbnQoKT8uc2V0SGlnaGxpZ2h0KGhpZ2gpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBzZXRDaGlsZEhpZ2hsaWdodChpOiBudW1iZXIsIGhpZ2g6IGJvb2xlYW4gfCBudWxsKTogdGhpcyB7XHJcbiAgICB0aGlzLnNldEhpZ2hsaWdodChoaWdoKTtcclxuICAgIHRoaXMuZ2V0Q2hpbGQoaSk/LnNldEhpZ2hsaWdodChoaWdoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgcmVtb3ZlKCk6IHRoaXMge1xyXG4gICAgaWYgKCF0aGlzLmlzTGVhZigpKSB7XHJcbiAgICAgIHRoaXMuJGNoaWxkcmVuPy5mb3JFYWNoKChjaGlsZCkgPT4ge1xyXG4gICAgICAgIGlmICghY2hpbGQpIHJldHVybjtcclxuICAgICAgICBjaGlsZC5yZW1vdmUoKTtcclxuICAgICAgICBjaGlsZCA9IG51bGw7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLiRwYXJlbnQpIHtcclxuICAgICAgY29uc3QgaSA9IHRoaXMuZ2V0UGFyZW50SW5kZXgoKTtcclxuICAgICAgaWYgKGkgJiYgdGhpcy4kcGFyZW50LmdldFN0YXJ0KCk/LiRjaGlsZHJlbj8uW2ldKVxyXG4gICAgICAgIHRoaXMuJHBhcmVudC5nZXRTdGFydCgpIS4kY2hpbGRyZW4hW2ldID0gbnVsbDtcclxuICAgICAgdGhpcy4kcGFyZW50LnJlbW92ZSgpO1xyXG4gICAgICB0aGlzLiRwYXJlbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgc3VwZXIucmVtb3ZlKCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHNldENlbnRlcih4OiBudW1iZXIsIHk6IG51bWJlciwgYW5pbWF0aW9uRHVyYXRpb246IG51bWJlciA9IDApOiB0aGlzIHtcclxuICAgIHN1cGVyLnNldENlbnRlcih4LCB5LCBhbmltYXRpb25EdXJhdGlvbik7XHJcbiAgICB0aGlzLiRjaGlsZHJlbj8uZm9yRWFjaCgoY2hpbGQpID0+IHtcclxuICAgICAgY2hpbGQ/LnVwZGF0ZSh7IHgxOiB4LCB5MTogeSB9LCBhbmltYXRpb25EdXJhdGlvbik7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuJHBhcmVudD8udXBkYXRlKHsgeDI6IHgsIHkyOiB5IH0sIGFuaW1hdGlvbkR1cmF0aW9uKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgcmVzaXplKFxyXG4gICAgc3RhcnRYOiBudW1iZXIsXHJcbiAgICBzdGFydFk6IG51bWJlcixcclxuICAgIHN2Z01hcmdpbjogbnVtYmVyLFxyXG4gICAgbm9kZVNwYWNpbmc6IG51bWJlcixcclxuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiBudW1iZXIgPSAwXHJcbiAgKTogdGhpcyB7XHJcbiAgICB0aGlzLl9yZXNpemVXaWR0aHMobm9kZVNwYWNpbmcpO1xyXG4gICAgY29uc3Qgc3ZnV2lkdGggPSB0aGlzLnJvb3QoKS52aWV3Ym94KCkud2lkdGg7XHJcbiAgICBpZiAoc3RhcnRYICsgdGhpcy4kcmlnaHRXaWR0aCA+IHN2Z1dpZHRoIC0gc3ZnTWFyZ2luKVxyXG4gICAgICBzdGFydFggPSBzdmdXaWR0aCAtIHRoaXMuJHJpZ2h0V2lkdGggLSBzdmdNYXJnaW47XHJcbiAgICBpZiAoc3RhcnRYIC0gdGhpcy4kbGVmdFdpZHRoIDwgc3ZnTWFyZ2luKVxyXG4gICAgICBzdGFydFggPSB0aGlzLiRsZWZ0V2lkdGggKyBzdmdNYXJnaW47XHJcbiAgICB0aGlzLl9zZXROZXdQb3NpdGlvbnMoc3RhcnRYLCBzdGFydFksIGFuaW1hdGlvbkR1cmF0aW9uKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIFRPRE86IFVwZGF0ZSBuYW1lIHRvIHJlZmxlY3QgdGhhdCBudW1iZXIgaXMgcmV0dXJuZWRcclxuICBfcmVzaXplV2lkdGhzKG5vZGVTcGFjaW5nOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgbGV0IGxlZnQgPSAwLFxyXG4gICAgICByaWdodCA9IDA7XHJcbiAgICB0aGlzLiRjaGlsZFdpZHRocyA9IDA7XHJcbiAgICB0aGlzLiR3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcclxuICAgIGlmICghdGhpcy5pc0xlYWYoKSkge1xyXG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuZ2V0Q2hpbGRyZW4oKSkge1xyXG4gICAgICAgIHRoaXMuJGNoaWxkV2lkdGhzICs9IGNoaWxkPy5fcmVzaXplV2lkdGhzKG5vZGVTcGFjaW5nKSB8fCAwO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHhTcGFjaW5nID0gbm9kZVNwYWNpbmc7XHJcbiAgICAgIHRoaXMuJHdpZHRoID0gTWF0aC5tYXgoXHJcbiAgICAgICAgdGhpcy4kd2lkdGgsXHJcbiAgICAgICAgdGhpcy4kY2hpbGRXaWR0aHMgKyB0aGlzLm51bVZhbHVlcygpICogeFNwYWNpbmdcclxuICAgICAgKTtcclxuICAgICAgbGVmdCA9IHRoaXMuZ2V0TGVmdCgpPy4kbGVmdFdpZHRoIHx8IDA7XHJcbiAgICAgIHJpZ2h0ID0gdGhpcy5nZXRSaWdodCgpPy4kcmlnaHRXaWR0aCB8fCAwO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWlkID0gdGhpcy4kd2lkdGggLSBsZWZ0IC0gcmlnaHQ7XHJcbiAgICB0aGlzLiRsZWZ0V2lkdGggPSBtaWQgLyAyICsgbGVmdDtcclxuICAgIHRoaXMuJHJpZ2h0V2lkdGggPSBtaWQgLyAyICsgcmlnaHQ7XHJcbiAgICByZXR1cm4gdGhpcy4kd2lkdGg7XHJcbiAgfVxyXG5cclxuICBfc2V0TmV3UG9zaXRpb25zKFxyXG4gICAgeDogbnVtYmVyLFxyXG4gICAgeTogbnVtYmVyLFxyXG4gICAgbm9kZVNwYWNpbmc6IG51bWJlcixcclxuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiBudW1iZXIgPSAwXHJcbiAgKTogdm9pZCB7XHJcbiAgICB0aGlzLnNldENlbnRlcih4LCB5LCBhbmltYXRpb25EdXJhdGlvbik7XHJcbiAgICBpZiAodGhpcy5pc0xlYWYoKSkgcmV0dXJuO1xyXG4gICAgeCAtPSB0aGlzLiRsZWZ0V2lkdGg7XHJcbiAgICBjb25zdCB4U3BhY2luZyA9ICh0aGlzLiR3aWR0aCAtIHRoaXMuJGNoaWxkV2lkdGhzKSAvIHRoaXMubnVtVmFsdWVzKCk7XHJcbiAgICBjb25zdCB5U3BhY2luZyA9IG5vZGVTcGFjaW5nO1xyXG4gICAgY29uc3QgbmV4dFkgPSB5ICsgdGhpcy5nZXRIZWlnaHQoKSArIHlTcGFjaW5nO1xyXG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmdldENoaWxkcmVuKCkpIHtcclxuICAgICAgY2hpbGQ/Ll9zZXROZXdQb3NpdGlvbnMoeCArIGNoaWxkLiRsZWZ0V2lkdGgsIG5leHRZLCBhbmltYXRpb25EdXJhdGlvbik7XHJcbiAgICAgIHggKz0gKGNoaWxkPy4kd2lkdGggfHwgMCkgKyB4U3BhY2luZztcclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgQ2lyY2xlIH0gZnJvbSBcIkBzdmdkb3Rqcy9zdmcuanNcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBIaWdobGlnaHRDaXJjbGUgZXh0ZW5kcyBDaXJjbGUge1xyXG4gIGluaXQoeDogbnVtYmVyLCB5OiBudW1iZXIsIHJhZGl1czogbnVtYmVyLCBzdHJva2VXaWR0aDogbnVtYmVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yYWRpdXMocmFkaXVzKVxyXG4gICAgICAuc3Ryb2tlKHsgd2lkdGg6IHN0cm9rZVdpZHRoIH0pXHJcbiAgICAgIC5jZW50ZXIoeCwgeSlcclxuICAgICAgLmFkZENsYXNzKFwiaGlnaGxpZ2h0LWNpcmNsZVwiKTtcclxuICB9XHJcblxyXG4gIGdldFNpemUoKSB7XHJcbiAgICBjb25zdCByID0gdGhpcy5hdHRyKFwiclwiKTtcclxuICAgIGlmICh0eXBlb2YgciA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHIgKiAyO1xyXG4gICAgaWYgKHR5cGVvZiByID09PSBcInN0cmluZ1wiICYmICFpc05hTihOdW1iZXIocikpKSByZXR1cm4gTnVtYmVyKHIpICogMjtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgc2V0U2l6ZShkaWFtZXRlcjogbnVtYmVyLCBhbmltYXRpb25EdXJhdGlvbjogbnVtYmVyKSB7XHJcbiAgICB0aGlzLmVuZ2luZSgpXHJcbiAgICAgIC5hbmltYXRlKHRoaXMsIGFuaW1hdGlvbkR1cmF0aW9uID4gMClcclxuICAgICAgLmF0dHIoXCJyXCIsIFN0cmluZyhkaWFtZXRlciAvIDIpKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBDb250YWluZXIsIEVsZW1lbnQsIGV4dGVuZCwgU3ZnIH0gZnJvbSBcIkBzdmdkb3Rqcy9zdmcuanNcIjtcclxuaW1wb3J0IHsgRW5naW5lIH0gZnJvbSBcIi4uLy4uL3NyYy9lbmdpbmVcIjtcclxuaW1wb3J0IHsgQVZMTm9kZSB9IGZyb20gXCIuL2F2bC1ub2RlXCI7XHJcbmltcG9ydCB7IEJpbmFyeU5vZGUgfSBmcm9tIFwiLi9iaW5hcnktbm9kZVwiO1xyXG5pbXBvcnQgeyBCVHJlZUNvbm5lY3Rpb24gfSBmcm9tIFwiLi9idHJlZS1jb25uZWN0aW9uXCI7XHJcbmltcG9ydCB7IEJUcmVlTm9kZSB9IGZyb20gXCIuL2J0cmVlLW5vZGVcIjtcclxuaW1wb3J0IHsgQ29ubmVjdGlvbiB9IGZyb20gXCIuL2Nvbm5lY3Rpb25cIjtcclxuaW1wb3J0IHsgR3JhcGhOb2RlIH0gZnJvbSBcIi4vZ3JhcGgtbm9kZVwiO1xyXG5pbXBvcnQgeyBIaWdobGlnaHRDaXJjbGUgfSBmcm9tIFwiLi9oaWdobGlnaHQtY2lyY2xlXCI7XHJcbmltcG9ydCB7IFRleHRDaXJjbGUgfSBmcm9tIFwiLi90ZXh0LWNpcmNsZVwiO1xyXG5cclxuZGVjbGFyZSBtb2R1bGUgXCJAc3ZnZG90anMvc3ZnLmpzXCIge1xyXG4gIGludGVyZmFjZSBTdmcge1xyXG4gICAgJGVuZ2luZTogRW5naW5lO1xyXG4gIH1cclxuXHJcbiAgaW50ZXJmYWNlIEVsZW1lbnQge1xyXG4gICAgZ2V0SGlnaGxpZ2h0KCk6IGJvb2xlYW47XHJcbiAgICBzZXRIaWdobGlnaHQoaGlnaDogYm9vbGVhbiB8IG51bGwpOiB0aGlzO1xyXG4gICAgZ2V0Q2VudGVyKCk6IFtudW1iZXIsIG51bWJlcl07XHJcbiAgICBzZXRDZW50ZXIoeDogbnVtYmVyLCB5OiBudW1iZXIsIGFuaW1hdGlvbkR1cmF0aW9uPzogbnVtYmVyKTogdGhpcztcclxuICAgIGRtb3ZlQ2VudGVyKGR4OiBudW1iZXIsIGR5OiBudW1iZXIsIGFuaW1hdGlvbkR1cmF0aW9uPzogbnVtYmVyKTogdGhpcztcclxuICAgIGVuZ2luZSgpOiBFbmdpbmU7XHJcbiAgfVxyXG5cclxuICBpbnRlcmZhY2UgQ29udGFpbmVyIHtcclxuICAgIHB1dDxUIGV4dGVuZHMgRWxlbWVudD4oZWxlbWVudDogVCwgaT86IG51bWJlcik6IFQ7XHJcbiAgICBoaWdobGlnaHRDaXJjbGUoXHJcbiAgICAgIHg6IG51bWJlcixcclxuICAgICAgeTogbnVtYmVyLFxyXG4gICAgICByYWRpdXM6IG51bWJlcixcclxuICAgICAgc3Ryb2tlV2lkdGg6IG51bWJlclxyXG4gICAgKTogSGlnaGxpZ2h0Q2lyY2xlO1xyXG4gICAgdGV4dENpcmNsZShcclxuICAgICAgdGV4dDogc3RyaW5nLFxyXG4gICAgICB4OiBudW1iZXIsXHJcbiAgICAgIHk6IG51bWJlcixcclxuICAgICAgc2l6ZTogbnVtYmVyLFxyXG4gICAgICBzdHJva2VXaWR0aDogbnVtYmVyXHJcbiAgICApOiBUZXh0Q2lyY2xlO1xyXG4gICAgZ3JhcGhOb2RlKFxyXG4gICAgICB0ZXh0OiBzdHJpbmcsXHJcbiAgICAgIHg6IG51bWJlcixcclxuICAgICAgeTogbnVtYmVyLFxyXG4gICAgICBzaXplOiBudW1iZXIsXHJcbiAgICAgIHN0cm9rZVdpZHRoOiBudW1iZXJcclxuICAgICk6IEdyYXBoTm9kZTtcclxuICAgIGJpbmFyeU5vZGUoXHJcbiAgICAgIHRleHQ6IHN0cmluZyxcclxuICAgICAgeDogbnVtYmVyLFxyXG4gICAgICB5OiBudW1iZXIsXHJcbiAgICAgIHNpemU6IG51bWJlcixcclxuICAgICAgc3Ryb2tlV2lkdGg6IG51bWJlclxyXG4gICAgKTogQmluYXJ5Tm9kZTtcclxuICAgIGF2bE5vZGUoXHJcbiAgICAgIHRleHQ6IHN0cmluZyxcclxuICAgICAgeDogbnVtYmVyLFxyXG4gICAgICB5OiBudW1iZXIsXHJcbiAgICAgIHNpemU6IG51bWJlcixcclxuICAgICAgc3Ryb2tlV2lkdGg6IG51bWJlclxyXG4gICAgKTogQVZMTm9kZTtcclxuICAgIGNvbm5lY3Rpb248VCBleHRlbmRzIFRleHRDaXJjbGU+KFxyXG4gICAgICBzdGFydDogVCxcclxuICAgICAgZW5kOiBULFxyXG4gICAgICBzdHJva2VXaWR0aDogbnVtYmVyLFxyXG4gICAgICBiZW5kPzogbnVtYmVyLFxyXG4gICAgICBkaXJlY3RlZD86IGJvb2xlYW5cclxuICAgICk6IENvbm5lY3Rpb248VD47XHJcbiAgICBiVHJlZU5vZGUoXHJcbiAgICAgIGxlYWY6IGJvb2xlYW4sXHJcbiAgICAgIG52YWx1ZXM6IG51bWJlcixcclxuICAgICAgeDogbnVtYmVyLFxyXG4gICAgICB5OiBudW1iZXIsXHJcbiAgICAgIG9iamVjdFNpemU6IG51bWJlcixcclxuICAgICAgc3Ryb2tlV2lkdGg6IG51bWJlclxyXG4gICAgKTogQlRyZWVOb2RlO1xyXG4gICAgYlRyZWVDb25uZWN0aW9uKFxyXG4gICAgICBzdGFydDogQlRyZWVOb2RlLFxyXG4gICAgICBlbmQ6IEJUcmVlTm9kZSxcclxuICAgICAgY2hpbGQ6IG51bWJlcixcclxuICAgICAgbnVtQ2hpbGRyZW46IG51bWJlcixcclxuICAgICAgc3Ryb2tlV2lkdGg6IG51bWJlclxyXG4gICAgKTogQlRyZWVDb25uZWN0aW9uO1xyXG4gIH1cclxufVxyXG5cclxuZXh0ZW5kKEVsZW1lbnQsIHtcclxuICBnZXRIaWdobGlnaHQoKSB7XHJcbiAgICByZXR1cm4gKHRoaXMgYXMgRWxlbWVudCkuaGFzQ2xhc3MoXCJoaWdobGlnaHRcIik7XHJcbiAgfSxcclxuICBzZXRIaWdobGlnaHQoaGlnaDogYm9vbGVhbiB8IG51bGwpIHtcclxuICAgIGlmIChoaWdoID09IG51bGwpICh0aGlzIGFzIEVsZW1lbnQpLnRvZ2dsZUNsYXNzKFwiaGlnaGxpZ2h0XCIpO1xyXG4gICAgZWxzZSBpZiAoaGlnaCkgKHRoaXMgYXMgRWxlbWVudCkuYWRkQ2xhc3MoXCJoaWdobGlnaHRcIik7XHJcbiAgICBlbHNlICh0aGlzIGFzIEVsZW1lbnQpLnJlbW92ZUNsYXNzKFwiaGlnaGxpZ2h0XCIpO1xyXG4gICAgcmV0dXJuIHRoaXMgYXMgRWxlbWVudDtcclxuICB9LFxyXG4gIGdldENlbnRlcigpIHtcclxuICAgIHJldHVybiBbKHRoaXMgYXMgRWxlbWVudCkuY3goKSwgKHRoaXMgYXMgRWxlbWVudCkuY3koKV0gYXMgW251bWJlciwgbnVtYmVyXTtcclxuICB9LFxyXG4gIHNldENlbnRlcih4OiBudW1iZXIsIHk6IG51bWJlciwgYW5pbWF0aW9uRHVyYXRpb246IG51bWJlciA9IDApIHtcclxuICAgIHJldHVybiAodGhpcyBhcyBFbGVtZW50KVxyXG4gICAgICAuZW5naW5lKClcclxuICAgICAgLmFuaW1hdGUodGhpcyBhcyBFbGVtZW50LCBhbmltYXRpb25EdXJhdGlvbiA+IDApXHJcbiAgICAgIC5jZW50ZXIoeCwgeSk7XHJcbiAgfSxcclxuICBkbW92ZUNlbnRlcihkeDogbnVtYmVyLCBkeTogbnVtYmVyLCBhbmltYXRpb25EdXJhdGlvbjogbnVtYmVyID0gMCkge1xyXG4gICAgKHRoaXMgYXMgRWxlbWVudCkuc2V0Q2VudGVyKFxyXG4gICAgICAodGhpcyBhcyBFbGVtZW50KS5jeCgpICsgZHgsXHJcbiAgICAgICh0aGlzIGFzIEVsZW1lbnQpLmN5KCkgKyBkeSxcclxuICAgICAgYW5pbWF0aW9uRHVyYXRpb25cclxuICAgICk7XHJcbiAgICByZXR1cm4gdGhpcyBhcyBFbGVtZW50O1xyXG4gIH0sXHJcbiAgZW5naW5lKCkge1xyXG4gICAgcmV0dXJuICh0aGlzIGFzIEVsZW1lbnQpLnJvb3QoKS4kZW5naW5lO1xyXG4gIH0sXHJcbn0pO1xyXG5cclxuZXh0ZW5kKENvbnRhaW5lciwge1xyXG4gIGhpZ2hsaWdodENpcmNsZSh4OiBudW1iZXIsIHk6IG51bWJlciwgcmFkaXVzOiBudW1iZXIsIHN0cm9rZVdpZHRoOiBudW1iZXIpIHtcclxuICAgIHJldHVybiAodGhpcyBhcyBDb250YWluZXIpXHJcbiAgICAgIC5wdXQobmV3IEhpZ2hsaWdodENpcmNsZSgpKVxyXG4gICAgICAuaW5pdCh4LCB5LCByYWRpdXMsIHN0cm9rZVdpZHRoKTtcclxuICB9LFxyXG4gIHRleHRDaXJjbGUoXHJcbiAgICB0ZXh0OiBzdHJpbmcsXHJcbiAgICB4OiBudW1iZXIsXHJcbiAgICB5OiBudW1iZXIsXHJcbiAgICBzaXplOiBudW1iZXIsXHJcbiAgICBzdHJva2VXaWR0aDogbnVtYmVyXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gKHRoaXMgYXMgQ29udGFpbmVyKVxyXG4gICAgICAucHV0KG5ldyBUZXh0Q2lyY2xlKCkpXHJcbiAgICAgIC5pbml0KHRleHQsIHgsIHksIHNpemUsIHN0cm9rZVdpZHRoKTtcclxuICB9LFxyXG4gIGdyYXBoTm9kZShcclxuICAgIHRleHQ6IHN0cmluZyxcclxuICAgIHg6IG51bWJlcixcclxuICAgIHk6IG51bWJlcixcclxuICAgIHNpemU6IG51bWJlcixcclxuICAgIHN0cm9rZVdpZHRoOiBudW1iZXJcclxuICApIHtcclxuICAgIHJldHVybiAodGhpcyBhcyBDb250YWluZXIpXHJcbiAgICAgIC5wdXQobmV3IEdyYXBoTm9kZSgpKVxyXG4gICAgICAuaW5pdCh0ZXh0LCB4LCB5LCBzaXplLCBzdHJva2VXaWR0aCk7XHJcbiAgfSxcclxuICBiaW5hcnlOb2RlKFxyXG4gICAgdGV4dDogc3RyaW5nLFxyXG4gICAgeDogbnVtYmVyLFxyXG4gICAgeTogbnVtYmVyLFxyXG4gICAgc2l6ZTogbnVtYmVyLFxyXG4gICAgc3Ryb2tlV2lkdGg6IG51bWJlclxyXG4gICkge1xyXG4gICAgcmV0dXJuICh0aGlzIGFzIENvbnRhaW5lcilcclxuICAgICAgLnB1dChuZXcgQmluYXJ5Tm9kZSgpKVxyXG4gICAgICAuaW5pdCh0ZXh0LCB4LCB5LCBzaXplLCBzdHJva2VXaWR0aCk7XHJcbiAgfSxcclxuICBhdmxOb2RlKFxyXG4gICAgdGV4dDogc3RyaW5nLFxyXG4gICAgeDogbnVtYmVyLFxyXG4gICAgeTogbnVtYmVyLFxyXG4gICAgc2l6ZTogbnVtYmVyLFxyXG4gICAgc3Ryb2tlV2lkdGg6IG51bWJlclxyXG4gICkge1xyXG4gICAgcmV0dXJuICh0aGlzIGFzIENvbnRhaW5lcilcclxuICAgICAgLnB1dChuZXcgQVZMTm9kZSgpKVxyXG4gICAgICAuaW5pdCh0ZXh0LCB4LCB5LCBzaXplLCBzdHJva2VXaWR0aCk7XHJcbiAgfSxcclxuICBjb25uZWN0aW9uPFQgZXh0ZW5kcyBUZXh0Q2lyY2xlPihcclxuICAgIHN0YXJ0OiBULFxyXG4gICAgZW5kOiBULFxyXG4gICAgc3Ryb2tlV2lkdGg6IG51bWJlcixcclxuICAgIGJlbmQ/OiBudW1iZXIsXHJcbiAgICBkaXJlY3RlZD86IGJvb2xlYW5cclxuICApIHtcclxuICAgIHJldHVybiAodGhpcyBhcyBDb250YWluZXIpXHJcbiAgICAgIC5wdXQobmV3IENvbm5lY3Rpb248VD4oKSlcclxuICAgICAgLmluaXQoc3RhcnQsIGVuZCwgc3Ryb2tlV2lkdGgsIGJlbmQsIGRpcmVjdGVkKTtcclxuICB9LFxyXG4gIGJUcmVlTm9kZShcclxuICAgIGxlYWY6IGJvb2xlYW4sXHJcbiAgICBudmFsdWVzOiBudW1iZXIsXHJcbiAgICB4OiBudW1iZXIsXHJcbiAgICB5OiBudW1iZXIsXHJcbiAgICBvYmplY3RTaXplOiBudW1iZXIsXHJcbiAgICBzdHJva2VXaWR0aDogbnVtYmVyXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gKHRoaXMgYXMgQ29udGFpbmVyKVxyXG4gICAgICAucHV0KG5ldyBCVHJlZU5vZGUoKSlcclxuICAgICAgLmluaXQobGVhZiwgbnZhbHVlcywgeCwgeSwgb2JqZWN0U2l6ZSwgc3Ryb2tlV2lkdGgpO1xyXG4gIH0sXHJcbiAgYlRyZWVDb25uZWN0aW9uKFxyXG4gICAgc3RhcnQ6IEJUcmVlTm9kZSxcclxuICAgIGVuZDogQlRyZWVOb2RlLFxyXG4gICAgY2hpbGQ6IG51bWJlcixcclxuICAgIG51bUNoaWxkcmVuOiBudW1iZXIsXHJcbiAgICBzdHJva2VXaWR0aDogbnVtYmVyXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gKHRoaXMgYXMgQ29udGFpbmVyKVxyXG4gICAgICAucHV0KG5ldyBCVHJlZUNvbm5lY3Rpb24oKSlcclxuICAgICAgLmluaXQoc3RhcnQsIGVuZCwgY2hpbGQsIG51bUNoaWxkcmVuLCBzdHJva2VXaWR0aCk7XHJcbiAgfSxcclxufSk7XHJcblxyXG5leHBvcnQgeyBTdmcgfTtcclxuIiwiaW1wb3J0IHsgRWxlbWVudCwgVGV4dCB9IGZyb20gXCJAc3ZnZG90anMvc3ZnLmpzXCI7XHJcbmltcG9ydCB7IFN2ZyB9IGZyb20gXCIuL29iamVjdHNcIjtcclxuXHJcbmV4cG9ydCB0eXBlIEVuZ2luZVRvb2xiYXJJdGVtcyA9IHtcclxuICBhbmltYXRpb25TcGVlZDogSFRNTFNlbGVjdEVsZW1lbnQ7XHJcbiAgb2JqZWN0U2l6ZTogSFRNTFNlbGVjdEVsZW1lbnQ7XHJcblxyXG4gIGdlbmVyYWxDb250cm9sczogSFRNTEZpZWxkU2V0RWxlbWVudDtcclxuICBhbGdvcml0aG1Db250cm9sczogSFRNTEZpZWxkU2V0RWxlbWVudDtcclxuXHJcbiAgc3RlcEZvcndhcmQ6IEhUTUxCdXR0b25FbGVtZW50O1xyXG4gIHN0ZXBCYWNrd2FyZDogSFRNTEJ1dHRvbkVsZW1lbnQ7XHJcbiAgdG9nZ2xlUnVubmVyOiBIVE1MQnV0dG9uRWxlbWVudDtcclxuICBmYXN0Rm9yd2FyZDogSFRNTEJ1dHRvbkVsZW1lbnQ7XHJcbiAgZmFzdEJhY2t3YXJkOiBIVE1MQnV0dG9uRWxlbWVudDtcclxufTtcclxuXHJcbnR5cGUgTGlzdGVuZXJzID0gXCJjbGlja1wiIHwgXCJjaGFuZ2VcIjsgLy8gVE9ETzogQmV0dGVyIG5hbWluZy5cclxudHlwZSBSZXNvbHZlID0gKHZhbHVlOiB1bmtub3duKSA9PiB2b2lkO1xyXG50eXBlIFJlamVjdCA9IChwcm9wczogeyB1bnRpbD86IG51bWJlcjsgcnVubmluZz86IGJvb2xlYW4gfSkgPT4gdm9pZDtcclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gQ29uc3RhbnRzIGFuZCBnbG9iYWwgdmFyaWFibGVzXHJcblxyXG5leHBvcnQgY2xhc3MgRW5naW5lIHtcclxuICAvLyBEZWZhdWx0IHZhcmlhYmxlIG5hbWVzIHN0YXJ0IHdpdGggJFxyXG5cclxuICBTdmc6IFN2ZztcclxuXHJcbiAgbWVzc2FnZXM6XHJcbiAgICB8IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIHN0cmluZyB8ICgoYXJnMDogc3RyaW5nKSA9PiBzdHJpbmcpPj5cclxuICAgIHwgdW5kZWZpbmVkO1xyXG5cclxuICAkU3ZnID0ge1xyXG4gICAgd2lkdGg6IDEwMDAsXHJcbiAgICBoZWlnaHQ6IDYwMCxcclxuICAgIG1hcmdpbjogMzAsXHJcbiAgICBvYmplY3RTaXplOiA0MCxcclxuICAgIGFuaW1hdGlvblNwZWVkOiAxMDAwLCAvLyBtaWxsaXNlY29uZHMgcGVyIHN0ZXBcclxuICB9O1xyXG5cclxuICAkQ29va2llRXhwaXJlRGF5cyA9IDMwO1xyXG4gICRDb29raWVzID0ge1xyXG4gICAgLy9UT0RPOiBjb25mdXNpbmcgbmFtaW5nXHJcbiAgICBhbmltYXRpb25TcGVlZDoge1xyXG4gICAgICBnZXRDb29raWU6ICh2YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMudG9vbGJhci5hbmltYXRpb25TcGVlZClcclxuICAgICAgICAgIHRoaXMudG9vbGJhci5hbmltYXRpb25TcGVlZC52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXRDb29raWU6ICgpID0+IHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKSxcclxuICAgIH0sXHJcbiAgICBvYmplY3RTaXplOiB7XHJcbiAgICAgIGdldENvb2tpZTogKHZhbHVlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBpZiAodGhpcy50b29sYmFyLm9iamVjdFNpemUpIHRoaXMudG9vbGJhci5vYmplY3RTaXplLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldENvb2tpZTogKCkgPT4gdGhpcy5nZXRPYmplY3RTaXplKCksXHJcbiAgICB9LFxyXG4gIH07XHJcblxyXG4gIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XHJcbiAgdG9vbGJhcjogRW5naW5lVG9vbGJhckl0ZW1zO1xyXG4gIGFjdGlvbnM6IHsgb3Blcjogc3RyaW5nOyBhcmdzOiB1bmtub3duW107IG5zdGVwczogbnVtYmVyIH1bXSA9IFtdO1xyXG4gIEN1cnJlbnRBY3Rpb246IG51bWJlciA9IDA7IC8vIHdhcyA9IG51bGwgYmVmb3JlLCB0aGlzIHNob3VsZCB3b3JrIGJldHRlclxyXG4gIEN1cnJlbnRTdGVwOiBudW1iZXIgPSAwOyAvLyB3YXMgPSBudWxsIGJlZm9yZSwgdGhpcyBzaG91bGQgd29yayBiZXR0ZXJcclxuICBERUJVRyA9IHRydWU7XHJcblxyXG4gIFN0YXRlOiB7XHJcbiAgICByZXNldHRpbmc6IGJvb2xlYW47XHJcbiAgICBhbmltYXRpbmc6IGJvb2xlYW47XHJcbiAgfSA9IHtcclxuICAgIHJlc2V0dGluZzogZmFsc2UsXHJcbiAgICBhbmltYXRpbmc6IGZhbHNlLFxyXG4gIH07XHJcblxyXG4gIEluZm86IHtcclxuICAgIHRpdGxlOiBUZXh0IHwgdW5kZWZpbmVkO1xyXG4gICAgYm9keTogVGV4dCB8IHVuZGVmaW5lZDtcclxuICAgIHByaW50ZXI6IFRleHQgfCB1bmRlZmluZWQ7XHJcbiAgICBzdGF0dXM6IFRleHQgfCB1bmRlZmluZWQ7XHJcbiAgfSA9IHtcclxuICAgIHRpdGxlOiB1bmRlZmluZWQsXHJcbiAgICBib2R5OiB1bmRlZmluZWQsXHJcbiAgICBwcmludGVyOiB1bmRlZmluZWQsXHJcbiAgICBzdGF0dXM6IHVuZGVmaW5lZCxcclxuICB9O1xyXG5cclxuICBFdmVudExpc3RlbmVyczogUmVjb3JkPHN0cmluZywgUGFydGlhbDxSZWNvcmQ8TGlzdGVuZXJzLCAoKSA9PiB2b2lkPj4+ID0ge1xyXG4gICAgc3RlcEZvcndhcmQ6IHt9LFxyXG4gICAgc3RlcEJhY2t3YXJkOiB7fSxcclxuICAgIGZhc3RGb3J3YXJkOiB7fSxcclxuICAgIGZhc3RCYWNrd2FyZDoge30sXHJcbiAgICB0b2dnbGVSdW5uZXI6IHt9LFxyXG4gIH07XHJcblxyXG4gIGdldEFuaW1hdGlvblNwZWVkKCk6IG51bWJlciB7XHJcbiAgICBpZiAodGhpcy50b29sYmFyLmFuaW1hdGlvblNwZWVkKVxyXG4gICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy50b29sYmFyLmFuaW1hdGlvblNwZWVkPy52YWx1ZSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuJFN2Zy5hbmltYXRpb25TcGVlZDtcclxuICB9XHJcblxyXG4gIGdldE9iamVjdFNpemUoKTogbnVtYmVyIHtcclxuICAgIGlmICh0aGlzLnRvb2xiYXIub2JqZWN0U2l6ZSlcclxuICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMudG9vbGJhci5vYmplY3RTaXplPy52YWx1ZSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuJFN2Zy5vYmplY3RTaXplO1xyXG4gIH1cclxuXHJcbiAgZ2V0Tm9kZVNwYWNpbmcoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmdldE9iamVjdFNpemUoKTtcclxuICB9XHJcblxyXG4gIGdldFN0cm9rZVdpZHRoKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RTaXplKCkgLyAxMjtcclxuICB9XHJcblxyXG4gIGdldE5vZGVTdGFydCgpOiBbbnVtYmVyLCBudW1iZXJdIHtcclxuICAgIHJldHVybiBbdGhpcy4kU3ZnLm1hcmdpbiArIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpIC8gMiwgdGhpcy4kU3ZnLm1hcmdpbiAqIDRdO1xyXG4gIH1cclxuXHJcbiAgZ2V0VHJlZVJvb3QoKTogW251bWJlciwgbnVtYmVyXSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICB0aGlzLlN2Zy52aWV3Ym94KCkud2lkdGggLyAyLFxyXG4gICAgICAyICogdGhpcy4kU3ZnLm1hcmdpbiArIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpIC8gMixcclxuICAgIF07XHJcbiAgfVxyXG5cclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gSW5pdGl0YWxpc2F0aW9uXHJcblxyXG4gIC8vIFRPRE86IFJlbW92ZSBkZWZhdWx0cz9cclxuICAvLyBJbXBvc2libGUgdG8gdHlwZSBkZWZhdWx0IGFuZCBpdCBpcyBub3QgdXNlZCBmb3IgcGFzc2luZyBpbiBhbnl0aGluZyBhbnl3ZXJlXHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVyU2VsZWN0b3I6IHN0cmluZywgZGVmYXVsdHMgPSB7fSkge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdHMpIHtcclxuICAgICAgaWYgKCFrZXkuc3RhcnRzV2l0aChcIiRcIikpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBkZWZhdWx0IGtleTogJHtrZXl9YCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVEZWZhdWx0KHRoaXMsIGRlZmF1bHRzLCB0cnVlKTtcclxuXHJcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yPEhUTUxFbGVtZW50Pihjb250YWluZXJTZWxlY3Rvcik7XHJcbiAgICBpZiAoIWNvbnRhaW5lcikgdGhyb3cgbmV3IEVycm9yKFwiTm8gY29udGFpbmVyIGZvdW5kXCIpO1xyXG5cclxuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgdGhpcy50b29sYmFyID0gdGhpcy5nZXRUb29sYmFyKCk7XHJcblxyXG4gICAgY29uc3Qgc3ZnQ29udGFpbmVyID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcInN2Z1wiKTtcclxuICAgIGlmICghc3ZnQ29udGFpbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdmcgZWxlbWVudCBmb3VuZFwiKTtcclxuXHJcbiAgICB0aGlzLlN2ZyA9IG5ldyBTdmcoc3ZnQ29udGFpbmVyKTtcclxuICAgIHRoaXMuU3ZnLnZpZXdib3goMCwgMCwgdGhpcy4kU3ZnLndpZHRoLCB0aGlzLiRTdmcuaGVpZ2h0KTtcclxuICAgIHRoaXMuU3ZnLiRlbmdpbmUgPSB0aGlzO1xyXG5cclxuICAgIGNvbnN0IGRlYnVnUGFyYW0gPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5ocmVmKS5nZXQoXCJkZWJ1Z1wiKTtcclxuICAgIHRoaXMuREVCVUcgPSBCb29sZWFuKGRlYnVnUGFyYW0gfHwgZmFsc2UpO1xyXG4gICAgaWYgKHRoaXMuREVCVUcpIHRoaXMuU3ZnLmFkZENsYXNzKFwiZGVidWdcIik7XHJcbiAgfVxyXG5cclxuICBnZXRUb29sYmFyKCk6IEVuZ2luZVRvb2xiYXJJdGVtcyB7XHJcbiAgICBjb25zdCBnZW5lcmFsQ29udHJvbHMgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yPEhUTUxGaWVsZFNldEVsZW1lbnQ+KFxyXG4gICAgICBcImZpZWxkc2V0LmdlbmVyYWxDb250cm9sc1wiXHJcbiAgICApO1xyXG4gICAgY29uc3QgYWxnb3JpdGhtQ29udHJvbHMgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yPEhUTUxGaWVsZFNldEVsZW1lbnQ+KFxyXG4gICAgICBcImZpZWxkc2V0LmFsZ29yaXRobUNvbnRyb2xzXCJcclxuICAgICk7XHJcblxyXG4gICAgY29uc3Qgc3RlcEZvcndhcmQgPVxyXG4gICAgICB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yPEhUTUxCdXR0b25FbGVtZW50PihcImJ1dHRvbi5zdGVwRm9yd2FyZFwiKTtcclxuICAgIGNvbnN0IHN0ZXBCYWNrd2FyZCA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3I8SFRNTEJ1dHRvbkVsZW1lbnQ+KFxyXG4gICAgICBcImJ1dHRvbi5zdGVwQmFja3dhcmRcIlxyXG4gICAgKTtcclxuICAgIGNvbnN0IHRvZ2dsZVJ1bm5lciA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3I8SFRNTEJ1dHRvbkVsZW1lbnQ+KFxyXG4gICAgICBcImJ1dHRvbi50b2dnbGVSdW5uZXJcIlxyXG4gICAgKTtcclxuICAgIGNvbnN0IGZhc3RGb3J3YXJkID1cclxuICAgICAgdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcjxIVE1MQnV0dG9uRWxlbWVudD4oXCJidXR0b24uZmFzdEZvcndhcmRcIik7XHJcbiAgICBjb25zdCBmYXN0QmFja3dhcmQgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yPEhUTUxCdXR0b25FbGVtZW50PihcclxuICAgICAgXCJidXR0b24uZmFzdEJhY2t3YXJkXCJcclxuICAgICk7XHJcbiAgICBjb25zdCBvYmplY3RTaXplID1cclxuICAgICAgdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcjxIVE1MU2VsZWN0RWxlbWVudD4oXCJzZWxlY3Qub2JqZWN0U2l6ZVwiKTtcclxuICAgIGNvbnN0IGFuaW1hdGlvblNwZWVkID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcjxIVE1MU2VsZWN0RWxlbWVudD4oXHJcbiAgICAgIFwic2VsZWN0LmFuaW1hdGlvblNwZWVkXCJcclxuICAgICk7XHJcblxyXG4gICAgaWYgKCFnZW5lcmFsQ29udHJvbHMpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZ2VuZXJhbCBjb250cm9scyBmaWVsZHNldFwiKTtcclxuICAgIGlmICghYWxnb3JpdGhtQ29udHJvbHMpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYWxnb3JpdGhtIGNvbnRyb2xzIGZpZWxkc2V0XCIpO1xyXG5cclxuICAgIGlmICghc3RlcEZvcndhcmQpIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgc3RlcCBmb3J3YXJkIGJ1dHRvblwiKTtcclxuICAgIGlmICghc3RlcEJhY2t3YXJkKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHN0ZXAgYmFja3dhcmQgYnV0dG9uXCIpO1xyXG4gICAgaWYgKCF0b2dnbGVSdW5uZXIpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdG9nZ2xlIHJ1bm5lciBidXR0b25cIik7XHJcbiAgICBpZiAoIWZhc3RGb3J3YXJkKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGZhc3QgZm9yd2FyZCBidXR0b25cIik7XHJcbiAgICBpZiAoIWZhc3RCYWNrd2FyZCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBmYXN0IGJhY2t3YXJkIGJ1dHRvblwiKTtcclxuICAgIGlmICghb2JqZWN0U2l6ZSkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBvYmplY3Qgc2l6ZSBzZWxlY3RcIik7XHJcbiAgICBpZiAoIWFuaW1hdGlvblNwZWVkKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGFuaW1hdGlvbiBzcGVlZCBzZWxlY3RcIik7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZ2VuZXJhbENvbnRyb2xzLFxyXG4gICAgICBhbGdvcml0aG1Db250cm9scyxcclxuICAgICAgc3RlcEZvcndhcmQsXHJcbiAgICAgIHN0ZXBCYWNrd2FyZCxcclxuICAgICAgdG9nZ2xlUnVubmVyLFxyXG4gICAgICBmYXN0Rm9yd2FyZCxcclxuICAgICAgZmFzdEJhY2t3YXJkLFxyXG4gICAgICBvYmplY3RTaXplLFxyXG4gICAgICBhbmltYXRpb25TcGVlZCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBpbml0aWFsaXNlKCk6IHZvaWQge1xyXG4gICAgdGhpcy5pbml0VG9vbGJhcigpO1xyXG4gICAgdGhpcy5yZXNldEFsbCgpO1xyXG4gICAgdGhpcy5zZXRSdW5uaW5nKHRydWUpO1xyXG4gIH1cclxuXHJcbiAgaW5pdFRvb2xiYXIoKTogdm9pZCB7XHJcbiAgICB0aGlzLnRvb2xiYXIuYW5pbWF0aW9uU3BlZWQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoKSA9PlxyXG4gICAgICB0aGlzLnNhdmVDb29raWVzKClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBhc3luYyByZXNldEFsbCgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xyXG4gICAgdGhpcy5sb2FkQ29va2llcygpO1xyXG4gICAgYXdhaXQgdGhpcy5yZXNldCgpO1xyXG4gIH1cclxuXHJcbiAgY29uZmlybVJlc2V0QWxsKCk6IGJvb2xlYW4ge1xyXG4gICAgaWYgKGNvbmZpcm0oXCJUaGlzIGNsZWFycyB0aGUgY2FudmFzIGFuZCB5b3VyIGhpc3RvcnkhXCIpKSB7XHJcbiAgICAgIHRoaXMucmVzZXRBbGwoKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBhc3luYyByZXNldCgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRoaXMuY2xlYXJDYW52YXMoKTtcclxuICAgIGF3YWl0IHRoaXMucmVzZXRBbGdvcml0aG0oKTtcclxuICAgIHRoaXMucmVzZXRMaXN0ZW5lcnMoZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcmVzZXRBbGdvcml0aG0oKTogUHJvbWlzZTx2b2lkPiB7fVxyXG5cclxuICBjbGVhckNhbnZhcygpOiB2b2lkIHtcclxuICAgIHRoaXMuU3ZnLmNsZWFyKCk7XHJcbiAgICBjb25zdCB3ID0gdGhpcy5Tdmcudmlld2JveCgpLndpZHRoO1xyXG4gICAgY29uc3QgaCA9IHRoaXMuU3ZnLnZpZXdib3goKS5oZWlnaHQ7XHJcbiAgICBpZiAodGhpcy5ERUJVRykge1xyXG4gICAgICBmb3IgKGxldCB4ID0gMTsgeCA8IHcgLyAxMDA7IHgrKylcclxuICAgICAgICB0aGlzLlN2Zy5saW5lKHggKiAxMDAsIDAsIHggKiAxMDAsIGgpLmFkZENsYXNzKFwiZ3JpZGxpbmVcIik7XHJcbiAgICAgIGZvciAobGV0IHkgPSAxOyB5IDwgaCAvIDEwMDsgeSsrKVxyXG4gICAgICAgIHRoaXMuU3ZnLmxpbmUoMCwgeSAqIDEwMCwgdywgeSAqIDEwMCkuYWRkQ2xhc3MoXCJncmlkbGluZVwiKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG1hcmdpbiA9IHRoaXMuJFN2Zy5tYXJnaW47XHJcbiAgICB0aGlzLkluZm8udGl0bGUgPSB0aGlzLlN2Zy50ZXh0KE5CU1ApLmFkZENsYXNzKFwidGl0bGVcIikueChtYXJnaW4pLnkobWFyZ2luKTtcclxuICAgIHRoaXMuSW5mby5ib2R5ID0gdGhpcy5TdmcudGV4dChOQlNQKVxyXG4gICAgICAuYWRkQ2xhc3MoXCJtZXNzYWdlXCIpXHJcbiAgICAgIC54KG1hcmdpbilcclxuICAgICAgLnkoMiAqIG1hcmdpbik7XHJcbiAgICB0aGlzLkluZm8ucHJpbnRlciA9IHRoaXMuU3ZnLnRleHQoTkJTUClcclxuICAgICAgLmFkZENsYXNzKFwicHJpbnRlclwiKVxyXG4gICAgICAueChtYXJnaW4pXHJcbiAgICAgIC5jeShoIC0gMiAqIG1hcmdpbik7XHJcbiAgICB0aGlzLkluZm8uc3RhdHVzID0gdGhpcy5TdmcudGV4dChOQlNQKVxyXG4gICAgICAuYWRkQ2xhc3MoXCJzdGF0dXMtcmVwb3J0XCIpXHJcbiAgICAgIC54KG1hcmdpbilcclxuICAgICAgLmN5KGggLSBtYXJnaW4pO1xyXG4gICAgdGhpcy51cGRhdGVDU1NWYXJpYWJsZXMoKTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZUNTU1ZhcmlhYmxlcygpOiB2b2lkIHtcclxuICAgIGNvbnN0IHJlbGF0aXZlU2l6ZSA9IE1hdGgucm91bmQoXHJcbiAgICAgICgxMDAgKiB0aGlzLmdldE9iamVjdFNpemUoKSkgLyB0aGlzLiRTdmcub2JqZWN0U2l6ZVxyXG4gICAgKTtcclxuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcclxuICAgICAgXCItLW5vZGUtZm9udC1zaXplXCIsXHJcbiAgICAgIGAke3JlbGF0aXZlU2l6ZX0lYFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHNldFN0YXR1cyhzdGF0dXM6IFwicnVubmluZ1wiIHwgXCJwYXVzZWRcIiB8IFwiaW5hY3RpdmVcIiwgdGltZW91dCA9IDEwKTogdm9pZCB7XHJcbiAgICBjb25zdCBjdXJyZW50U3RhdHVzID0gdGhpcy5JbmZvLnN0YXR1cztcclxuICAgIGlmIChjdXJyZW50U3RhdHVzID09PSB1bmRlZmluZWQpIHJldHVybjtcclxuXHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgaWYgKHN0YXR1cyA9PT0gXCJydW5uaW5nXCIpIHtcclxuICAgICAgICBjdXJyZW50U3RhdHVzXHJcbiAgICAgICAgICAudGV4dChcIkFuaW1hdGluZ1wiKVxyXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKFwicGF1c2VkXCIpXHJcbiAgICAgICAgICAuYWRkQ2xhc3MoXCJydW5uaW5nXCIpO1xyXG4gICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJwYXVzZWRcIikge1xyXG4gICAgICAgIGN1cnJlbnRTdGF0dXMudGV4dChcIlBhdXNlZFwiKS5hZGRDbGFzcyhcInBhdXNlZFwiKS5yZW1vdmVDbGFzcyhcInJ1bm5pbmdcIik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY3VycmVudFN0YXR1cy50ZXh0KFwiSWRsZVwiKS5yZW1vdmVDbGFzcyhcInBhdXNlZFwiKS5yZW1vdmVDbGFzcyhcInJ1bm5pbmdcIik7XHJcbiAgICAgIH1cclxuICAgIH0sIHRpbWVvdXQpO1xyXG4gIH1cclxuXHJcbiAgc2V0SWRsZVRpdGxlKCk6IHZvaWQge1xyXG4gICAgLy8gVE9ETzogUGVyaGFwcyBhZGQgZXJyb3JzIGlmIG5vdCBmb3VuZFxyXG4gICAgaWYgKHRoaXMuSW5mby50aXRsZSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICB0aGlzLkluZm8udGl0bGUudGV4dChcIlNlbGVjdCBhbiBhY3Rpb24gZnJvbSB0aGUgbWVudSBhYm92ZVwiKTtcclxuICAgIGlmICh0aGlzLkluZm8uYm9keSAhPT0gdW5kZWZpbmVkKSB0aGlzLkluZm8uYm9keS50ZXh0KE5CU1ApO1xyXG4gIH1cclxuXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFRoZSBkZWZhdWx0IGxpc3RlbmVyc1xyXG5cclxuICAkSWRsZUxpc3RlbmVyczogUmVjb3JkPFxyXG4gICAgc3RyaW5nLFxyXG4gICAgeyB0eXBlOiBMaXN0ZW5lcnM7IGNvbmRpdGlvbjogKCkgPT4gYm9vbGVhbjsgaGFuZGxlcjogKCkgPT4gdm9pZCB9XHJcbiAgPiA9IHtcclxuICAgIHN0ZXBCYWNrd2FyZDoge1xyXG4gICAgICB0eXBlOiBcImNsaWNrXCIsXHJcbiAgICAgIGNvbmRpdGlvbjogKCkgPT4gdGhpcy5hY3Rpb25zLmxlbmd0aCA+IDAsXHJcbiAgICAgIGhhbmRsZXI6ICgpID0+IHtcclxuICAgICAgICB0aGlzLnNldFJ1bm5pbmcoZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMuYWN0aW9ucy5wb3AoKSE7IC8vICEgYmVjYXVzZSB3ZSBrbm93IHRoYXQgYXJyYXkgaXMgbm9uLWVtcHR5IChhY3Rpb25zLmxlbmd0aCA+IDApO1xyXG4gICAgICAgIHRoaXMuZXhlY3V0ZShhY3Rpb24ub3BlciwgYWN0aW9uLmFyZ3MsIGFjdGlvbi5uc3RlcHMgLSAxKTtcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgICBmYXN0QmFja3dhcmQ6IHtcclxuICAgICAgdHlwZTogXCJjbGlja1wiLFxyXG4gICAgICBjb25kaXRpb246ICgpID0+IHRoaXMuYWN0aW9ucy5sZW5ndGggPiAwLFxyXG4gICAgICBoYW5kbGVyOiAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5hY3Rpb25zLnBvcCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY29uc3QgYWN0aW9uID0gdGhpcy5hY3Rpb25zLnBvcCgpITtcclxuICAgICAgICAgIHRoaXMuZXhlY3V0ZShhY3Rpb24ub3BlciwgYWN0aW9uLmFyZ3MsIGFjdGlvbi5uc3RlcHMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICAgIG9iamVjdFNpemU6IHtcclxuICAgICAgdHlwZTogXCJjaGFuZ2VcIixcclxuICAgICAgY29uZGl0aW9uOiAoKSA9PiB0cnVlLFxyXG4gICAgICBoYW5kbGVyOiAoKSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuYWN0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb25zdCBhY3Rpb24gPSB0aGlzLmFjdGlvbnMucG9wKCkhOyAvLyAhIGJlY2F1c2Ugd2Uga25vdyB0aGF0IGFycmF5IGlzIG5vbi1lbXB0eSAoYWN0aW9ucy5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgdGhpcy5leGVjdXRlKGFjdGlvbi5vcGVyLCBhY3Rpb24uYXJncywgYWN0aW9uLm5zdGVwcyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gIH07XHJcblxyXG4gIC8vIFRPRE86IEZpeCBzb21lIG5pY2UgdHlwZSBmb3IgdGhpc1xyXG4gICRBc3luY0xpc3RlbmVyczogUmVjb3JkPFxyXG4gICAgc3RyaW5nLFxyXG4gICAge1xyXG4gICAgICB0eXBlOiBMaXN0ZW5lcnM7XHJcbiAgICAgIGhhbmRsZXI6IChyZXNvbHZlOiBSZXNvbHZlLCByZWplY3Q6IFJlamVjdCkgPT4gdm9pZDtcclxuICAgIH1cclxuICA+ID0ge1xyXG4gICAgc3RlcEZvcndhcmQ6IHtcclxuICAgICAgdHlwZTogXCJjbGlja1wiLFxyXG4gICAgICBoYW5kbGVyOiAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgdGhpcy5zZXRSdW5uaW5nKGZhbHNlKTtcclxuICAgICAgICB0aGlzLnN0ZXBGb3J3YXJkKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgZmFzdEZvcndhcmQ6IHtcclxuICAgICAgdHlwZTogXCJjbGlja1wiLFxyXG4gICAgICBoYW5kbGVyOiAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgdGhpcy5hY3Rpb25zW3RoaXMuQ3VycmVudEFjdGlvbl0ubnN0ZXBzID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XHJcbiAgICAgICAgdGhpcy5mYXN0Rm9yd2FyZChyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICAgIHRvZ2dsZVJ1bm5lcjoge1xyXG4gICAgICB0eXBlOiBcImNsaWNrXCIsXHJcbiAgICAgIGhhbmRsZXI6IChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICB0aGlzLnRvZ2dsZVJ1bm5lcigpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzUnVubmluZygpKSB7XHJcbiAgICAgICAgICB0aGlzLnN0ZXBGb3J3YXJkKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuQ3VycmVudFN0ZXArKztcclxuICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgc3RlcEJhY2t3YXJkOiB7XHJcbiAgICAgIHR5cGU6IFwiY2xpY2tcIixcclxuICAgICAgaGFuZGxlcjogKHJlc29sdmUsIHJlamVjdCkgPT5cclxuICAgICAgICByZWplY3QoeyB1bnRpbDogdGhpcy5DdXJyZW50U3RlcCAtIDEsIHJ1bm5pbmc6IGZhbHNlIH0pLFxyXG4gICAgfSxcclxuICAgIGZhc3RCYWNrd2FyZDoge1xyXG4gICAgICB0eXBlOiBcImNsaWNrXCIsXHJcbiAgICAgIGhhbmRsZXI6IChyZXNvbHZlLCByZWplY3QpID0+IHJlamVjdCh7IHVudGlsOiAwIH0pLFxyXG4gICAgfSxcclxuICAgIG9iamVjdFNpemU6IHtcclxuICAgICAgdHlwZTogXCJjaGFuZ2VcIixcclxuICAgICAgaGFuZGxlcjogKHJlc29sdmUsIHJlamVjdCkgPT4gcmVqZWN0KHsgdW50aWw6IHRoaXMuQ3VycmVudFN0ZXAgfSksXHJcbiAgICB9LFxyXG4gIH07XHJcblxyXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyBVcGRhdGluZyBsaXN0ZW5lcnNcclxuXHJcbiAgZGlzYWJsZVdoZW5SdW5uaW5nKGRpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICBmb3IgKGNvbnN0IGVsZW0gb2YgdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbDxcclxuICAgICAgSFRNTElucHV0RWxlbWVudCB8IEhUTUxTZWxlY3RFbGVtZW50XHJcbiAgICA+KFwiLmRpc2FibGVXaGVuUnVubmluZ1wiKSlcclxuICAgICAgZWxlbS5kaXNhYmxlZCA9IGRpc2FibGVkO1xyXG4gIH1cclxuXHJcbiAgcmVzZXRMaXN0ZW5lcnMoaXNSdW5uaW5nOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICB0aGlzLnNhdmVDb29raWVzKCk7XHJcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEVuZ2luZSkge1xyXG4gICAgICB0aGlzLmRpc2FibGVXaGVuUnVubmluZyh0cnVlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5hZGRMaXN0ZW5lcihcInRvZ2dsZVJ1bm5lclwiLCBcImNsaWNrXCIsICgpID0+IHRoaXMudG9nZ2xlUnVubmVyKCkpO1xyXG4gICAgaWYgKGlzUnVubmluZykge1xyXG4gICAgICB0aGlzLmRpc2FibGVXaGVuUnVubmluZyh0cnVlKTtcclxuICAgICAgdGhpcy5zZXRTdGF0dXMoXCJwYXVzZWRcIik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmRpc2FibGVXaGVuUnVubmluZyhmYWxzZSk7XHJcbiAgICB0aGlzLnNldElkbGVUaXRsZSgpO1xyXG4gICAgdGhpcy5zZXRTdGF0dXMoXCJpbmFjdGl2ZVwiKTtcclxuICAgIGZvciAoY29uc3QgaWQgaW4gdGhpcy4kSWRsZUxpc3RlbmVycykge1xyXG4gICAgICBjb25zdCBsaXN0ZW5lciA9IHRoaXMuJElkbGVMaXN0ZW5lcnNbaWRdO1xyXG4gICAgICBpZiAobGlzdGVuZXIuY29uZGl0aW9uKCkpIHtcclxuICAgICAgICBpZiAodGhpcy5ERUJVRylcclxuICAgICAgICAgIHRoaXMuYWRkTGlzdGVuZXIoaWQsIGxpc3RlbmVyLnR5cGUsICgpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgYCR7aWR9ICR7bGlzdGVuZXIudHlwZX06ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5hY3Rpb25zKX1gXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyLmhhbmRsZXIoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIGVsc2UgdGhpcy5hZGRMaXN0ZW5lcihpZCwgbGlzdGVuZXIudHlwZSwgbGlzdGVuZXIuaGFuZGxlcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFkZExpc3RlbmVyKGlkOiBzdHJpbmcsIHR5cGU6IExpc3RlbmVycywgaGFuZGxlcjogKCkgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5FdmVudExpc3RlbmVycztcclxuICAgIGlmICghbGlzdGVuZXJzW2lkXSkgbGlzdGVuZXJzW2lkXSA9IHt9O1xyXG4gICAgY29uc3QgZWxlbSA9IHRoaXMudG9vbGJhcltpZCBhcyBrZXlvZiB0eXBlb2YgdGhpcy50b29sYmFyXTtcclxuXHJcbiAgICBpZiAoIWVsZW0pIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGVsZW1lbnQgdG8gYWRkIGxpc3RlbmVyIHRvXCIpO1xyXG5cclxuICAgIGNvbnN0IG9sZEhhbmRsZXIgPSBsaXN0ZW5lcnNbaWRdW3R5cGVdO1xyXG4gICAgaWYgKG9sZEhhbmRsZXIpIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBvbGRIYW5kbGVyKTtcclxuICAgIGxpc3RlbmVyc1tpZF1bdHlwZV0gPSBoYW5kbGVyO1xyXG4gICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpO1xyXG4gICAgZWxlbS5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmVtb3ZlQWxsTGlzdGVuZXJzKCk6IHZvaWQge1xyXG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5FdmVudExpc3RlbmVycztcclxuXHJcbiAgICBmb3IgKGNvbnN0IGlkIGluIGxpc3RlbmVycykge1xyXG4gICAgICBjb25zdCBlbGVtID0gdGhpcy50b29sYmFyW2lkIGFzIGtleW9mIHR5cGVvZiB0aGlzLnRvb2xiYXJdO1xyXG5cclxuICAgICAgaWYgKCFlbGVtKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGVsZW1lbnQgdG8gcmVtb3ZlIGxpc3RlbmVyIGZyb21cIik7XHJcblxyXG4gICAgICBlbGVtLmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgZm9yIChjb25zdCB0eXBlIGluIGxpc3RlbmVyc1tpZF0pXHJcbiAgICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpZF1bdHlwZSBhcyBMaXN0ZW5lcnNdISk7IC8vICEgYmVjYXVzZSB3ZSBrbm93IHRoYXQgdGhlIHR5cGUgZXhpc3RzXHJcbiAgICAgIGxpc3RlbmVyc1tpZF0gPSB7fTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyBFeGVjdXRpbmcgdGhlIGFjdGlvbnNcclxuXHJcbiAgYXN5bmMgc3VibWl0KG1ldGhvZDogc3RyaW5nLCBmaWVsZDogSFRNTElucHV0RWxlbWVudCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmF3VmFsdWUgPSBmaWVsZC52YWx1ZTtcclxuICAgICAgZmllbGQudmFsdWUgPSBcIlwiO1xyXG4gICAgICBjb25zdCB2YWx1ZXMgPSBwYXJzZVZhbHVlcyhyYXdWYWx1ZSk7XHJcbiAgICAgIGlmICh2YWx1ZXMpIGF3YWl0IHRoaXMuZXhlY3V0ZShtZXRob2QsIHZhbHVlcyk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBhc3luYyBleGVjdXRlKFxyXG4gICAgb3BlcmF0aW9uOiBzdHJpbmcsXHJcbiAgICBhcmdzOiB1bmtub3duW10gPSBbXSxcclxuICAgIHVudGlsID0gMFxyXG4gICk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgYXdhaXQgdGhpcy5yZXNldCgpO1xyXG4gICAgdGhpcy5hY3Rpb25zLnB1c2goeyBvcGVyOiBvcGVyYXRpb24sIGFyZ3M6IGFyZ3MsIG5zdGVwczogdW50aWwgfSk7XHJcbiAgICBpZiAodGhpcy5ERUJVRylcclxuICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgYEVYRUMgJHt1bnRpbH06ICR7b3BlcmF0aW9ufSAke2FyZ3Muam9pbihcIiwgXCIpfSwgJHtKU09OLnN0cmluZ2lmeShcclxuICAgICAgICAgIHRoaXMuYWN0aW9uc1xyXG4gICAgICAgICl9YFxyXG4gICAgICApO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IHRoaXMucnVuQWN0aW9uc0xvb3AoKTtcclxuICAgICAgdGhpcy5hY3Rpb25zW3RoaXMuYWN0aW9ucy5sZW5ndGggLSAxXS5uc3RlcHMgPSB0aGlzLkN1cnJlbnRTdGVwIHx8IDA7IC8vIFRPRE86IE5vdCBzdXJlIGlmIHRoaXMgaXMgY29ycmVjdFxyXG4gICAgICBpZiAodGhpcy5ERUJVRylcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGBET05FIC8gJHt0aGlzLkN1cnJlbnRTdGVwfTogJHtKU09OLnN0cmluZ2lmeSh0aGlzLmFjdGlvbnMpfWBcclxuICAgICAgICApO1xyXG4gICAgICB0aGlzLnJlc2V0TGlzdGVuZXJzKGZhbHNlKTtcclxuICAgIH0gY2F0Y2ggKHJlYXNvbikge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdHlwZW9mIHJlYXNvbiAhPT0gXCJvYmplY3RcIiB8fFxyXG4gICAgICAgIHJlYXNvbiA9PT0gbnVsbCB8fCAvLyBBZGRlZCBsaW5lIHRvIGhlbHAgY2hlY2tzIGJlbG93XHJcbiAgICAgICAgXCJ1bnRpbFwiIGluIHJlYXNvbiA9PT0gZmFsc2UgfHwgLy8gQWRkZWQgbGluZSB0byBoZWxwIGNoZWNrcyBiZWxvd1xyXG4gICAgICAgIHR5cGVvZiByZWFzb24udW50aWwgIT09IFwibnVtYmVyXCIgLy8gQ2hhbmdlZCB0byBiZSBhYmxlIHRvIGFzc2lnbiB0byB1bnRpbCB3aGljaCBpcyBhIG51bWJlclxyXG4gICAgICApIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKHJlYXNvbik7XHJcbiAgICAgICAgdGhpcy5yZXNldExpc3RlbmVycyhmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuYWN0aW9ucy5wb3AoKTtcclxuICAgICAgaWYgKFwicnVubmluZ1wiIGluIHJlYXNvbiAmJiB0eXBlb2YgcmVhc29uLnJ1bm5pbmcgPT09IFwiYm9vbGVhblwiKVxyXG4gICAgICAgIHRoaXMuc2V0UnVubmluZyhyZWFzb24ucnVubmluZyk7XHJcbiAgICAgIHVudGlsID0gcmVhc29uLnVudGlsO1xyXG4gICAgICBpZiAodGhpcy5ERUJVRylcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIGBSRVJVTiAke3VudGlsfSAvICR7dGhpcy5DdXJyZW50U3RlcH06ICR7SlNPTi5zdHJpbmdpZnkoXHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uc1xyXG4gICAgICAgICAgKX1gXHJcbiAgICAgICAgKTtcclxuICAgICAgaWYgKHVudGlsIDw9IDAgJiYgdGhpcy5hY3Rpb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCBhY3Rpb24gPSB0aGlzLmFjdGlvbnMucG9wKCkhOyAvLyAhIGJlY2F1c2Ugd2Uga25vdyB0aGF0IGFycmF5IGlzIG5vbi1lbXB0eSAoYWN0aW9ucy5sZW5ndGggPiAwKVxyXG4gICAgICAgIChvcGVyYXRpb24gPSBhY3Rpb24ub3BlciksXHJcbiAgICAgICAgICAoYXJncyA9IGFjdGlvbi5hcmdzKSxcclxuICAgICAgICAgICh1bnRpbCA9IGFjdGlvbi5uc3RlcHMpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh1bnRpbCA+IDApIHtcclxuICAgICAgICB0aGlzLmV4ZWN1dGUob3BlcmF0aW9uLCBhcmdzLCB1bnRpbCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBydW5BY3Rpb25zTG9vcCgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGZvciAobGV0IG5BY3Rpb24gPSAwOyBuQWN0aW9uIDwgdGhpcy5hY3Rpb25zLmxlbmd0aDsgbkFjdGlvbisrKSB7XHJcbiAgICAgIHRoaXMucmVzZXRMaXN0ZW5lcnModHJ1ZSk7XHJcbiAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMuYWN0aW9uc1tuQWN0aW9uXTtcclxuICAgICAgdGhpcy5DdXJyZW50QWN0aW9uID0gbkFjdGlvbjtcclxuICAgICAgdGhpcy5DdXJyZW50U3RlcCA9IDA7XHJcbiAgICAgIC8vIE1ha2UgY2FtZWxDYXNlIHNlcGFyYXRlIHdvcmRzOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjExNDg2MzBcclxuICAgICAgY29uc3QgbWVzc2FnZUFyciA9IGFjdGlvbi5vcGVyLm1hdGNoKC9bQS1aYS16XVthLXpdKi9nKSB8fCBbXTtcclxuICAgICAgbGV0IG1lc3NhZ2UgPSBtZXNzYWdlQXJyLmpvaW4oXCIgXCIpO1xyXG4gICAgICBtZXNzYWdlID0gYCR7XHJcbiAgICAgICAgbWVzc2FnZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG1lc3NhZ2Uuc3Vic3RyaW5nKDEpXHJcbiAgICAgIH0gJHthY3Rpb24uYXJncy5qb2luKFwiLCBcIil9YDtcclxuICAgICAgaWYgKHRoaXMuREVCVUcpXHJcbiAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICBgQ0FMTCAke25BY3Rpb259OiAke21lc3NhZ2V9LCAke0pTT04uc3RyaW5naWZ5KHRoaXMuYWN0aW9ucyl9YFxyXG4gICAgICAgICk7XHJcbiAgICAgIHRoaXMuSW5mby50aXRsZT8udGV4dChtZXNzYWdlKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZShcIlwiKTtcclxuICAgICAgaWYgKFxyXG4gICAgICAgICEoXHJcbiAgICAgICAgICBhY3Rpb24ub3BlciBpbiB0aGlzICYmXHJcbiAgICAgICAgICB0eXBlb2YgdGhpc1thY3Rpb24ub3BlciBhcyBrZXlvZiBFbmdpbmVdID09PSBcImZ1bmN0aW9uXCJcclxuICAgICAgICApXHJcbiAgICAgIClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBhY3Rpb24gdGhhdCBkb2VzIG5vdCBleGlzdFwiKTtcclxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBIYXZlIGNoZWNrZWQgdGhhdCBpdCBleGlzdHMgYW5kIHRoYXQgaXMgYSBmdW5jdGlvbi4gT25seSB0aGluZyB3b3VsZCBiZSB0byB2YWxpZGF0ZSBpbnB1dC4gQmV0dGVyIHRvIGRvIGluIGVhY2ggZnVuY3Rpb24gaW4gYW55IGNhc2VcclxuICAgICAgYXdhaXQgdGhpc1thY3Rpb24ub3Blcl0oLi4uYWN0aW9uLmFyZ3MpOyAvLyBLb21tZXIgYmxpIGtuw7ZsaWcgYXR0IGzDtnNhXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwYXVzZShcclxuICAgIG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCxcclxuICAgIC4uLmFyZ3M6IHVua25vd25bXVxyXG4gICk6IFByb21pc2U8dW5rbm93bj4gfCBudWxsIHtcclxuICAgIGNvbnN0IHRpdGxlID0gdGhpcy5nZXRNZXNzYWdlKG1lc3NhZ2UsIC4uLmFyZ3MpO1xyXG4gICAgaWYgKHRoaXMuREVCVUcpXHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIGAke1xyXG4gICAgICAgICAgdGhpcy5DdXJyZW50U3RlcFxyXG4gICAgICAgIH0uIERvaW5nOiAke3RpdGxlfSAocnVubmluZzogJHt0aGlzLmlzUnVubmluZygpfSksICR7SlNPTi5zdHJpbmdpZnkoXHJcbiAgICAgICAgICB0aGlzLmFjdGlvbnNcclxuICAgICAgICApfWBcclxuICAgICAgKTtcclxuICAgIGlmICh0aGlzLlN0YXRlLnJlc2V0dGluZykgcmV0dXJuIG51bGw7XHJcbiAgICBpZiAodGl0bGUgIT09IG51bGwgJiYgdGhpcy5JbmZvLmJvZHkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLkluZm8uYm9keS50ZXh0KHRpdGxlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMuYWN0aW9uc1t0aGlzLkN1cnJlbnRBY3Rpb25dO1xyXG4gICAgICBpZiAoYWN0aW9uLm5zdGVwcyAhPSBudWxsICYmIHRoaXMuQ3VycmVudFN0ZXAgPCBhY3Rpb24ubnN0ZXBzKSB7XHJcbiAgICAgICAgdGhpcy5mYXN0Rm9yd2FyZChyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxldCBydW5uZXJUaW1lcjogTm9kZUpTLlRpbWVvdXQgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLiRBc3luY0xpc3RlbmVycykge1xyXG4gICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSB0aGlzLiRBc3luY0xpc3RlbmVyc1tpZF07XHJcbiAgICAgICAgICB0aGlzLmFkZExpc3RlbmVyKGlkLCBsaXN0ZW5lci50eXBlLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChydW5uZXJUaW1lcik7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyLmhhbmRsZXIocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc1J1bm5pbmcoKSkge1xyXG4gICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJydW5uaW5nXCIpO1xyXG4gICAgICAgICAgcnVubmVyVGltZXIgPSBzZXRUaW1lb3V0KFxyXG4gICAgICAgICAgICAoKSA9PiB0aGlzLnN0ZXBGb3J3YXJkKHJlc29sdmUsIHJlamVjdCksXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKSAqIDEuMVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gVE9ETzogRml4IHR5cGUgb2YgdGl0bGUgYW5kIHVwZGF0ZSByZXR1cm4gdHlwZVxyXG4gIGdldE1lc3NhZ2UobWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkLCAuLi5hcmdzOiB1bmtub3duW10pIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2UpKSBbbWVzc2FnZSwgLi4uYXJnc10gPSBbLi4ubWVzc2FnZSwgLi4uYXJnc107IC8vIFRPRE86IGlzIHRoaXMgdXNlZD8/XHJcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkgY29uc29sZS5lcnJvcihcIlVua25vd24gbWVzc2FnZTpcIiwgbWVzc2FnZSwgLi4uYXJncyk7XHJcbiAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgfVxyXG4gICAgaWYgKCFtZXNzYWdlKSByZXR1cm4gYXJncy5qb2luKFwiXFxuXCIpO1xyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGlzLmNvbnN0cnVjdG9yLm1lc3NhZ2VzIGRvbnQga25vdyB3aGF0IGl0IGlzXHJcbiAgICBsZXQgdGl0bGUgPSB0aGlzLm1lc3NhZ2VzIHx8IHRoaXMuY29uc3RydWN0b3IubWVzc2FnZXMgfHwge307XHJcbiAgICBjb25zdCBrZXlzID0gbWVzc2FnZS5zcGxpdChcIi5cIik7XHJcbiAgICBpZiAoIShrZXlzWzBdIGluIHRpdGxlKSkgcmV0dXJuIFttZXNzYWdlLCAuLi5hcmdzXS5qb2luKFwiXFxuXCIpO1xyXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xyXG4gICAgICBpZiAoISh0eXBlb2YgdGl0bGUgPT09IFwib2JqZWN0XCIgJiYga2V5IGluIHRpdGxlKSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmtub3duIG1lc3NhZ2U6XCIsIG1lc3NhZ2UsIC4uLmFyZ3MpO1xyXG4gICAgICAgIHJldHVybiBbbWVzc2FnZSwgLi4uYXJnc10uam9pbihcIlxcblwiKTtcclxuICAgICAgfVxyXG4gICAgICB0aXRsZSA9IHRpdGxlW2tleV07XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHRpdGxlID09PSBcImZ1bmN0aW9uXCIpIHRpdGxlID0gdGl0bGUoLi4uYXJncyk7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aXRsZSkpIHRpdGxlID0gdGl0bGUuam9pbihcIlxcblwiKTtcclxuICAgIGlmICh0eXBlb2YgdGl0bGUgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIlVua25vd24gbWVzc2FnZTpcIiwgbWVzc2FnZSwgLi4uYXJncyk7XHJcbiAgICAgIHJldHVybiBbbWVzc2FnZSwgLi4uYXJnc10uam9pbihcIlxcblwiKTtcclxuICAgIH1cclxuICAgIGlmICh0aXRsZSA9PT0gXCJcIikgdGl0bGUgPSBOQlNQO1xyXG4gICAgcmV0dXJuIHRpdGxlO1xyXG4gIH1cclxuXHJcbiAgc3RlcEZvcndhcmQocmVzb2x2ZTogUmVzb2x2ZSwgcmVqZWN0OiBSZWplY3QpOiB2b2lkIHtcclxuICAgIHRoaXMuQ3VycmVudFN0ZXArKztcclxuICAgIHRoaXMuU3RhdGUuYW5pbWF0aW5nID0gdHJ1ZTtcclxuICAgIHJlc29sdmUodW5kZWZpbmVkKTtcclxuICB9XHJcblxyXG4gIGZhc3RGb3J3YXJkKHJlc29sdmU6IFJlc29sdmUsIHJlamVjdDogUmVqZWN0KTogdm9pZCB7XHJcbiAgICBjb25zdCBhY3Rpb24gPSB0aGlzLmFjdGlvbnNbdGhpcy5DdXJyZW50QWN0aW9uXTtcclxuICAgIGlmICh0aGlzLkN1cnJlbnRTdGVwID49IGFjdGlvbi5uc3RlcHMpIHtcclxuICAgICAgYWN0aW9uLm5zdGVwcyA9IHRoaXMuQ3VycmVudFN0ZXA7XHJcbiAgICB9XHJcbiAgICB0aGlzLkN1cnJlbnRTdGVwKys7XHJcbiAgICB0aGlzLlN0YXRlLmFuaW1hdGluZyA9IGZhbHNlO1xyXG4gICAgaWYgKHRoaXMuREVCVUcpIHNldFRpbWVvdXQocmVzb2x2ZSwgMTApO1xyXG4gICAgZWxzZSByZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgfVxyXG5cclxuICBpc1J1bm5pbmcoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy50b29sYmFyLnRvZ2dsZVJ1bm5lcj8uY2xhc3NMaXN0LmNvbnRhaW5zKFwic2VsZWN0ZWRcIikgfHwgZmFsc2U7XHJcbiAgfVxyXG5cclxuICBzZXRSdW5uaW5nKHJ1bm5pbmc6IGJvb2xlYW4pOiB0aGlzIHtcclxuICAgIGNvbnN0IGNsYXNzZXMgPSB0aGlzLnRvb2xiYXIudG9nZ2xlUnVubmVyPy5jbGFzc0xpc3Q7XHJcbiAgICBpZiAoY2xhc3NlcyA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyB0b2dnbGVSdW5uZXJcIik7XHJcbiAgICBpZiAocnVubmluZykgY2xhc3Nlcy5hZGQoXCJzZWxlY3RlZFwiKTtcclxuICAgIGVsc2UgY2xhc3Nlcy5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgdG9nZ2xlUnVubmVyKCk6IHRoaXMge1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0UnVubmluZyghdGhpcy5pc1J1bm5pbmcoKSk7XHJcbiAgfVxyXG5cclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gQ29va2llc1xyXG5cclxuICBsb2FkQ29va2llcygpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLkRFQlVHKSBjb25zb2xlLmxvZyhcIkxvYWRpbmcgY29va2llc1wiLCBkb2N1bWVudC5jb29raWUpO1xyXG4gICAgY29uc3QgYWxsQ29va2llcyA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdChcIjtcIik7XHJcbiAgICBmb3IgKGNvbnN0IGNvb2tpZU5hbWUgaW4gdGhpcy4kQ29va2llcykge1xyXG4gICAgICBmb3IgKGNvbnN0IGNvb2tpZSBvZiBhbGxDb29raWVzKSB7XHJcbiAgICAgICAgY29uc3QgW2Nvb2tpZU5hbWUwLCB2YWx1ZTBdID0gY29va2llLnNwbGl0KFwiPVwiLCAyKTtcclxuICAgICAgICBpZiAoY29va2llTmFtZTAudHJpbSgpID09PSBjb29raWVOYW1lKSB7XHJcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZTApO1xyXG4gICAgICAgICAgdGhpcy4kQ29va2llc1tjb29raWVOYW1lIGFzIGtleW9mIHR5cGVvZiB0aGlzLiRDb29raWVzXS5nZXRDb29raWUoXHJcbiAgICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzYXZlQ29va2llcygpOiB2b2lkIHtcclxuICAgIGxldCBleHBpcmVzID0gXCJcIjtcclxuICAgIGlmICh0aGlzLiRDb29raWVFeHBpcmVEYXlzID4gMCkge1xyXG4gICAgICBjb25zdCBleGRhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICBleGRhdGUuc2V0RGF0ZShleGRhdGUuZ2V0RGF0ZSgpICsgdGhpcy4kQ29va2llRXhwaXJlRGF5cyk7XHJcbiAgICAgIGV4cGlyZXMgPSBgO2V4cGlyZXM9JHtleGRhdGUudG9VVENTdHJpbmcoKX1gO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBjb29raWVOYW1lIGluIHRoaXMuJENvb2tpZXMpIHtcclxuICAgICAgY29uc3QgdmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQoXHJcbiAgICAgICAgdGhpcy4kQ29va2llc1tjb29raWVOYW1lIGFzIGtleW9mIHR5cGVvZiB0aGlzLiRDb29raWVzXS5zZXRDb29raWUoKVxyXG4gICAgICApO1xyXG4gICAgICBkb2N1bWVudC5jb29raWUgPSBgJHtjb29raWVOYW1lfT0ke3ZhbHVlfSR7ZXhwaXJlc31gO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuREVCVUcpIGNvbnNvbGUubG9nKFwiU2V0dGluZyBjb29raWVzXCIsIGRvY3VtZW50LmNvb2tpZSk7XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPOiBGaXggdG8gbWF0Y2ggdGhlIG5ldyBsYXlvdXQgb2YgYmFzaWMgb2JqZWN0c1xyXG4gIC8vIFdpbGwgbm90IHdvcmsgcmlnaHQgbm93XHJcbiAgLy8gVE9ETzogRml4IHRvIHdvcmsgd2l0aCBnZW5lcmljIG9iamVjdHNcclxuICBhbmltYXRlKGVsZW06IEVsZW1lbnQsIGFuaW1hdGUgPSB0cnVlKSB7XHJcbiAgICBpZiAodGhpcy5TdGF0ZS5hbmltYXRpbmcgJiYgYW5pbWF0ZSkge1xyXG4gICAgICB0aGlzLnNldFN0YXR1cyhcInJ1bm5pbmdcIik7XHJcbiAgICAgIHRoaXMuc2V0U3RhdHVzKFwicGF1c2VkXCIsIHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKSk7XHJcbiAgICAgIHJldHVybiBlbGVtLmFuaW1hdGUodGhpcy5nZXRBbmltYXRpb25TcGVlZCgpLCAwLCBcIm5vd1wiKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBlbGVtO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLyBIZWxwZXIgZnVuY3Rpb25zXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplTnVtYmVyKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcgfCBudW1iZXIge1xyXG4gIGlucHV0ID0gaW5wdXQudHJpbSgpO1xyXG4gIHJldHVybiBpbnB1dCA9PT0gXCJcIiB8fCBpc05hTihOdW1iZXIoaW5wdXQpKSA/IGlucHV0IDogTnVtYmVyKGlucHV0KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVmFsdWVzKFxyXG4gIHZhbHVlczogc3RyaW5nIHwgc3RyaW5nW10gfCBudWxsIHwgdW5kZWZpbmVkXHJcbik6IChzdHJpbmcgfCBudW1iZXIpW10ge1xyXG4gIGlmICghdmFsdWVzKSByZXR1cm4gW107XHJcbiAgaWYgKHR5cGVvZiB2YWx1ZXMgPT09IFwic3RyaW5nXCIpIHtcclxuICAgIHZhbHVlcyA9IHZhbHVlcy50cmltKCkuc3BsaXQoL1xccysvKTtcclxuICB9XHJcbiAgcmV0dXJuIHZhbHVlcy5tYXAoKHYpID0+IG5vcm1hbGl6ZU51bWJlcih2KSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRSZXR1cm5TdWJtaXQoXHJcbiAgZmllbGQ6IEhUTUxJbnB1dEVsZW1lbnQsXHJcbiAgYWxsb3dlZDogc3RyaW5nLFxyXG4gIGFjdGlvbjogKCkgPT4gdm9pZFxyXG4pOiB2b2lkIHtcclxuICBhbGxvd2VkID1cclxuICAgIGFsbG93ZWQgPT09IFwiaW50XCJcclxuICAgICAgPyBcIjAtOVwiXHJcbiAgICAgIDogYWxsb3dlZCA9PT0gXCJpbnQrXCJcclxuICAgICAgPyBcIjAtOSBcIlxyXG4gICAgICA6IGFsbG93ZWQgPT09IFwiZmxvYXRcIlxyXG4gICAgICA/IFwiLS4wLTlcIlxyXG4gICAgICA6IGFsbG93ZWQgPT09IFwiZmxvYXQrXCJcclxuICAgICAgPyBcIi0uMC05IFwiXHJcbiAgICAgIDogYWxsb3dlZCA9PT0gXCJBTFBIQVwiXHJcbiAgICAgID8gXCJBLVpcIlxyXG4gICAgICA6IGFsbG93ZWQgPT09IFwiQUxQSEErXCJcclxuICAgICAgPyBcIkEtWiBcIlxyXG4gICAgICA6IGFsbG93ZWQgPT09IFwiYWxwaGFcIlxyXG4gICAgICA/IFwiYS16QS1aXCJcclxuICAgICAgOiBhbGxvd2VkID09PSBcImFscGhhK1wiXHJcbiAgICAgID8gXCJhLXpBLVogXCJcclxuICAgICAgOiBhbGxvd2VkID09PSBcIkFMUEhBTlVNXCJcclxuICAgICAgPyBcIkEtWjAtOVwiXHJcbiAgICAgIDogYWxsb3dlZCA9PT0gXCJBTFBIQU5VTStcIlxyXG4gICAgICA/IFwiQS1aMC05IFwiXHJcbiAgICAgIDogYWxsb3dlZCA9PT0gXCJhbHBoYW51bVwiXHJcbiAgICAgID8gXCJhLXpBLVowLTlcIlxyXG4gICAgICA6IGFsbG93ZWQgPT09IFwiYWxwaGFudW0rXCJcclxuICAgICAgPyBcImEtekEtWjAtOSBcIlxyXG4gICAgICA6IGFsbG93ZWQ7XHJcblxyXG4gIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgW14ke2FsbG93ZWR9XWAsIFwiZ1wiKTtcclxuXHJcbiAgY29uc3QgdHJhbnNmb3JtOiAoczogc3RyaW5nKSA9PiBzdHJpbmcgPVxyXG4gICAgYWxsb3dlZCA9PT0gYWxsb3dlZC50b1VwcGVyQ2FzZSgpXHJcbiAgICAgID8gKHMpID0+IHMudG9VcHBlckNhc2UoKVxyXG4gICAgICA6IGFsbG93ZWQgPT09IGFsbG93ZWQudG9Mb3dlckNhc2UoKVxyXG4gICAgICA/IChzKSA9PiBzLnRvTG93ZXJDYXNlKClcclxuICAgICAgOiAocykgPT4gcztcclxuXHJcbiAgLy8gSWRlYSB0YWtlbiBmcm9tIGhlcmU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNDcxOTgxOFxyXG4gIGZpZWxkLm9uaW5wdXQgPSAoZXZlbnQpID0+IHtcclxuICAgIGxldCBwb3MgPSBmaWVsZC5zZWxlY3Rpb25TdGFydCB8fCAwOyAvLyBDb3JyZWN0IHRvIGFkZCAwP1xyXG4gICAgbGV0IHZhbHVlID0gdHJhbnNmb3JtKGZpZWxkLnZhbHVlKTtcclxuICAgIGlmIChyZWdleC50ZXN0KHZhbHVlKSkge1xyXG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVnZXgsIFwiXCIpO1xyXG4gICAgICBwb3MtLTtcclxuICAgIH1cclxuICAgIGZpZWxkLnZhbHVlID0gdmFsdWU7XHJcbiAgICBmaWVsZC5zZXRTZWxlY3Rpb25SYW5nZShwb3MsIHBvcyk7XHJcbiAgfTtcclxuXHJcbiAgaWYgKGFjdGlvbikge1xyXG4gICAgZmllbGQub25rZXlkb3duID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgYWN0aW9uKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vLyBUT0RPOiBGaXggdHlwZXNcclxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZURlZmF1bHQoXHJcbiAgb2JqOiBhbnksXHJcbiAgZGVmYXVsdE9iajogYW55LFxyXG4gIG92ZXJyaWRlOiBib29sZWFuID0gZmFsc2VcclxuKTogdm9pZCB7XHJcbiAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdE9iaikge1xyXG4gICAgaWYgKCEoa2V5IGluIG9iaikpIHtcclxuICAgICAgb2JqW2tleV0gPSBkZWZhdWx0T2JqW2tleV07XHJcbiAgICB9IGVsc2UgaWYgKFxyXG4gICAgICB0eXBlb2Ygb2JqW2tleV0gPT09IFwib2JqZWN0XCIgJiZcclxuICAgICAgb2JqW2tleV0gIT09IG51bGwgJiZcclxuICAgICAgdHlwZW9mIGRlZmF1bHRPYmpba2V5XSA9PT0gXCJvYmplY3RcIiAmJlxyXG4gICAgICBkZWZhdWx0T2JqW2tleV0gIT09IG51bGxcclxuICAgICkge1xyXG4gICAgICB1cGRhdGVEZWZhdWx0KG9ialtrZXldLCBkZWZhdWx0T2JqW2tleV0sIG92ZXJyaWRlKTtcclxuICAgIH0gZWxzZSBpZiAob3ZlcnJpZGUpIHtcclxuICAgICAgb2JqW2tleV0gPSBkZWZhdWx0T2JqW2tleV07XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbW9kdWxvKG46IG51bWJlciwgZDogbnVtYmVyKTogbnVtYmVyIHtcclxuICBjb25zdCByZW0gPSBuICUgZDtcclxuICByZXR1cm4gcmVtIDwgMCA/IHJlbSArIGQgOiByZW07XHJcbn1cclxuXHJcbi8vIE5vbi1icmVha2luZyBzcGFjZTpcclxuZXhwb3J0IGNvbnN0IE5CU1AgPSBcIlxcdTAwQTBcIjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlKGE6IHN0cmluZyB8IG51bWJlciwgYjogc3RyaW5nIHwgbnVtYmVyKTogLTEgfCAwIHwgMSB7XHJcbiAgLy8gV2UgdXNlIG5vbi1icmVha2luZyBzcGFjZSBhcyBhIHByb3h5IGZvciB0aGUgZW1wdHkgc3RyaW5nLFxyXG4gIC8vIGJlY2F1c2UgU1ZHIHRleHQgb2JqZWN0cyByZXNldCBjb29yZGluYXRlcyB0byAoMCwgMCkgZm9yIHRoZSBlbXB0eSBzdHJpbmcuXHJcbiAgaWYgKGEgPT09IE5CU1ApIGEgPSBcIlwiO1xyXG4gIGlmIChiID09PSBOQlNQKSBiID0gXCJcIjtcclxuICBpZiAoaXNOYU4oTnVtYmVyKGEpKSA9PT0gaXNOYU4oTnVtYmVyKGIpKSkge1xyXG4gICAgLy8gYSBhbmQgYiBhcmUgKDEpIGJvdGggbnVtYmVycyBvciAoMikgYm90aCBub24tbnVtYmVyc1xyXG4gICAgaWYgKCFpc05hTihOdW1iZXIoYSkpKSB7XHJcbiAgICAgIC8vIGEgYW5kIGIgYXJlIGJvdGggbnVtYmVyc1xyXG4gICAgICBhID0gTnVtYmVyKGEpO1xyXG4gICAgICBiID0gTnVtYmVyKGIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA8IGIgPyAtMSA6IDE7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIGEgYW5kIGIgYXJlIG9mIGRpZmZlcmVudCB0eXBlc1xyXG4gICAgLy8gbGV0J3Mgc2F5IHRoYXQgbnVtYmVycyBhcmUgc21hbGxlciB0aGFuIG5vbi1udW1iZXJzXHJcbiAgICByZXR1cm4gaXNOYU4oTnVtYmVyKGEpKSA/IDEgOiAtMTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgVGV4dCB9IGZyb20gXCJAc3ZnZG90anMvc3ZnLmpzXCI7XHJcbmltcG9ydCB7XHJcbiAgY29tcGFyZSxcclxuICBFbmdpbmUsXHJcbiAgRW5naW5lVG9vbGJhckl0ZW1zLFxyXG4gIHBhcnNlVmFsdWVzLFxyXG59IGZyb20gXCIuLi8uLi9zcmMvZW5naW5lXCI7XHJcbmltcG9ydCB7IEJpbmFyeU5vZGUgfSBmcm9tIFwiLi4vb2JqZWN0cy9iaW5hcnktbm9kZVwiO1xyXG5pbXBvcnQgeyBIaWdobGlnaHRDaXJjbGUgfSBmcm9tIFwiLi4vb2JqZWN0cy9oaWdobGlnaHQtY2lyY2xlXCI7XHJcblxyXG50eXBlIEJTVFRvb2xiYXJJdGVtcyA9IEVuZ2luZVRvb2xiYXJJdGVtcyAmIHtcclxuICBzaG93TnVsbE5vZGVzOiBIVE1MSW5wdXRFbGVtZW50O1xyXG59O1xyXG5cclxuZXhwb3J0IGNsYXNzIEJTVCBleHRlbmRzIEVuZ2luZSB7XHJcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIGZpeCBtZXNzYWdlIHR5cGluZ1xyXG4gIG1lc3NhZ2VzID0gQlNUTWVzc2FnZXM7XHJcblxyXG4gIGluaXRpYWxWYWx1ZXM6IChzdHJpbmcgfCBudW1iZXIpW10gPSBbXTtcclxuICB0cmVlUm9vdDogQmluYXJ5Tm9kZSB8IG51bGwgPSBudWxsO1xyXG5cclxuICB0b29sYmFyOiBCU1RUb29sYmFySXRlbXM7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lclNlbGVjdG9yOiBzdHJpbmcpIHtcclxuICAgIHN1cGVyKGNvbnRhaW5lclNlbGVjdG9yKTtcclxuICAgIHRoaXMudG9vbGJhciA9IHRoaXMuZ2V0VG9vbGJhcigpO1xyXG4gIH1cclxuXHJcbiAgZ2V0VG9vbGJhcigpOiBCU1RUb29sYmFySXRlbXMge1xyXG4gICAgY29uc3QgdG9vbGJhciA9IHN1cGVyLmdldFRvb2xiYXIoKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIkluc2VydGluZyBuZXcgMlwiKTtcclxuICAgIHRvb2xiYXIuZ2VuZXJhbENvbnRyb2xzLmluc2VydEFkamFjZW50SFRNTChcclxuICAgICAgXCJiZWZvcmVlbmRcIixcclxuICAgICAgYDxzcGFuIGNsYXNzPVwiZm9ybWdyb3VwXCI+PGxhYmVsPlxyXG4gICAgICAgIDxpbnB1dCBjbGFzcz1cInNob3dOdWxsTm9kZXNcIiB0eXBlPVwiY2hlY2tib3hcIi8+IFNob3cgbnVsbCBub2Rlc1xyXG4gICAgICAgPC9sYWJlbD48L3NwYW4+YFxyXG4gICAgKTtcclxuICAgIGNvbnN0IHNob3dOdWxsTm9kZXMgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yPEhUTUxJbnB1dEVsZW1lbnQ+KFxyXG4gICAgICBcImlucHV0LnNob3dOdWxsTm9kZXNcIlxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAoIXNob3dOdWxsTm9kZXMpIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHNob3cgbnVsbCBub2RlcyBpbnB1dFwiKTtcclxuXHJcbiAgICByZXR1cm4geyAuLi50b29sYmFyLCBzaG93TnVsbE5vZGVzIH07XHJcbiAgfVxyXG5cclxuICBpbml0aWFsaXNlKGluaXRpYWxWYWx1ZXMgPSBudWxsKTogdGhpcyB7XHJcbiAgICB0aGlzLmluaXRpYWxWYWx1ZXMgPSBwYXJzZVZhbHVlcyhpbml0aWFsVmFsdWVzKTtcclxuICAgIHN1cGVyLmluaXRpYWxpc2UoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcmVzZXRBbGdvcml0aG0oKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBhd2FpdCBzdXBlci5yZXNldEFsZ29yaXRobSgpO1xyXG4gICAgdGhpcy50cmVlUm9vdCA9IG51bGw7XHJcbiAgICBpZiAodGhpcy5pbml0aWFsVmFsdWVzKSB7XHJcbiAgICAgIHRoaXMuU3RhdGUucmVzZXR0aW5nID0gdHJ1ZTtcclxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBEZWNpZGUgaG93IHdlIHdhbnQgdG8gaGFuZGxlIG51bWJlcnMgYW5kIHRoZW4gdXBkYXRlIHR5cGVzXHJcbiAgICAgIGF3YWl0IHRoaXMuaW5zZXJ0KC4uLnRoaXMuaW5pdGlhbFZhbHVlcyk7XHJcbiAgICAgIHRoaXMuU3RhdGUucmVzZXR0aW5nID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpbml0VG9vbGJhcigpOiB2b2lkIHtcclxuICAgIHN1cGVyLmluaXRUb29sYmFyKCk7XHJcblxyXG4gICAgdGhpcy50b29sYmFyLnNob3dOdWxsTm9kZXMuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoKSA9PlxyXG4gICAgICB0aGlzLnRvZ2dsZU51bGxOb2RlcyhudWxsKVxyXG4gICAgKTtcclxuICAgIHRoaXMudG9nZ2xlTnVsbE5vZGVzKHRydWUpO1xyXG4gIH1cclxuXHJcbiAgdG9nZ2xlTnVsbE5vZGVzKHNob3c6IGJvb2xlYW4gfCBudWxsKTogdGhpcyB7XHJcbiAgICBpZiAoc2hvdyA9PSBudWxsKSBzaG93ID0gdGhpcy50b29sYmFyLnNob3dOdWxsTm9kZXMuY2hlY2tlZDtcclxuICAgIHRoaXMudG9vbGJhci5zaG93TnVsbE5vZGVzLmNoZWNrZWQgPSBzaG93O1xyXG4gICAgaWYgKHNob3cpIHRoaXMuU3ZnLmFkZENsYXNzKFwic2hvd251bGxub2Rlc1wiKTtcclxuICAgIGVsc2UgdGhpcy5TdmcucmVtb3ZlQ2xhc3MoXCJzaG93bnVsbG5vZGVzXCIpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBuZXdOb2RlKHRleHQ6IHN0cmluZyk6IEJpbmFyeU5vZGUge1xyXG4gICAgcmV0dXJuIHRoaXMuU3ZnLmJpbmFyeU5vZGUoXHJcbiAgICAgIHRleHQsXHJcbiAgICAgIC4uLnRoaXMuZ2V0Tm9kZVN0YXJ0KCksXHJcbiAgICAgIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpLFxyXG4gICAgICB0aGlzLmdldFN0cm9rZVdpZHRoKClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICByZXNpemVUcmVlKCk6IHRoaXMge1xyXG4gICAgY29uc3QgYW5pbWF0ZSA9ICF0aGlzLlN0YXRlLnJlc2V0dGluZztcclxuICAgIHRoaXMudHJlZVJvb3Q/LnJlc2l6ZShcclxuICAgICAgLi4udGhpcy5nZXRUcmVlUm9vdCgpLFxyXG4gICAgICB0aGlzLiRTdmcubWFyZ2luLFxyXG4gICAgICB0aGlzLmdldE5vZGVTcGFjaW5nKCksXHJcbiAgICAgIGFuaW1hdGUgPyB0aGlzLiRTdmcuYW5pbWF0aW9uU3BlZWQgOiAwXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBhc3luYyBpbnNlcnQoLi4udmFsdWVzOiBzdHJpbmdbXSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgZm9yIChjb25zdCB2YWwgb2YgdmFsdWVzKSBhd2FpdCB0aGlzLmluc2VydE9uZSh2YWwpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZmluZCh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTx7XHJcbiAgICBzdWNjZXNzOiBib29sZWFuO1xyXG4gICAgbm9kZTogQmluYXJ5Tm9kZSB8IG51bGw7XHJcbiAgfT4ge1xyXG4gICAgaWYgKCF0aGlzLnRyZWVSb290KSB7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UoXCJnZW5lcmFsLmVtcHR5XCIpO1xyXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbm9kZTogbnVsbCB9O1xyXG4gICAgfVxyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcImZpbmQuc3RhcnRcIiwgdmFsdWUpO1xyXG4gICAgY29uc3QgZm91bmQgPSBhd2FpdCB0aGlzLmZpbmRIZWxwZXIodmFsdWUpO1xyXG4gICAgZm91bmQubm9kZT8uc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgY29uc3QgcGF0aCA9IGZvdW5kLnN1Y2Nlc3MgPyBcImZpbmQuZm91bmRcIiA6IFwiZmluZC5ub3Rmb3VuZFwiO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShwYXRoLCB2YWx1ZSk7XHJcbiAgICBmb3VuZC5ub2RlPy5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgcmV0dXJuIGZvdW5kO1xyXG4gIH1cclxuXHJcbiAgLy8gVE9ETzogRml4IHNvIHRoYXQgd2Uga25vdyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gYSBub2RlXHJcbiAgLy8gVE9ETzogQ2hhbmdlIHN1Y2Nlc3MgdG8gZm91bmQgYmVjYXVzZSB3ZSBhbHdheXMgZmluZCBzb21ldGhpbmdcclxuICBhc3luYyBmaW5kSGVscGVyKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPFxyXG4gICAgfCB7XHJcbiAgICAgICAgc3VjY2VzczogdHJ1ZTtcclxuICAgICAgICBub2RlOiBCaW5hcnlOb2RlO1xyXG4gICAgICB9XHJcbiAgICB8IHtcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZTtcclxuICAgICAgICBub2RlOiBCaW5hcnlOb2RlIHwgbnVsbDtcclxuICAgICAgfVxyXG4gID4ge1xyXG4gICAgbGV0IHBhcmVudDogQmluYXJ5Tm9kZSB8IG51bGwgPSBudWxsO1xyXG4gICAgbGV0IG5vZGU6IEJpbmFyeU5vZGUgfCBudWxsID0gdGhpcy50cmVlUm9vdDtcclxuICAgIGNvbnN0IHBvaW50ZXIgPSB0aGlzLlN2Zy5oaWdobGlnaHRDaXJjbGUoXHJcbiAgICAgIG5vZGU/LmN4KCkgfHwgMCxcclxuICAgICAgbm9kZT8uY3koKSB8fCAwLFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICApO1xyXG4gICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgbm9kZS5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICAgIGNvbnN0IGNtcCA9IGNvbXBhcmUodmFsdWUsIG5vZGUuZ2V0VGV4dCgpKTtcclxuICAgICAgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgIHBvaW50ZXIucmVtb3ZlKCk7XHJcbiAgICAgICAgbm9kZS5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIG5vZGU6IG5vZGUgfTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBjbXAgPCAwID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCI7XHJcbiAgICAgIG5vZGUuc2V0Q2hpbGRIaWdobGlnaHQoZGlyZWN0aW9uLCB0cnVlKTtcclxuICAgICAgcGFyZW50ID0gbm9kZTtcclxuICAgICAgbm9kZSA9IHBhcmVudC5nZXRDaGlsZChkaXJlY3Rpb24pO1xyXG4gICAgICBpZiAobm9kZSlcclxuICAgICAgICBwb2ludGVyLnNldENlbnRlcihub2RlLmN4KCksIG5vZGUuY3koKSwgdGhpcy5nZXRBbmltYXRpb25TcGVlZCgpKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZShcImZpbmQubG9va1wiLCBkaXJlY3Rpb24pO1xyXG4gICAgICBwYXJlbnQuc2V0Q2hpbGRIaWdobGlnaHQoZGlyZWN0aW9uLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBwb2ludGVyLnJlbW92ZSgpO1xyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG5vZGU6IHBhcmVudCB9O1xyXG4gIH1cclxuXHJcbiAgLy8gVE9ETzogQ291bGQgYmUgY2hhbmdlZCB0byBvbmx5IHJldHVybiB0aGUgc3VjY2VzcyBwYXJ0XHJcbiAgYXN5bmMgaW5zZXJ0T25lKHZhbHVlOiBzdHJpbmcpOiBQcm9taXNlPHtcclxuICAgIHN1Y2Nlc3M6IGJvb2xlYW47XHJcbiAgICBub2RlOiBCaW5hcnlOb2RlIHwgbnVsbDtcclxuICB9PiB7XHJcbiAgICBpZiAoIXRoaXMudHJlZVJvb3QpIHtcclxuICAgICAgdGhpcy50cmVlUm9vdCA9IHRoaXMubmV3Tm9kZSh2YWx1ZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UoXCJpbnNlcnQubmV3cm9vdFwiLCB2YWx1ZSk7XHJcbiAgICAgIHRoaXMucmVzaXplVHJlZSgpO1xyXG4gICAgICBhd2FpdCB0aGlzLnBhdXNlKHVuZGVmaW5lZCk7XHJcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIG5vZGU6IHRoaXMudHJlZVJvb3QgfTtcclxuICAgIH1cclxuXHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwiaW5zZXJ0LnNlYXJjaFwiLCB2YWx1ZSk7XHJcbiAgICBjb25zdCBmb3VuZCA9IGF3YWl0IHRoaXMuZmluZEhlbHBlcih2YWx1ZSk7XHJcbiAgICBpZiAoZm91bmQuc3VjY2Vzcykge1xyXG4gICAgICBmb3VuZC5ub2RlPy5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UoXCJpbnNlcnQuZXhpc3RzXCIsIGZvdW5kLm5vZGUpO1xyXG4gICAgICBmb3VuZC5ub2RlPy5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbm9kZTogZm91bmQubm9kZSB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgY2hpbGQgPSB0aGlzLm5ld05vZGUodmFsdWUpO1xyXG4gICAgY29uc3QgY21wID0gY29tcGFyZSh2YWx1ZSwgZm91bmQubm9kZT8uZ2V0VGV4dCgpIHx8IFwiXCIpO1xyXG4gICAgY29uc3QgZGlyZWN0aW9uID0gY21wIDwgMCA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xyXG4gICAgZm91bmQubm9kZT8uc2V0Q2hpbGQoZGlyZWN0aW9uLCBjaGlsZCwgdGhpcy5nZXRTdHJva2VXaWR0aCgpKTtcclxuICAgIGNoaWxkLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgIGZvdW5kLm5vZGU/LnNldENoaWxkSGlnaGxpZ2h0KGRpcmVjdGlvbiwgdHJ1ZSk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwiaW5zZXJ0LmNoaWxkXCIsIHZhbHVlLCBkaXJlY3Rpb24pO1xyXG4gICAgZm91bmQubm9kZT8uc2V0Q2hpbGRIaWdobGlnaHQoZGlyZWN0aW9uLCBmYWxzZSk7XHJcbiAgICBjaGlsZC5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgdGhpcy5yZXNpemVUcmVlKCk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKHVuZGVmaW5lZCk7XHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBub2RlOiBjaGlsZCB9O1xyXG4gIH1cclxuXHJcbiAgLy8gVE9ETzogdXBkYXRlIHR5cGUgd2l0aCBzZXBhcmF0ZSBmb3Igc3VjY2VzcyB0cnVlIGFuZCBmYWxzZVxyXG4gIGFzeW5jIGRlbGV0ZSh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogUHJvbWlzZTx7XHJcbiAgICBzdWNjZXNzOiBib29sZWFuO1xyXG4gICAgZGlyZWN0aW9uOiBcImxlZnRcIiB8IFwicmlnaHRcIiB8IG51bGw7XHJcbiAgICBwYXJlbnQ6IEJpbmFyeU5vZGUgfCBudWxsO1xyXG4gIH0gfCBudWxsPiB7XHJcbiAgICBpZiAoIXRoaXMudHJlZVJvb3QpIHtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZShcImdlbmVyYWwuZW1wdHlcIik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcImRlbGV0ZS5zZWFyY2hcIiwgdmFsdWUpO1xyXG4gICAgY29uc3QgZm91bmQgPSBhd2FpdCB0aGlzLmZpbmRIZWxwZXIodmFsdWUpO1xyXG4gICAgaWYgKCFmb3VuZC5zdWNjZXNzKSB7XHJcbiAgICAgIGZvdW5kLm5vZGU/LnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZShcImRlbGV0ZS5ub3RleGlzdHNcIiwgdmFsdWUpO1xyXG4gICAgICBmb3VuZC5ub2RlPy5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgICBjb25zdCBkaXJlY3Rpb24gPVxyXG4gICAgICAgIGNvbXBhcmUodmFsdWUsIGZvdW5kLm5vZGU/LmdldFRleHQoKSB8fCBcIlwiKSA8IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGRpcmVjdGlvbjogZGlyZWN0aW9uLCBwYXJlbnQ6IGZvdW5kLm5vZGUgfTtcclxuICAgIH1cclxuICAgIGZvdW5kLm5vZGU/LnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UoXCJkZWxldGUuZm91bmRcIiwgdmFsdWUpO1xyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGVsZXRlSGVscGVyKGZvdW5kLm5vZGUpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZGVsZXRlSGVscGVyKG5vZGU6IEJpbmFyeU5vZGUgfCBudWxsKTogUHJvbWlzZTx7XHJcbiAgICBzdWNjZXNzOiBib29sZWFuO1xyXG4gICAgZGlyZWN0aW9uOiBcImxlZnRcIiB8IFwicmlnaHRcIiB8IG51bGw7XHJcbiAgICBwYXJlbnQ6IEJpbmFyeU5vZGUgfCBudWxsO1xyXG4gIH0+IHtcclxuICAgIGlmICghKG5vZGU/LmdldExlZnQoKSAmJiBub2RlPy5nZXRSaWdodCgpKSkge1xyXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5kZWxldGVOb2RlKG5vZGUpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcG9pbnRlciA9IHRoaXMuU3ZnLmhpZ2hsaWdodENpcmNsZShcclxuICAgICAgbm9kZS5jeCgpLFxyXG4gICAgICBub2RlLmN5KCksXHJcbiAgICAgIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpLFxyXG4gICAgICB0aGlzLmdldFN0cm9rZVdpZHRoKClcclxuICAgICk7XHJcbiAgICBub2RlLnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICBub2RlLmFkZENsYXNzKFwibWFya2VkXCIpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcImRlbGV0ZS5wcmVkZWNlc3Nvci5zZWFyY2hcIiwgbm9kZSk7XHJcblxyXG4gICAgbGV0IHByZWRlY2Vzc29yID0gbm9kZS5nZXRMZWZ0KCk7XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICBwcmVkZWNlc3Nvcj8uc2V0UGFyZW50SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgICBwb2ludGVyLnNldENlbnRlcihcclxuICAgICAgICBwcmVkZWNlc3Nvcj8uY3goKSB8fCAwLFxyXG4gICAgICAgIHByZWRlY2Vzc29yPy5jeSgpIHx8IDAsXHJcbiAgICAgICAgdGhpcy5nZXRBbmltYXRpb25TcGVlZCgpXHJcbiAgICAgICk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgICAgcHJlZGVjZXNzb3I/LnNldFBhcmVudEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICAgIGlmICghcHJlZGVjZXNzb3I/LmdldFJpZ2h0KCkpIGJyZWFrO1xyXG4gICAgICBwcmVkZWNlc3NvciA9IHByZWRlY2Vzc29yLmdldFJpZ2h0KCk7XHJcbiAgICB9XHJcbiAgICBwcmVkZWNlc3Nvcj8uc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgcG9pbnRlci5yZW1vdmUoKTtcclxuICAgIGNvbnN0IG5ld1RleHQgPSBwcmVkZWNlc3Nvcj8uZ2V0VGV4dCgpO1xyXG4gICAgY29uc3QgbW92aW5nID0gdGhpcy5TdmcudGV4dENpcmNsZShcclxuICAgICAgbmV3VGV4dCB8fCBcIlwiLFxyXG4gICAgICBwcmVkZWNlc3Nvcj8uY3goKSB8fCAwLFxyXG4gICAgICBwcmVkZWNlc3Nvcj8uY3koKSB8fCAwLFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICApO1xyXG4gICAgbW92aW5nLmFkZENsYXNzKFwidW5maWxsZWRcIik7XHJcbiAgICBtb3Zpbmcuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcImRlbGV0ZS5wcmVkZWNlc3Nvci5yZXBsYWNlXCIsIG5vZGUsIHByZWRlY2Vzc29yKTtcclxuICAgIG1vdmluZy5zZXRDZW50ZXIobm9kZS5jeCgpLCBub2RlLmN5KCksIHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKSk7XHJcbiAgICBub2RlLnNldFRleHQoXCJcIik7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKHVuZGVmaW5lZCk7XHJcbiAgICBub2RlLnNldFRleHQobmV3VGV4dCB8fCBcIlwiKTtcclxuICAgIG1vdmluZy5yZW1vdmUoKTtcclxuICAgIG5vZGUucmVtb3ZlQ2xhc3MoXCJtYXJrZWRcIik7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZGVsZXRlLnByZWRlY2Vzc29yLmRlbGV0ZVwiLCBwcmVkZWNlc3Nvcik7XHJcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kZWxldGVOb2RlKHByZWRlY2Vzc29yKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGRlbGV0ZU5vZGUobm9kZTogQmluYXJ5Tm9kZSB8IG51bGwgfCB1bmRlZmluZWQpOiBQcm9taXNlPHtcclxuICAgIHN1Y2Nlc3M6IGJvb2xlYW47XHJcbiAgICBkaXJlY3Rpb246IFwibGVmdFwiIHwgXCJyaWdodFwiIHwgbnVsbDtcclxuICAgIHBhcmVudDogQmluYXJ5Tm9kZSB8IG51bGw7XHJcbiAgfT4ge1xyXG4gICAgLy8gVGhlIG5vZGUgd2lsbCBOT1QgaGF2ZSB0d28gY2hpbGRyZW4gLSB0aGlzIGhhcyBiZWVuIHRha2VuIGNhcmUgb2YgYnkgZGVsZXRlSGVscGVyXHJcbiAgICBjb25zdCBjaGlsZCA9IG5vZGU/LmdldExlZnQoKSB8fCBub2RlPy5nZXRSaWdodCgpO1xyXG4gICAgY29uc3QgcGFyZW50ID0gbm9kZT8uZ2V0UGFyZW50KCk7XHJcbiAgICBpZiAoIXBhcmVudCkge1xyXG4gICAgICBpZiAoIWNoaWxkKSB7XHJcbiAgICAgICAgdGhpcy50cmVlUm9vdCA9IG51bGw7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wYXVzZShcImRlbGV0ZS5yb290LnNpbmdsZXRvblwiLCBub2RlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnRyZWVSb290ID0gY2hpbGQ7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wYXVzZShcImRlbGV0ZS5yb290Lm9uZWNoaWxkXCIsIGNoaWxkLCBub2RlKTtcclxuICAgICAgfVxyXG4gICAgICBub2RlPy5yZW1vdmUoKTtcclxuICAgICAgdGhpcy5yZXNpemVUcmVlKCk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGlyZWN0aW9uOiBudWxsLCBwYXJlbnQ6IG51bGwgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBwYXJlbnQuZ2V0TGVmdCgpID09PSBub2RlID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCI7XHJcbiAgICBpZiAoY2hpbGQpIHtcclxuICAgICAgbm9kZT8uc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgICAgaWYgKGNoaWxkID09PSBwYXJlbnQuZ2V0TGVmdCgpPy5nZXRMZWZ0KCkpXHJcbiAgICAgICAgbm9kZT8uZG1vdmVDZW50ZXIoXHJcbiAgICAgICAgICAtbm9kZS5nZXRTaXplKCksXHJcbiAgICAgICAgICAtbm9kZS5nZXRTaXplKCkgLyAyLFxyXG4gICAgICAgICAgdGhpcy5nZXRBbmltYXRpb25TcGVlZCgpXHJcbiAgICAgICAgKTtcclxuICAgICAgaWYgKGNoaWxkID09PSBwYXJlbnQuZ2V0UmlnaHQoKT8uZ2V0UmlnaHQoKSlcclxuICAgICAgICBub2RlPy5kbW92ZUNlbnRlcihcclxuICAgICAgICAgIG5vZGUuZ2V0U2l6ZSgpLFxyXG4gICAgICAgICAgLW5vZGUuZ2V0U2l6ZSgpIC8gMixcclxuICAgICAgICAgIHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKVxyXG4gICAgICAgICk7XHJcbiAgICAgIHBhcmVudC5zZXRDaGlsZChkaXJlY3Rpb24sIGNoaWxkLCB0aGlzLmdldFN0cm9rZVdpZHRoKCkpO1xyXG4gICAgICBjaGlsZC5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICAgIHBhcmVudC5zZXRDaGlsZEhpZ2hsaWdodChkaXJlY3Rpb24sIHRydWUpO1xyXG4gICAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZGVsZXRlLnJlZGlyZWN0XCIsIHBhcmVudCwgY2hpbGQpO1xyXG4gICAgICBwYXJlbnQuc2V0Q2hpbGRIaWdobGlnaHQoZGlyZWN0aW9uLCBmYWxzZSk7XHJcbiAgICAgIGNoaWxkLnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICAgIG5vZGU/LnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZShcImRlbGV0ZS5ub2RlXCIsIG5vZGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZShcImRlbGV0ZS5sZWFmXCIsIG5vZGUpO1xyXG4gICAgfVxyXG4gICAgbm9kZT8ucmVtb3ZlKCk7XHJcbiAgICB0aGlzLnJlc2l6ZVRyZWUoKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRpcmVjdGlvbjogZGlyZWN0aW9uLCBwYXJlbnQ6IHBhcmVudCB9O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcHJpbnQoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAoIXRoaXMudHJlZVJvb3QpIHtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZShcImdlbmVyYWwuZW1wdHlcIik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy5JbmZvLnByaW50ZXI/LmJib3goKSB8fCB7IHg6IDAsIHk6IDAgfTtcclxuICAgIGNvbnN0IHByaW50ZWQgPSBbXHJcbiAgICAgIHRoaXMuU3ZnLnRleHQoXCJQcmludGVkIG5vZGVzOiBcIikuYWRkQ2xhc3MoXCJwcmludGVyXCIpLngoeCkueSh5KSxcclxuICAgIF07XHJcbiAgICBjb25zdCBwb2ludGVyID0gdGhpcy5TdmcuaGlnaGxpZ2h0Q2lyY2xlKFxyXG4gICAgICAuLi50aGlzLmdldE5vZGVTdGFydCgpLFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICApO1xyXG4gICAgYXdhaXQgdGhpcy5wcmludEhlbHBlcih0aGlzLnRyZWVSb290LCBwb2ludGVyLCBwcmludGVkKTtcclxuICAgIHBvaW50ZXIucmVtb3ZlKCk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKHVuZGVmaW5lZCk7XHJcbiAgICBmb3IgKGNvbnN0IGxibCBvZiBwcmludGVkKSBsYmwucmVtb3ZlKCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBwcmludEhlbHBlcihcclxuICAgIG5vZGU6IEJpbmFyeU5vZGUsXHJcbiAgICBwb2ludGVyOiBIaWdobGlnaHRDaXJjbGUsXHJcbiAgICBwcmludGVkOiBUZXh0W11cclxuICApOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHBvaW50ZXIuc2V0Q2VudGVyKG5vZGUuY3goKSwgbm9kZS5jeSgpLCB0aGlzLmdldEFuaW1hdGlvblNwZWVkKCkpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgaWYgKG5vZGUuZ2V0TGVmdCgpKSB7XHJcbiAgICAgIGF3YWl0IHRoaXMucHJpbnRIZWxwZXIobm9kZS5nZXRMZWZ0KCkhLCBwb2ludGVyLCBwcmludGVkKTsgLy8gISBCZWNhdXNlIGNoZWNrZWQgYWJvdmVcclxuICAgICAgcG9pbnRlci5zZXRDZW50ZXIobm9kZS5jeCgpLCBub2RlLmN5KCksIHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKSk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxibCA9IHRoaXMuU3ZnLnRleHQobm9kZS5nZXRUZXh0KCkpLmNlbnRlcihub2RlLmN4KCksIG5vZGUuY3koKSk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKHVuZGVmaW5lZCk7XHJcbiAgICBjb25zdCBsYXN0ID0gcHJpbnRlZFtwcmludGVkLmxlbmd0aCAtIDFdO1xyXG4gICAgY29uc3Qgc3BhY2luZyA9IHRoaXMuZ2V0Tm9kZVNwYWNpbmcoKSAvIDI7XHJcbiAgICB0aGlzLmFuaW1hdGUobGJsKVxyXG4gICAgICAuY3kobGFzdC5jeSgpKVxyXG4gICAgICAueChsYXN0LmJib3goKS54MiArIHNwYWNpbmcpO1xyXG4gICAgcHJpbnRlZC5wdXNoKGxibCk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKHVuZGVmaW5lZCk7XHJcbiAgICBpZiAobm9kZS5nZXRSaWdodCgpKSB7XHJcbiAgICAgIGF3YWl0IHRoaXMucHJpbnRIZWxwZXIobm9kZS5nZXRSaWdodCgpISwgcG9pbnRlciwgcHJpbnRlZCk7XHJcbiAgICAgIHRoaXMuYW5pbWF0ZShwb2ludGVyKTsgLy8gVGVtcG9yYXJ5IHVudGlsIHdlIGZpbmQgYSB3YXkgdG8gYW5pbWF0ZSBzZXRDZW50ZXJcclxuICAgICAgcG9pbnRlci5zZXRDZW50ZXIobm9kZS5jeCgpLCBub2RlLmN5KCksIHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKSk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyBSb3RhdGUgdGhlIHRyZWVcclxuICAvLyBUaGVzZSBhcmUgbm90IHVzZWQgYnkgQlNULCBidXQgYnkgc2VsZi1iYWxhbmNpbmcgc3ViY2xhc3Nlc1xyXG4gIC8vIFRoZSBmb2xsb3dpbmcgcm90YXRpb25zIGFyZSBpbXBsZW1lbnRlZDpcclxuICAvLyAgLSBTaW5nbGUgUm90YXRlOiBMZWZ0IGFuZCBSaWdodCAoYWxzbyBrbm93biBhcyBaaWcpXHJcbiAgLy8gIC0gRG91YmxlIFJvdGF0ZTogTGVmdC1SaWdodCBhbmQgUmlnaHQtTGVmdCAoYWxzbyBrbm93biBhcyBaaWctWmFnKVxyXG5cclxuICBhc3luYyByZXNldEhlaWdodChub2RlOiB1bmtub3duKSB7XHJcbiAgICAvLyBCU1RzIGRvIG5vdCBzdG9yZSB0aGUgaGVpZ2h0IGluIHRoZSBub2Rlcywgc28gZG8gbm90aGluZ1xyXG4gICAgLy8gVGhpcyBpcyBpbXBsZW1lbnRlZCBieSwgZS5nLiwgQVZMIHRyZWVzXHJcbiAgfVxyXG5cclxuICBhc3luYyBkb3VibGVSb3RhdGUoXHJcbiAgICBmaXJzdERpcjogXCJsZWZ0XCIgfCBcInJpZ2h0XCIsXHJcbiAgICBub2RlOiBCaW5hcnlOb2RlXHJcbiAgKTogUHJvbWlzZTxCaW5hcnlOb2RlPiB7XHJcbiAgICAvLyBOb3RlOiAnbGVmdCcgYW5kICdyaWdodCcgYXJlIHZhcmlhYmxlcyB0aGF0IGNhbiBoYXZlIHZhbHVlcyBcImxlZnRcIiBvciBcInJpZ2h0XCIhXHJcbiAgICBjb25zdCBzZWNvbmREaXIgPSBmaXJzdERpciA9PT0gXCJsZWZ0XCIgPyBcInJpZ2h0XCIgOiBcImxlZnRcIjtcclxuICAgIGNvbnN0IGNoaWxkID0gbm9kZS5nZXRDaGlsZChzZWNvbmREaXIpO1xyXG5cclxuICAgIGlmIChjaGlsZCA9PT0gdW5kZWZpbmVkIHx8IGNoaWxkID09PSBudWxsKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEIgbm9kZSBpbiBzaW5nbGVSb3RhdGVcIik7XHJcblxyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcInJvdGF0ZS56aWd6YWdcIiwgY2hpbGQsIHNlY29uZERpciwgbm9kZSwgZmlyc3REaXIpO1xyXG4gICAgYXdhaXQgdGhpcy5zaW5nbGVSb3RhdGUoc2Vjb25kRGlyLCBjaGlsZCk7XHJcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zaW5nbGVSb3RhdGUoZmlyc3REaXIsIG5vZGUpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc2luZ2xlUm90YXRlKFxyXG4gICAgZmlyc3REaXI6IFwibGVmdFwiIHwgXCJyaWdodFwiLFxyXG4gICAgbm9kZTogQmluYXJ5Tm9kZVxyXG4gICk6IFByb21pc2U8QmluYXJ5Tm9kZT4ge1xyXG4gICAgLy8gTm90ZTogJ2xlZnQnIGFuZCAncmlnaHQnIGFyZSB2YXJpYWJsZXMgdGhhdCBjYW4gaGF2ZSB2YWx1ZXMgXCJsZWZ0XCIgb3IgXCJyaWdodFwiIVxyXG4gICAgLy8gU28sIGlmIGxlZnQ9PT1cInJpZ2h0XCIsIHRoZW4gd2Ugcm90YXRlIHJpZ2h0LlxyXG4gICAgY29uc3Qgc2Vjb25kRGlyID0gZmlyc3REaXIgPT09IFwibGVmdFwiID8gXCJyaWdodFwiIDogXCJsZWZ0XCI7XHJcblxyXG4gICAgY29uc3QgQSA9IG5vZGU7XHJcbiAgICBjb25zdCBCID0gQS5nZXRDaGlsZChzZWNvbmREaXIpO1xyXG5cclxuICAgIGlmIChCID09PSB1bmRlZmluZWQgfHwgQiA9PT0gbnVsbClcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBCIG5vZGUgaW4gc2luZ2xlUm90YXRlXCIpO1xyXG5cclxuICAgIGNvbnN0IEMgPSBCLmdldENoaWxkKGZpcnN0RGlyKTtcclxuXHJcbiAgICBBLnNldENoaWxkSGlnaGxpZ2h0KHNlY29uZERpciwgdHJ1ZSk7XHJcbiAgICBCPy5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwicm90YXRlLnNpbmdsZVwiLCBBLCBmaXJzdERpcik7XHJcblxyXG4gICAgY29uc3QgcGFyZW50ID0gQS5nZXRQYXJlbnQoKTtcclxuICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgY29uc3QgZGlyZWN0aW9uID0gcGFyZW50LmdldExlZnQoKSA9PT0gQSA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xyXG4gICAgICBCPy5zZXRQYXJlbnQoZGlyZWN0aW9uLCBwYXJlbnQsIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnRyZWVSb290ID0gQjtcclxuICAgIH1cclxuICAgIEEuc2V0Q2hpbGQoc2Vjb25kRGlyLCBDIGFzIEJpbmFyeU5vZGUsIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKSk7XHJcbiAgICBCLnNldENoaWxkKGZpcnN0RGlyLCBBLCB0aGlzLmdldFN0cm9rZVdpZHRoKCkpO1xyXG5cclxuICAgIEIuc2V0Q2hpbGRIaWdobGlnaHQoZmlyc3REaXIsIHRydWUpO1xyXG4gICAgQS5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKHVuZGVmaW5lZCk7XHJcbiAgICB0aGlzLnJlc2l6ZVRyZWUoKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuXHJcbiAgICBCLnNldENoaWxkSGlnaGxpZ2h0KGZpcnN0RGlyLCBmYWxzZSk7XHJcbiAgICBBLnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICBhd2FpdCB0aGlzLnJlc2V0SGVpZ2h0KEEpO1xyXG4gICAgYXdhaXQgdGhpcy5yZXNldEhlaWdodChCKTtcclxuICAgIHJldHVybiBCO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IEJTVE1lc3NhZ2VzID0ge1xyXG4gIGdlbmVyYWw6IHtcclxuICAgIGVtcHR5OiBcIlRyZWUgaXMgZW1wdHlcIixcclxuICB9LFxyXG4gIGZpbmQ6IHtcclxuICAgIHN0YXJ0OiAodmFsdWU6IHN0cmluZykgPT4gYFNlYXJjaGluZyBmb3IgJHt2YWx1ZX1gLFxyXG4gICAgZm91bmQ6ICh2YWx1ZTogc3RyaW5nKSA9PiBgRm91bmQgJHt2YWx1ZX1gLFxyXG4gICAgbm90Zm91bmQ6ICh2YWx1ZTogc3RyaW5nKSA9PiBgRGlkIG5vdCBmaW5kICR7dmFsdWV9YCxcclxuICAgIGxvb2s6IChkaXJlY3Rpb246IFwibGVmdFwiIHwgXCJyaWdodFwiKSA9PiBgTG9vayBpbnRvICR7ZGlyZWN0aW9ufSBjaGlsZGAsXHJcbiAgfSxcclxuICBpbnNlcnQ6IHtcclxuICAgIG5ld3Jvb3Q6ICh2YWx1ZTogc3RyaW5nKSA9PiBgQ3JlYXRlIGEgbmV3IHRyZWUgcm9vdCAke3ZhbHVlfWAsXHJcbiAgICBzZWFyY2g6ICh2YWx1ZTogc3RyaW5nKSA9PiBgU2VhcmNoaW5nIGZvciBub2RlIHRvIGluc2VydCAke3ZhbHVlfWAsXHJcbiAgICBleGlzdHM6IChub2RlOiBzdHJpbmcpID0+IGBUaGVyZSBpcyBhbHJlYWR5IGEgbm9kZSAke25vZGV9YCxcclxuICAgIGNoaWxkOiAodmFsdWU6IHN0cmluZywgZGlyZWN0aW9uOiBcImxlZnRcIiB8IFwicmlnaHRcIikgPT5cclxuICAgICAgYEluc2VydCAke3ZhbHVlfSBhcyAke2RpcmVjdGlvbn0gY2hpbGRgLFxyXG4gIH0sXHJcbiAgZGVsZXRlOiB7XHJcbiAgICBzZWFyY2g6ICh2YWx1ZTogc3RyaW5nKSA9PiBgU2VhcmNoaW5nIGZvciBub2RlIHRvIGRlbGV0ZSAke3ZhbHVlfWAsXHJcbiAgICBub3RleGlzdHM6ICh2YWx1ZTogc3RyaW5nKSA9PiBgVGhlcmUgaXMgbm8gbm9kZSAke3ZhbHVlfWAsXHJcbiAgICBmb3VuZDogKHZhbHVlOiBzdHJpbmcpID0+IGBGb3VuZCBub2RlICR7dmFsdWV9IHRvIGRlbGV0ZWAsXHJcbiAgICBwcmVkZWNlc3Nvcjoge1xyXG4gICAgICBzZWFyY2g6IChub2RlOiBzdHJpbmcpID0+IGBGaW5kaW5nIHRoZSBwcmVkZWNlc3NvciBub2RlIG9mICR7bm9kZX1gLFxyXG4gICAgICByZXBsYWNlOiAobm9kZTogc3RyaW5nLCBwcmVkZWNlc3Nvcjogc3RyaW5nKSA9PlxyXG4gICAgICAgIGBSZXBsYWNlIHRoZSB2YWx1ZSBvZiAke25vZGV9IHdpdGggJHtwcmVkZWNlc3Nvcn1gLFxyXG4gICAgICBkZWxldGU6IChwcmVkZWNlc3Nvcjogc3RyaW5nKSA9PlxyXG4gICAgICAgIGBOb3cgZGVsZXRlIHRoZSBwcmVkZWNlc3NvciAke3ByZWRlY2Vzc29yfWAsXHJcbiAgICB9LFxyXG4gICAgcmVkaXJlY3Q6IChwYXJlbnQ6IHN0cmluZywgY2hpbGQ6IHN0cmluZykgPT5cclxuICAgICAgYFJlZGlyZWN0IHBhcmVudCAke3BhcmVudH0gdG8gY2hpbGQgJHtjaGlsZH1gLFxyXG4gICAgcm9vdDoge1xyXG4gICAgICBzaW5nbGV0b246IChyb290OiBzdHJpbmcpID0+IGBSZW1vdmUgdGhlIHJvb3Qgbm9kZSAke3Jvb3R9YCxcclxuICAgICAgb25lY2hpbGQ6IChjaGlsZDogc3RyaW5nLCByb290OiBzdHJpbmcpID0+IFtcclxuICAgICAgICBgTWFrZSB0aGUgY2hpbGQgJHtjaGlsZH0gdGhlIG5ldyByb290LGAsXHJcbiAgICAgICAgYGFuZCByZW1vdmUgbm9kZSAke3Jvb3R9YCxcclxuICAgICAgXSxcclxuICAgIH0sXHJcbiAgICBub2RlOiAobm9kZTogc3RyaW5nKSA9PiBgUmVtb3ZlIG5vZGUgJHtub2RlfWAsXHJcbiAgICBsZWFmOiAobm9kZTogc3RyaW5nKSA9PiBgUmVtb3ZlIGxlYWYgbm9kZSAke25vZGV9YCxcclxuICB9LFxyXG4gIHJvdGF0ZToge1xyXG4gICAgc2luZ2xlOiAobm9kZTogc3RyaW5nLCBkaXI6IFwibGVmdFwiIHwgXCJyaWdodFwiKSA9PiBgUm90YXRlICR7bm9kZX0gJHtkaXJ9YCxcclxuICAgIHppZ3phZzogKFxyXG4gICAgICBjaGlsZDogc3RyaW5nLFxyXG4gICAgICBkaXIxOiBcImxlZnRcIiB8IFwicmlnaHRcIixcclxuICAgICAgbm9kZTogc3RyaW5nLFxyXG4gICAgICBkaXIyOiBcImxlZnRcIiB8IFwicmlnaHRcIlxyXG4gICAgKSA9PiBgWmlnLXphZzogUm90YXRlICR7Y2hpbGR9ICR7ZGlyMX0sIHRoZW4gcm90YXRlICR7bm9kZX0gJHtkaXIyfWAsXHJcbiAgfSxcclxufSBhcyBjb25zdDtcclxuIiwiaW1wb3J0IHsgdXBkYXRlRGVmYXVsdCB9IGZyb20gXCIuLi8uLi9zcmMvZW5naW5lXCI7XHJcbmltcG9ydCB7IEFWTE5vZGUgfSBmcm9tIFwiLi4vLi4vc3JjL29iamVjdHMvYXZsLW5vZGVcIjtcclxuaW1wb3J0IHsgSGlnaGxpZ2h0Q2lyY2xlIH0gZnJvbSBcIi4uLy4uL3NyYy9vYmplY3RzL2hpZ2hsaWdodC1jaXJjbGVcIjtcclxuaW1wb3J0IHsgQlNULCBCU1RNZXNzYWdlcyB9IGZyb20gXCIuL0JTVFwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFWTCBleHRlbmRzIEJTVCB7XHJcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIGZpeCBtZXNzYWdlIHR5cGluZ1xyXG4gIG1lc3NhZ2VzID0gdXBkYXRlRGVmYXVsdChBVkxtZXNzYWdlcywgQlNUTWVzc2FnZXMpO1xyXG4gIHRyZWVSb290OiBBVkxOb2RlIHwgbnVsbCA9IG51bGw7XHJcbiAgcG9pbnRlcjogSGlnaGxpZ2h0Q2lyY2xlIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIG5ld05vZGUodGV4dDogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gdGhpcy5TdmcuYXZsTm9kZShcclxuICAgICAgdGV4dCxcclxuICAgICAgLi4udGhpcy5nZXROb2RlU3RhcnQoKSxcclxuICAgICAgdGhpcy5nZXRPYmplY3RTaXplKCksXHJcbiAgICAgIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGdldEhlaWdodChub2RlOiBBVkxOb2RlIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIG5vZGUgPyBub2RlLmdldEhlaWdodCgpIDogMDtcclxuICB9XHJcblxyXG4gIGFzeW5jIGluc2VydE9uZSh2YWx1ZTogc3RyaW5nKTogUHJvbWlzZTx7XHJcbiAgICBzdWNjZXNzOiBib29sZWFuO1xyXG4gICAgbm9kZTogQVZMTm9kZSB8IG51bGw7XHJcbiAgfT4ge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VwZXIuaW5zZXJ0T25lKHZhbHVlKTtcclxuICAgIGlmIChyZXN1bHQuc3VjY2VzcyAmJiByZXN1bHQubm9kZSkge1xyXG4gICAgICAocmVzdWx0Lm5vZGUgYXMgQVZMTm9kZSkudXBkYXRlSGVpZ2h0UG9zaXRpb24oKTtcclxuICAgICAgYXdhaXQgdGhpcy51cGRhdGVIZWlnaHRzKHJlc3VsdC5ub2RlIGFzIEFWTE5vZGUsIHVuZGVmaW5lZCk7XHJcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlSGVpZ2h0UG9zaXRpb25zKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0IGFzIHtcclxuICAgICAgc3VjY2VzczogYm9vbGVhbjtcclxuICAgICAgbm9kZTogQVZMTm9kZSB8IG51bGw7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZGVsZXRlKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN1cGVyLmRlbGV0ZSh2YWx1ZSk7XHJcbiAgICBpZiAocmVzdWx0Py5zdWNjZXNzKSB7XHJcbiAgICAgIGlmIChyZXN1bHQucGFyZW50KSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVIZWlnaHRzKHJlc3VsdC5wYXJlbnQgYXMgQVZMTm9kZSwgcmVzdWx0LmRpcmVjdGlvbik7XHJcbiAgICAgIH1cclxuICAgICAgYXdhaXQgdGhpcy51cGRhdGVIZWlnaHRQb3NpdGlvbnMoKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBhc3luYyB1cGRhdGVIZWlnaHRQb3NpdGlvbnMoKSB7XHJcbiAgICB0aGlzLlN2Zy5maW5kKFwiZ1wiKS5mb3JFYWNoKChub2RlKSA9PiB7XHJcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVZMTm9kZSkgbm9kZS51cGRhdGVIZWlnaHRQb3NpdGlvbigpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyB1cGRhdGVIZWlnaHRzKFxyXG4gICAgbm9kZTogQVZMTm9kZSxcclxuICAgIGZyb21jaGlsZDogXCJsZWZ0XCIgfCBcInJpZ2h0XCIgfCB1bmRlZmluZWQgfCBudWxsXHJcbiAgKSB7XHJcbiAgICBjb25zdCBjaGlsZCA9IChmcm9tY2hpbGQgJiYgbm9kZS5nZXRDaGlsZChmcm9tY2hpbGQpKSB8fCBub2RlO1xyXG4gICAgdGhpcy5wb2ludGVyID0gdGhpcy5TdmcuaGlnaGxpZ2h0Q2lyY2xlKFxyXG4gICAgICBjaGlsZC5jeCgpLFxyXG4gICAgICBjaGlsZC5jeSgpLFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICApO1xyXG4gICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgdGhpcy5wb2ludGVyLnNldENlbnRlcihub2RlLmN4KCksIG5vZGUuY3koKSwgdGhpcy5nZXRBbmltYXRpb25TcGVlZCgpKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZShcIm5vZGUudXBkYXRlSGVpZ2h0XCIpO1xyXG4gICAgICBjb25zdCBsZWZ0SGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoXHJcbiAgICAgICAgICBub2RlLmdldExlZnQoKSBhcyBBVkxOb2RlIHwgbnVsbCB8IHVuZGVmaW5lZFxyXG4gICAgICAgICksXHJcbiAgICAgICAgcmlnaHRIZWlnaHQgPSB0aGlzLmdldEhlaWdodChcclxuICAgICAgICAgIG5vZGUuZ2V0UmlnaHQoKSBhcyBBVkxOb2RlIHwgbnVsbCB8IHVuZGVmaW5lZFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCBoZWlnaHQgPSAxICsgTWF0aC5tYXgobGVmdEhlaWdodCwgcmlnaHRIZWlnaHQpO1xyXG5cclxuICAgICAgaWYgKGhlaWdodCAhPT0gdGhpcy5nZXRIZWlnaHQobm9kZSkpIHtcclxuICAgICAgICBub2RlLnNldEhlaWdodEhpZ2hsaWdodCh0cnVlKTtcclxuICAgICAgICBub2RlLnNldEhlaWdodChoZWlnaHQpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgICAgICBub2RlLnNldEhlaWdodEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG5vZGUgPSBhd2FpdCB0aGlzLnJlYmFsYW5jZShub2RlKTtcclxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIHVwZGF0ZSB0eXBlc1xyXG4gICAgICBub2RlID0gbm9kZS5nZXRQYXJlbnQoKSBhcyBBVkxOb2RlIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHRoaXMucG9pbnRlci5yZW1vdmUoKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHJlYmFsYW5jZShub2RlOiBBVkxOb2RlKSB7XHJcbiAgICBjb25zdCBsZWZ0SGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoXHJcbiAgICAgICAgbm9kZS5nZXRMZWZ0KCkgYXMgQVZMTm9kZSB8IG51bGwgfCB1bmRlZmluZWRcclxuICAgICAgKSxcclxuICAgICAgcmlnaHRIZWlnaHQgPSB0aGlzLmdldEhlaWdodChcclxuICAgICAgICBub2RlLmdldFJpZ2h0KCkgYXMgQVZMTm9kZSB8IG51bGwgfCB1bmRlZmluZWRcclxuICAgICAgKTtcclxuICAgIGlmIChNYXRoLmFicyhsZWZ0SGVpZ2h0IC0gcmlnaHRIZWlnaHQpIDw9IDEpIHJldHVybiBub2RlO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcIm5vZGUudW5iYWxhbmNlZFwiKTtcclxuICAgIGNvbnN0IGxlZnQgPSBsZWZ0SGVpZ2h0IDwgcmlnaHRIZWlnaHQgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcclxuICAgIGNvbnN0IHJpZ2h0ID0gbGVmdCA9PT0gXCJsZWZ0XCIgPyBcInJpZ2h0XCIgOiBcImxlZnRcIjtcclxuICAgIGNvbnN0IGNoaWxkID0gbm9kZS5nZXRDaGlsZChyaWdodCk7XHJcbiAgICBjb25zdCBjaGlsZExlZnQgPSB0aGlzLmdldEhlaWdodChcclxuICAgICAgICBjaGlsZD8uZ2V0Q2hpbGQobGVmdCkgYXMgQVZMTm9kZSB8IG51bGwgfCB1bmRlZmluZWRcclxuICAgICAgKSxcclxuICAgICAgY2hpbGRSaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KFxyXG4gICAgICAgIGNoaWxkPy5nZXRDaGlsZChyaWdodCkgYXMgQVZMTm9kZSB8IG51bGwgfCB1bmRlZmluZWRcclxuICAgICAgKTtcclxuICAgIHRoaXMucG9pbnRlcj8uaGlkZSgpO1xyXG4gICAgaWYgKGNoaWxkTGVmdCA8PSBjaGlsZFJpZ2h0KSB7XHJcbiAgICAgIG5vZGUgPSAoYXdhaXQgdGhpcy5zaW5nbGVSb3RhdGUobGVmdCwgbm9kZSkpIGFzIEFWTE5vZGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBub2RlID0gKGF3YWl0IHRoaXMuZG91YmxlUm90YXRlKGxlZnQsIG5vZGUpKSBhcyBBVkxOb2RlO1xyXG4gICAgfVxyXG4gICAgdGhpcy5wb2ludGVyID0gdGhpcy5TdmcuaGlnaGxpZ2h0Q2lyY2xlKFxyXG4gICAgICBub2RlLmN4KCksXHJcbiAgICAgIG5vZGUuY3koKSxcclxuICAgICAgdGhpcy5nZXRPYmplY3RTaXplKCksXHJcbiAgICAgIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKVxyXG4gICAgKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UoXCJub2RlLmJhbGFuY2VkXCIpO1xyXG4gICAgcmV0dXJuIG5vZGU7XHJcbiAgfVxyXG5cclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gUm90YXRlIHRoZSB0cmVlXHJcblxyXG4gIGFzeW5jIHJlc2V0SGVpZ2h0KG5vZGU6IEFWTE5vZGUpIHtcclxuICAgIGNvbnN0IGhlaWdodCA9XHJcbiAgICAgIDEgK1xyXG4gICAgICBNYXRoLm1heChcclxuICAgICAgICB0aGlzLmdldEhlaWdodChub2RlLmdldExlZnQoKSBhcyBBVkxOb2RlKSxcclxuICAgICAgICB0aGlzLmdldEhlaWdodChub2RlLmdldFJpZ2h0KCkgYXMgQVZMTm9kZSlcclxuICAgICAgKTtcclxuICAgIGlmIChoZWlnaHQgIT09IHRoaXMuZ2V0SGVpZ2h0KG5vZGUpKSB7XHJcbiAgICAgIG5vZGUuc2V0SGVpZ2h0KGhlaWdodCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgQVZMbWVzc2FnZXMgPSB7XHJcbiAgbm9kZToge1xyXG4gICAgdXBkYXRlSGVpZ2h0OiBcIlVwZGF0ZSBub2RlIGhlaWdodHNcIixcclxuICAgIHVuYmFsYW5jZWQ6IFwiTm9kZSBpcyB1bmJhbGFuY2VkIVwiLFxyXG4gICAgYmFsYW5jZWQ6IFwiTm9kZSBpcyBub3cgYmFsYW5jZWRcIixcclxuICB9LFxyXG59O1xyXG4iLCIvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIEltcG9ydCBhbmQgZXhwb3J0IGluZm9ybWF0aW9uIHVzZWQgYnkgdGhlIEphdmFzY3JpcHQgbGludGVyIEVTTGludDpcclxuLyogZ2xvYmFscyBEU1ZpcyAqL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5pbXBvcnQgeyBUZXh0IH0gZnJvbSBcIkBzdmdkb3Rqcy9zdmcuanNcIjtcclxuaW1wb3J0IHsgSGlnaGxpZ2h0Q2lyY2xlIH0gZnJvbSBcInNyYy9vYmplY3RzL2hpZ2hsaWdodC1jaXJjbGVcIjtcclxuaW1wb3J0IHtcclxuICBjb21wYXJlLFxyXG4gIEVuZ2luZSxcclxuICBFbmdpbmVUb29sYmFySXRlbXMsXHJcbiAgcGFyc2VWYWx1ZXMsXHJcbn0gZnJvbSBcIi4uLy4uL3NyYy9lbmdpbmVcIjtcclxuaW1wb3J0IHsgQlRyZWVOb2RlIH0gZnJvbSBcIi4uLy4uL3NyYy9vYmplY3RzL2J0cmVlLW5vZGVcIjtcclxuaW1wb3J0IHsgQlNUTWVzc2FnZXMgfSBmcm9tIFwiLi9CU1RcIjtcclxuXHJcbnR5cGUgQlRyZWVUb29sYmFySXRlbXMgPSBFbmdpbmVUb29sYmFySXRlbXMgJiB7XHJcbiAgbWF4RGVncmVlOiBIVE1MU2VsZWN0RWxlbWVudDtcclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBCVHJlZSBleHRlbmRzIEVuZ2luZSB7XHJcbiAgaW5pdGlhbFZhbHVlczogKHN0cmluZyB8IG51bWJlcilbXSA9IFtdO1xyXG4gIHRyZWVSb290OiBCVHJlZU5vZGUgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIGZpeCBtZXNzYWdlIHR5cGluZ1xyXG4gIG1lc3NhZ2VzID0ge1xyXG4gICAgLi4uQlNUTWVzc2FnZXMsXHJcbiAgICAuLi5CVHJlZU1lc3NhZ2VzLFxyXG4gICAgZmluZDoge1xyXG4gICAgICAuLi5CU1RNZXNzYWdlcy5maW5kLFxyXG4gICAgICAuLi5CVHJlZU1lc3NhZ2VzLmZpbmQsXHJcbiAgICB9LFxyXG4gICAgaW5zZXJ0OiB7XHJcbiAgICAgIC4uLkJTVE1lc3NhZ2VzLmluc2VydCxcclxuICAgICAgLi4uQlRyZWVNZXNzYWdlcy5pbnNlcnQsXHJcbiAgICB9LFxyXG4gICAgZGVsZXRlOiB7XHJcbiAgICAgIC4uLkJTVE1lc3NhZ2VzLmRlbGV0ZSxcclxuICAgICAgLi4uQlRyZWVNZXNzYWdlcy5kZWxldGUsXHJcbiAgICB9LFxyXG4gIH07XHJcblxyXG4gIHRvb2xiYXI6IEJUcmVlVG9vbGJhckl0ZW1zO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJTZWxlY3Rvcjogc3RyaW5nKSB7XHJcbiAgICBzdXBlcihjb250YWluZXJTZWxlY3Rvcik7XHJcbiAgICB0aGlzLnRvb2xiYXIgPSB0aGlzLmdldFRvb2xiYXIoKTtcclxuICB9XHJcblxyXG4gIGdldFRvb2xiYXIoKTogQlRyZWVUb29sYmFySXRlbXMge1xyXG4gICAgY29uc3QgdG9vbGJhciA9IHN1cGVyLmdldFRvb2xiYXIoKTtcclxuXHJcbiAgICB0b29sYmFyLmFsZ29yaXRobUNvbnRyb2xzLmluc2VydEFkamFjZW50SFRNTChcclxuICAgICAgXCJiZWZvcmVlbmRcIixcclxuICAgICAgYDxzcGFuIGNsYXNzPVwiZm9ybWdyb3VwXCI+PGxhYmVsPlxyXG4gICAgICAgIE1heCBkZWdyZWU6XHJcbiAgICAgICAgPHNlbGVjdCBjbGFzcz1cIm1heERlZ3JlZSBkaXNhYmxlV2hlblJ1bm5pbmdcIj5cclxuICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIzXCI+Mi8zLXRyZWU8L29wdGlvbj5cclxuICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI0XCI+Mi8zLzQtdHJlZTwvb3B0aW9uPlxyXG4gICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjVcIj5NYXggZGVncmVlIDU8L29wdGlvbj5cclxuICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI2XCI+TWF4IGRlZ3JlZSA2PC9vcHRpb24+XHJcbiAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgIDwvbGFiZWw+PC9zcGFuPmBcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgbWF4RGVncmVlID1cclxuICAgICAgdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcjxIVE1MU2VsZWN0RWxlbWVudD4oXCJzZWxlY3QubWF4RGVncmVlXCIpO1xyXG5cclxuICAgIGlmICghbWF4RGVncmVlKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBtYXggZGVncmVlIHNlbGVjdCBlbGVtZW50XCIpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIC4uLnRvb2xiYXIsXHJcbiAgICAgIG1heERlZ3JlZSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBpbml0aWFsaXNlKGluaXRpYWxWYWx1ZXMgPSBudWxsKSB7XHJcbiAgICB0aGlzLmluaXRpYWxWYWx1ZXMgPSBwYXJzZVZhbHVlcyhpbml0aWFsVmFsdWVzKTtcclxuICAgIHN1cGVyLmluaXRpYWxpc2UoKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHJlc2V0QWxnb3JpdGhtKCkge1xyXG4gICAgYXdhaXQgc3VwZXIucmVzZXRBbGdvcml0aG0oKTtcclxuICAgIHRoaXMudHJlZVJvb3QgPSBudWxsO1xyXG4gICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlcykge1xyXG4gICAgICB0aGlzLlN0YXRlLnJlc2V0dGluZyA9IHRydWU7XHJcbiAgICAgIGF3YWl0IHRoaXMuaW5zZXJ0KC4uLnRoaXMuaW5pdGlhbFZhbHVlcyk7XHJcbiAgICAgIHRoaXMuU3RhdGUucmVzZXR0aW5nID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpbml0VG9vbGJhcigpIHtcclxuICAgIHN1cGVyLmluaXRUb29sYmFyKCk7XHJcblxyXG4gICAgdGhpcy50b29sYmFyLm1heERlZ3JlZT8uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoKSA9PlxyXG4gICAgICB0aGlzLmNvbmZpcm1SZXNldEFsbCgpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgZ2V0TWF4RGVncmVlKCkge1xyXG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMudG9vbGJhci5tYXhEZWdyZWU/LnZhbHVlIHx8IFwiMFwiKTtcclxuICB9XHJcblxyXG4gIGdldE1heEtleXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRNYXhEZWdyZWUoKSAtIDE7XHJcbiAgfVxyXG5cclxuICBnZXRNaW5LZXlzKCkge1xyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoKHRoaXMuZ2V0TWF4RGVncmVlKCkgKyAxKSAvIDIpIC0gMTtcclxuICB9XHJcblxyXG4gIGdldFNwbGl0SW5kZXgoKSB7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcigodGhpcy5nZXRNYXhEZWdyZWUoKSAtIDEpIC8gMik7XHJcbiAgfVxyXG5cclxuICByZXNpemVUcmVlKHN2Z01hcmdpbjogbnVtYmVyLCBub2RlU3BhY2luZzogbnVtYmVyKSB7XHJcbiAgICBjb25zdCBhbmltYXRlID0gIXRoaXMuU3RhdGUucmVzZXR0aW5nO1xyXG4gICAgdGhpcy50cmVlUm9vdD8ucmVzaXplKFxyXG4gICAgICAuLi50aGlzLmdldFRyZWVSb290KCksXHJcbiAgICAgIHN2Z01hcmdpbixcclxuICAgICAgbm9kZVNwYWNpbmcsXHJcbiAgICAgIGFuaW1hdGUgPyB0aGlzLmdldEFuaW1hdGlvblNwZWVkKCkgOiAwXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgaW5zZXJ0KC4uLnZhbHVlczogKG51bWJlciB8IHN0cmluZylbXSkge1xyXG4gICAgZm9yIChjb25zdCB2YWwgb2YgdmFsdWVzKSBhd2FpdCB0aGlzLmluc2VydE9uZSh2YWwpO1xyXG4gIH1cclxuXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gRmluZCBhIHZhbHVlXHJcblxyXG4gIGFzeW5jIGZpbmQodmFsdWU6IG51bWJlciB8IHN0cmluZykge1xyXG4gICAgaWYgKCF0aGlzLnRyZWVSb290KSB7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UoXCJnZW5lcmFsLmVtcHR5XCIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZmluZC5zdGFydFwiLCB2YWx1ZSk7XHJcbiAgICBjb25zdCBmb3VuZCA9IGF3YWl0IHRoaXMuZmluZEhlbHBlcih2YWx1ZSk7XHJcbiAgICBmb3VuZC5ub2RlPy5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBjb25zdCBwYXRoID0gZm91bmQuc3VjY2VzcyA/IFwiZmluZC5mb3VuZFwiIDogXCJmaW5kLm5vdGZvdW5kXCI7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKHBhdGgsIHZhbHVlKTtcclxuICAgIGZvdW5kLm5vZGU/LnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBmaW5kSGVscGVyKHZhbHVlOiBudW1iZXIgfCBzdHJpbmcsIGZpbmRMZWFmID0gZmFsc2UpIHtcclxuICAgIGxldCBwYXJlbnQgPSBudWxsO1xyXG4gICAgbGV0IG5vZGUgPSB0aGlzLnRyZWVSb290O1xyXG4gICAgY29uc3QgcG9pbnRlciA9IHRoaXMuU3ZnLmhpZ2hsaWdodENpcmNsZShcclxuICAgICAgLi4udGhpcy5nZXROb2RlU3RhcnQoKSxcclxuICAgICAgdGhpcy5nZXRPYmplY3RTaXplKCksXHJcbiAgICAgIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKVxyXG4gICAgKTtcclxuICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgIHBvaW50ZXIuc2V0Q2VudGVyKFxyXG4gICAgICAgIG5vZGUuZ2V0Q1goMCwgdGhpcy5nZXRPYmplY3RTaXplKCkpLFxyXG4gICAgICAgIG5vZGUuY3koKSxcclxuICAgICAgICB0aGlzLmdldEFuaW1hdGlvblNwZWVkKClcclxuICAgICAgKTtcclxuICAgICAgbm9kZS5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICBsZXQgY21wU3RyID0gU3RyaW5nKHZhbHVlKTtcclxuICAgICAgd2hpbGUgKGkgPCBub2RlLm51bVZhbHVlcygpKSB7XHJcbiAgICAgICAgY29uc3QgdHh0ID0gbm9kZS5nZXRUZXh0KGkpO1xyXG4gICAgICAgIGNvbnN0IGNtcCA9IGNvbXBhcmUodmFsdWUsIHR4dCk7XHJcbiAgICAgICAgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgY21wU3RyID0gYCR7dHh0fSA9ICR7dmFsdWV9YDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgY21wU3RyID0gYCR7Y21wU3RyfSA8ICR7dHh0fWA7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY21wU3RyID0gYCR7dHh0fSA8ICR7dmFsdWV9YDtcclxuICAgICAgICBpKys7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgZm91bmQgPVxyXG4gICAgICAgIGkgPCBub2RlLm51bVZhbHVlcygpICYmIGNvbXBhcmUodmFsdWUsIG5vZGUuZ2V0VGV4dChpKSkgPT09IDA7XHJcbiAgICAgIHBvaW50ZXIuc2V0Q2VudGVyKFxyXG4gICAgICAgIG5vZGUuZ2V0Q1goaSAtIChmb3VuZCA/IDAgOiAwLjUpLCB0aGlzLmdldE9iamVjdFNpemUoKSksXHJcbiAgICAgICAgbm9kZS5jeSgpLFxyXG4gICAgICAgIHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKG5vZGUuaXNMZWFmKCkgfHwgKGZvdW5kICYmICFmaW5kTGVhZikpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLnBhdXNlKGNtcFN0cik7XHJcbiAgICAgICAgcG9pbnRlci5yZW1vdmUoKTtcclxuICAgICAgICBub2RlLnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZm91bmQsIG5vZGU6IG5vZGUsIGk6IGkgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGZvdW5kKSBpKys7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UoXHJcbiAgICAgICAgYCR7Y21wU3RyfTogJHt0aGlzLmdldE1lc3NhZ2UoXHJcbiAgICAgICAgICBcIm5vZGUubG9va050aENoaWxkXCIsXHJcbiAgICAgICAgICB0aGlzLmdldE9yZGluYWwoaSwgbm9kZS5udW1DaGlsZHJlbigpKVxyXG4gICAgICAgICl9YFxyXG4gICAgICApO1xyXG4gICAgICBub2RlLnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICAgIHBhcmVudCA9IG5vZGU7XHJcbiAgICAgIG5vZGUgPSBwYXJlbnQuZ2V0Q2hpbGQoaSk7XHJcbiAgICB9XHJcbiAgICBwb2ludGVyLnJlbW92ZSgpO1xyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG5vZGU6IHBhcmVudCwgaTogbnVsbCB9O1xyXG4gIH1cclxuXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gSW5zZXJ0IGEgdmFsdWVcclxuXHJcbiAgYXN5bmMgaW5zZXJ0T25lKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpIHtcclxuICAgIGlmICh0aGlzLnRyZWVSb290KSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuaW5zZXJ0Qm90dG9tdXAodmFsdWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy50cmVlUm9vdCA9IHRoaXMuU3ZnLmJUcmVlTm9kZShcclxuICAgICAgICB0cnVlLFxyXG4gICAgICAgIDEsXHJcbiAgICAgICAgLi4udGhpcy5nZXROb2RlU3RhcnQoKSxcclxuICAgICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgICB0aGlzLmdldFN0cm9rZVdpZHRoKClcclxuICAgICAgKTtcclxuICAgICAgdGhpcy50cmVlUm9vdC5zZXRUZXh0KDAsIFN0cmluZyh2YWx1ZSkpO1xyXG4gICAgICBhd2FpdCB0aGlzLnBhdXNlKFwiaW5zZXJ0Lm5ld3Jvb3RcIiwgdmFsdWUpO1xyXG4gICAgICB0aGlzLnJlc2l6ZVRyZWUodGhpcy4kU3ZnLm1hcmdpbiwgdGhpcy5nZXROb2RlU3BhY2luZygpKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgaW5zZXJ0Qm90dG9tdXAodmFsdWU6IG51bWJlciB8IHN0cmluZykge1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcImluc2VydC5zZWFyY2hcIiwgdmFsdWUpO1xyXG4gICAgY29uc3QgZm91bmQgPSBhd2FpdCB0aGlzLmZpbmRIZWxwZXIodmFsdWUpO1xyXG4gICAgY29uc3Qgbm9kZSA9IGZvdW5kLm5vZGU7XHJcblxyXG4gICAgaWYgKCFub2RlKSByZXR1cm47XHJcblxyXG4gICAgbm9kZS5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBpZiAoZm91bmQuc3VjY2Vzcykge1xyXG4gICAgICBhd2FpdCB0aGlzLnBhdXNlKFwiaW5zZXJ0LmV4aXN0c1wiLCBmb3VuZC5ub2RlKTtcclxuICAgICAgbm9kZS5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbm9kZS5pbnNlcnRWYWx1ZShcclxuICAgICAgICBmb3VuZC5pIHx8IDAsXHJcbiAgICAgICAgU3RyaW5nKHZhbHVlKSxcclxuICAgICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgICB0aGlzLmdldFN0cm9rZVdpZHRoKClcclxuICAgICAgKTtcclxuICAgICAgdGhpcy5yZXNpemVUcmVlKHRoaXMuJFN2Zy5tYXJnaW4sIHRoaXMuZ2V0Tm9kZVNwYWNpbmcoKSk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UoXHJcbiAgICAgICAgXCJpbnNlcnQubnRoXCIsXHJcbiAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgdGhpcy5nZXRPcmRpbmFsKGZvdW5kLmkgfHwgMCwgbm9kZT8ubnVtVmFsdWVzKCkpXHJcbiAgICAgICk7XHJcbiAgICAgIG5vZGU/LnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMuaW5zZXJ0UmVwYWlyKG5vZGUpO1xyXG4gICAgICBhd2FpdCB0aGlzLnBhdXNlKHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBpbnNlcnRSZXBhaXIobm9kZTogQlRyZWVOb2RlKSB7XHJcbiAgICBpZiAobm9kZS5udW1WYWx1ZXMoKSA+IHRoaXMuZ2V0TWF4S2V5cygpKSB7XHJcbiAgICAgIGlmICghbm9kZS5nZXRQYXJlbnQoKSkge1xyXG4gICAgICAgIHRoaXMudHJlZVJvb3QgPSBhd2FpdCB0aGlzLnNwbGl0KG5vZGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSBhd2FpdCB0aGlzLnNwbGl0KG5vZGUpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMuaW5zZXJ0UmVwYWlyKG5ld05vZGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBzcGxpdChub2RlOiBCVHJlZU5vZGUpIHtcclxuICAgIG5vZGUuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcIm5vZGUuc3BsaXRcIiwgbm9kZSk7XHJcbiAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xyXG4gICAgY29uc3QgcGFyZW50SW5kZXggPSBub2RlLmdldFBhcmVudEluZGV4KCk7XHJcblxyXG4gICAgY29uc3QgcmlzaW5nVmFsdWUgPSBub2RlLmdldFRleHQodGhpcy5nZXRTcGxpdEluZGV4KCkpO1xyXG4gICAgY29uc3QgcmlnaHRTcGxpdCA9IHRoaXMuZ2V0U3BsaXRJbmRleCgpICsgMTtcclxuICAgIGNvbnN0IHJpc2luZ1ggPSBub2RlLmdldENYKHJpZ2h0U3BsaXQgLSAxLCB0aGlzLmdldE9iamVjdFNpemUoKSk7XHJcbiAgICBjb25zdCByaXNpbmdOb2RlID0gdGhpcy5TdmcuYlRyZWVOb2RlKFxyXG4gICAgICBmYWxzZSxcclxuICAgICAgMSxcclxuICAgICAgcmlzaW5nWCxcclxuICAgICAgbm9kZS5jeSgpLFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICApO1xyXG4gICAgcmlzaW5nTm9kZS5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICByaXNpbmdOb2RlLnNldFRleHQoMCwgcmlzaW5nVmFsdWUpO1xyXG5cclxuICAgIGNvbnN0IHJpZ2h0VmFsdWVzID0gbm9kZS5udW1WYWx1ZXMoKSAtIHJpZ2h0U3BsaXQ7XHJcbiAgICBjb25zdCByaWdodFggPSBub2RlLmdldENYKFxyXG4gICAgICByaWdodFNwbGl0ICsgcmlnaHRWYWx1ZXMgLyAyIC0gMC41LFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKVxyXG4gICAgKTtcclxuICAgIGNvbnN0IHJpZ2h0Tm9kZSA9IHRoaXMuU3ZnLmJUcmVlTm9kZShcclxuICAgICAgbm9kZS5pc0xlYWYoKSxcclxuICAgICAgcmlnaHRWYWx1ZXMsXHJcbiAgICAgIHJpZ2h0WCxcclxuICAgICAgbm9kZS5jeSgpLFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICApO1xyXG4gICAgcmlnaHROb2RlLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgIGZvciAobGV0IGkgPSByaWdodFNwbGl0OyBpIDwgbm9kZS5udW1WYWx1ZXMoKTsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGogPSBpIC0gcmlnaHRTcGxpdDtcclxuICAgICAgcmlnaHROb2RlLnNldFRleHQoaiwgbm9kZS5nZXRUZXh0KGkpKTtcclxuICAgIH1cclxuICAgIGlmICghbm9kZS5pc0xlYWYoKSkge1xyXG4gICAgICBmb3IgKGxldCBpID0gcmlnaHRTcGxpdDsgaSA8IG5vZGUubnVtQ2hpbGRyZW4oKTsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgaiA9IGkgLSByaWdodFNwbGl0O1xyXG4gICAgICAgIHJpZ2h0Tm9kZS5zZXRDaGlsZChqLCBub2RlLmdldENoaWxkKGkpLCB0aGlzLmdldFN0cm9rZVdpZHRoKCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBub2RlLnNldE51bVZhbHVlcyhcclxuICAgICAgdGhpcy5nZXRTcGxpdEluZGV4KCksXHJcbiAgICAgIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpLFxyXG4gICAgICB0aGlzLmdldFN0cm9rZVdpZHRoKClcclxuICAgICk7XHJcbiAgICByaXNpbmdOb2RlLnNldENoaWxkKDAsIG5vZGUsIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKSk7XHJcbiAgICByaXNpbmdOb2RlLnNldENoaWxkKDEsIHJpZ2h0Tm9kZSwgdGhpcy5nZXRTdHJva2VXaWR0aCgpKTtcclxuXHJcbiAgICBpZiAocGFyZW50ICYmIHBhcmVudEluZGV4ICE9PSBudWxsKSB7XHJcbiAgICAgIHBhcmVudC5zZXRDaGlsZChwYXJlbnRJbmRleCwgcmlzaW5nTm9kZSwgdGhpcy5nZXRTdHJva2VXaWR0aCgpKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgICByaXNpbmdOb2RlLnNldENlbnRlcihcclxuICAgICAgICBwYXJlbnQuZ2V0Q1gocGFyZW50SW5kZXggLSAwLjUsIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpKSxcclxuICAgICAgICBwYXJlbnQuY3koKSxcclxuICAgICAgICB0aGlzLmdldEFuaW1hdGlvblNwZWVkKClcclxuICAgICAgKTtcclxuICAgICAgbm9kZS5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgICByaWdodE5vZGUuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgICBwYXJlbnQuaW5zZXJ0VmFsdWUoXHJcbiAgICAgICAgcGFyZW50SW5kZXgsXHJcbiAgICAgICAgcmlzaW5nVmFsdWUsXHJcbiAgICAgICAgdGhpcy5nZXRPYmplY3RTaXplKCksXHJcbiAgICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICAgICk7XHJcbiAgICAgIHBhcmVudC5zZXRDaGlsZChwYXJlbnRJbmRleCwgbm9kZSwgdGhpcy5nZXRTdHJva2VXaWR0aCgpKTtcclxuICAgICAgcGFyZW50LnNldENoaWxkKHBhcmVudEluZGV4ICsgMSwgcmlnaHROb2RlLCB0aGlzLmdldFN0cm9rZVdpZHRoKCkpO1xyXG4gICAgICByaXNpbmdOb2RlLnJlbW92ZSgpO1xyXG4gICAgICB0aGlzLnJlc2l6ZVRyZWUodGhpcy4kU3ZnLm1hcmdpbiwgdGhpcy5nZXROb2RlU3BhY2luZygpKTtcclxuICAgICAgcmV0dXJuIHBhcmVudDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnRyZWVSb290ID0gcmlzaW5nTm9kZTtcclxuICAgIHRoaXMucmVzaXplVHJlZSh0aGlzLiRTdmcubWFyZ2luLCB0aGlzLmdldE5vZGVTcGFjaW5nKCkpO1xyXG4gICAgdGhpcy50cmVlUm9vdC5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgbm9kZS5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgcmlnaHROb2RlLnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICByZXR1cm4gdGhpcy50cmVlUm9vdDtcclxuICB9XHJcblxyXG4gIGdldE9yZGluYWwoaTogbnVtYmVyLCBuOiBudW1iZXIpIHtcclxuICAgIGlmIChuID09PSAxKSB7XHJcbiAgICAgIHJldHVybiBcIm9ubHlcIjtcclxuICAgIH0gZWxzZSBpZiAobiA8PSAzKSB7XHJcbiAgICAgIHJldHVybiBpID09PSAwID8gXCJsZWZ0XCIgOiBpID09PSBuIC0gMSA/IFwicmlnaHRcIiA6IFwibWlkZGxlXCI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gaSA9PT0gMFxyXG4gICAgICAgID8gXCJmaXJzdFwiXHJcbiAgICAgICAgOiBpID09PSAxXHJcbiAgICAgICAgPyBcInNlY29uZFwiXHJcbiAgICAgICAgOiBpID09PSBuIC0gMVxyXG4gICAgICAgID8gXCJsYXN0XCJcclxuICAgICAgICA6IGAke2l9cmRgO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gUHJpbnQgYWxsIHZhbHVlc1xyXG5cclxuICBhc3luYyBwcmludCgpIHtcclxuICAgIGlmICghdGhpcy50cmVlUm9vdCkge1xyXG4gICAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZ2VuZXJhbC5lbXB0eVwiKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5JbmZvLnByaW50ZXIpIHRocm93IG5ldyBFcnJvcihcIk5vIGluZm8gcHJpbnRlclwiKTtcclxuXHJcbiAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMuSW5mby5wcmludGVyLmJib3goKTtcclxuICAgIGNvbnN0IHByaW50ZWQgPSBbXHJcbiAgICAgIHRoaXMuU3ZnLnRleHQoXCJQcmludGVkIG5vZGVzOiBcIikuYWRkQ2xhc3MoXCJwcmludGVyXCIpLngoeCkueSh5KSxcclxuICAgIF07XHJcbiAgICBjb25zdCBwb2ludGVyID0gdGhpcy5TdmcuaGlnaGxpZ2h0Q2lyY2xlKFxyXG4gICAgICAuLi50aGlzLmdldE5vZGVTdGFydCgpLFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICApO1xyXG4gICAgYXdhaXQgdGhpcy5wcmludEhlbHBlcih0aGlzLnRyZWVSb290LCBwb2ludGVyLCBwcmludGVkKTtcclxuICAgIHBvaW50ZXIucmVtb3ZlKCk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKHVuZGVmaW5lZCk7XHJcbiAgICBmb3IgKGNvbnN0IGxibCBvZiBwcmludGVkKSBsYmwucmVtb3ZlKCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBwcmludEhlbHBlcihcclxuICAgIG5vZGU6IEJUcmVlTm9kZSxcclxuICAgIHBvaW50ZXI6IEhpZ2hsaWdodENpcmNsZSxcclxuICAgIHByaW50ZWQ6IFRleHRbXVxyXG4gICkge1xyXG4gICAgaWYgKG5vZGUuaXNMZWFmKCkpIHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLm51bVZhbHVlcygpOyBpKyspIHtcclxuICAgICAgICBwb2ludGVyLnNldENlbnRlcihcclxuICAgICAgICAgIG5vZGUuZ2V0Q1goaSwgdGhpcy5nZXRPYmplY3RTaXplKCkpLFxyXG4gICAgICAgICAgbm9kZS5jeSgpLFxyXG4gICAgICAgICAgdGhpcy5nZXRBbmltYXRpb25TcGVlZCgpXHJcbiAgICAgICAgKTtcclxuICAgICAgICBhd2FpdCB0aGlzLnByaW50T25lTGFiZWwobm9kZSwgaSwgcHJpbnRlZCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5udW1DaGlsZHJlbigpOyBpKyspIHtcclxuICAgICAgICBwb2ludGVyLnNldENlbnRlcihcclxuICAgICAgICAgIG5vZGUuZ2V0Q1goaSAtIDAuNSwgdGhpcy5nZXRPYmplY3RTaXplKCkpLFxyXG4gICAgICAgICAgTnVtYmVyKG5vZGUueSgpKSArIE51bWJlcihub2RlLmhlaWdodCgpKSxcclxuICAgICAgICAgIHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMucHJpbnRIZWxwZXIobm9kZS5nZXRDaGlsZChpKSEsIHBvaW50ZXIsIHByaW50ZWQpO1xyXG4gICAgICAgIGlmIChpIDwgbm9kZS5udW1WYWx1ZXMoKSkge1xyXG4gICAgICAgICAgcG9pbnRlci5zZXRDZW50ZXIoXHJcbiAgICAgICAgICAgIG5vZGUuZ2V0Q1goaSwgdGhpcy5nZXRPYmplY3RTaXplKCkpLFxyXG4gICAgICAgICAgICBub2RlLmN5KCksXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGF3YWl0IHRoaXMucHJpbnRPbmVMYWJlbChub2RlLCBpLCBwcmludGVkKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcG9pbnRlci5zZXRDZW50ZXIoXHJcbiAgICAgICAgICAgIG5vZGUuZ2V0Q1goaSAtIDAuNSwgdGhpcy5nZXRPYmplY3RTaXplKCkpLFxyXG4gICAgICAgICAgICBub2RlLmN5KCksXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIHByaW50T25lTGFiZWwobm9kZTogQlRyZWVOb2RlLCBpOiBudW1iZXIsIHByaW50ZWQ6IFRleHRbXSkge1xyXG4gICAgY29uc3QgbGJsID0gdGhpcy5TdmcudGV4dChub2RlLmdldFRleHQoaSkpLmNlbnRlcihcclxuICAgICAgbm9kZS5nZXRDWChpLCB0aGlzLmdldE9iamVjdFNpemUoKSksXHJcbiAgICAgIG5vZGUuY3koKVxyXG4gICAgKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgIGNvbnN0IGxhc3QgPSBwcmludGVkW3ByaW50ZWQubGVuZ3RoIC0gMV07XHJcbiAgICBjb25zdCBzcGFjaW5nID0gdGhpcy5nZXROb2RlU3BhY2luZygpIC8gMjtcclxuICAgIHRoaXMuYW5pbWF0ZShsYmwpXHJcbiAgICAgIC5jeShsYXN0LmN5KCkpXHJcbiAgICAgIC54KGxhc3QuYmJveCgpLngyICsgc3BhY2luZyk7XHJcbiAgICBwcmludGVkLnB1c2gobGJsKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICB9XHJcblxyXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIERlbGV0ZSBhIHZhbHVlXHJcblxyXG4gIGFzeW5jIGRlbGV0ZSh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nKSB7XHJcbiAgICBpZiAoIXRoaXMudHJlZVJvb3QpIHtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZShcImdlbmVyYWwuZW1wdHlcIik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGF3YWl0IHRoaXMucGF1c2UoXCJkZWxldGUuc2VhcmNoXCIsIHZhbHVlKTtcclxuICAgIGNvbnN0IGZvdW5kID0gYXdhaXQgdGhpcy5maW5kSGVscGVyKHZhbHVlKTtcclxuICAgIGlmICghZm91bmQuc3VjY2Vzcykge1xyXG4gICAgICBmb3VuZC5ub2RlPy5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UoXCJkZWxldGUubm90ZXhpc3RzXCIsIHZhbHVlKTtcclxuICAgICAgZm91bmQubm9kZT8uc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm91bmQubm9kZT8uc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcImRlbGV0ZS5mb3VuZFwiLCB2YWx1ZSk7XHJcbiAgICBmb3VuZC5ub2RlPy5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgaWYgKGZvdW5kLm5vZGU/LmlzTGVhZigpKSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuZGVsZXRlTGVhZihmb3VuZC5ub2RlLCBmb3VuZC5pIHx8IDApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYXdhaXQgdGhpcy5kZWxldGVOb25sZWFmKGZvdW5kLm5vZGUgYXMgQlRyZWVOb2RlLCBmb3VuZC5pIHx8IDApO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMudHJlZVJvb3QubnVtVmFsdWVzKCkgPT09IDApIHtcclxuICAgICAgdGhpcy50cmVlUm9vdC5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UoXCJkZWxldGUucm9vdC5lbXB0eVwiKTtcclxuICAgICAgY29uc3QgbmV3Um9vdCA9IHRoaXMudHJlZVJvb3QuaXNMZWFmKCkgPyBudWxsIDogdGhpcy50cmVlUm9vdC5nZXRMZWZ0KCk7XHJcbiAgICAgIHRoaXMudHJlZVJvb3QucmVtb3ZlKCk7XHJcbiAgICAgIHRoaXMudHJlZVJvb3QgPSBuZXdSb290O1xyXG4gICAgICB0aGlzLnJlc2l6ZVRyZWUodGhpcy4kU3ZnLm1hcmdpbiwgdGhpcy5nZXROb2RlU3BhY2luZygpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGRlbGV0ZUxlYWYobm9kZTogQlRyZWVOb2RlLCBpOiBudW1iZXIpIHtcclxuICAgIG5vZGUuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcclxuICAgICAgXCJkZWxldGUubGVhZi5udGhcIixcclxuICAgICAgbm9kZSxcclxuICAgICAgdGhpcy5nZXRPcmRpbmFsKGksIG5vZGUubnVtVmFsdWVzKCkpXHJcbiAgICApO1xyXG4gICAgbm9kZS5kZWxldGVWYWx1ZShpLCB0aGlzLmdldE9iamVjdFNpemUoKSwgdGhpcy5nZXRTdHJva2VXaWR0aCgpKTtcclxuICAgIHRoaXMucmVzaXplVHJlZSh0aGlzLiRTdmcubWFyZ2luLCB0aGlzLmdldE5vZGVTcGFjaW5nKCkpO1xyXG4gICAgbm9kZS5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgYXdhaXQgdGhpcy5yZXBhaXJBZnRlckRlbGV0ZShub2RlKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGRlbGV0ZU5vbmxlYWYobm9kZTogQlRyZWVOb2RlLCBpOiBudW1iZXIpIHtcclxuICAgIG5vZGUuYWRkQ2xhc3MoXCJtYXJrZWRcIik7XHJcbiAgICBjb25zdCBwb2ludGVyID0gdGhpcy5TdmcuaGlnaGxpZ2h0Q2lyY2xlKFxyXG4gICAgICBub2RlLmdldENYKGksIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpKSxcclxuICAgICAgbm9kZS5jeSgpLFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICApO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcImZpbmQucHJlZGVjZXNzb3JcIiwgbm9kZS5nZXRUZXh0KGkpKTtcclxuICAgIGxldCBtYXhOb2RlID0gbm9kZS5nZXRDaGlsZChpKTtcclxuICAgIGxldCBqO1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgaiA9IChtYXhOb2RlPy5udW1WYWx1ZXMoKSB8fCAwKSAtIDE7XHJcbiAgICAgIHBvaW50ZXIuc2V0Q2VudGVyKFxyXG4gICAgICAgIG1heE5vZGU/LmdldENYKGosIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpKSB8fCAwLFxyXG4gICAgICAgIG1heE5vZGU/LmN5KCkgfHwgMCxcclxuICAgICAgICB0aGlzLmdldEFuaW1hdGlvblNwZWVkKClcclxuICAgICAgKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgICBpZiAobWF4Tm9kZT8uaXNMZWFmKCkpIGJyZWFrO1xyXG4gICAgICBtYXhOb2RlID0gbWF4Tm9kZT8uZ2V0UmlnaHQoKSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWF4VmFsdWUgPSBtYXhOb2RlLmdldFRleHQoaik7XHJcbiAgICBjb25zdCByaXNpbmdOb2RlID0gdGhpcy5TdmcuYlRyZWVOb2RlKFxyXG4gICAgICBmYWxzZSxcclxuICAgICAgMSxcclxuICAgICAgbWF4Tm9kZS5nZXRDWChqLCB0aGlzLmdldE9iamVjdFNpemUoKSksXHJcbiAgICAgIG1heE5vZGUuY3koKSxcclxuICAgICAgdGhpcy5nZXRPYmplY3RTaXplKCksXHJcbiAgICAgIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKVxyXG4gICAgKTtcclxuICAgIHJpc2luZ05vZGUuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgcmlzaW5nTm9kZS5zZXRUZXh0KDAsIG1heFZhbHVlKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UoXCJkZWxldGUucmVwbGFjZVwiLCBub2RlLmdldFRleHQoaSksIG1heFZhbHVlKTtcclxuICAgIHBvaW50ZXIucmVtb3ZlKCk7XHJcbiAgICByaXNpbmdOb2RlLnNldENlbnRlcihcclxuICAgICAgbm9kZS5nZXRDWChpLCB0aGlzLmdldE9iamVjdFNpemUoKSksXHJcbiAgICAgIG5vZGUuY3koKSxcclxuICAgICAgdGhpcy5nZXRBbmltYXRpb25TcGVlZCgpXHJcbiAgICApO1xyXG4gICAgbm9kZS5zZXRUZXh0KGksIFwiXCIpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgbm9kZS5zZXRUZXh0KGksIG1heFZhbHVlKTtcclxuICAgIHJpc2luZ05vZGUucmVtb3ZlKCk7XHJcbiAgICBub2RlLnJlbW92ZUNsYXNzKFwibWFya2VkXCIpO1xyXG4gICAgbWF4Tm9kZS5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZGVsZXRlLmxlYWYudmFsdWVcIiwgbWF4VmFsdWUsIG1heE5vZGUpO1xyXG4gICAgYXdhaXQgdGhpcy5kZWxldGVMZWFmKG1heE5vZGUsIGopO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcmVwYWlyQWZ0ZXJEZWxldGUobm9kZTogQlRyZWVOb2RlKSB7XHJcbiAgICBpZiAobm9kZS5udW1WYWx1ZXMoKSA+PSB0aGlzLmdldE1pbktleXMoKSkgcmV0dXJuO1xyXG4gICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcclxuICAgIGlmICghcGFyZW50KSByZXR1cm47XHJcblxyXG4gICAgbm9kZS5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwibm9kZS50b29GZXdcIiwgbm9kZSk7XHJcbiAgICBjb25zdCBpID0gbm9kZS5nZXRQYXJlbnRJbmRleCgpIHx8IDA7XHJcbiAgICBpZiAoXHJcbiAgICAgIGkgPiAwICYmXHJcbiAgICAgIHBhcmVudC5nZXRDaGlsZChpIC0gMSkgIT09IG51bGwgJiZcclxuICAgICAgcGFyZW50LmdldENoaWxkKGkgLSAxKSEubnVtVmFsdWVzKCkgPiB0aGlzLmdldE1pbktleXMoKVxyXG4gICAgKSB7XHJcbiAgICAgIC8vIFN0ZWFsIGZyb20gbGVmdCBzaWJsaW5nXHJcbiAgICAgIGF3YWl0IHRoaXMuc3RlYWxGcm9tTGVmdChub2RlLCBpKTtcclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgIGkgPCBwYXJlbnQubnVtVmFsdWVzKCkgJiZcclxuICAgICAgcGFyZW50LmdldENoaWxkKGkgKyAxKSAhPT0gbnVsbCAmJlxyXG4gICAgICBwYXJlbnQuZ2V0Q2hpbGQoaSArIDEpIS5udW1WYWx1ZXMoKSA+IHRoaXMuZ2V0TWluS2V5cygpXHJcbiAgICApIHtcclxuICAgICAgLy8gU3RlYWwgZnJvbSByaWdodCBzaWJsaW5nXHJcbiAgICAgIGF3YWl0IHRoaXMuc3RlYWxGcm9tUmlnaHQobm9kZSwgaSk7XHJcbiAgICB9IGVsc2UgaWYgKGkgPCBwYXJlbnQubnVtQ2hpbGRyZW4oKSAtIDEpIHtcclxuICAgICAgLy8gTWVyZ2Ugd2l0aCByaWdodCBzaWJsaW5nXHJcbiAgICAgIGNvbnN0IG5leHROb2RlID0gYXdhaXQgdGhpcy5tZXJnZVJpZ2h0KG5vZGUpO1xyXG4gICAgICBhd2FpdCB0aGlzLnJlcGFpckFmdGVyRGVsZXRlKG5leHROb2RlLmdldFBhcmVudCgpIGFzIEJUcmVlTm9kZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBNZXJnZSB3aXRoIGxlZnQgc2libGluZ1xyXG4gICAgICBjb25zdCBuZXh0Tm9kZSA9IGF3YWl0IHRoaXMubWVyZ2VSaWdodChcclxuICAgICAgICBwYXJlbnQuZ2V0Q2hpbGQoaSAtIDEpIGFzIEJUcmVlTm9kZVxyXG4gICAgICApO1xyXG4gICAgICBhd2FpdCB0aGlzLnJlcGFpckFmdGVyRGVsZXRlKG5leHROb2RlLmdldFBhcmVudCgpIGFzIEJUcmVlTm9kZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBtZXJnZVJpZ2h0KG5vZGU6IEJUcmVlTm9kZSkge1xyXG4gICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcclxuICAgIGNvbnN0IHBhcmVudEluZGV4ID0gbm9kZS5nZXRQYXJlbnRJbmRleCgpO1xyXG5cclxuICAgIGlmICghcGFyZW50IHx8IHBhcmVudEluZGV4ID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhcmVudFwiKTtcclxuXHJcbiAgICBjb25zdCBwYXJlbnRWYWx1ZSA9IHBhcmVudD8uZ2V0VGV4dChwYXJlbnRJbmRleCk7XHJcbiAgICBjb25zdCByaWdodFNpYiA9IHBhcmVudC5nZXRDaGlsZChwYXJlbnRJbmRleCArIDEpO1xyXG4gICAgbm9kZS5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBwYXJlbnQuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgcmlnaHRTaWI/LnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UoXCJub2RlLm1lcmdlUmlnaHRcIiwgbm9kZSwgcGFyZW50VmFsdWUsIHJpZ2h0U2liKTtcclxuXHJcbiAgICBjb25zdCBzaW5raW5nTm9kZSA9IHRoaXMuU3ZnLmJUcmVlTm9kZShcclxuICAgICAgZmFsc2UsXHJcbiAgICAgIDEsXHJcbiAgICAgIHBhcmVudC5nZXRDWChwYXJlbnRJbmRleCwgdGhpcy5nZXRPYmplY3RTaXplKCkpLFxyXG4gICAgICBwYXJlbnQuY3koKSxcclxuICAgICAgdGhpcy5nZXRPYmplY3RTaXplKCksXHJcbiAgICAgIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKVxyXG4gICAgKTtcclxuICAgIHNpbmtpbmdOb2RlLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgIHNpbmtpbmdOb2RlLnNldFRleHQoMCwgcGFyZW50VmFsdWUpO1xyXG4gICAgcGFyZW50LnNldFRleHQocGFyZW50SW5kZXgsIFwiXCIpO1xyXG4gICAgY29uc3Qgc2lua2luZ1ggPVxyXG4gICAgICAoTnVtYmVyKG5vZGUueCgpKSArIE51bWJlcihub2RlLndpZHRoKCkpICsgTnVtYmVyKHJpZ2h0U2liPy54KCkpKSAvIDI7XHJcbiAgICBzaW5raW5nTm9kZS5zZXRDZW50ZXIoc2lua2luZ1gsIG5vZGUuY3koKSwgdGhpcy5nZXRBbmltYXRpb25TcGVlZCgpKTtcclxuICAgIG5vZGUuc2V0Q2VudGVyKFxyXG4gICAgICBzaW5raW5nWCAtICh0aGlzLmdldE9iamVjdFNpemUoKSArIE51bWJlcihub2RlLndpZHRoKCkpKSAvIDIsXHJcbiAgICAgIG5vZGUuY3koKSxcclxuICAgICAgdGhpcy5nZXRBbmltYXRpb25TcGVlZCgpXHJcbiAgICApO1xyXG4gICAgcmlnaHRTaWI/LnNldENlbnRlcihcclxuICAgICAgc2lua2luZ1ggKyAodGhpcy5nZXRPYmplY3RTaXplKCkgKyBOdW1iZXIocmlnaHRTaWIud2lkdGgoKSkpIC8gMixcclxuICAgICAgbm9kZS5jeSgpLFxyXG4gICAgICB0aGlzLmdldEFuaW1hdGlvblNwZWVkKClcclxuICAgICk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKHVuZGVmaW5lZCk7XHJcblxyXG4gICAgY29uc3Qgbm9kZVNpemUgPSBub2RlLm51bVZhbHVlcygpO1xyXG4gICAgY29uc3QgdGV4dHNUb0luc2VydCA9IFtwYXJlbnRWYWx1ZV0uY29uY2F0KHJpZ2h0U2liPy5nZXRUZXh0cygpIHx8IFtdKTtcclxuICAgIG5vZGUuc2V0TnVtVmFsdWVzKFxyXG4gICAgICBub2RlU2l6ZSArIHRleHRzVG9JbnNlcnQubGVuZ3RoLFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICApO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0c1RvSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIG5vZGUuc2V0VGV4dChub2RlU2l6ZSArIGksIHRleHRzVG9JbnNlcnRbaV0pO1xyXG4gICAgICBpZiAoIW5vZGUuaXNMZWFmKCkpIHtcclxuICAgICAgICBub2RlLnNldENoaWxkKFxyXG4gICAgICAgICAgbm9kZVNpemUgKyBpICsgMSxcclxuICAgICAgICAgIHJpZ2h0U2liPy5nZXRDaGlsZChpKSBhcyBCVHJlZU5vZGUsXHJcbiAgICAgICAgICB0aGlzLmdldFN0cm9rZVdpZHRoKClcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBwYXJlbnQuZGVsZXRlVmFsdWUoXHJcbiAgICAgIHBhcmVudEluZGV4LFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpLFxyXG4gICAgICBmYWxzZVxyXG4gICAgKTtcclxuICAgIHNpbmtpbmdOb2RlLnJlbW92ZSgpO1xyXG4gICAgcmlnaHRTaWI/LnJlbW92ZSgpO1xyXG4gICAgdGhpcy5yZXNpemVUcmVlKHRoaXMuJFN2Zy5tYXJnaW4sIHRoaXMuZ2V0Tm9kZVNwYWNpbmcoKSk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKHVuZGVmaW5lZCk7XHJcbiAgICBub2RlLnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICBwYXJlbnQuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgIHJldHVybiBub2RlO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc3RlYWxGcm9tUmlnaHQobm9kZTogQlRyZWVOb2RlLCBwYXJlbnRJbmRleDogbnVtYmVyKSB7XHJcbiAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xyXG4gICAgY29uc3QgcmlnaHRTaWIgPSBwYXJlbnQ/LmdldENoaWxkKHBhcmVudEluZGV4ICsgMSk7XHJcblxyXG4gICAgaWYgKCFwYXJlbnQgfHwgIXJpZ2h0U2liKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgXCJDYW4gbm90IHN0ZWFsIGZyb20gcmlnaHQsIG1pc3NpbmcgcGFyZW50IG9yIHJpZ2h0IHNpYmxpbmdcIlxyXG4gICAgICApO1xyXG5cclxuICAgIG5vZGUuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgcGFyZW50LnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgIHJpZ2h0U2liLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuXHJcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBwYXJlbnQuZ2V0VGV4dChwYXJlbnRJbmRleCk7XHJcbiAgICBjb25zdCByaWdodFZhbHVlID0gcmlnaHRTaWIuZ2V0VGV4dCgwKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UoXCJub2RlLnN0ZWFsLnJpZ2h0XCIsIG5vZGUsIGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZSk7XHJcblxyXG4gICAgY29uc3QgbGVmdE5vZGUgPSB0aGlzLlN2Zy5iVHJlZU5vZGUoXHJcbiAgICAgIGZhbHNlLFxyXG4gICAgICAxLFxyXG4gICAgICBwYXJlbnQ/LmdldENYKHBhcmVudEluZGV4LCB0aGlzLmdldE9iamVjdFNpemUoKSksXHJcbiAgICAgIHBhcmVudD8uY3koKSxcclxuICAgICAgdGhpcy5nZXRPYmplY3RTaXplKCksXHJcbiAgICAgIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKVxyXG4gICAgKTtcclxuICAgIGxlZnROb2RlLnNldFRleHQoMCwgbGVmdFZhbHVlIHx8IFwiXCIpO1xyXG4gICAgbGVmdE5vZGUuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgY29uc3QgcmlnaHROb2RlID0gdGhpcy5TdmcuYlRyZWVOb2RlKFxyXG4gICAgICBmYWxzZSxcclxuICAgICAgMSxcclxuICAgICAgcmlnaHRTaWI/LmdldENYKDAsIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpKSxcclxuICAgICAgcmlnaHRTaWI/LmN5KCksXHJcbiAgICAgIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpLFxyXG4gICAgICB0aGlzLmdldFN0cm9rZVdpZHRoKClcclxuICAgICk7XHJcbiAgICByaWdodE5vZGUuc2V0VGV4dCgwLCByaWdodFZhbHVlIHx8IFwiXCIpO1xyXG4gICAgcmlnaHROb2RlLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuXHJcbiAgICBub2RlLmluc2VydFZhbHVlKFxyXG4gICAgICBub2RlLm51bVZhbHVlcygpLFxyXG4gICAgICBcIlwiLFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICApO1xyXG4gICAgcGFyZW50LnNldFRleHQocGFyZW50SW5kZXgsIFwiXCIpO1xyXG4gICAgcmlnaHRTaWIuc2V0VGV4dCgwLCBcIlwiKTtcclxuXHJcbiAgICBsZWZ0Tm9kZS5zZXRDZW50ZXIoXHJcbiAgICAgIG5vZGUuZ2V0Q1gobm9kZS5udW1WYWx1ZXMoKSAtIDEsIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpKSxcclxuICAgICAgbm9kZS5jeSgpLFxyXG4gICAgICB0aGlzLmdldEFuaW1hdGlvblNwZWVkKClcclxuICAgICk7XHJcbiAgICByaWdodE5vZGUuc2V0Q2VudGVyKFxyXG4gICAgICBwYXJlbnQuZ2V0Q1gocGFyZW50SW5kZXgsIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpKSxcclxuICAgICAgcGFyZW50LmN5KCksXHJcbiAgICAgIHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKVxyXG4gICAgKTtcclxuICAgIGlmICghbm9kZS5pc0xlYWYoKSlcclxuICAgICAgbm9kZS5zZXRDaGlsZChcclxuICAgICAgICBub2RlLm51bUNoaWxkcmVuKCkgLSAxLFxyXG4gICAgICAgIHJpZ2h0U2liLmdldENoaWxkKDApLFxyXG4gICAgICAgIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKVxyXG4gICAgICApO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG5cclxuICAgIGxlZnROb2RlLnJlbW92ZSgpO1xyXG4gICAgcmlnaHROb2RlLnJlbW92ZSgpO1xyXG4gICAgcmlnaHRTaWIuZGVsZXRlVmFsdWUoMCwgdGhpcy5nZXRPYmplY3RTaXplKCksIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKSk7XHJcbiAgICBwYXJlbnQuc2V0VGV4dChwYXJlbnRJbmRleCwgcmlnaHRWYWx1ZSk7XHJcbiAgICBub2RlLnNldFRleHQobm9kZS5udW1WYWx1ZXMoKSAtIDEsIGxlZnRWYWx1ZSk7XHJcbiAgICB0aGlzLnJlc2l6ZVRyZWUodGhpcy4kU3ZnLm1hcmdpbiwgdGhpcy5nZXROb2RlU3BhY2luZygpKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgIG5vZGUuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgIHBhcmVudC5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgcmlnaHRTaWIuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgIHJldHVybiBub2RlO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc3RlYWxGcm9tTGVmdChub2RlOiBCVHJlZU5vZGUsIHBhcmVudEluZGV4OiBudW1iZXIpIHtcclxuICAgIHBhcmVudEluZGV4LS07XHJcbiAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xyXG4gICAgY29uc3QgbGVmdFNpYiA9IHBhcmVudD8uZ2V0Q2hpbGQocGFyZW50SW5kZXgpO1xyXG5cclxuICAgIGlmICghcGFyZW50IHx8ICFsZWZ0U2liKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgXCJDYW4gbm90IHN0ZWFsIGZyb20gbGVmdCwgbWlzc2luZyBwYXJlbnQgb3IgbGVmdCBzaWJsaW5nXCJcclxuICAgICAgKTtcclxuXHJcbiAgICBub2RlLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgIHBhcmVudC5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBsZWZ0U2liLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuXHJcbiAgICBjb25zdCByaWdodFZhbHVlID0gcGFyZW50LmdldFRleHQocGFyZW50SW5kZXgpO1xyXG4gICAgY29uc3QgbGVmdFZhbHVlID0gbGVmdFNpYi5nZXRUZXh0KGxlZnRTaWIubnVtVmFsdWVzKCkgLSAxKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UoXCJub2RlLnN0ZWFsLmxlZnRcIiwgbm9kZSwgbGVmdFZhbHVlLCByaWdodFZhbHVlKTtcclxuXHJcbiAgICBjb25zdCByaWdodE5vZGUgPSB0aGlzLlN2Zy5iVHJlZU5vZGUoXHJcbiAgICAgIGZhbHNlLFxyXG4gICAgICAxLFxyXG4gICAgICBwYXJlbnQuZ2V0Q1gocGFyZW50SW5kZXgsIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpKSxcclxuICAgICAgcGFyZW50LmN5KCksXHJcbiAgICAgIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpLFxyXG4gICAgICB0aGlzLmdldFN0cm9rZVdpZHRoKClcclxuICAgICk7XHJcbiAgICByaWdodE5vZGUuc2V0VGV4dCgwLCByaWdodFZhbHVlKTtcclxuICAgIHJpZ2h0Tm9kZS5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBjb25zdCBsZWZ0Tm9kZSA9IHRoaXMuU3ZnLmJUcmVlTm9kZShcclxuICAgICAgZmFsc2UsXHJcbiAgICAgIDEsXHJcbiAgICAgIGxlZnRTaWIuZ2V0Q1gobGVmdFNpYi5udW1WYWx1ZXMoKSAtIDEsIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpKSxcclxuICAgICAgbGVmdFNpYi5jeSgpLFxyXG4gICAgICB0aGlzLmdldE9iamVjdFNpemUoKSxcclxuICAgICAgdGhpcy5nZXRTdHJva2VXaWR0aCgpXHJcbiAgICApO1xyXG4gICAgbGVmdE5vZGUuc2V0VGV4dCgwLCBsZWZ0VmFsdWUpO1xyXG4gICAgbGVmdE5vZGUuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG5cclxuICAgIG5vZGUuaW5zZXJ0VmFsdWUoMCwgXCJcIiwgdGhpcy5nZXRPYmplY3RTaXplKCksIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKSwgdHJ1ZSk7XHJcbiAgICBwYXJlbnQuc2V0VGV4dChwYXJlbnRJbmRleCwgXCJcIik7XHJcbiAgICBsZWZ0U2liLnNldFRleHQobGVmdFNpYi5udW1WYWx1ZXMoKSAtIDEsIFwiXCIpO1xyXG5cclxuICAgIHJpZ2h0Tm9kZS5zZXRDZW50ZXIoXHJcbiAgICAgIG5vZGUuZ2V0Q1goMCwgdGhpcy5nZXRPYmplY3RTaXplKCkpLFxyXG4gICAgICBub2RlLmN5KCksXHJcbiAgICAgIHRoaXMuZ2V0QW5pbWF0aW9uU3BlZWQoKVxyXG4gICAgKTtcclxuICAgIGxlZnROb2RlLnNldENlbnRlcihcclxuICAgICAgcGFyZW50LmdldENYKHBhcmVudEluZGV4LCB0aGlzLmdldE9iamVjdFNpemUoKSksXHJcbiAgICAgIHBhcmVudC5jeSgpLFxyXG4gICAgICB0aGlzLmdldEFuaW1hdGlvblNwZWVkKClcclxuICAgICk7XHJcbiAgICBpZiAoIW5vZGUuaXNMZWFmKCkpXHJcbiAgICAgIG5vZGUuc2V0Q2hpbGQoXHJcbiAgICAgICAgMCxcclxuICAgICAgICBsZWZ0U2liLmdldENoaWxkKGxlZnRTaWIubnVtQ2hpbGRyZW4oKSAtIDEpLFxyXG4gICAgICAgIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKVxyXG4gICAgICApO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG5cclxuICAgIHJpZ2h0Tm9kZS5yZW1vdmUoKTtcclxuICAgIGxlZnROb2RlLnJlbW92ZSgpO1xyXG4gICAgbGVmdFNpYi5kZWxldGVWYWx1ZShcclxuICAgICAgbGVmdFNpYi5udW1WYWx1ZXMoKSAtIDEsXHJcbiAgICAgIHRoaXMuZ2V0T2JqZWN0U2l6ZSgpLFxyXG4gICAgICB0aGlzLmdldFN0cm9rZVdpZHRoKCksXHJcbiAgICAgIGZhbHNlXHJcbiAgICApO1xyXG4gICAgcGFyZW50LnNldFRleHQocGFyZW50SW5kZXgsIGxlZnRWYWx1ZSk7XHJcbiAgICBub2RlLnNldFRleHQoMCwgcmlnaHRWYWx1ZSk7XHJcbiAgICB0aGlzLnJlc2l6ZVRyZWUodGhpcy4kU3ZnLm1hcmdpbiwgdGhpcy5nZXROb2RlU3BhY2luZygpKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgIG5vZGUuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgIHBhcmVudC5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgbGVmdFNpYi5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgcmV0dXJuIG5vZGU7XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBCVHJlZU1lc3NhZ2VzID0ge1xyXG4gIGZpbmQ6IHtcclxuICAgIHByZWRlY2Vzc29yOiAodmFsOiBzdHJpbmcpID0+IGBGaW5kIHRoZSBwcmVkZWNlc3NvciB2YWx1ZSBvZiAke3ZhbH1gLFxyXG4gIH0sXHJcbiAgaW5zZXJ0OiB7XHJcbiAgICBudGg6ICh2YWw6IHN0cmluZywgbnRoOiBudW1iZXIpID0+XHJcbiAgICAgIGBJbnNlcnQgJHt2YWx9IGFzICR7bnRofSB2YWx1ZSBpbiB0aGUgbm9kZWAsXHJcbiAgfSxcclxuICBkZWxldGU6IHtcclxuICAgIHJvb3Q6IHtcclxuICAgICAgZW1wdHk6IFwiUmVtb3ZlIGVtcHR5IHRyZWUgcm9vdFwiLFxyXG4gICAgfSxcclxuICAgIGxlYWY6IHtcclxuICAgICAgbnRoOiAobGVhZjogQlRyZWVOb2RlLCBudGg6IG51bWJlcikgPT5cclxuICAgICAgICBgRGVsZXRlIHRoZSAke250aH0gdmFsdWUgaW4gbGVhZiAke2xlYWZ9YCxcclxuICAgICAgdmFsdWU6ICh2YWw6IHN0cmluZywgbGVhZjogQlRyZWVOb2RlKSA9PlxyXG4gICAgICAgIGBOb3cgZGVsZXRlICR7dmFsfSBpbiB0aGUgbGVhZiBub2RlICR7bGVhZn1gLFxyXG4gICAgfSxcclxuICAgIHJlcGxhY2U6ICh2YWw6IHN0cmluZywgbmV3VmFsOiBzdHJpbmcpID0+XHJcbiAgICAgIGBSZXBsYWNlIHRoZSB2YWx1ZSAke3ZhbH0gd2l0aCAke25ld1ZhbH1gLFxyXG4gIH0sXHJcbiAgbm9kZToge1xyXG4gICAgbG9va050aENoaWxkOiAobnRoOiBudW1iZXIpID0+IGBMb29rIGludG8gJHtudGh9IGNoaWxkYCxcclxuICAgIHNwbGl0OiAobm9kZTogQlRyZWVOb2RlKSA9PiBgU3BsaXR0aW5nIG5vZGUgJHtub2RlfWAsXHJcbiAgICB0b29GZXc6IChub2RlOiBCVHJlZU5vZGUpID0+IGBOb2RlICR7bm9kZX0gaGFzIHRvbyBmZXcgdmFsdWVzYCxcclxuICAgIG1lcmdlUmlnaHQ6IChub2RlOiBCVHJlZU5vZGUsIHBhcmVudDogQlRyZWVOb2RlLCByaWdodFNpYjogQlRyZWVOb2RlKSA9PiBbXHJcbiAgICAgIFwiTWVyZ2luZyBub2RlczpcIixcclxuICAgICAgYCR7bm9kZX0gKyBbJHtwYXJlbnR9XSArICR7cmlnaHRTaWJ9YCxcclxuICAgIF0sXHJcbiAgICBzdGVhbDoge1xyXG4gICAgICByaWdodDogKG5vZGU6IEJUcmVlTm9kZSwgbGVmdDogQlRyZWVOb2RlLCByaWdodDogQlRyZWVOb2RlKSA9PiBbXHJcbiAgICAgICAgXCJTdGVhbGluZyBmcm9tIHJpZ2h0IHNpYmxpbmc6XCIsXHJcbiAgICAgICAgYCR7bm9kZX0g4oaQIFske2xlZnR9XSDihpAgWyR7cmlnaHR9XWAsXHJcbiAgICAgIF0sXHJcbiAgICAgIGxlZnQ6IChub2RlOiBCVHJlZU5vZGUsIGxlZnQ6IEJUcmVlTm9kZSwgcmlnaHQ6IEJUcmVlTm9kZSkgPT4gW1xyXG4gICAgICAgIFwiU3RlYWxpbmcgZnJvbSBsZWZ0IHNpYmxpbmc6XCIsXHJcbiAgICAgICAgYFske2xlZnR9XSDihpIgWyR7cmlnaHR9XSDihpIgJHtub2RlfWAsXHJcbiAgICAgIF0sXHJcbiAgICB9LFxyXG4gIH0sXHJcbn0gYXMgY29uc3Q7XHJcbiIsIi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gSW1wb3J0IGFuZCBleHBvcnQgaW5mb3JtYXRpb24gdXNlZCBieSB0aGUgSmF2YXNjcmlwdCBsaW50ZXIgRVNMaW50OlxyXG4vKiBnbG9iYWxzIERTVmlzICovXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbmltcG9ydCB7IEJpbmFyeU5vZGUgfSBmcm9tIFwic3JjL29iamVjdHMvYmluYXJ5LW5vZGVcIjtcclxuaW1wb3J0IHsgQlNULCBCU1RNZXNzYWdlcyB9IGZyb20gXCIuL0JTVFwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFJlZEJsYWNrIGV4dGVuZHMgQlNUIHtcclxuICBtZXNzYWdlcyA9IHtcclxuICAgIC4uLkJTVE1lc3NhZ2VzLFxyXG4gICAgLi4uUmVkQmxhY2tNZXNzYWdlcyxcclxuICAgIHJvdGF0ZToge1xyXG4gICAgICAuLi5CU1RNZXNzYWdlcy5yb3RhdGUsXHJcbiAgICAgIC4uLlJlZEJsYWNrTWVzc2FnZXMucm90YXRlLFxyXG4gICAgfSxcclxuICB9O1xyXG5cclxuICBuZXdOb2RlKHRleHQ6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIHN1cGVyLm5ld05vZGUodGV4dCkuYWRkQ2xhc3MoXCJyZWRcIik7XHJcbiAgfVxyXG5cclxuICBhc3luYyBpbnNlcnRPbmUodmFsdWU6IHN0cmluZykge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VwZXIuaW5zZXJ0T25lKHZhbHVlKTtcclxuICAgIGlmIChyZXN1bHQ/LnN1Y2Nlc3MgJiYgcmVzdWx0Lm5vZGUpIHtcclxuICAgICAgYXdhaXQgdGhpcy5maXhEb3VibGVSZWQocmVzdWx0Lm5vZGUpO1xyXG4gICAgICBpZiAodGhpcy50cmVlUm9vdCAmJiB0aGlzLmlzUmVkKHRoaXMudHJlZVJvb3QpKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wYXVzZShcImNvbG9yLnJlZFJvb3RCbGFja1wiKTtcclxuICAgICAgICB0aGlzLmNvbG9yQmxhY2sodGhpcy50cmVlUm9vdCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBhc3luYyBmaXhEb3VibGVSZWQobm9kZTogQmluYXJ5Tm9kZSkge1xyXG4gICAgbGV0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XHJcbiAgICBpZiAoIXBhcmVudCkgcmV0dXJuO1xyXG4gICAgaWYgKCF0aGlzLmlzUmVkKHBhcmVudCkpIHJldHVybjtcclxuXHJcbiAgICBsZXQgZ3JhbmRwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XHJcbiAgICBpZiAoIWdyYW5kcGFyZW50KSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgcGlibGluZyA9IHBhcmVudC5nZXRTaWJsaW5nKCk7XHJcbiAgICBpZiAocGlibGluZyAmJiB0aGlzLmlzUmVkKHBpYmxpbmcpKSB7XHJcbiAgICAgIG5vZGUuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgICBwYXJlbnQuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgICBwaWJsaW5nLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZShcImNvbG9yLnB1c2hEb3duQmxhY2tcIiwgbm9kZSwgcGFyZW50LCBwaWJsaW5nKTtcclxuICAgICAgbm9kZS5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgICBwYXJlbnQuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgICAgcGlibGluZy5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgICB0aGlzLmNvbG9yQmxhY2socGlibGluZyk7XHJcbiAgICAgIHRoaXMuY29sb3JCbGFjayhwYXJlbnQpO1xyXG4gICAgICB0aGlzLmNvbG9yUmVkKGdyYW5kcGFyZW50KTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgICBhd2FpdCB0aGlzLmZpeERvdWJsZVJlZChncmFuZHBhcmVudCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgc2lkZTogXCJsZWZ0XCIgfCBcInJpZ2h0XCIgPSBub2RlLmlzTGVmdENoaWxkKCkgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcclxuICAgIGxldCByb3RhdGU6IFwibGVmdFwiIHwgXCJyaWdodFwiID0gcGFyZW50LmlzTGVmdENoaWxkKCkgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcclxuICAgIGlmIChzaWRlICE9PSByb3RhdGUpIHtcclxuICAgICAgbm9kZS5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICAgIHBhcmVudC5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICAgIGdyYW5kcGFyZW50LnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZShcInJvdGF0ZS5wYXJlbnRcIiwgbm9kZSwgc2lkZSwgcm90YXRlLCBwYXJlbnQpLFxyXG4gICAgICAgIG5vZGUuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgICAgcGFyZW50LnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICAgIGdyYW5kcGFyZW50LnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICAgIG5vZGUgPSAoYXdhaXQgdGhpcy5zaW5nbGVSb3RhdGUocm90YXRlLCBwYXJlbnQpKS5nZXRDaGlsZChcclxuICAgICAgICByb3RhdGVcclxuICAgICAgKSBhcyBCaW5hcnlOb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHNpZGUgPSBub2RlLmlzTGVmdENoaWxkKCkgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcclxuICAgIHJvdGF0ZSA9IHNpZGUgPT09IFwibGVmdFwiID8gXCJyaWdodFwiIDogXCJsZWZ0XCI7XHJcbiAgICBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xyXG4gICAgZ3JhbmRwYXJlbnQgPSBwYXJlbnQ/LmdldFBhcmVudCgpIHx8IG51bGw7XHJcblxyXG4gICAgaWYgKCFwYXJlbnQgfHwgIWdyYW5kcGFyZW50KVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHBhcmVudCBvciBncmFuZHBhcmVudFwiKTtcclxuXHJcbiAgICBub2RlLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgIHBhcmVudC5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBncmFuZHBhcmVudD8uc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcInJvdGF0ZS5ncmFuZHBhcmVudFwiLCBub2RlLCBzaWRlLCBncmFuZHBhcmVudCwgcm90YXRlKTtcclxuICAgIG5vZGUuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgIHBhcmVudC5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgZ3JhbmRwYXJlbnQ/LnNldEhpZ2hsaWdodChmYWxzZSk7XHJcbiAgICB0aGlzLmNvbG9yQmxhY2socGFyZW50KTtcclxuICAgIHRoaXMuY29sb3JSZWQoZ3JhbmRwYXJlbnQpO1xyXG4gICAgYXdhaXQgdGhpcy5zaW5nbGVSb3RhdGUocm90YXRlLCBncmFuZHBhcmVudCBhcyBCaW5hcnlOb2RlKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGRlbGV0ZSh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdXBlci5kZWxldGUodmFsdWUpO1xyXG4gICAgaWYgKHJlc3VsdD8uc3VjY2Vzcykge1xyXG4gICAgICBpZiAocmVzdWx0LnBhcmVudCAmJiByZXN1bHQuZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5maXhEZWxldGVJbWJhbGFuY2UocmVzdWx0LnBhcmVudCwgcmVzdWx0LmRpcmVjdGlvbik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMudHJlZVJvb3QgJiYgdGhpcy5pc1JlZCh0aGlzLnRyZWVSb290KSkge1xyXG4gICAgICAgIHRoaXMuY29sb3JCbGFjayh0aGlzLnRyZWVSb290KTtcclxuICAgICAgICBhd2FpdCB0aGlzLnBhdXNlKFwiY29sb3Iucm9vdEJsYWNrXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZml4RGVsZXRlSW1iYWxhbmNlKHBhcmVudDogQmluYXJ5Tm9kZSwgZGlyOiBcImxlZnRcIiB8IFwicmlnaHRcIikge1xyXG4gICAgY29uc3QgY2hpbGQgPSBwYXJlbnQuZ2V0Q2hpbGQoZGlyKTtcclxuICAgIGlmIChjaGlsZCAmJiB0aGlzLmlzUmVkKGNoaWxkKSkge1xyXG4gICAgICB0aGlzLmNvbG9yQmxhY2soY2hpbGQpO1xyXG4gICAgICBjaGlsZC5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UoXCJjb2xvci5ub2RlQmxhY2tcIiwgY2hpbGQpO1xyXG4gICAgICBjaGlsZC5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgfSBlbHNlIGlmICghcGFyZW50LmlzTGVhZigpKSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuZml4RG91YmxlQmxhY2socGFyZW50LCBkaXIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZml4RG91YmxlQmxhY2socGFyZW50OiBCaW5hcnlOb2RlLCBsZWZ0OiBcImxlZnRcIiB8IFwicmlnaHRcIikge1xyXG4gICAgLy8gVE9ETzogRml4IHZhcmlhYmxlIG5hbWVzXHJcbiAgICBjb25zdCByaWdodCA9IGxlZnQgPT09IFwibGVmdFwiID8gXCJyaWdodFwiIDogXCJsZWZ0XCI7XHJcbiAgICBjb25zdCByaWdodENoaWxkID0gcGFyZW50LmdldENoaWxkKHJpZ2h0KTtcclxuICAgIGNvbnN0IHJpZ2h0R3JhbmRjaGlsZCA9IHJpZ2h0Q2hpbGQ/LmdldENoaWxkKHJpZ2h0KTtcclxuICAgIGNvbnN0IGxlZnRHcmFuZGNoaWxkID0gcmlnaHRDaGlsZD8uZ2V0Q2hpbGQobGVmdCk7XHJcbiAgICBwYXJlbnQuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcImJhbGFuY2luZy5wYXJlbnRJbWJhbGFuY2VkXCIsIHBhcmVudCk7XHJcblxyXG4gICAgLy8gU2libGluZyBpcyByZWRcclxuICAgIGlmIChyaWdodENoaWxkICYmIHRoaXMuaXNSZWQocmlnaHRDaGlsZCkpIHtcclxuICAgICAgcGFyZW50LnNldENoaWxkSGlnaGxpZ2h0KHJpZ2h0LCB0cnVlKTtcclxuICAgICAgcmlnaHRDaGlsZC5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UoXCJyb3RhdGUucmVkU2libGluZ1wiLCBwYXJlbnQsIHJpZ2h0LCByaWdodENoaWxkLCBsZWZ0KTtcclxuICAgICAgcGFyZW50LnNldENoaWxkSGlnaGxpZ2h0KHJpZ2h0LCBmYWxzZSk7XHJcbiAgICAgIHJpZ2h0Q2hpbGQuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuXHJcbiAgICAgIHRoaXMuY29sb3JCbGFjayhyaWdodENoaWxkKTtcclxuICAgICAgdGhpcy5jb2xvclJlZChwYXJlbnQpO1xyXG4gICAgICBhd2FpdCB0aGlzLnNpbmdsZVJvdGF0ZShsZWZ0LCBwYXJlbnQpO1xyXG4gICAgICBhd2FpdCB0aGlzLmZpeERvdWJsZUJsYWNrKHBhcmVudCwgbGVmdCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTaWJsaW5nJ3MgZGlzdGFudCBjaGlsZCBpcyByZWRcclxuICAgIGlmIChyaWdodEdyYW5kY2hpbGQgJiYgdGhpcy5pc1JlZChyaWdodEdyYW5kY2hpbGQpKSB7XHJcbiAgICAgIHBhcmVudC5zZXRDaGlsZEhpZ2hsaWdodChyaWdodCwgdHJ1ZSk7XHJcbiAgICAgIHJpZ2h0Q2hpbGQ/LnNldENoaWxkSGlnaGxpZ2h0KHJpZ2h0LCB0cnVlKTtcclxuICAgICAgcmlnaHRHcmFuZGNoaWxkLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZShcInJvdGF0ZS5yZWREaXN0YW50Q2hpbGRcIiwgcmlnaHQsIHJpZ2h0Q2hpbGQsIGxlZnQpO1xyXG4gICAgICBwYXJlbnQuc2V0Q2hpbGRIaWdobGlnaHQocmlnaHQsIGZhbHNlKTtcclxuICAgICAgcmlnaHRDaGlsZD8uc2V0Q2hpbGRIaWdobGlnaHQocmlnaHQsIGZhbHNlKTtcclxuICAgICAgcmlnaHRHcmFuZGNoaWxkLnNldEhpZ2hsaWdodChmYWxzZSk7XHJcblxyXG4gICAgICBpZiAodGhpcy5pc0JsYWNrKHBhcmVudCkpIHRoaXMuY29sb3JCbGFjayhyaWdodENoaWxkIGFzIEJpbmFyeU5vZGUpO1xyXG4gICAgICBlbHNlIHRoaXMuY29sb3JSZWQocmlnaHRDaGlsZCBhcyBCaW5hcnlOb2RlKTtcclxuICAgICAgdGhpcy5jb2xvckJsYWNrKHBhcmVudCk7XHJcbiAgICAgIHRoaXMuY29sb3JCbGFjayhyaWdodEdyYW5kY2hpbGQpO1xyXG4gICAgICBhd2FpdCB0aGlzLnNpbmdsZVJvdGF0ZShsZWZ0LCBwYXJlbnQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2libGluZydzIGNsb3NlIGNoaWxkIGlzIHJlZFxyXG4gICAgaWYgKHJpZ2h0Q2hpbGQgJiYgbGVmdEdyYW5kY2hpbGQgJiYgdGhpcy5pc1JlZChsZWZ0R3JhbmRjaGlsZCkpIHtcclxuICAgICAgcGFyZW50LnNldENoaWxkSGlnaGxpZ2h0KHJpZ2h0LCB0cnVlKTtcclxuICAgICAgcmlnaHRDaGlsZC5zZXRDaGlsZEhpZ2hsaWdodChsZWZ0LCB0cnVlKTtcclxuICAgICAgbGVmdEdyYW5kY2hpbGQuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgICBhd2FpdCB0aGlzLnBhdXNlKFwicm90YXRlLnJlZENsb3NlQ2hpbGRcIiwgcmlnaHQsIHJpZ2h0Q2hpbGQsIGxlZnQpO1xyXG4gICAgICBwYXJlbnQuc2V0Q2hpbGRIaWdobGlnaHQocmlnaHQsIGZhbHNlKTtcclxuICAgICAgcmlnaHRDaGlsZC5zZXRDaGlsZEhpZ2hsaWdodChsZWZ0LCBmYWxzZSk7XHJcbiAgICAgIGxlZnRHcmFuZGNoaWxkLnNldEhpZ2hsaWdodChmYWxzZSk7XHJcblxyXG4gICAgICB0aGlzLmNvbG9yUmVkKHJpZ2h0Q2hpbGQpO1xyXG4gICAgICB0aGlzLmNvbG9yQmxhY2sobGVmdEdyYW5kY2hpbGQpO1xyXG4gICAgICBhd2FpdCB0aGlzLnNpbmdsZVJvdGF0ZShyaWdodCwgcmlnaHRDaGlsZCk7XHJcbiAgICAgIGF3YWl0IHRoaXMuZml4RG91YmxlQmxhY2socGFyZW50LCBsZWZ0KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBhcmVudCBpcyByZWRcclxuICAgIGlmICh0aGlzLmlzUmVkKHBhcmVudCkpIHtcclxuICAgICAgcGFyZW50LnNldENoaWxkSGlnaGxpZ2h0KHJpZ2h0LCB0cnVlKTtcclxuICAgICAgcmlnaHRDaGlsZD8uc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgICBhd2FpdCB0aGlzLnBhdXNlKFwiY29sb3Iuc3dpdGNoXCIsIHBhcmVudCwgcmlnaHQsIHJpZ2h0Q2hpbGQpO1xyXG4gICAgICBwYXJlbnQuc2V0Q2hpbGRIaWdobGlnaHQocmlnaHQsIGZhbHNlKTtcclxuICAgICAgcmlnaHRDaGlsZD8uc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuXHJcbiAgICAgIHRoaXMuY29sb3JCbGFjayhwYXJlbnQpO1xyXG4gICAgICB0aGlzLmNvbG9yUmVkKHJpZ2h0Q2hpbGQgYXMgQmluYXJ5Tm9kZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBbGwgYXJlIGJsYWNrXHJcbiAgICBwYXJlbnQuc2V0Q2hpbGRIaWdobGlnaHQocmlnaHQsIHRydWUpO1xyXG4gICAgcmlnaHRDaGlsZD8uc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZShcImNvbG9yLmNoaWxkUmVkXCIsIHBhcmVudCwgcmlnaHQsIHJpZ2h0Q2hpbGQpO1xyXG4gICAgcGFyZW50LnNldENoaWxkSGlnaGxpZ2h0KHJpZ2h0LCBmYWxzZSk7XHJcbiAgICByaWdodENoaWxkPy5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG5cclxuICAgIHRoaXMuY29sb3JSZWQocmlnaHRDaGlsZCBhcyBCaW5hcnlOb2RlKTtcclxuICAgIGNvbnN0IGdyYW5kcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xyXG4gICAgaWYgKGdyYW5kcGFyZW50KSB7XHJcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHBhcmVudCA9PT0gZ3JhbmRwYXJlbnQuZ2V0TGVmdCgpID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCI7XHJcbiAgICAgIGF3YWl0IHRoaXMuZml4RG91YmxlQmxhY2soZ3JhbmRwYXJlbnQsIGRpcmVjdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gUmVkL2JsYWNrIGxldmVsXHJcblxyXG4gIGlzQmxhY2sobm9kZTogQmluYXJ5Tm9kZSkge1xyXG4gICAgcmV0dXJuICFub2RlIHx8IG5vZGUuaGFzQ2xhc3MoXCJibGFja1wiKTtcclxuICB9XHJcblxyXG4gIGlzUmVkKG5vZGU6IEJpbmFyeU5vZGUpIHtcclxuICAgIHJldHVybiAhdGhpcy5pc0JsYWNrKG5vZGUpO1xyXG4gIH1cclxuXHJcbiAgY29sb3JCbGFjayhub2RlOiBCaW5hcnlOb2RlKSB7XHJcbiAgICBub2RlLmFkZENsYXNzKFwiYmxhY2tcIik7XHJcbiAgfVxyXG5cclxuICBjb2xvclJlZChub2RlOiBCaW5hcnlOb2RlKSB7XHJcbiAgICBub2RlLnJlbW92ZUNsYXNzKFwiYmxhY2tcIik7XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBSZWRCbGFja01lc3NhZ2VzID0ge1xyXG4gIGNvbG9yOiB7XHJcbiAgICByZWRSb290QmxhY2s6IFwiVHJlZSByb290IGlzIHJlZDogQ29sb3IgaXQgYmxhY2tcIixcclxuICAgIHJvb3RCbGFjazogXCJDb2xvciB0aGUgcm9vdCBibGFja1wiLFxyXG4gICAgbm9kZUJsYWNrOiAobjogQmluYXJ5Tm9kZSkgPT4gYENvbG9yIG5vZGUgJHtufSBibGFja2AsXHJcbiAgICBwdXNoRG93bkJsYWNrOiAoXHJcbiAgICAgIG5vZGU6IEJpbmFyeU5vZGUsXHJcbiAgICAgIHBhcmVudDogQmluYXJ5Tm9kZSxcclxuICAgICAgcGlibGluZzogQmluYXJ5Tm9kZVxyXG4gICAgKSA9PiBbXHJcbiAgICAgIGBOb2RlICR7bm9kZX0sIHBhcmVudCAke3BhcmVudH0gYW5kIHBhcmVudCdzIHNpYmxpbmcgJHtwaWJsaW5nfSBhcmUgYWxsIHJlZGAsXHJcbiAgICAgIFwiUHVzaCBibGFja25lc3MgZG93biBmcm9tIGdyYW5kcGFyZW50XCIsXHJcbiAgICBdLFxyXG4gICAgc3dpdGNoOiAoXHJcbiAgICAgIHBhcmVudDogQmluYXJ5Tm9kZSxcclxuICAgICAgZGlyOiBcImxlZnRcIiB8IFwicmlnaHRcIixcclxuICAgICAgZGlyQ2hpbGQ6IEJpbmFyeU5vZGVcclxuICAgICkgPT4gW1xyXG4gICAgICBgUGFyZW50ICR7cGFyZW50fSBpcyByZWQsYCxcclxuICAgICAgYCR7ZGlyfSBjaGlsZCAke2RpckNoaWxkfSBhbmQgaXRzIGNoaWxkcmVuIGFyZSBibGFjazpgLFxyXG4gICAgICBcIlN3aXRjaCBjb2xvcnNcIixcclxuICAgIF0sXHJcbiAgICBjaGlsZFJlZDogKFxyXG4gICAgICBwYXJlbnQ6IEJpbmFyeU5vZGUsXHJcbiAgICAgIGRpcjogXCJsZWZ0XCIgfCBcInJpZ2h0XCIsXHJcbiAgICAgIGRpckNoaWxkOiBCaW5hcnlOb2RlXHJcbiAgICApID0+IFtcclxuICAgICAgYFBhcmVudCAke3BhcmVudH0sICR7ZGlyfSBjaGlsZCAke2RpckNoaWxkfSBhbmQgaXRzIGNoaWxkcmVuIGFyZSBibGFjazpgLFxyXG4gICAgICBgQ29sb3IgJHtkaXJ9IGNoaWxkIHJlZGAsXHJcbiAgICBdLFxyXG4gIH0sXHJcbiAgYmFsYW5jaW5nOiB7XHJcbiAgICBwYXJlbnRJbWJhbGFuY2VkOiAocGFyZW50OiBCaW5hcnlOb2RlKSA9PiBgUGFyZW50ICR7cGFyZW50fSBpcyBpbWJhbGFuY2VkYCxcclxuICB9LFxyXG4gIHJvdGF0ZToge1xyXG4gICAgcGFyZW50OiAoXHJcbiAgICAgIG5vZGU6IEJpbmFyeU5vZGUsXHJcbiAgICAgIHNpZGU6IFwibGVmdFwiIHwgXCJyaWdodFwiLFxyXG4gICAgICByb3RhdGU6IFwibGVmdFwiIHwgXCJyaWdodFwiLFxyXG4gICAgICBwYXJlbnQ6IEJpbmFyeU5vZGVcclxuICAgICkgPT4gW1xyXG4gICAgICBgTm9kZSAke25vZGV9IGlzIGEgcmVkICR7c2lkZX0gY2hpbGQgb2YgYSByZWQgJHtyb3RhdGV9IGNoaWxkYCxcclxuICAgICAgYFJvdGF0ZSBwYXJlbnQgJHtwYXJlbnR9ICR7cm90YXRlfWAsXHJcbiAgICBdLFxyXG4gICAgZ3JhbmRwYXJlbnQ6IChcclxuICAgICAgbm9kZTogQmluYXJ5Tm9kZSxcclxuICAgICAgc2lkZTogXCJsZWZ0XCIgfCBcInJpZ2h0XCIsXHJcbiAgICAgIGdyYW5kcGFyZW50OiBCaW5hcnlOb2RlLFxyXG4gICAgICByb3RhdGU6IFwibGVmdFwiIHwgXCJyaWdodFwiXHJcbiAgICApID0+IFtcclxuICAgICAgYE5vZGUgJHtub2RlfSBpcyBhIHJlZCAke3NpZGV9IGNoaWxkIG9mIGEgcmVkICR7c2lkZX0gY2hpbGRgLFxyXG4gICAgICBgU3dpdGNoIGNvbG9ycyBhbmQgcm90YXRlIGdyYW5kcGFyZW50ICR7Z3JhbmRwYXJlbnR9ICR7cm90YXRlfWAsXHJcbiAgICBdLFxyXG4gICAgcmVkU2libGluZzogKFxyXG4gICAgICBwYXJlbnQ6IEJpbmFyeU5vZGUsXHJcbiAgICAgIHJpZ2h0OiBcImxlZnRcIiB8IFwicmlnaHRcIixcclxuICAgICAgcmlnaHRDaGlsZDogQmluYXJ5Tm9kZSxcclxuICAgICAgbGVmdDogXCJsZWZ0XCIgfCBcInJpZ2h0XCJcclxuICAgICkgPT4gW1xyXG4gICAgICBgUGFyZW50ICR7cGFyZW50fSBpcyBibGFjaywgYW5kIGl0cyAke3JpZ2h0fSBjaGlsZCAke3JpZ2h0Q2hpbGR9IGlzIHJlZDpgLFxyXG4gICAgICBgU3dpdGNoIGNvbG9ycyBhbmQgcm90YXRlICR7bGVmdH1gLFxyXG4gICAgXSxcclxuICAgIHJlZERpc3RhbnRDaGlsZDogKFxyXG4gICAgICByaWdodDogXCJsZWZ0XCIgfCBcInJpZ2h0XCIsXHJcbiAgICAgIHJpZ2h0Q2hpbGQ6IEJpbmFyeU5vZGUsXHJcbiAgICAgIGxlZnQ6IFwibGVmdFwiIHwgXCJyaWdodFwiXHJcbiAgICApID0+IFtcclxuICAgICAgYCR7cmlnaHR9IGNoaWxkICR7cmlnaHRDaGlsZH0gaXMgYmxhY2ssIGl0cyAke3JpZ2h0fSBjaGlsZCBpcyByZWQ6YCxcclxuICAgICAgYFN3aXRjaCBjb2xvcnMgYW5kIHJvdGF0ZSAke2xlZnR9YCxcclxuICAgIF0sXHJcbiAgICByZWRDbG9zZUNoaWxkOiAoXHJcbiAgICAgIHJpZ2h0OiBcImxlZnRcIiB8IFwicmlnaHRcIixcclxuICAgICAgcmlnaHRDaGlsZDogQmluYXJ5Tm9kZSxcclxuICAgICAgbGVmdDogXCJsZWZ0XCIgfCBcInJpZ2h0XCJcclxuICAgICkgPT4gW1xyXG4gICAgICBgJHtyaWdodH0gY2hpbGQgJHtyaWdodENoaWxkfSBpcyBibGFjaywgaXRzICR7bGVmdH0gY2hpbGQgaXMgcmVkOmAsXHJcbiAgICAgIGBTd2l0Y2ggY29sb3JzIGFuZCByb3RhdGUgY2hpbGQgJHtyaWdodH1gLFxyXG4gICAgXSxcclxuICB9LFxyXG59IGFzIGNvbnN0O1xyXG4iLCIvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIEltcG9ydCBhbmQgZXhwb3J0IGluZm9ybWF0aW9uIHVzZWQgYnkgdGhlIEphdmFzY3JpcHQgbGludGVyIEVTTGludDpcclxuLyogZ2xvYmFscyBEU1ZpcyAqL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG5pbXBvcnQgeyBjb21wYXJlIH0gZnJvbSBcIi4uLy4uL3NyYy9lbmdpbmVcIjtcclxuaW1wb3J0IHsgQmluYXJ5Tm9kZSB9IGZyb20gXCIuLi8uLi9zcmMvb2JqZWN0cy9iaW5hcnktbm9kZVwiO1xyXG5pbXBvcnQgeyBCU1QsIEJTVE1lc3NhZ2VzIH0gZnJvbSBcIi4vQlNUXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgU3BsYXlUcmVlIGV4dGVuZHMgQlNUIHtcclxuICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IEVycm9yIGJlY2F1c2UgY2hhbmdlIG9mIGRlbGV0ZS5yb290IGZyb20gb2JqZWN0IHRvIHN0cmluZ1xyXG4gIG1lc3NhZ2VzID0ge1xyXG4gICAgLi4uQlNUTWVzc2FnZXMsXHJcbiAgICAuLi5TcGxheVRyZWVNZXNzYWdlcyxcclxuICAgIHJvdGF0ZToge1xyXG4gICAgICAuLi5CU1RNZXNzYWdlcy5yb3RhdGUsXHJcbiAgICAgIC4uLlNwbGF5VHJlZU1lc3NhZ2VzLnJvdGF0ZSxcclxuICAgIH0sXHJcbiAgICBkZWxldGU6IHtcclxuICAgICAgLi4uQlNUTWVzc2FnZXMuZGVsZXRlLFxyXG4gICAgICAuLi5TcGxheVRyZWVNZXNzYWdlcy5kZWxldGUsXHJcbiAgICB9LFxyXG4gIH07XHJcbiAgYXN5bmMgZmluZCh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKSB7XHJcbiAgICBjb25zdCBmb3VuZCA9IGF3YWl0IHN1cGVyLmZpbmQodmFsdWUpO1xyXG4gICAgaWYgKGZvdW5kPy5ub2RlKSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuc3BsYXlVcChmb3VuZC5ub2RlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmb3VuZDtcclxuICB9XHJcblxyXG4gIGFzeW5jIGluc2VydE9uZSh2YWx1ZTogc3RyaW5nKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdXBlci5pbnNlcnRPbmUodmFsdWUpO1xyXG4gICAgaWYgKHJlc3VsdD8ubm9kZSkge1xyXG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSBhd2FpdCB0aGlzLnBhdXNlKFwiaW5zZXJ0LmV4aXN0c1wiLCByZXN1bHQubm9kZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMuc3BsYXlVcChyZXN1bHQubm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZGVsZXRlKHZhbHVlOiBzdHJpbmcpOiBQcm9taXNlPHtcclxuICAgIHN1Y2Nlc3M6IGJvb2xlYW47XHJcbiAgICBkaXJlY3Rpb246IFwibGVmdFwiIHwgXCJyaWdodFwiIHwgbnVsbDtcclxuICAgIHBhcmVudDogQmluYXJ5Tm9kZSB8IG51bGw7XHJcbiAgfSB8IG51bGw+IHtcclxuICAgIGlmICghdGhpcy50cmVlUm9vdClcclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGRpcmVjdGlvbjogbnVsbCwgcGFyZW50OiBudWxsIH07XHJcblxyXG4gICAgYXdhaXQgdGhpcy5maW5kKHZhbHVlKTtcclxuICAgIGlmIChjb21wYXJlKHZhbHVlLCB0aGlzLnRyZWVSb290Py5nZXRUZXh0KCkpICE9PSAwKSB7XHJcbiAgICAgIGF3YWl0IHRoaXMucGF1c2UoXCJkZWxldGUubm90ZXhpc3RzXCIsIHZhbHVlKTtcclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIHBhcmVudDogbnVsbCwgZGlyZWN0aW9uOiBudWxsIH07XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy50cmVlUm9vdC5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZGVsZXRlLnJvb3RcIik7XHJcbiAgICBpZiAoISh0aGlzLnRyZWVSb290LmdldExlZnQoKSAmJiB0aGlzLnRyZWVSb290LmdldFJpZ2h0KCkpKSB7XHJcbiAgICAgIC8vIFRPRE86IEZpeCB2YXJpYWJsZSBuYW1lc1xyXG4gICAgICBjb25zdCBsZWZ0ID0gdGhpcy50cmVlUm9vdC5nZXRMZWZ0KCkgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcclxuICAgICAgY29uc3QgcmlnaHQgPSBsZWZ0ID09PSBcImxlZnRcIiA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xyXG4gICAgICBjb25zdCBjaGlsZCA9XHJcbiAgICAgICAgdGhpcy50cmVlUm9vdC5nZXRMZWZ0KCkgfHwgKHRoaXMudHJlZVJvb3QuZ2V0UmlnaHQoKSBhcyBCaW5hcnlOb2RlKTtcclxuICAgICAgY29uc3QgbmV3Um9vdCA9IGNoaWxkLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZShcImRlbGV0ZS5zaW5nbGVDaGlsZFwiLCByaWdodCwgbGVmdCk7XHJcbiAgICAgIHRoaXMudHJlZVJvb3QucmVtb3ZlKCk7XHJcbiAgICAgIHRoaXMudHJlZVJvb3QgPSBuZXdSb290O1xyXG4gICAgICB0aGlzLnJlc2l6ZVRyZWUoKTtcclxuICAgICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBwYXJlbnQ6IHRoaXMudHJlZVJvb3QsIGRpcmVjdGlvbjogbGVmdCB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy50cmVlUm9vdC5nZXRSaWdodCgpO1xyXG4gICAgY29uc3QgbGVmdCA9IHRoaXMudHJlZVJvb3QuZ2V0TGVmdCgpO1xyXG4gICAgdGhpcy50cmVlUm9vdC5yZW1vdmUoKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UoXCJkZWxldGUuc3BsYXlMYXJnZXN0XCIpO1xyXG5cclxuICAgIGxldCBsYXJnZXN0TGVmdCA9IGxlZnQgYXMgQmluYXJ5Tm9kZTsgLy8gVE9ETzogQ2hlY2sgaWYgaSBjYW4gZG8gdGhpc1xyXG4gICAgbGFyZ2VzdExlZnQuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgaWYgKGxhcmdlc3RMZWZ0LmdldFJpZ2h0KCkpIHtcclxuICAgICAgd2hpbGUgKGxhcmdlc3RMZWZ0LmdldFJpZ2h0KCkpIHtcclxuICAgICAgICBsYXJnZXN0TGVmdC5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgICAgIGxhcmdlc3RMZWZ0ID0gbGFyZ2VzdExlZnQuZ2V0UmlnaHQoKSE7XHJcbiAgICAgICAgbGFyZ2VzdExlZnQuc2V0SGlnaGxpZ2h0KHRydWUpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMucGF1c2UodW5kZWZpbmVkKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGFyZ2VzdExlZnQuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgIGF3YWl0IHRoaXMuc3BsYXlVcChsYXJnZXN0TGVmdCk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwiZGVsZXRlLmNvbm5lY3RMZWZ0UmlnaHRcIik7XHJcbiAgICBsYXJnZXN0TGVmdC5zZXRIaWdobGlnaHQodHJ1ZSk7XHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKHVuZGVmaW5lZCk7XHJcbiAgICBsYXJnZXN0TGVmdC5zZXRIaWdobGlnaHQoZmFsc2UpO1xyXG4gICAgbGFyZ2VzdExlZnQuc2V0UmlnaHQocmlnaHQgYXMgQmluYXJ5Tm9kZSwgdGhpcy5nZXRTdHJva2VXaWR0aCgpKTtcclxuICAgIHRoaXMudHJlZVJvb3QgPSBsYXJnZXN0TGVmdDtcclxuICAgIHRoaXMucmVzaXplVHJlZSgpO1xyXG4gICAgYXdhaXQgdGhpcy5wYXVzZSh1bmRlZmluZWQpO1xyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgcGFyZW50OiB0aGlzLnRyZWVSb290LCBkaXJlY3Rpb246IG51bGwgfTsgLy8gVE9ETzogdXBkYXRlIGRpcmVjdGlvblxyXG4gIH1cclxuXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFNwbGF5IGEgbm9kZSB0byB0aGUgcm9vdCBvZiB0aGUgdHJlZVxyXG5cclxuICBhc3luYyBzcGxheVVwKG5vZGU6IEJpbmFyeU5vZGUpIHtcclxuICAgIGlmIChub2RlID09PSB0aGlzLnRyZWVSb290KSByZXR1cm47XHJcbiAgICBub2RlLnNldEhpZ2hsaWdodCh0cnVlKTtcclxuICAgIGF3YWl0IHRoaXMucGF1c2UoXCJyb3RhdGUuc3BsYXlVcFwiLCBub2RlKTtcclxuICAgIG5vZGUuc2V0SGlnaGxpZ2h0KGZhbHNlKTtcclxuICAgIHdoaWxlIChub2RlLmdldFBhcmVudCgpKSB7XHJcbiAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCkhO1xyXG4gICAgICBjb25zdCBsZWZ0ID0gbm9kZS5pc0xlZnRDaGlsZCgpID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCI7XHJcbiAgICAgIGNvbnN0IHJpZ2h0ID0gbGVmdCA9PT0gXCJsZWZ0XCIgPyBcInJpZ2h0XCIgOiBcImxlZnRcIjtcclxuICAgICAgaWYgKCFwYXJlbnQuZ2V0UGFyZW50KCkpIHtcclxuICAgICAgICBub2RlID0gYXdhaXQgdGhpcy5zaW5nbGVSb3RhdGUocmlnaHQsIHBhcmVudCk7XHJcbiAgICAgIH0gZWxzZSBpZiAocGFyZW50LmlzQ2hpbGQocmlnaHQpKSB7XHJcbiAgICAgICAgbm9kZSA9IGF3YWl0IHRoaXMuZG91YmxlUm90YXRlKGxlZnQsIHBhcmVudC5nZXRQYXJlbnQoKSEpO1xyXG4gICAgICAgIC8vIHRoaXMuc3BsYXlIZWxwZXIobm9kZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gbm9kZSA9IGF3YWl0IHRoaXMuc2luZ2xlUm90YXRlKHJpZ2h0LCBwYXJlbnQpO1xyXG4gICAgICAgIG5vZGUgPSBhd2FpdCB0aGlzLnppZ1ppZyhyaWdodCwgcGFyZW50LmdldFBhcmVudCgpISk7XHJcbiAgICAgICAgLy8gdGhpcy5zcGxheUhlbHBlcihub2RlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgc3BsYXlIZWxwZXIobm9kZTogQmluYXJ5Tm9kZSkge1xyXG4gICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcclxuICAgIGlmICghcGFyZW50KSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgbGVmdCA9IG5vZGUuaXNMZWZ0Q2hpbGQoKSA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xyXG4gICAgY29uc3QgcmlnaHQgPSBsZWZ0ID09PSBcImxlZnRcIiA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xyXG4gICAgaWYgKCFwYXJlbnQ/LmdldFBhcmVudCgpKSB7XHJcbiAgICAgIHRoaXMuc2luZ2xlUm90YXRlKGxlZnQsIHBhcmVudCk7XHJcbiAgICB9IGVsc2UgaWYgKHBhcmVudC5pc0NoaWxkKHJpZ2h0KSkge1xyXG4gICAgICB0aGlzLmRvdWJsZVJvdGF0ZShsZWZ0LCBwYXJlbnQuZ2V0UGFyZW50KCkhKTtcclxuICAgICAgdGhpcy5zcGxheUhlbHBlcihub2RlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuemlnWmlnKHJpZ2h0LCBwYXJlbnQuZ2V0UGFyZW50KCkhKTtcclxuICAgICAgdGhpcy5zcGxheUhlbHBlcihub2RlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIHppZ1ppZyhsZWZ0OiBcImxlZnRcIiB8IFwicmlnaHRcIiwgbm9kZTogQmluYXJ5Tm9kZSkge1xyXG4gICAgLy8gTm90ZTogJ2xlZnQnIGFuZCAncmlnaHQnIGFyZSB2YXJpYWJsZXMgdGhhdCBjYW4gaGF2ZSB2YWx1ZXMgXCJsZWZ0XCIgb3IgXCJyaWdodFwiIVxyXG4gICAgY29uc3QgcmlnaHQgPSBsZWZ0ID09PSBcImxlZnRcIiA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xyXG4gICAgY29uc3QgY2hpbGQgPSBub2RlLmdldENoaWxkKHJpZ2h0KTtcclxuXHJcbiAgICBpZiAoIWNoaWxkKSByZXR1cm4gbm9kZTtcclxuXHJcbiAgICBhd2FpdCB0aGlzLnBhdXNlKFwicm90YXRlLnppZ3ppZ1wiLCBub2RlLCBsZWZ0LCBjaGlsZCk7XHJcbiAgICBhd2FpdCB0aGlzLnNpbmdsZVJvdGF0ZShsZWZ0LCBub2RlKTtcclxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNpbmdsZVJvdGF0ZShsZWZ0LCBjaGlsZCk7XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBTcGxheVRyZWVNZXNzYWdlcyA9IHtcclxuICBkZWxldGU6IHtcclxuICAgIHJvb3Q6IFwiUmVtb3ZlIHJvb3QsIGxlYXZpbmcgbGVmdCBhbmQgcmlnaHQgdHJlZXNcIixcclxuICAgIHNpbmdsZUNoaWxkOiAocmlnaHQ6IFwibGVmdFwiIHwgXCJyaWdodFwiLCBsZWZ0OiBcImxlZnRcIiB8IFwicmlnaHRcIikgPT5cclxuICAgICAgYE5vICR7cmlnaHR9IHRyZWUsIG1ha2UgJHtsZWZ0fSB0cmVlIHRoZSByb290YCxcclxuICAgIHNwbGF5TGFyZ2VzdDogXCJTcGxheSBsYXJnZXN0IGVsZW1lbnQgaW4gbGVmdCB0cmVlIHRvIHJvb3RcIixcclxuICAgIGNvbm5lY3RMZWZ0UmlnaHQ6XHJcbiAgICAgIFwiTGVmdCB0cmVlIG5vdyBoYXMgbm8gcmlnaHQgc3VidHJlZSwgY29ubmVjdCBsZWZ0IGFuZCByaWdodCB0cmVlc1wiLFxyXG4gIH0sXHJcbiAgcm90YXRlOiB7XHJcbiAgICBzcGxheVVwOiAobm9kZTogQmluYXJ5Tm9kZSkgPT4gYE5vdyBzcGxheWluZyAke25vZGV9IHVwIHRvIHRoZSByb290YCxcclxuICAgIHppZ3ppZzogKG5vZGU6IEJpbmFyeU5vZGUsIGxlZnQ6IFwibGVmdFwiIHwgXCJyaWdodFwiLCBjaGlsZDogQmluYXJ5Tm9kZSkgPT5cclxuICAgICAgYFppZy16aWc6IFJvdGF0ZSAke25vZGV9ICR7bGVmdH0sIHRoZW4gcm90YXRlICR7Y2hpbGR9ICR7bGVmdH1gLFxyXG4gIH0sXHJcbn07XHJcbiIsImltcG9ydCB7IGFkZFJldHVyblN1Ym1pdCwgRW5naW5lIH0gZnJvbSBcIi4vZW5naW5lXCI7XHJcbmltcG9ydCB7IEFWTCB9IGZyb20gXCIuL3RyZWVzL0FWTFwiO1xyXG5pbXBvcnQgeyBCU1QgfSBmcm9tIFwiLi90cmVlcy9CU1RcIjtcclxuaW1wb3J0IHsgQlRyZWUgfSBmcm9tIFwiLi90cmVlcy9CVHJlZVwiO1xyXG5pbXBvcnQgeyBSZWRCbGFjayB9IGZyb20gXCIuL3RyZWVzL1JlZEJsYWNrXCI7XHJcbmltcG9ydCB7IFNwbGF5VHJlZSB9IGZyb20gXCIuL3RyZWVzL1NwbGF5VHJlZVwiO1xyXG5cclxuY29uc3QgQ09MTEVDVElPTlMgPSB7XHJcbiAgQlNUOiBCU1QsXHJcbiAgQVZMOiBBVkwsXHJcbiAgUmVkQmxhY2s6IFJlZEJsYWNrLFxyXG4gIFNwbGF5VHJlZTogU3BsYXlUcmVlLFxyXG4gIEJUcmVlOiBCVHJlZSxcclxufSBhcyBjb25zdDtcclxuXHJcbnR5cGUgQ29sbGVjdGlvblRvb2xiYXJJdGVtcyA9IHtcclxuICBpbnNlcnRTZWxlY3Q6IEhUTUxTZWxlY3RFbGVtZW50O1xyXG4gIGluc2VydEZpZWxkOiBIVE1MSW5wdXRFbGVtZW50O1xyXG4gIGluc2VydFN1Ym1pdDogSFRNTElucHV0RWxlbWVudDtcclxuICBmaW5kRmllbGQ6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgZmluZFN1Ym1pdDogSFRNTElucHV0RWxlbWVudDtcclxuICBkZWxldGVGaWVsZDogSFRNTElucHV0RWxlbWVudDtcclxuICBkZWxldGVTdWJtaXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgcHJpbnRTdWJtaXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgY2xlYXJTdWJtaXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbn07XHJcblxyXG5pbml0aWFsaXNlQ29sbGVjdGlvbnMoXCIjY29sbGVjdGlvbnNDb250YWluZXJcIik7XHJcblxyXG5mdW5jdGlvbiBpbml0aWFsaXNlQ29sbGVjdGlvbnMoY29udGFpbmVySUQ6IHN0cmluZykge1xyXG4gIGNvbnN0IGFsZ29TZWxlY3RvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXHJcbiAgICBgJHtjb250YWluZXJJRH0gc2VsZWN0LmFsZ29yaXRobVNlbGVjdG9yYFxyXG4gICkgYXMgSFRNTFNlbGVjdEVsZW1lbnQ7XHJcblxyXG4gIGlmICghYWxnb1NlbGVjdG9yKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBhbGdvIHNlbGVjdG9yXCIpO1xyXG5cclxuICBhbGdvU2VsZWN0b3IuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoKSA9PiB7XHJcbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XHJcblxyXG4gICAgaWYgKGFsZ29TZWxlY3Rvci52YWx1ZSBpbiBDT0xMRUNUSU9OUylcclxuICAgICAgc2VhcmNoUGFyYW1zLnNldChcImFsZ29yaXRobVwiLCBhbGdvU2VsZWN0b3IudmFsdWUpO1xyXG4gICAgZWxzZSBzZWFyY2hQYXJhbXMuZGVsZXRlKFwiYWxnb3JpdGhtXCIpO1xyXG5cclxuICAgIGlmIChDb2xsZWN0aW9uRW5naW5lLkRFQlVHKSBzZWFyY2hQYXJhbXMuc2V0KFwiZGVidWdcIiwgXCJ0cnVlXCIpO1xyXG4gICAgZWxzZSBzZWFyY2hQYXJhbXMuZGVsZXRlKFwiZGVidWdcIik7XHJcblxyXG4gICAgY29uc3QgdXJsID0gYCR7d2luZG93LmxvY2F0aW9uLnBhdGhuYW1lfT8ke3NlYXJjaFBhcmFtc31gO1xyXG4gICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKFwiXCIsIFwiXCIsIHVybCk7XHJcbiAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgfSk7XHJcblxyXG4gIGxldCBhbGdvID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZikuc2VhcmNoUGFyYW1zLmdldChcImFsZ29yaXRobVwiKTtcclxuICBpZiAoIShhbGdvICYmIC9eW1xcdy5dKyQvLnRlc3QoYWxnbykgJiYgYWxnbyBpbiBDT0xMRUNUSU9OUykpIHtcclxuICAgIGFsZ28gPSBcIlwiO1xyXG4gIH1cclxuICBjb25zdCBhbGdvQ2xhc3MgPSBhbGdvIGFzIGtleW9mIHR5cGVvZiBDT0xMRUNUSU9OUyB8IFwiXCI7XHJcbiAgYWxnb1NlbGVjdG9yLnZhbHVlID0gYWxnbztcclxuICBjb25zdCBDb2xsZWN0aW9uID0gYWxnb0NsYXNzID8gQ09MTEVDVElPTlNbYWxnb0NsYXNzXSA6IEVuZ2luZTtcclxuICBjb25zdCBDb2xsZWN0aW9uRW5naW5lID0gbmV3IENvbGxlY3Rpb24oY29udGFpbmVySUQpO1xyXG4gIENvbGxlY3Rpb25FbmdpbmUuaW5pdGlhbGlzZSgpO1xyXG5cclxuICBjb25zdCB0b29sYmFyID0gZ2V0Q29sbGVjdGlvbnNUb29sYmFyKENvbGxlY3Rpb25FbmdpbmUuY29udGFpbmVyKTtcclxuXHJcbiAgdG9vbGJhci5pbnNlcnRTZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoKSA9PiB7XHJcbiAgICB0b29sYmFyLmluc2VydEZpZWxkLnZhbHVlID0gdG9vbGJhci5pbnNlcnRTZWxlY3QudmFsdWU7XHJcbiAgICB0b29sYmFyLmluc2VydFNlbGVjdC52YWx1ZSA9IFwiXCI7XHJcbiAgfSk7XHJcblxyXG4gIGFkZFJldHVyblN1Ym1pdCh0b29sYmFyLmluc2VydEZpZWxkLCBcIkFMUEhBTlVNK1wiLCAoKSA9PlxyXG4gICAgQ29sbGVjdGlvbkVuZ2luZS5zdWJtaXQoXCJpbnNlcnRcIiwgdG9vbGJhci5pbnNlcnRGaWVsZClcclxuICApO1xyXG5cclxuICB0b29sYmFyLmluc2VydFN1Ym1pdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgQ29sbGVjdGlvbkVuZ2luZS5zdWJtaXQoXCJpbnNlcnRcIiwgdG9vbGJhci5pbnNlcnRGaWVsZCk7XHJcbiAgfSk7XHJcblxyXG4gIGFkZFJldHVyblN1Ym1pdCh0b29sYmFyLmZpbmRGaWVsZCwgXCJBTFBIQU5VTVwiLCAoKSA9PlxyXG4gICAgQ29sbGVjdGlvbkVuZ2luZS5zdWJtaXQoXCJmaW5kXCIsIHRvb2xiYXIuZmluZEZpZWxkKVxyXG4gICk7XHJcbiAgdG9vbGJhci5maW5kU3VibWl0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PlxyXG4gICAgQ29sbGVjdGlvbkVuZ2luZS5zdWJtaXQoXCJmaW5kXCIsIHRvb2xiYXIuZmluZEZpZWxkKVxyXG4gICk7XHJcbiAgYWRkUmV0dXJuU3VibWl0KHRvb2xiYXIuZGVsZXRlRmllbGQsIFwiQUxQSEFOVU1cIiwgKCkgPT5cclxuICAgIENvbGxlY3Rpb25FbmdpbmUuc3VibWl0KFwiZGVsZXRlXCIsIHRvb2xiYXIuZGVsZXRlRmllbGQpXHJcbiAgKTtcclxuICB0b29sYmFyLmRlbGV0ZVN1Ym1pdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT5cclxuICAgIENvbGxlY3Rpb25FbmdpbmUuc3VibWl0KFwiZGVsZXRlXCIsIHRvb2xiYXIuZGVsZXRlRmllbGQpXHJcbiAgKTtcclxuICB0b29sYmFyLnByaW50U3VibWl0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PlxyXG4gICAgQ29sbGVjdGlvbkVuZ2luZS5zdWJtaXQoXCJwcmludFwiLCB0b29sYmFyLnByaW50U3VibWl0KVxyXG4gICk7XHJcbiAgdG9vbGJhci5jbGVhclN1Ym1pdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT5cclxuICAgIENvbGxlY3Rpb25FbmdpbmUuY29uZmlybVJlc2V0QWxsKClcclxuICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDb2xsZWN0aW9uc1Rvb2xiYXIoY29udGFpbmVyOiBIVE1MRWxlbWVudCkge1xyXG4gIGNvbnN0IGluc2VydFNlbGVjdCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yPEhUTUxTZWxlY3RFbGVtZW50PihcclxuICAgIFwic2VsZWN0Lmluc2VydFNlbGVjdFwiXHJcbiAgKTtcclxuICBjb25zdCBpbnNlcnRGaWVsZCA9XHJcbiAgICBjb250YWluZXIucXVlcnlTZWxlY3RvcjxIVE1MSW5wdXRFbGVtZW50PihcImlucHV0Lmluc2VydEZpZWxkXCIpO1xyXG4gIGNvbnN0IGluc2VydFN1Ym1pdCA9XHJcbiAgICBjb250YWluZXIucXVlcnlTZWxlY3RvcjxIVE1MSW5wdXRFbGVtZW50PihcImlucHV0Lmluc2VydFN1Ym1pdFwiKTtcclxuICBjb25zdCBmaW5kRmllbGQgPVxyXG4gICAgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3I8SFRNTElucHV0RWxlbWVudD4oXCJpbnB1dC5maW5kRmllbGRcIik7XHJcbiAgY29uc3QgZmluZFN1Ym1pdCA9XHJcbiAgICBjb250YWluZXIucXVlcnlTZWxlY3RvcjxIVE1MSW5wdXRFbGVtZW50PihcImlucHV0LmZpbmRTdWJtaXRcIik7XHJcbiAgY29uc3QgZGVsZXRlRmllbGQgPVxyXG4gICAgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3I8SFRNTElucHV0RWxlbWVudD4oXCJpbnB1dC5kZWxldGVGaWVsZFwiKTtcclxuICBjb25zdCBkZWxldGVTdWJtaXQgPVxyXG4gICAgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3I8SFRNTElucHV0RWxlbWVudD4oXCJpbnB1dC5kZWxldGVTdWJtaXRcIik7XHJcbiAgY29uc3QgcHJpbnRTdWJtaXQgPVxyXG4gICAgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3I8SFRNTElucHV0RWxlbWVudD4oXCJpbnB1dC5wcmludFN1Ym1pdFwiKTtcclxuICBjb25zdCBjbGVhclN1Ym1pdCA9XHJcbiAgICBjb250YWluZXIucXVlcnlTZWxlY3RvcjxIVE1MSW5wdXRFbGVtZW50PihcImlucHV0LmNsZWFyU3VibWl0XCIpO1xyXG5cclxuICBpZiAoIWluc2VydFNlbGVjdCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBpbnNlcnQgc2VsZWN0XCIpO1xyXG4gIGlmICghaW5zZXJ0RmllbGQpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgaW5zZXJ0IGZpZWxkXCIpO1xyXG4gIGlmICghaW5zZXJ0U3VibWl0KSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGluc2VydCBzdWJtaXRcIik7XHJcbiAgaWYgKCFmaW5kRmllbGQpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZmluZCBmaWVsZFwiKTtcclxuICBpZiAoIWZpbmRTdWJtaXQpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZmluZCBzdWJtaXRcIik7XHJcbiAgaWYgKCFkZWxldGVGaWVsZCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBkZWxldGUgZmllbGRcIik7XHJcbiAgaWYgKCFkZWxldGVTdWJtaXQpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZGVsZXRlIHN1Ym1pdFwiKTtcclxuICBpZiAoIXByaW50U3VibWl0KSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHByaW50IHN1Ym1pdFwiKTtcclxuICBpZiAoIWNsZWFyU3VibWl0KSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGNsZWFyIHN1Ym1pdFwiKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGluc2VydFNlbGVjdCxcclxuICAgIGluc2VydEZpZWxkLFxyXG4gICAgaW5zZXJ0U3VibWl0LFxyXG4gICAgZmluZEZpZWxkLFxyXG4gICAgZmluZFN1Ym1pdCxcclxuICAgIGRlbGV0ZUZpZWxkLFxyXG4gICAgZGVsZXRlU3VibWl0LFxyXG4gICAgcHJpbnRTdWJtaXQsXHJcbiAgICBjbGVhclN1Ym1pdCxcclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///166\n")}},__webpack_require__={d:(Q,B)=>{for(var n in B)__webpack_require__.o(B,n)&&!__webpack_require__.o(Q,n)&&Object.defineProperty(Q,n,{enumerable:!0,get:B[n]})},o:(Q,B)=>Object.prototype.hasOwnProperty.call(Q,B),r:Q=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})}},__webpack_exports__={};__webpack_modules__[166](0,__webpack_exports__,__webpack_require__)})();